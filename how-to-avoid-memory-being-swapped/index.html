<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><title>how to avoid memory being swapped (locking memory pages) - 杂货铺</title><meta name=Description content="杂七杂八的，随手记录。"><meta property="og:url" content="https://yangyingchao.github.io/how-to-avoid-memory-being-swapped/">
<meta property="og:site_name" content="杂货铺"><meta property="og:title" content="how to avoid memory being swapped (locking memory pages)"><meta property="og:description" content="Table of Contents 1 mlockall() 2 how to do this after program started and program does not call mlockall() ? 3 内核实现 3.1 mlockall() 3.2 内存区域标记 4 Swap 4.1 Swap info 4.2 Locks 4.3 fork 时候复制 swap… 4.4 进程退出时候清理 swap 。。。 5 RLIMIT_MEMLOCK 本文为摘录(或转载)，侵删，原文为： https://stackoverflow.com/questions/12520499/linux-how-to-lock-the-pages-of-a-process-in-memory
1 mlockall() from manpage:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 mlockall() and munlockall() mlockall() locks all pages mapped into the address space of the calling process. This in‐ cludes the pages of the code, data, and stack segment, as well as shared libraries, user space kernel data, shared memory, and memory-mapped files. All mapped pages are guaranteed to be resident in RAM when the call returns successfully; the pages are guaranteed to stay in RAM until later unlocked. The flags argument is constructed as the bitwise OR of one or more of the following constants: MCL_CURRENT Lock all pages which are currently mapped into the address space of the process. MCL_FUTURE Lock all pages which will become mapped into the address space of the process in the future. These could be, for instance, new pages required by a growing heap and stack as well as new memory-mapped files or shared memory regions. MCL_ONFAULT (since Linux 4.4) Used together with MCL_CURRENT, MCL_FUTURE, or both. Mark all current (with MCL_CUR‐ RENT) or future (with MCL_FUTURE) mappings to lock pages when they are faulted in. When used with MCL_CURRENT, all present pages are locked, but mlockall() will not fault in non-present pages. When used with MCL_FUTURE, all future mappings will be marked to lock pages when they are faulted in, but they will not be populated by the lock when the mapping is created. MCL_ONFAULT must be used with either MCL_CURRENT or MCL_FUTURE or both. If MCL_FUTURE has been specified, then a later system call (e.g., mmap(2), sbrk(2), mal‐ loc(3)), may fail if it would cause the number of locked bytes to exceed the permitted maximum (see below). In the same circumstances, stack growth may likewise fail: the kernel will deny stack expansion and deliver a SIGSEGV signal to the process. munlockall() unlocks all pages mapped into the address space of the calling process. 2 how to do this after program started and program does not call mlockall() ? Make a GDB command file that contains something like this:"><meta property="og:locale" content="zh_cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-12-16T00:00:00+00:00"><meta property="article:modified_time" content="2023-12-16T00:00:00+00:00"><meta property="article:tag" content="Memory"><meta property="article:tag" content="Mlock"><meta property="article:tag" content="Swap"><meta property="article:tag" content="Lock"><meta property="article:tag" content="Mlockall"><meta property="og:image" content="https://yangyingchao.github.io/logo.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://yangyingchao.github.io/logo.png"><meta name=twitter:title content="how to avoid memory being swapped (locking memory pages)"><meta name=twitter:description content="Table of Contents 1 mlockall() 2 how to do this after program started and program does not call mlockall() ? 3 内核实现 3.1 mlockall() 3.2 内存区域标记 4 Swap 4.1 Swap info 4.2 Locks 4.3 fork 时候复制 swap… 4.4 进程退出时候清理 swap 。。。 5 RLIMIT_MEMLOCK 本文为摘录(或转载)，侵删，原文为： https://stackoverflow.com/questions/12520499/linux-how-to-lock-the-pages-of-a-process-in-memory
1 mlockall() from manpage:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 mlockall() and munlockall() mlockall() locks all pages mapped into the address space of the calling process. This in‐ cludes the pages of the code, data, and stack segment, as well as shared libraries, user space kernel data, shared memory, and memory-mapped files. All mapped pages are guaranteed to be resident in RAM when the call returns successfully; the pages are guaranteed to stay in RAM until later unlocked. The flags argument is constructed as the bitwise OR of one or more of the following constants: MCL_CURRENT Lock all pages which are currently mapped into the address space of the process. MCL_FUTURE Lock all pages which will become mapped into the address space of the process in the future. These could be, for instance, new pages required by a growing heap and stack as well as new memory-mapped files or shared memory regions. MCL_ONFAULT (since Linux 4.4) Used together with MCL_CURRENT, MCL_FUTURE, or both. Mark all current (with MCL_CUR‐ RENT) or future (with MCL_FUTURE) mappings to lock pages when they are faulted in. When used with MCL_CURRENT, all present pages are locked, but mlockall() will not fault in non-present pages. When used with MCL_FUTURE, all future mappings will be marked to lock pages when they are faulted in, but they will not be populated by the lock when the mapping is created. MCL_ONFAULT must be used with either MCL_CURRENT or MCL_FUTURE or both. If MCL_FUTURE has been specified, then a later system call (e.g., mmap(2), sbrk(2), mal‐ loc(3)), may fail if it would cause the number of locked bytes to exceed the permitted maximum (see below). In the same circumstances, stack growth may likewise fail: the kernel will deny stack expansion and deliver a SIGSEGV signal to the process. munlockall() unlocks all pages mapped into the address space of the calling process. 2 how to do this after program started and program does not call mlockall() ? Make a GDB command file that contains something like this:"><meta name=application-name content="LoveIt"><meta name=apple-mobile-web-app-title content="LoveIt"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://yangyingchao.github.io/how-to-avoid-memory-being-swapped/><link rel=prev href=https://yangyingchao.github.io/logindex/><link rel=next href=https://yangyingchao.github.io/note-about-po-file/><link rel=stylesheet href=/css/style.min.css><link rel=preload href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css></noscript><link rel=preload href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"how to avoid memory being swapped (locking memory pages)","inLanguage":"zh-cn","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/yangyingchao.github.io\/how-to-avoid-memory-being-swapped\/"},"image":["https:\/\/yangyingchao.github.io\/images\/Apple-Devices-Preview.png"],"genre":"posts","keywords":"memory, mlock, swap, lock, mlockall","wordcount":1901,"url":"https:\/\/yangyingchao.github.io\/how-to-avoid-memory-being-swapped\/","datePublished":"2023-12-16T00:00:00+00:00","dateModified":"2023-12-16T00:00:00+00:00","publisher":{"@type":"Organization","name":"xxxx","logo":"https:\/\/yangyingchao.github.io\/images\/avatar.png"},"author":{"@type":"Person","name":"yc"},"description":""}</script></head><body data-header-desktop=normal data-header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("theme","dark")</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title=杂货铺><span class=header-title-pre><i class="fa-solid fa-house-chimney"></i></span>老杨的杂货铺</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/>所有文章 </a><a class=menu-item href=/tags/>标签 </a><a class=menu-item href=/categories/>分类 </a><a class=menu-item href=https://github.com/yangyingchao/MyNotes title=GitHub rel="noopener noreffer" target=_blank><i class='fab fa-github fa-fw' aria-hidden=true></i> </a><span class="menu-item delimiter"></span><span class="menu-item search" id=search-desktop>
<input type=text placeholder=搜索文章标题或内容... id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fas fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fas fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-desktop><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i>
</span></span><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题><i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title=杂货铺><span class=header-title-pre><i class="fa-solid fa-house-chimney"></i></span>老杨的杂货铺</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><div class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容... id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fas fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fas fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-mobile><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></div><a class=menu-item href=/posts/ title>所有文章</a><a class=menu-item href=/tags/ title>标签</a><a class=menu-item href=/categories/ title>分类</a><a class=menu-item href=https://github.com/yangyingchao/MyNotes title=GitHub rel="noopener noreffer" target=_blank><i class='fab fa-github fa-fw' aria-hidden=true></i></a><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>目录</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">how to avoid memory being swapped (locking memory pages)</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=/ title=Author rel=author class=author><i class="fas fa-user-circle fa-fw" aria-hidden=true></i>yc</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw" aria-hidden=true></i>&nbsp;<time datetime=2023-12-16>2023-12-16</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden=true></i>&nbsp;约 1901 字&nbsp;
<i class="far fa-clock fa-fw" aria-hidden=true></i>&nbsp;预计阅读 4 分钟&nbsp;</div></div><div class="details toc" id=toc-static data-kept><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fas fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#h:a69e195a-92fb-405b-9b6c-ec86c0015e47><span class=section-num>1</span> mlockall()</a></li><li><a href=#h:694a46e8-f346-48c2-a21e-a71751c8643d><span class=section-num>2</span> how to do this after program started and program does not call <code>mlockall()</code> ?</a></li><li><a href=#h:a99f5c47-b061-4e47-a7f0-51dcf4e3b852><span class=section-num>3</span> 内核实现</a><ul><li><a href=#h:6ff510c5-4a77-4766-b6ec-49b25660504a><span class=section-num>3.1</span> mlockall()</a><ul><li><a href=#h:d9c66345-c146-46da-968a-1daaea8804cf><span class=section-num>3.1.1</span> EPERM 的情况</a></li></ul></li><li><a href=#h:75a484c0-9716-44e8-8811-9041f9878f19><span class=section-num>3.2</span> 内存区域标记</a></li></ul></li><li><a href=#h:7ad9b325-1adc-4075-ac3b-3e92208ae6a6><span class=section-num>4</span> Swap</a><ul><li><a href=#h:ddbd6d4f-ac07-456e-a148-dcdeac5f975d><span class=section-num>4.1</span> Swap info</a></li><li><a href=#h:1fe99bb1-aeb0-4a49-9efe-56e123310ee6><span class=section-num>4.2</span> Locks</a><ul><li><a href=#h:4542388b-4a23-4f9a-afc5-7d3afbbaf6c5><span class=section-num>4.2.1</span> 全局锁</a></li><li><a href=#h:35cfd6f1-394c-4a8f-8883-aff2964a9ff3><span class=section-num>4.2.2</span> 粗粒度锁</a></li><li><a href=#h:aef166e9-9c66-4f62-8668-78d4e76aeaf9><span class=section-num>4.2.3</span> 细粒度锁</a></li></ul></li><li><a href=#h:36e44df6-8e26-4bd4-bfc8-80df31b3614b><span class=section-num>4.3</span> fork 时候复制 swap…</a><ul><li><a href=#h:b1a19790-e8c8-4c2a-a0a1-13fad351664e><span class=section-num>4.3.1</span> <code>swap_duplicate</code></a></li></ul></li><li><a href=#h:cb155170-b5a3-421f-9f98-090780fbf82a><span class=section-num>4.4</span> 进程退出时候清理 swap 。。。</a></li></ul></li><li><a href=#h:e5964c54-29f4-42fa-af12-10ca1093f20b><span class=section-num>5</span> RLIMIT_MEMLOCK</a></li></ul></nav></div></div><div class=content id=content><div class="ox-hugo-toc toc has-section-numbers"><div class=heading>Table of Contents</div><ul><li><span class=section-num>1</span> <a href=#h:a69e195a-92fb-405b-9b6c-ec86c0015e47 rel>mlockall()</a></li><li><span class=section-num>2</span> <a href=#h:694a46e8-f346-48c2-a21e-a71751c8643d rel>how to do this after program started and program does not call <code>mlockall()</code> ?</a></li><li><span class=section-num>3</span> <a href=#h:a99f5c47-b061-4e47-a7f0-51dcf4e3b852 rel>内核实现</a><ul><li><span class=section-num>3.1</span> <a href=#h:6ff510c5-4a77-4766-b6ec-49b25660504a rel>mlockall()</a></li><li><span class=section-num>3.2</span> <a href=#h:75a484c0-9716-44e8-8811-9041f9878f19 rel>内存区域标记</a></li></ul></li><li><span class=section-num>4</span> <a href=#h:7ad9b325-1adc-4075-ac3b-3e92208ae6a6 rel>Swap</a><ul><li><span class=section-num>4.1</span> <a href=#h:ddbd6d4f-ac07-456e-a148-dcdeac5f975d rel>Swap info</a></li><li><span class=section-num>4.2</span> <a href=#h:1fe99bb1-aeb0-4a49-9efe-56e123310ee6 rel>Locks</a></li><li><span class=section-num>4.3</span> <a href=#h:36e44df6-8e26-4bd4-bfc8-80df31b3614b rel>fork 时候复制 swap…</a></li><li><span class=section-num>4.4</span> <a href=#h:cb155170-b5a3-421f-9f98-090780fbf82a rel>进程退出时候清理 swap 。。。</a></li></ul></li><li><span class=section-num>5</span> <a href=#h:e5964c54-29f4-42fa-af12-10ca1093f20b rel>RLIMIT_MEMLOCK</a></li></ul></div><p>本文为摘录(或转载)，侵删，原文为： <a href=https://stackoverflow.com/questions/12520499/linux-how-to-lock-the-pages-of-a-process-in-memory target=_blank rel="noopener noreffer">https://stackoverflow.com/questions/12520499/linux-how-to-lock-the-pages-of-a-process-in-memory</a></p><h2 id=h:a69e195a-92fb-405b-9b6c-ec86c0015e47><span class=section-num>1</span> mlockall()</h2><p>from manpage:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>
</span></span><span class=line><span class=cl>mlockall() and munlockall()
</span></span><span class=line><span class=cl>    mlockall() locks all pages mapped into the address space of the  calling  process.   This  in‐
</span></span><span class=line><span class=cl>    cludes the pages of the code, data, and stack segment, as well as shared libraries, user space
</span></span><span class=line><span class=cl>    kernel data, shared memory, and memory-mapped files.  All mapped pages are  guaranteed  to  be
</span></span><span class=line><span class=cl>    resident  in  RAM  when the call returns successfully; the pages are guaranteed to stay in RAM
</span></span><span class=line><span class=cl>    until later unlocked.
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    The flags argument is constructed as the bitwise OR of one or more of the following constants:
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    MCL_CURRENT
</span></span><span class=line><span class=cl>           Lock all pages which are currently mapped into the address space of the process.
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    MCL_FUTURE
</span></span><span class=line><span class=cl>           Lock all pages which will become mapped into the address space of the  process  in  the
</span></span><span class=line><span class=cl>           future.   These  could be, for instance, new pages required by a growing heap and stack
</span></span><span class=line><span class=cl>           as well as new memory-mapped files or shared memory regions.
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    MCL_ONFAULT (since Linux 4.4)
</span></span><span class=line><span class=cl>           Used together with MCL_CURRENT, MCL_FUTURE, or both.  Mark all current  (with  MCL_CUR‐
</span></span><span class=line><span class=cl>           RENT)  or  future  (with  MCL_FUTURE)  mappings to lock pages when they are faulted in.
</span></span><span class=line><span class=cl>           When used with MCL_CURRENT, all present pages are locked, but mlockall() will not fault
</span></span><span class=line><span class=cl>           in non-present pages.  When used with MCL_FUTURE, all future mappings will be marked to
</span></span><span class=line><span class=cl>           lock pages when they are faulted in, but they will not be populated by  the  lock  when
</span></span><span class=line><span class=cl>           the mapping is created.  MCL_ONFAULT must be used with either MCL_CURRENT or MCL_FUTURE
</span></span><span class=line><span class=cl>           or both.
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    If MCL_FUTURE has been specified, then a later  system  call  (e.g.,  mmap(2),  sbrk(2),  mal‐
</span></span><span class=line><span class=cl>    loc(3)), may fail if it would cause the number of locked bytes to exceed the permitted maximum
</span></span><span class=line><span class=cl>    (see below).  In the same circumstances, stack growth may likewise fail: the kernel will  deny
</span></span><span class=line><span class=cl>    stack expansion and deliver a SIGSEGV signal to the process.
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>munlockall() unlocks all pages mapped into the address space of the calling process.
</span></span></code></pre></td></tr></table></div></div><h2 id=h:694a46e8-f346-48c2-a21e-a71751c8643d><span class=section-num>2</span> how to do this after program started and program does not call <code>mlockall()</code> ?</h2><p>Make a GDB command file that contains something like this:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>call mlockall<span class=o>(</span>3<span class=o>)</span>
</span></span><span class=line><span class=cl>detach
</span></span></code></pre></td></tr></table></div></div><p>Then on the command line, find the PID of the process you want to mlock. Type:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>gdb --pid <span class=o>[</span>PID<span class=o>]</span> --batch -x <span class=o>[</span><span class=nb>command</span> file<span class=o>]</span>
</span></span></code></pre></td></tr></table></div></div><p>If you get fancy with <code>pgrep</code> that could be:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>gdb --pid <span class=k>$(</span>pgrep sshd<span class=k>)</span> --batch -x <span class=o>[</span><span class=nb>command</span> file<span class=o>]</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=h:a99f5c47-b061-4e47-a7f0-51dcf4e3b852><span class=section-num>3</span> 内核实现</h2><h3 id=h:6ff510c5-4a77-4766-b6ec-49b25660504a><span class=section-num>3.1</span> mlockall()</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=nf>SYSCALL_DEFINE1</span><span class=p>(</span><span class=n>mlockall</span><span class=p>,</span> <span class=kt>int</span><span class=p>,</span> <span class=n>flags</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>lock_limit</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>ret</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>flags</span> <span class=o>||</span> <span class=p>(</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=o>~</span><span class=p>(</span><span class=n>MCL_CURRENT</span> <span class=o>|</span> <span class=n>MCL_FUTURE</span> <span class=o>|</span> <span class=n>MCL_ONFAULT</span><span class=p>))</span> <span class=o>||</span>
</span></span><span class=line><span class=cl>        <span class=n>flags</span> <span class=o>==</span> <span class=n>MCL_ONFAULT</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=o>-</span><span class=n>EINVAL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=nf>can_do_mlock</span><span class=p>())</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=o>-</span><span class=n>EPERM</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>lock_limit</span> <span class=o>=</span> <span class=nf>rlimit</span><span class=p>(</span><span class=n>RLIMIT_MEMLOCK</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>lock_limit</span> <span class=o>&gt;&gt;=</span> <span class=n>PAGE_SHIFT</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>mmap_write_lock_killable</span><span class=p>(</span><span class=n>current</span><span class=o>-&gt;</span><span class=n>mm</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=o>-</span><span class=n>EINTR</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>ret</span> <span class=o>=</span> <span class=o>-</span><span class=n>ENOMEM</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=p>(</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=n>MCL_CURRENT</span><span class=p>)</span> <span class=o>||</span> <span class=p>(</span><span class=n>current</span><span class=o>-&gt;</span><span class=n>mm</span><span class=o>-&gt;</span><span class=n>total_vm</span> <span class=o>&lt;=</span> <span class=n>lock_limit</span><span class=p>)</span> <span class=o>||</span>
</span></span><span class=line><span class=cl>        <span class=nf>capable</span><span class=p>(</span><span class=n>CAP_IPC_LOCK</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=n>ret</span> <span class=o>=</span> <span class=nf>apply_mlockall_flags</span><span class=p>(</span><span class=n>flags</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>mmap_write_unlock</span><span class=p>(</span><span class=n>current</span><span class=o>-&gt;</span><span class=n>mm</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>ret</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=n>MCL_CURRENT</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=nf>mm_populate</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>TASK_SIZE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>ret</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=h:d9c66345-c146-46da-968a-1daaea8804cf><span class=section-num>3.1.1</span> EPERM 的情况</h4><p>当可执行程序拥有 <code>CAP_IPC_LOCK</code> 时候，可以有权限执行 mlock, 否则的话，下列情况会返回 EPERM:</p><ol><li>RLIMIT_MEMLOCK 为 0 时候：<div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>bool</span> <span class=nf>can_do_mlock</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>rlimit</span><span class=p>(</span><span class=n>RLIMIT_MEMLOCK</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>capable</span><span class=p>(</span><span class=n>CAP_IPC_LOCK</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></li><li><code>MCL_CURRENT</code> 被设置，并且当前进程已使用的内存超过了 <code>RLIMIT_MEMLOCK</code> .</li></ol><h3 id=h:75a484c0-9716-44e8-8811-9041f9878f19><span class=section-num>3.2</span> 内存区域标记</h3><h2 id=h:7ad9b325-1adc-4075-ac3b-3e92208ae6a6><span class=section-num>4</span> Swap</h2><h3 id=h:ddbd6d4f-ac07-456e-a148-dcdeac5f975d><span class=section-num>4.1</span> Swap info</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>  1
</span><span class=lnt>  2
</span><span class=lnt>  3
</span><span class=lnt>  4
</span><span class=lnt>  5
</span><span class=lnt>  6
</span><span class=lnt>  7
</span><span class=lnt>  8
</span><span class=lnt>  9
</span><span class=lnt> 10
</span><span class=lnt> 11
</span><span class=lnt> 12
</span><span class=lnt> 13
</span><span class=lnt> 14
</span><span class=lnt> 15
</span><span class=lnt> 16
</span><span class=lnt> 17
</span><span class=lnt> 18
</span><span class=lnt> 19
</span><span class=lnt> 20
</span><span class=lnt> 21
</span><span class=lnt> 22
</span><span class=lnt> 23
</span><span class=lnt> 24
</span><span class=lnt> 25
</span><span class=lnt> 26
</span><span class=lnt> 27
</span><span class=lnt> 28
</span><span class=lnt> 29
</span><span class=lnt> 30
</span><span class=lnt> 31
</span><span class=lnt> 32
</span><span class=lnt> 33
</span><span class=lnt> 34
</span><span class=lnt> 35
</span><span class=lnt> 36
</span><span class=lnt> 37
</span><span class=lnt> 38
</span><span class=lnt> 39
</span><span class=lnt> 40
</span><span class=lnt> 41
</span><span class=lnt> 42
</span><span class=lnt> 43
</span><span class=lnt> 44
</span><span class=lnt> 45
</span><span class=lnt> 46
</span><span class=lnt> 47
</span><span class=lnt> 48
</span><span class=lnt> 49
</span><span class=lnt> 50
</span><span class=lnt> 51
</span><span class=lnt> 52
</span><span class=lnt> 53
</span><span class=lnt> 54
</span><span class=lnt> 55
</span><span class=lnt> 56
</span><span class=lnt> 57
</span><span class=lnt> 58
</span><span class=lnt> 59
</span><span class=lnt> 60
</span><span class=lnt> 61
</span><span class=lnt> 62
</span><span class=lnt> 63
</span><span class=lnt> 64
</span><span class=lnt> 65
</span><span class=lnt> 66
</span><span class=lnt> 67
</span><span class=lnt> 68
</span><span class=lnt> 69
</span><span class=lnt> 70
</span><span class=lnt> 71
</span><span class=lnt> 72
</span><span class=lnt> 73
</span><span class=lnt> 74
</span><span class=lnt> 75
</span><span class=lnt> 76
</span><span class=lnt> 77
</span><span class=lnt> 78
</span><span class=lnt> 79
</span><span class=lnt> 80
</span><span class=lnt> 81
</span><span class=lnt> 82
</span><span class=lnt> 83
</span><span class=lnt> 84
</span><span class=lnt> 85
</span><span class=lnt> 86
</span><span class=lnt> 87
</span><span class=lnt> 88
</span><span class=lnt> 89
</span><span class=lnt> 90
</span><span class=lnt> 91
</span><span class=lnt> 92
</span><span class=lnt> 93
</span><span class=lnt> 94
</span><span class=lnt> 95
</span><span class=lnt> 96
</span><span class=lnt> 97
</span><span class=lnt> 98
</span><span class=lnt> 99
</span><span class=lnt>100
</span><span class=lnt>101
</span><span class=lnt>102
</span><span class=lnt>103
</span><span class=lnt>104
</span><span class=lnt>105
</span><span class=lnt>106
</span><span class=lnt>107
</span><span class=lnt>108
</span><span class=lnt>109
</span><span class=lnt>110
</span><span class=lnt>111
</span><span class=lnt>112
</span><span class=lnt>113
</span><span class=lnt>114
</span><span class=lnt>115
</span><span class=lnt>116
</span><span class=lnt>117
</span><span class=lnt>118
</span><span class=lnt>119
</span><span class=lnt>120
</span><span class=lnt>121
</span><span class=lnt>122
</span><span class=lnt>123
</span><span class=lnt>124
</span><span class=lnt>125
</span><span class=lnt>126
</span><span class=lnt>127
</span><span class=lnt>128
</span><span class=lnt>129
</span><span class=lnt>130
</span><span class=lnt>131
</span><span class=lnt>132
</span><span class=lnt>133
</span><span class=lnt>134
</span><span class=lnt>135
</span><span class=lnt>136
</span><span class=lnt>137
</span><span class=lnt>138
</span><span class=lnt>139
</span><span class=lnt>140
</span><span class=lnt>141
</span><span class=lnt>142
</span><span class=lnt>143
</span><span class=lnt>144
</span><span class=lnt>145
</span><span class=lnt>146
</span><span class=lnt>147
</span><span class=lnt>148
</span><span class=lnt>149
</span><span class=lnt>150
</span><span class=lnt>151
</span><span class=lnt>152
</span><span class=lnt>153
</span><span class=lnt>154
</span><span class=lnt>155
</span><span class=lnt>156
</span><span class=lnt>157
</span><span class=lnt>158
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=k>class</span> <span class=n>swap_info_struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=o>+</span> <span class=n>unsigned</span> <span class=n>flags</span>
</span></span><span class=line><span class=cl>    <span class=o>+</span> <span class=n>short</span> <span class=n>prio</span>
</span></span><span class=line><span class=cl>    <span class=o>+</span> <span class=n>struct</span> <span class=n>list</span>
</span></span><span class=line><span class=cl>    <span class=o>+</span> <span class=n>struct</span> <span class=n>avail_lists</span>
</span></span><span class=line><span class=cl>    <span class=o>+</span> <span class=n>signed</span> <span class=n>type</span>
</span></span><span class=line><span class=cl>    <span class=o>+</span> <span class=n>unsigned</span> <span class=nb>max</span>
</span></span><span class=line><span class=cl>    <span class=o>+</span> <span class=n>unsigned</span> <span class=n>swap_map</span>
</span></span><span class=line><span class=cl>    <span class=o>+</span> <span class=n>struct</span> <span class=n>cluster_info</span>
</span></span><span class=line><span class=cl>    <span class=o>+</span> <span class=n>struct</span> <span class=n>free_clusters</span>
</span></span><span class=line><span class=cl>    <span class=o>+</span> <span class=n>unsigned</span> <span class=n>lowest_bit</span>
</span></span><span class=line><span class=cl>    <span class=o>+</span> <span class=n>unsigned</span> <span class=n>highest_bit</span>
</span></span><span class=line><span class=cl>    <span class=o>+</span> <span class=n>unsigned</span> <span class=n>pages</span>
</span></span><span class=line><span class=cl>    <span class=o>+</span> <span class=n>unsigned</span> <span class=n>inuse_pages</span>
</span></span><span class=line><span class=cl>    <span class=o>+</span> <span class=n>unsigned</span> <span class=n>cluster_next</span>
</span></span><span class=line><span class=cl>    <span class=o>+</span> <span class=n>unsigned</span> <span class=n>cluster_nr</span>
</span></span><span class=line><span class=cl>    <span class=o>+</span> <span class=n>struct</span> <span class=n>percpu_cluster</span>
</span></span><span class=line><span class=cl>    <span class=o>+</span> <span class=n>struct</span> <span class=n>curr_swap_extent</span>
</span></span><span class=line><span class=cl>    <span class=o>+</span> <span class=n>struct</span> <span class=n>first_swap_extent</span>
</span></span><span class=line><span class=cl>    <span class=o>+</span> <span class=n>struct</span> <span class=n>bdev</span>
</span></span><span class=line><span class=cl>    <span class=o>+</span> <span class=n>struct</span> <span class=n>swap_file</span>
</span></span><span class=line><span class=cl>    <span class=o>+</span> <span class=n>unsigned</span> <span class=n>old_block_size</span>
</span></span><span class=line><span class=cl>    <span class=o>+</span> <span class=n>spinlock_t</span> <span class=n>lock</span>
</span></span><span class=line><span class=cl>    <span class=o>+</span> <span class=n>spinlock_t</span> <span class=n>cont_lock</span>
</span></span><span class=line><span class=cl>    <span class=o>+</span> <span class=n>struct</span> <span class=n>discard_work</span>
</span></span><span class=line><span class=cl>    <span class=o>+</span> <span class=n>struct</span> <span class=n>discard_clusters</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=n>swap_cluster_info</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=o>+</span> <span class=n>spinlock_t</span> <span class=n>lock</span>
</span></span><span class=line><span class=cl><span class=o>+</span> <span class=n>unsigned</span> <span class=n>data</span>
</span></span><span class=line><span class=cl><span class=o>+</span> <span class=n>unsigned</span> <span class=n>flags</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>swap_info_struct</span> <span class=o>*--</span> <span class=n>swap_cluster_info</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=n>swap_cluster_list</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=o>+</span> <span class=n>struct</span> <span class=n>head</span>
</span></span><span class=line><span class=cl><span class=o>+</span> <span class=n>struct</span> <span class=n>tail</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>swap_info_struct</span> <span class=o>*--</span> <span class=n>swap_cluster_list</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=n>swap_extent</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=o>+</span> <span class=n>struct</span> <span class=n>list</span>
</span></span><span class=line><span class=cl><span class=o>+</span> <span class=n>unsigned</span> <span class=n>start_page</span>
</span></span><span class=line><span class=cl><span class=o>+</span> <span class=n>unsigned</span> <span class=n>nr_pages</span>
</span></span><span class=line><span class=cl><span class=o>+</span> <span class=n>sector_t</span> <span class=n>start_block</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>swap_info_struct</span> <span class=o>*--</span> <span class=n>swap_extent</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>note</span> <span class=n>left</span> <span class=n>of</span> <span class=n>swap_extent</span>
</span></span><span class=line><span class=cl><span class=err>一个交换区范围</span> <span class=p>(</span><span class=n>swap</span> <span class=n>extent</span> <span class=nb>range</span><span class=p>)</span> <span class=err>将交换文件的</span>
</span></span><span class=line><span class=cl><span class=n>PAGE_SIZE</span> <span class=err>大小的页的范围映射到磁盘块的范围上。</span>
</span></span><span class=line><span class=cl><span class=err>交换区范围列表映射整个交换文件。</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>end</span> <span class=n>note</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=n>block_device</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=o>+</span> <span class=n>dev_t</span> <span class=n>bd_dev</span>
</span></span><span class=line><span class=cl><span class=o>+</span> <span class=ne>int</span> <span class=n>bd_openers</span>
</span></span><span class=line><span class=cl><span class=o>+</span> <span class=n>struct</span> <span class=n>bd_inode</span>
</span></span><span class=line><span class=cl><span class=o>+</span> <span class=n>struct</span> <span class=n>bd_super</span>
</span></span><span class=line><span class=cl><span class=o>+</span> <span class=n>struct</span> <span class=n>bd_mutex</span>
</span></span><span class=line><span class=cl><span class=o>+</span> <span class=n>void</span> <span class=n>bd_claiming</span>
</span></span><span class=line><span class=cl><span class=o>+</span> <span class=n>void</span> <span class=n>bd_holder</span>
</span></span><span class=line><span class=cl><span class=o>+</span> <span class=ne>int</span> <span class=n>bd_holders</span>
</span></span><span class=line><span class=cl><span class=o>+</span> <span class=ne>bool</span> <span class=n>bd_write_holder</span>
</span></span><span class=line><span class=cl><span class=o>+</span> <span class=n>struct</span> <span class=n>bd_holder_disks</span>
</span></span><span class=line><span class=cl><span class=o>+</span> <span class=n>struct</span> <span class=n>bd_contains</span>
</span></span><span class=line><span class=cl><span class=o>+</span> <span class=n>unsigned</span> <span class=n>bd_block_size</span>
</span></span><span class=line><span class=cl><span class=o>+</span> <span class=n>u8</span> <span class=n>bd_partno</span>
</span></span><span class=line><span class=cl><span class=o>+</span> <span class=n>struct</span> <span class=n>bd_part</span>
</span></span><span class=line><span class=cl><span class=o>+</span> <span class=n>unsigned</span> <span class=n>bd_part_count</span>
</span></span><span class=line><span class=cl><span class=o>+</span> <span class=ne>int</span> <span class=n>bd_invalidated</span>
</span></span><span class=line><span class=cl><span class=o>+</span> <span class=n>struct</span> <span class=n>bd_disk</span>
</span></span><span class=line><span class=cl><span class=o>+</span> <span class=n>struct</span> <span class=n>bd_queue</span>
</span></span><span class=line><span class=cl><span class=o>+</span> <span class=n>struct</span> <span class=n>bd_bdi</span>
</span></span><span class=line><span class=cl><span class=o>+</span> <span class=n>struct</span> <span class=n>bd_list</span>
</span></span><span class=line><span class=cl><span class=o>+</span> <span class=n>unsigned</span> <span class=n>bd_private</span>
</span></span><span class=line><span class=cl><span class=o>+</span> <span class=ne>int</span> <span class=n>bd_fsfreeze_count</span>
</span></span><span class=line><span class=cl><span class=o>+</span> <span class=n>struct</span> <span class=n>bd_fsfreeze_mutex</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>swap_info_struct</span> <span class=o>*--</span> <span class=n>block_device</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=n>file</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=o>+</span> <span class=n>union</span> <span class=n>f_u</span>
</span></span><span class=line><span class=cl><span class=o>+</span> <span class=n>struct</span> <span class=n>f_path</span>
</span></span><span class=line><span class=cl><span class=o>+</span> <span class=n>struct</span> <span class=n>f_inode</span>
</span></span><span class=line><span class=cl><span class=o>+</span> <span class=k>const</span> <span class=n>f_op</span>
</span></span><span class=line><span class=cl><span class=o>+</span> <span class=n>spinlock_t</span> <span class=n>f_lock</span>
</span></span><span class=line><span class=cl><span class=o>+</span> <span class=k>enum</span> <span class=n>f_write_hint</span>
</span></span><span class=line><span class=cl><span class=o>+</span> <span class=n>atomic_long_t</span> <span class=n>f_count</span>
</span></span><span class=line><span class=cl><span class=o>+</span> <span class=n>unsigned</span> <span class=n>f_flags</span>
</span></span><span class=line><span class=cl><span class=o>+</span> <span class=n>fmode_t</span> <span class=n>f_mode</span>
</span></span><span class=line><span class=cl><span class=o>+</span> <span class=n>struct</span> <span class=n>f_pos_lock</span>
</span></span><span class=line><span class=cl><span class=o>+</span> <span class=n>loff_t</span> <span class=n>f_pos</span>
</span></span><span class=line><span class=cl><span class=o>+</span> <span class=n>struct</span> <span class=n>f_owner</span>
</span></span><span class=line><span class=cl><span class=o>+</span> <span class=k>const</span> <span class=n>f_cred</span>
</span></span><span class=line><span class=cl><span class=o>+</span> <span class=n>struct</span> <span class=n>f_ra</span>
</span></span><span class=line><span class=cl><span class=o>+</span> <span class=n>u64</span> <span class=n>f_version</span>
</span></span><span class=line><span class=cl><span class=o>+</span> <span class=n>void</span> <span class=n>f_security</span>
</span></span><span class=line><span class=cl><span class=o>+</span> <span class=n>void</span> <span class=n>private_data</span>
</span></span><span class=line><span class=cl><span class=o>+</span> <span class=n>struct</span> <span class=n>f_ep_links</span>
</span></span><span class=line><span class=cl><span class=o>+</span> <span class=n>struct</span> <span class=n>f_tfile_llink</span>
</span></span><span class=line><span class=cl><span class=o>+</span> <span class=n>struct</span> <span class=n>f_mapping</span>
</span></span><span class=line><span class=cl><span class=o>+</span> <span class=n>errseq_t</span> <span class=n>f_wb_err</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>swap_info_struct</span> <span class=o>*--</span> <span class=n>file</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=n>address_space</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=o>+</span> <span class=n>struct</span> <span class=n>host</span>
</span></span><span class=line><span class=cl><span class=o>+</span> <span class=n>struct</span> <span class=n>i_pages</span>
</span></span><span class=line><span class=cl><span class=o>+</span> <span class=n>atomic_t</span> <span class=n>i_mmap_writable</span>
</span></span><span class=line><span class=cl><span class=o>+</span> <span class=n>struct</span> <span class=n>i_mmap</span>
</span></span><span class=line><span class=cl><span class=o>+</span> <span class=n>struct</span> <span class=n>i_mmap_rwsem</span>
</span></span><span class=line><span class=cl><span class=o>+</span> <span class=n>unsigned</span> <span class=n>nrpages</span>
</span></span><span class=line><span class=cl><span class=o>+</span> <span class=n>unsigned</span> <span class=n>nrexceptional</span>
</span></span><span class=line><span class=cl><span class=o>+</span> <span class=n>unsigned</span> <span class=n>writeback_index</span>
</span></span><span class=line><span class=cl><span class=o>+</span> <span class=k>const</span> <span class=n>a_ops</span>
</span></span><span class=line><span class=cl><span class=o>+</span> <span class=n>unsigned</span> <span class=n>flags</span>
</span></span><span class=line><span class=cl><span class=o>+</span> <span class=n>spinlock_t</span> <span class=n>private_lock</span>
</span></span><span class=line><span class=cl><span class=o>+</span> <span class=n>gfp_t</span> <span class=n>gfp_mask</span>
</span></span><span class=line><span class=cl><span class=o>+</span> <span class=n>struct</span> <span class=n>private_list</span>
</span></span><span class=line><span class=cl><span class=o>+</span> <span class=n>void</span> <span class=n>private_data</span>
</span></span><span class=line><span class=cl><span class=o>+</span> <span class=n>errseq_t</span> <span class=n>wb_err</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>file</span> <span class=o>*--</span> <span class=n>address_space</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=n>inode</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=o>+</span> <span class=n>umode_t</span> <span class=n>i_mode</span>
</span></span><span class=line><span class=cl><span class=o>+</span> <span class=n>unsigned</span> <span class=n>i_opflags</span>
</span></span><span class=line><span class=cl><span class=o>+</span> <span class=n>kuid_t</span> <span class=n>i_uid</span>
</span></span><span class=line><span class=cl><span class=o>+</span> <span class=n>kgid_t</span> <span class=n>i_gid</span>
</span></span><span class=line><span class=cl><span class=o>+</span> <span class=n>unsigned</span> <span class=n>i_flags</span>
</span></span><span class=line><span class=cl><span class=o>+</span> <span class=n>struct</span> <span class=n>i_acl</span>
</span></span><span class=line><span class=cl><span class=o>+</span> <span class=n>struct</span> <span class=n>i_default_acl</span>
</span></span><span class=line><span class=cl><span class=o>+</span> <span class=k>const</span> <span class=n>i_op</span>
</span></span><span class=line><span class=cl><span class=o>+</span> <span class=n>struct</span> <span class=n>i_sb</span>
</span></span><span class=line><span class=cl><span class=o>+</span> <span class=n>struct</span> <span class=n>i_mapping</span>
</span></span><span class=line><span class=cl><span class=o>+</span> <span class=n>void</span> <span class=n>i_security</span>
</span></span><span class=line><span class=cl><span class=o>+</span> <span class=n>unsigned</span> <span class=n>i_ino</span>
</span></span><span class=line><span class=cl><span class=o>+</span> <span class=n>dev_t</span> <span class=n>i_rdev</span>
</span></span><span class=line><span class=cl><span class=o>+</span> <span class=n>loff_t</span> <span class=n>i_size</span>
</span></span><span class=line><span class=cl><span class=o>+</span> <span class=n>struct</span> <span class=n>i_atime</span>
</span></span><span class=line><span class=cl><span class=o>+</span> <span class=n>void</span> <span class=n>i_private</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>address_space</span> <span class=o>*--</span> <span class=n>inode</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm> * MAX_SWAPFILES defines the maximum number of swaptypes: things which can
</span></span></span><span class=line><span class=cl><span class=cm> * be swapped to.  The swap type and the offset into that swap type are
</span></span></span><span class=line><span class=cl><span class=cm> * encoded into pte&#39;s and into pgoff_t&#39;s in the swapcache.  Using five bits
</span></span></span><span class=line><span class=cl><span class=cm> * for the type means that the maximum number of swapcache pages is 27 bits
</span></span></span><span class=line><span class=cl><span class=cm> * on 32-bit-pgoff_t architectures.  And that assumes that the architecture packs
</span></span></span><span class=line><span class=cl><span class=cm> * the type/offset into the pte as 5/27 as well.
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm> * MAX_SWAPFILES 定义了最大的swaptypes数量：可以被交换到的东西。交换类型和交换类型中的偏移量都被编码到
</span></span></span><span class=line><span class=cl><span class=cm> * pte和swapcache中的pgoff_t中。对于类型使用五位意味着在32位pgoff_t架构上，swapcache页面的最大数量为27
</span></span></span><span class=line><span class=cl><span class=cm> * 位。并且这假设架构也将类型/偏移量打包到pte中，比例为5/27。
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#define MAX_SWAPFILES                              \
</span></span></span><span class=line><span class=cl><span class=cp>    ((1 &lt;&lt; MAX_SWAPFILES_SHIFT) - SWP_DEVICE_NUM - \
</span></span></span><span class=line><span class=cl><span class=cp>    SWP_MIGRATION_NUM - SWP_HWPOISON_NUM)
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>swap_info_struct</span> <span class=o>*</span><span class=n>swap_info</span><span class=p>[</span><span class=n>MAX_SWAPFILES</span><span class=p>];</span>
</span></span></code></pre></td></tr></table></div></div><p>最多 <code>MAX_SWAPFILES</code> 个 swap 设备。</p><h3 id=h:1fe99bb1-aeb0-4a49-9efe-56e123310ee6><span class=section-num>4.2</span> Locks</h3><h4 id=h:4542388b-4a23-4f9a-afc5-7d3afbbaf6c5><span class=section-num>4.2.1</span> 全局锁</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=nf>DEFINE_SPINLOCK</span><span class=p>(</span><span class=n>swap_lock</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=h:35cfd6f1-394c-4a8f-8883-aff2964a9ff3><span class=section-num>4.2.2</span> 粗粒度锁</h4><h4 id=h:aef166e9-9c66-4f62-8668-78d4e76aeaf9><span class=section-num>4.2.3</span> 细粒度锁</h4><h3 id=h:36e44df6-8e26-4bd4-bfc8-80df31b3614b><span class=section-num>4.3</span> fork 时候复制 swap…</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>14.74%     0.00%  xxxxsql  [kernel.kallsyms]         [k] entry_SYSCALL_64_after_hwframe
</span></span><span class=line><span class=cl>        |
</span></span><span class=line><span class=cl>        ---entry_SYSCALL_64_after_hwframe
</span></span><span class=line><span class=cl>           do_syscall_64
</span></span><span class=line><span class=cl>           |
</span></span><span class=line><span class=cl>           |--7.61%--__x64_sys_exit_group
</span></span><span class=line><span class=cl>           |          do_group_exit
</span></span><span class=line><span class=cl>           |          |
</span></span><span class=line><span class=cl>           |           --7.61%--do_exit
</span></span><span class=line><span class=cl>           |                     |
</span></span><span class=line><span class=cl>           |                      --7.46%--mmput
</span></span><span class=line><span class=cl>           |                                |
</span></span><span class=line><span class=cl>           |                                 --7.45%--exit_mmap
</span></span><span class=line><span class=cl>           |                                           |
</span></span><span class=line><span class=cl>           |                                            --6.37%--unmap_vmas
</span></span><span class=line><span class=cl>           |                                                      |
</span></span><span class=line><span class=cl>           |                                                       --6.33%--unmap_page_range
</span></span><span class=line><span class=cl>           |                                                                 |
</span></span><span class=line><span class=cl>           |                                                                 |--0.98%--free_swap_and_cache
</span></span><span class=line><span class=cl>           |                                                                 |
</span></span><span class=line><span class=cl>           |                                                                  --0.76%--tlb_flush_mmu
</span></span><span class=line><span class=cl>           |
</span></span><span class=line><span class=cl>           |--3.40%--_do_fork
</span></span><span class=line><span class=cl>           |          |
</span></span><span class=line><span class=cl>           |           --3.38%--copy_process
</span></span><span class=line><span class=cl>           |                     |
</span></span><span class=line><span class=cl>           |                      --3.15%--dup_mm
</span></span><span class=line><span class=cl>           |                                |
</span></span><span class=line><span class=cl>           |                                 --2.42%--copy_page_range
</span></span><span class=line><span class=cl>           |                                           |
</span></span><span class=line><span class=cl>           |                                            --2.35%--copy_pte_range.isra.97
</span></span><span class=line><span class=cl>           |                                                      |
</span></span><span class=line><span class=cl>           |                                                       --0.98%--swap_duplicate
</span></span><span class=line><span class=cl>           |                                                                 |
</span></span><span class=line><span class=cl>           |                                                                  --0.83%--__swap_duplicate
</span></span></code></pre></td></tr></table></div></div><h4 id=h:b1a19790-e8c8-4c2a-a0a1-13fad351664e><span class=section-num>4.3.1</span> <code>swap_duplicate</code></h4><ul><li>将 swap entry 的引用计数增加 1。</li><li>返回 <code>0</code> : 表示成功</li><li>返回 <code>-ENOMEM</code><br>如果需要 <code>swap_count_continuation</code> 但无法原子地分配，</li><li>如果 <code>__swap_duplicate()</code> 因其他原因失败（ <code>-EINVAL</code> 或 <code>-ENOENT</code> ），如页表条目损坏，则返回 0，就像它成功一样。</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm> * Increase reference count of swap entry by 1.
</span></span></span><span class=line><span class=cl><span class=cm> * Returns 0 for success, or -ENOMEM if a swap_count_continuation is required
</span></span></span><span class=line><span class=cl><span class=cm> * but could not be atomically allocated.  Returns 0, just as if it succeeded,
</span></span></span><span class=line><span class=cl><span class=cm> * if __swap_duplicate() fails for another reason (-EINVAL or -ENOENT), which
</span></span></span><span class=line><span class=cl><span class=cm> * might occur if a page table entry has got corrupted.
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>swap_duplicate</span><span class=p>(</span><span class=kt>swp_entry_t</span> <span class=n>entry</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>err</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=o>!</span><span class=n>err</span> <span class=o>&amp;&amp;</span> <span class=nf>__swap_duplicate</span><span class=p>(</span><span class=n>entry</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span> <span class=o>==</span> <span class=o>-</span><span class=n>ENOMEM</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>err</span> <span class=o>=</span> <span class=nf>add_swap_count_continuation</span><span class=p>(</span><span class=n>entry</span><span class=p>,</span> <span class=n>GFP_ATOMIC</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>err</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=h:cb155170-b5a3-421f-9f98-090780fbf82a><span class=section-num>4.4</span> 进程退出时候清理 swap 。。。</h3><h2 id=h:e5964c54-29f4-42fa-af12-10ca1093f20b><span class=section-num>5</span> RLIMIT_MEMLOCK</h2></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>更新于 2023-12-16</span></div></div><div class=post-info-line><div class=post-info-md><span><a class=link-to-markdown href=/how-to-avoid-memory-being-swapped/index.md target=_blank>阅读原始文档</a></span></div><div class=post-info-share><span></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw" aria-hidden=true></i>&nbsp;<a href=/tags/memory/>Memory</a>,&nbsp;<a href=/tags/mlock/>Mlock</a>,&nbsp;<a href=/tags/swap/>Swap</a>,&nbsp;<a href=/tags/lock/>Lock</a>,&nbsp;<a href=/tags/mlockall/>Mlockall</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/logindex/ class=prev rel=prev title="LogIndex | PolarDB for PostgreSQL"><i class="fas fa-angle-left fa-fw" aria-hidden=true></i>LogIndex | PolarDB for PostgreSQL</a>
<a href=/note-about-po-file/ class=next rel=next title="Note about PO file in PostgreSQL">Note about PO file in PostgreSQL<i class="fas fa-angle-right fa-fw" aria-hidden=true></i></a></div></div><div id=comments><div id=giscus class=comment></div><noscript>Please enable JavaScript to view the comments powered by <a href=https://giscus.app>Giscus</a>.</noscript></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line itemscope itemtype=http://schema.org/CreativeWork>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title=回到顶部><i class="fas fa-arrow-up fa-fw" aria-hidden=true></i>
</a><a href=# id=view-comments class=fixed-button title=查看评论><i class="fas fa-comment fa-fw" aria-hidden=true></i></a></div><script type=text/javascript src=https://cdn.jsdelivr.net/npm/autocomplete.js@0.38.1/dist/autocomplete.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/algoliasearch@4.13.1/dist/algoliasearch-lite.umd.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"复制到剪贴板",maxShownLines:50},comment:{giscus:{category:"Announcements",categoryId:"R_kgDON6NYZA",darkTheme:"dark",emitMetadata:"0",inputPosition:"bottom",lang:"zh-CN",lazyLoading:!1,lightTheme:"light",mapping:"pathname",reactionsEnabled:"1",repo:"yangyingchao/giscus",repoId:""}},search:{algoliaAppID:null,algoliaIndex:"index.zh-cn",algoliaSearchKey:null,highlightTag:"em",maxResultLength:10,noResultsFound:"没有找到结果",snippetLength:30,type:"algolia"}}</script><script type=text/javascript src=/js/theme.min.js></script></body></html>