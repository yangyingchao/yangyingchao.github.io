[{"categories":null,"content":" Table of Contents 1 情绪的重要性 2 学习金字塔：吸收 90%的信息 3 如何吸收自己看过的东西？ 4 猎奇：让思想碰撞 本文为摘录(或转载)，侵删，原文为： https://bookfere.com/post/186.html 吸收的数量并不重要，如何吸收知识才是重要的。 几天前，我1做了一件我之前从来没有做过的事情。 我将 JayZ 的专辑《Magna Carta Holy Grail》从头听到尾，中间没有停顿过。我戴上耳机，闭上眼睛，一直在听。我之前会边阅读边思考，所以能记下许多东西，但这一次，我第一次用边听边思考的方式听音乐。听过这张专辑后，我似乎与专辑建立起了更深的情感。我在网上搜索 JayZ，第二天又将这张专辑从头听到尾。 建立深厚情感让人很有收获，但是它带来了许多其他东西——它赋予我灵感，于是我写下了这篇文章。所以尽管我在听专辑的时候并没有什么产出，但是它激发我进行创造。 创造很重要，而整合自己吸收的东西是创造过程中的重要一环。 我在上大学的时候，在一家心理实验中心做过研究，导师是理查德·戴维森博士，他曾被《时代》杂志评为百大最具影响人物。 我们实验室做过的一个实验是有关冥想，研究冥想的时候噪音如何在脑子中减少，工作记忆和智商是如何得到提升。 当你完全投入的时候，你的大脑会建立起更深厚的情感关系，强化你未来回忆起这些事情的能力。 ","date":"2025-08-20","objectID":"/bookfere_com_post_186/:0:0","tags":null,"title":"如何在有限的阅读时间里做到过目不忘","uri":"/bookfere_com_post_186/"},{"categories":null,"content":"1 情绪的重要性 我们对一些瞬间总会记忆犹新。 有可能是演唱会上的一首歌，有可能是旅行当中难忘的经历。这些瞬间让你记忆犹新，因为它们让你开心、难过或是生气。当你将某种情绪和经历联系起来的时候，你的体内释放了荷尔蒙，在大脑中的一些部门起到了润滑作用，神经形成了新的记忆回路。这也就是为什么过去的一些事情总是在你思考的时候浮现——带有情绪的经历往往让人记忆犹新。 如果你在投入的时候，能够更加关注，就能在情感上与这段经历建立关系，记住更多的东西，有利于日后创新。 ","date":"2025-08-20","objectID":"/bookfere_com_post_186/:1:0","tags":null,"title":"如何在有限的阅读时间里做到过目不忘","uri":"/bookfere_com_post_186/"},{"categories":null,"content":"2 学习金字塔：吸收 90%的信息 每次刷微博，看文章，看视频，我都觉得自己特别内疚，希望自己记住所有的东西。事实上，我认为自己正在吸收的东西很快就会溜走。你是在被动地吸收，快速浏览，不断翻页。 学习金字塔理论认为，学习最有效的方式是将学到的知识传授给别人或者马上付诸实践。 如果能够马上把知识传授给别人，就能吸收 90%的内容； 如果能够马上把知识付诸实践，就能吸收 75%的内容； 如果能够与他人进行小组讨论，就能吸收 50%的内容； 如果通过范例学习，就能吸收 30%的内容； 如果通过视频和音频学习，就能吸收 20%的内容； 如果通过阅读学习，就能吸收 10%的内容； 如果通过听讲座学习，就能吸收 5%的内容。 这也就是为什么伟大的作家也同时是兢兢业业的读者，他们投入到一个话题当中去，因为他们需要创造一个有意义的对话。 自学成才的人，通常是吸收信息的高手，因为他们能够不断反思，并且将学习到的知识付诸实践。达芬奇就是自学成才，他有自己的一套体系，通过付诸实践和奖励来吸收信息。在这个过程当中，他会犯错，但是正是这些错误巩固了他的知识。 听讲和阅读只是听讲和阅读。它们并不是真正的学习。真正的学习源于犯错。犯错源于行动。 ","date":"2025-08-20","objectID":"/bookfere_com_post_186/:2:0","tags":null,"title":"如何在有限的阅读时间里做到过目不忘","uri":"/bookfere_com_post_186/"},{"categories":null,"content":"3 如何吸收自己看过的东西？ 看书或者看电影是产出的重要部分，但是我一定会确保自己全身心投入。以下是我的一些方法，用吸收的知识为今后的产出打下基础。 每次看微博或是一篇文章的时候，我都抱着一种看完之后要向朋友讲述的心态。这是最基本的，因为这样才能吸收自己看到的东西，而不是仅仅看看内容，点个大拇指。 著名心理学家罗伯特·B·西奥迪尼通常会从一本笔记本当中抽出一张纸，在读完每个章节之后，写上总结。研究表明，这个做法比不断阅读相同章节可以让你记住 50%更多内容。 看得时候就抱着自己要将知识传授给别人的心态。当你阅读的时候，脑子里想着自己要将看到的知识教给别人。可以是你的孩子、爱人或是父母。看过之后，与他们分享，并且付诸实践。 通过实践和犯错的方法学习能够解释为什么研究表明，人们在旅行或是留学的时候能够产出更多的东西。研究者发现，人们在海外留学的时候，能够更快产生情感联系，说明全身心投入可以让你产出更多东西。 付诸实践能够让你更好地吸收知识。正是通过犯错，才能真正学习。 ","date":"2025-08-20","objectID":"/bookfere_com_post_186/:3:0","tags":null,"title":"如何在有限的阅读时间里做到过目不忘","uri":"/bookfere_com_post_186/"},{"categories":null,"content":"4 猎奇：让思想碰撞 研究发现，特殊的经历能够产生新的神经联络，会于你已有的思想产生碰撞。 与不同的人交往，或者做一些你从未做过的事情，这样往往能够产生新观点。灵感可能来源一个墙上很小的标志，也有可能来源于和服务员的对话。无论是和好朋友吃饭或者看电影，能够专注地投入现在正在做的事情，你的感官也会更加投入。 本文转载自 LinkedIn 中国(微信 ID：LinkedIn-China) 作者：领英用户（LinkedIn Member）Mikael Cho，Crew 创始人，曾就职于 Uber Foundry、Blue、Kuuala ↩︎ ","date":"2025-08-20","objectID":"/bookfere_com_post_186/:4:0","tags":null,"title":"如何在有限的阅读时间里做到过目不忘","uri":"/bookfere_com_post_186/"},{"categories":null,"content":" Table of Contents 1 Linkers part 1 1.1 链接器做什么？ 2 Linkers part 2 2.1 Basic Linker Data Types 2.2 基本链接器操作 3 part 3 3.1 地址空间 3.2 对象文件格式 4 Shared Libraries 5 Part 5 5.1 Shared Libraries Redux 5.2 ELF Symbols 6 Linkers part 6 6.1 重定位 (Relocations) 6.2 Position Dependent Shared Libraries 7 Linkers part 7: classic small optimization: Thread Local Storage 8 Linkers part 8: ELF Segments 9 Linkers part 9 9.1 Symbol Versions 9.2 Relaxation 10 Linkers part 10： Parallel Linking 11 Linkers part 11 本文为摘录(或转载)，侵删，原文为： https://www.airs.com/blog/archives/38 ","date":"2025-08-08","objectID":"/www_airs_com_archives_38/:0:0","tags":["linkers","lianjieqi"],"title":"Linkers","uri":"/www_airs_com_archives_38/"},{"categories":null,"content":"1 Linkers part 1 ","date":"2025-08-08","objectID":"/www_airs_com_archives_38/:1:0","tags":["linkers","lianjieqi"],"title":"Linkers","uri":"/www_airs_com_archives_38/"},{"categories":null,"content":"1.1 链接器做什么？ 很简单：链接器将目标文件转换为可执行文件和共享库。让我们看看这意味着什么。使用链接器的情况是，软件开发过程包括用某种语言编写程序代码：例如，C或 C++或 Fortran（但通常不包括 Java，因为 Java 通常以不同的方式工作，使用加载器而不是链接器）。编译器将这种人类可读的程序代码转换为另一种人类可读的文本形式，称为汇编代码。汇编代码是机器语言的可读形式，计算机可以直接执行。汇编器用于将此汇编代码转换为目标文件。为了完整起见，我要提到某些编译器在内部包括一个汇编器，并直接生成目标文件。无论哪种方式，这就是事情变得有趣的地方。 在古老的日子里，当恐龙漫游数据中心时，许多程序是自给自足的。在那些日子里，通常没有编译器——人们直接用汇编代码编写——而汇编器实际上生成了可执行文件，机器可以直接执行。随着 Fortran 和 Cobol 等语言的出现，人们开始以子例程库的方式思考，这意味着必须有某种方法在两个不同的时间运行汇编器，并将输出组合成一个可执行文件。这要求汇编器生成不同类型的输出，这种输出被称为目标文件（我不知道这个名字来自哪里）。同时需要一个新程序将不同的目标文件组合成一个单一的可执行文件。这个新程序被称为链接器（这个名字的来源应该很明显）。 链接器今天仍然执行相同的任务。在接下来的几十年里，添加了一个新特性：共享库。 ","date":"2025-08-08","objectID":"/www_airs_com_archives_38/:1:1","tags":["linkers","lianjieqi"],"title":"Linkers","uri":"/www_airs_com_archives_38/"},{"categories":null,"content":"2 Linkers part 2 ","date":"2025-08-08","objectID":"/www_airs_com_archives_38/:2:0","tags":["linkers","lianjieqi"],"title":"Linkers","uri":"/www_airs_com_archives_38/"},{"categories":null,"content":"2.1 Basic Linker Data Types 链接器操作于少量基本数据类型：符号 (symbols)、重定位 (relocations)和内容 (contents)。这些在输入的目标文件中定义。以下是这些的概述。 2.1.1 符号 symbol 一个符号基本上是一个名称和一个值。许多符号代表源代码中的静态对象——即在程序运行期间存在于单一位置的对象。例如，在从 C 代码生成的目标文件中，将为每个函数以及每个全局和静态变量生成一个符号。此类符号的值仅仅是对其内容的偏移量。这种类型的符号称为定义符号。重要的是不要将表示变量 my_global_var 的符号的值与 my_global_var 本身的值混淆。符号的值大致是该变量的地址：在 C 中从表达式 \u0026my_global_var 获得的值。 符号还用于表示对在不同目标文件中定义的名称的引用。这样的引用被称为未定义符号。还有其他一些使用较少的符号类型，我将在后面描述。 在链接过程中，链接器将为每个定义符号分配一个地址，并通过查找具有相同名称的定义符号来解析每个未定义符号。 2.1.2 重定位 重定位是对内容执行的计算。大多数重定位引用一个符号和内容内的一个偏移量。许多重定位还会提供一个额外的操作数，称为附加数。一个简单且常用的重定位是“将内容中的此位置设置为此符号的值加上此附加数。”重定位所做的计算类型本质上依赖于链接器所生成代码的处理器架构。例如，RISC 处理器需要两个或更多指令来形成内存地址，因此每个指令将有单独的重定位；例如，“将内容中的此位置设置为此符号值的低 16 位。” 在链接过程中，链接器将按照指示执行所有重定位计算。目标文件中的重定位可能引用未定义符号。如果链接器无法解析该符号，它通常会发出错误（但并不总是：对于某些符号类型或某些重定位类型，错误可能不合适）。 2.1.3 内容 内容是程序执行期间内存应如何显示的内容。内容具有大小、一个字节数组和类型。它们包含由编译器和汇编器生成的机器代码（称为文本）。它们包含已初始化变量的值（数据）。它们包含如字符串常量和开关表等静态无名数据（只读数据或 rdata）。它们包含未初始化的变量，这种情况下字节数组通常会被省略，并假设仅包含零（bss）。编译器和汇编器努力生成完全正确的内容，但链接器实际上对此并不关心，只将其视为原始数据。链接器从每个文件中读取内容，将其按照类型连接在一起，应用重定位，并将结果写入可执行文件。 ","date":"2025-08-08","objectID":"/www_airs_com_archives_38/:2:1","tags":["linkers","lianjieqi"],"title":"Linkers","uri":"/www_airs_com_archives_38/"},{"categories":null,"content":"2.2 基本链接器操作 此时，我们已经足够了解每个链接器使用的基本步骤。 – 读取输入目标文件。确定内容的长度和类型。读取符号。– 构建一个包含所有符号的符号表，将未定义符号链接到它们的定义。– 决定所有内容在输出可执行文件中的位置，这意味着决定它们在程序运行时应该放在哪里。– 读取内容数据和重定位。将重定位应用于内容。将结果写入输出文件。– 可选地写出完整的符号表及符号的最终值。 ","date":"2025-08-08","objectID":"/www_airs_com_archives_38/:2:2","tags":["linkers","lianjieqi"],"title":"Linkers","uri":"/www_airs_com_archives_38/"},{"categories":null,"content":"3 part 3 ","date":"2025-08-08","objectID":"/www_airs_com_archives_38/:3:0","tags":["linkers","lianjieqi"],"title":"Linkers","uri":"/www_airs_com_archives_38/"},{"categories":null,"content":"3.1 地址空间 地址空间简单来说就是内存的一个视图，在这个视图中，每个字节都有一个地址。链接器处理三种不同类型的地址空间。 每个输入对象文件是一个小的地址空间：其内容都有地址，符号和重定位通过地址引用这些内容。 输出程序在运行时将被放置在内存的某个位置。这就是输出地址空间，我通常称之为使用虚拟内存地址。 输出程序将在内存的某个位置被加载。这就是加载内存地址。 在典型的 Unix 系统中，虚拟内存地址和加载内存地址是相同的。在嵌入式系统中，它们通常不同；例如，初始化的数据（全局或静态变量的初始内容）可能会被加载到 ROM 中的加载内存地址，然后复制到虚拟内存地址的 RAM 中。 共享库通常可以在不同进程中以不同的虚拟内存地址运行。共享库在创建时有一个基地址；这通常仅仅是零。当动态链接器将共享库复制到进程的虚拟内存空间时，必须应用重定位以调整共享库使其在虚拟内存地址上运行。共享库系统最小化必须应用的重定位数量，因为它们在启动程序时需要时间。 ","date":"2025-08-08","objectID":"/www_airs_com_archives_38/:3:1","tags":["linkers","lianjieqi"],"title":"Linkers","uri":"/www_airs_com_archives_38/"},{"categories":null,"content":"3.2 对象文件格式 正如我上面所说，汇编器将人类可读的汇编语言转换为对象文件。对象文件是以一种为链接器设计的格式编写的二进制数据文件。链接器生成一个可执行文件。这个可执行文件是以一种为操作系统或加载程序设计的格式编写的二进制数据文件（即使在动态链接时也是如此，通常操作系统在调用动态链接器以开始运行程序之前会加载可执行文件）。对象文件格式并没有逻辑要求与可执行文件格式相似。然而，在实践中，它们通常非常相似。 大多数对象文件格式定义了段。段通常保存内存内容，或者可以用于保存其他类型的数据。段通常有一个名称、一个类型、一个大小、一个地址和一个关联的数据数组。 对象文件格式可以分为两种一般类型：记录导向和段导向。 记录导向的对象 记录导向的对象文件格式定义了一系列大小各异的记录。每个记录以某种特殊代码开始，后面可能跟着数据。读取对象文件需要从头开始读取并处理每个记录。记录用于描述符号和段。重定位可能与段相关联，或者可能由其他记录指定。IEEE-695 和 Mach-O 是当前使用的记录导向对象文件格式。 段导向的对象文件 在段导向的对象文件格式中，文件头描述了具有指定数量段的段表。符号可以出现在由文件头描述的对象文件的单独部分，或者可以出现在特殊段中。重定位可以附加到段上，或者可以出现在单独的段中。对象文件可以通过读取段表，然后直接读取特定段来进行读取。ELF、COFF、PE 和 a.out 是段导向对象文件格式。 每种对象文件格式都需要能够表示调试信息。调试信息由编译器生成，并由调试器读取。通常，链接器可以将其视为任何其他类型的数据。然而，在实践中，程序的调试信息可能比实际程序本身要大。链接器可以使用各种技术来减少调试信息的量，从而减少可执行文件的大小。这可以加快链接速度，但需要链接器理解调试信息。 a.out 对象文件格式使用符号表中的特殊字符串存储调试信息，这些字符串被称为 stabs。这些特殊字符串就是特殊类型的符号名称。这种技术也被某些 ECOFF 变体和旧版本的 Mach-O 使用。 COFF 对象文件格式使用符号表中的特殊字段存储调试信息。这种类型信息是有限的，对于 C++来说完全不够用。解决这些限制的常见技术是在 COFF 段中嵌入 stabs 字符串。 ELF 对象文件格式在具有特殊名称的段中存储调试信息。调试信息可以是 stabs 字符串或 DWARF 调试格式。 ","date":"2025-08-08","objectID":"/www_airs_com_archives_38/:3:2","tags":["linkers","lianjieqi"],"title":"Linkers","uri":"/www_airs_com_archives_38/"},{"categories":null,"content":"4 Shared Libraries 我们已经讨论了一些目标文件和可执行文件，那么共享库是什么样的呢？我将重点讲述 SVR4（以及 GNU/Linux 等）中使用的 ELF 共享库，因为它们是最灵活的共享库实现，也是我最熟悉的。 Windows 共享库，称为 DLL，在灵活性方面较低，因为您必须根据代码是否将进入共享库以不同的方式进行编译。您还必须在源代码中表达符号可见性。这并不是本质上的坏事，实际上 ELF 随着时间的推移吸收了一些这些思路，但 ELF 格式在链接时做出更多的决策，因此更强大。 当程序链接器创建共享库时，它尚不知道该共享库将在哪个虚拟地址上运行。实际上，在不同的进程中，同一个共享库将在不同的地址上运行，这取决于动态链接器所做的决策。这意味着共享库代码必须是位置无关的(positionindependent)。更准确地说，在动态链接器加载完成后，它必须是位置无关的。只要有足够的重定位信息，动态链接器总是能够将任何代码片段转换为在任何虚拟地址上运行。然而，进行重定位计算必须在每次程序启动时进行，这意味着程序的启动速度会变慢。因此，任何共享库系统都寻求生成位置独立的代码，这要求在运行时应用的重定位数量尽可能最小，同时仍能接近位置相关代码的运行效率。 一个额外的复杂性是，ELF 共享库的设计大致相当于普通的档案。这意味着默认情况下，主可执行文件可能会覆盖共享库中的符号，导致共享库中的引用会调用可执行文件中的定义，即使共享库也定义了相同的符号。例如，一个可执行文件可能定义了自己版本的 malloc。C 库也定义了 malloc，并且 C 库中包含调用 malloc 的代码。如果可执行文件自己定义了 malloc，它将覆盖 C 库中的函数。当 C 库中的某个其他函数调用 malloc 时，它将调用可执行文件中的定义，而不是 C 库中的定义。 因此，对于任何特定的 ELF 实现，存在不同的要求在不同的方向上拉扯。正确的实现选择将取决于处理器的特性。尽管如此，大多数，但不是全部，处理器做出的决策相当相似。这里我将描述常见的情况。使用常见情况的处理器实例是 i386；做出一些不同决策的处理器实例是 PowerPC。 在一般情况下，代码可能会以两种不同的模式编译。 默认情况下，代码是位置依赖的。 将位置依赖的代码放入共享库会导致程序链接器生成大量的重定位信息，并使动态链接器在运行时进行大量处理。 代码也可以以位置无关模式编译，通常使用 -fpic 选项。 位置无关代码在调用非静态函数或引用全局或静态变量时稍微慢一些。然而，它需要的重定位信息要少得多，因此动态链接器将更快地启动程序。 位置无关代码将通过过程链接表（PLT）调用非静态函数。这个 PLT 在.o 文件中并不存在。在.o 文件中，使用 PLT 由一种特殊的重定位来指示。当程序链接器处理这样的重定位时，它会在 PLT 中创建一个条目。它将调整指令，使其成为对 PLT 条目的 PC 相对调用。PC 相对调用本质上是位置无关的，因此不需要重定位条目。程序链接器将为 PLT 条目创建一个重定位，指示动态链接器哪个符号与该条目相关联。这个过程将共享库中每个函数调用的动态重定位数量从每个函数调用一个减少到每个被调用函数一个。 进一步地，PLT（程序链接表）入口通常由动态链接器懒惰地重定位。在大多数 ELF 系统上，这种懒惰行为可以通过在运行程序时设置 LD_BIND_NOW 环境变量来覆盖。然而，默认情况下，动态链接器实际上不会对 PLT 应用重定位，直到某些代码真正调用了相关函数。这也加快了启动时间，因为许多程序的调用不会触发每一个可能的函数。考虑到共享 C 库时尤其如此，因为它的函数调用远比任何典型的程序要多得多。 为了使这一切正常工作，程序链接器将 PLT 入口初始化为加载一个索引到某个寄存器中或将其压入栈中，然后跳转到公共代码。公共代码回调到动态链接器，动态链接器使用该索引查找适当的 PLT 重定位，并利用该重定位找到被调用的函数。动态链接器随后使用函数的地址初始化 PLT 条目，然后跳转到该函数的代码。下次调用该函数时，PLT 条目将直接跳转到该函数。 在给出一个例子之前，我将谈谈位置无关代码中的另一个主要数据结构，即全局偏移表（Global Offset Table，简称 GOT）。它用于全局和静态变量。对于每个来自位置无关代码的全局变量引用，编译器将生成一个从 GOT 中加载以获取变量地址的操作，随后再执行第二个加载以获取变量的实际值。GOT 的地址通常存储在一个寄存器中，以便高效访问。与 PLT 一样，GOT 并不在.o 文件中存在，而是由程序链接器创建。程序链接器将创建动态重定位，动态链接器将在运行时使用这些重定位来初始化 GOT。与 PLT 不同，动态链接器在程序启动时总会完全初始化 GOT。 例如，在 i386 上，GOT 的地址存储在寄存器%ebx 中。这个寄存器在每个位置无关代码函数的入口处进行初始化。初始化序列因编译器而异，但通常看起来像这样： call __i686.get_pc_thunk.bx add $offset,%ebx 函数 __i686.get_pc_thunk.bx 的内容如下： mov (%esp),%ebx ret 这一指令序列使用位置无关序列获取它运行的地址。然后使用一个偏移量获取 GOT 的地址。请注意，这要求 GOT 始终与代码保持固定的偏移，无论共享库被加载到哪里。也就是说，动态链接器必须将共享库作为一个固定单元加载；它不能将不同部分加载到不同地址。 现在，通过从 %ebx 的固定偏移量加载地址，来读取或写入全局和静态变量。程序链接器将为 GOT 中的每个条目创建动态重定位，告知动态链接器如何初始化该条目。这些重定位的类型为 GLOB_DAT。 对于函数调用，程序链接器将设置一个 PLT 条目，形如下述所示： jmp *offset(%ebx) pushl #index jmp first_plt_entry 程序链接器将为 PLT 中的每个条目在 GOT 中分配一个条目。它将为 GOT 条目创建类型为 JMP_SLOT 的动态重定位。它将初始化 GOT 条目为共享库的基地址加上上面代码序列中第二个指令的地址。当动态链接器对 JMP_SLOT 重定位执行初始懒惰绑定时，它仅需在 GOT 条目中添加共享库加载地址与共享库基地址之间的差异。其效果是，第一次 jmp 指令将跳转到第二个指令，该指令将压入索引条目并跳转到第一个 PLT 条目。第一个 PLT 条目是特殊的，形如下述所示： pushl 4(%ebx) jmp *8(%ebx) 这引用了 GOT 中的第二和第三条目。动态链接器将初始化它们，使其具有适合于回调到动态链接器本身的相应值。动态链接器将使用第一个代码序列中压入的索引来查找 JMP_SLOT 重定位。当动态链接器确定要调用的函数时，它将把函数的地址存储到第一个代码序列所引用的 GOT 条目中。因此，下次调用该函数时，jmp 指令将直接跳转到正确的代码。 这只是快速浏览了许多细节，但我希望这能传达主要思想。这意味着，对于 i386 上的位置无关代码，每次对全局函数的调用在第一次调用后需要多一个额外的指令。每次对全局或静态变量的引用也需要多一个额外的指令。几乎每个函数在开始时使用四个额外的指令来初始化%ebx（不引用任何全局变量的叶子函数不需要初始化%ebx）。所有这些对程序缓存都有一定的负面影响。这是为了让动态链接器快速启动程序而付出的运行时性能代价。 在其他处理器上，细节自然有所不同。然而，整体风格是相似的：位置无关代码在共享库中启动更快，但运行稍微慢一些。 ","date":"2025-08-08","objectID":"/www_airs_com_archives_38/:4:0","tags":["linkers","lianjieqi"],"title":"Linkers","uri":"/www_airs_com_archives_38/"},{"categories":null,"content":"5 Part 5 ","date":"2025-08-08","objectID":"/www_airs_com_archives_38/:5:0","tags":["linkers","lianjieqi"],"title":"Linkers","uri":"/www_airs_com_archives_38/"},{"categories":null,"content":"5.1 Shared Libraries Redux 当程序链接器将依赖于位置的代码放入共享库时，它必须将对象文件中的更多重定位信息复制到共享库中。这些重定位信息将在运行时由动态链接器计算为动态重定位。有些重定位信息不必被复制；例如，指向共享库中局部符号的相对程序计数器重定位可以由程序链接器完全解析，而不需要动态重定位。然而，请注意，指向全局符号的相对程序计数器重定位确实需要动态重定位；否则，主可执行文件将无法覆盖该符号。有些重定位信息必须存在于共享库中，但不需要是对象文件中重定位信息的实际副本；例如，一个计算共享库中局部符号绝对地址的重定位通常可以用 RELATIVE 重定位替代，该重定位仅指示动态链接器添加共享库加载地址与其基址之间的差值。使用 RELATIVE 重定位的优势在于动态链接器可以在运行时快速计算，因为它不需要确定符号的值。 对于位置无关代码，程序链接器的工作更加复杂。编译器和汇编器会协同生成位置无关代码的特殊重定位。虽然各个处理器的细节有所不同，但通常会有一个 PLT 重定位和一个 GOT 重定位。这些重定位会指导程序链接器为 PLT 或 GOT 添加一个条目，同时执行一些计算。例如，在 i386 上，位置无关代码中的函数调用会生成一个 R_386_PLT32 重定位。该重定位将像往常一样引用一个符号。它会指导程序链接器为该符号添加一个 PLT 条目，如果尚不存在的话。重定位的计算随后是对 PLT 条目的 PC 相对引用。（重定位名称中的 32 指的是引用的大小，即 32 位）。昨天我描述了在 i386 上每个 PLT 条目也都有一个对应的 GOT 条目，因此 R_386_PLT32 重定位实际上指导程序链接器同时创建一个 PLT 条目和一个 GOT 条目。 当程序链接器在 PLT 或 GOT 中创建一个条目时，它还必须生成一个动态重定位以告知动态链接器有关该条目的信息。通常这将是一个 JMP_SLOT 或 GLOB_DAT 重定位。 这就意味着程序链接器必须跟踪每个符号的 PLT 条目和 GOT 条目。当然，最初不会有这样的条目。当链接器看到 PLT 或 GOT 重定位时，它必须检查重定位所引用的符号是否已经有 PLT 或 GOT 条目，如果没有则创建一个。注意，单个符号可能同时具有 PLT 条目和 GOT 条目；这会发生在位置无关代码中，该代码既调用函数又取其地址。 动态链接器在 PLT 和 GOT 表中的工作是简单地在运行时计算 JMP_SLOT 和 GLOB_DAT 重定位。这里的主要复杂性是我昨天描述的 PLT 条目的惰性求值。 C 语言允许取函数地址，这引入了一个有趣的复杂性。在 C 中，您可以取函数的地址，并且可以将这个地址与另一个函数地址进行比较。问题在于，如果您在共享库中取一个函数的地址，得到的自然结果将是 PLT 条目的地址。毕竟，调用函数的跳转就是跳转到这个地址。然而，每个共享库都有其自己的 PLT，因此特定函数的地址在每个共享库中都会有所不同。这意味着在不同共享库中生成的函数指针的比较可能不同，而它们应该相同。这不是一个纯假设的问题；当我做一个错误端口时，在我修复错误之前，我看到在 Tcl 共享库中比较函数指针时失败了。 在大多数处理器上，解决此错误的办法是对具有 PLT 条目但未定义的符号进行特殊标记。通常符号将被标记为未定义，但带有非零值——该值将设置为 PLT 条目的地址。当动态链接器在搜索用于重定位的符号值时，如果它发现这样的特殊标记符号，它将使用非零值。这将确保所有非函数调用的符号引用都将使用相同的值。为了使这项工作正常，编译器和汇编器必须确保任何不涉及调用的函数引用都不会携带标准 PLT 重定位。这种对函数地址的特殊处理需要在程序链接器和动态链接器中实现。 ","date":"2025-08-08","objectID":"/www_airs_com_archives_38/:5:1","tags":["linkers","lianjieqi"],"title":"Linkers","uri":"/www_airs_com_archives_38/"},{"categories":null,"content":"5.2 ELF Symbols 好了，关于共享库的内容够多了。让我们更详细地讨论 ELF 符号。我不打算详细列出确切的数据结构——您可以查阅 ELF ABI。我要讨论的是不同的字段及其含义。许多不同类型的 ELF 符号也被其他目标文件格式使用，但我不会涵盖这一点。 ELF 符号表中的一个条目有八个部分信息：名称，值，大小，节，绑定，类型，可见性，以及未定义的附加信息（目前有六个位未定义，尽管可能会添加更多）。在共享对象中定义的 ELF 符号也可能有一个关联的版本名称。 对于普通定义的符号，节是在文件中的某个节（具体而言，符号表条目保存了指向节表的索引）。对于目标文件，值是相对于节的起始位置。对于可执行文件，值是绝对地址。对于共享库，值是相对于基地址。 对于未定义引用符号，节索引是特殊值 SHN_UNDEF，其值为 0。节索引 SHN_ABS（0xfff1）表示符号的值是一个绝对值，而不是相对于任何节。 节索引 SHN_COMMON（0xfff2）表示公共符号。公共符号是为处理 Fortran 公共块而发明的，它们通常也用于 C 语言中的未初始化全局变量。公共符号具有不寻常的语义。公共符号的值为零，但将大小字段设置为所需的大小。如果一个目标文件有一个公共符号，而另一个文件有一个定义，该公共符号将被视为未定义引用。如果公共符号没有定义，程序链接器会假装看到一个初始化为零的适当大小的定义。两个目标文件可能有不同大小的公共符号，在这种情况下，程序链接器将使用最大的大小。在共享库之间实现公共符号的语义是一个棘手的问题，最近通过引入公共符号的类型和特殊节索引有所缓解（见下面关于符号类型的讨论）。 除了公共符号外，ELF 符号的大小是变量或函数的大小。这主要用于调试目的。 ELF 符号的绑定可以是全局的、本地的或弱的。全局符号是全局可见的。本地符号只有在本地可见（例如，一个静态函数）。弱符号有两种类型。弱未定义引用类似于普通未定义引用，除了如果重定位引用了一个没有定义符号的弱未定义引用符号，则它不是错误。相反，重定位的计算就像该符号的值为零一样。 弱定义符号允许与同名的非弱定义符号链接，而不引起多重定义错误。历史上，程序链接器处理弱定义符号有两种方式。在 SVR4 上，如果程序链接器看到一个弱定义符号后跟同名的非弱定义符号，它将发出多重定义错误。然而，非弱定义符号后跟弱定义符号不会导致错误。在 Solaris 上，一个弱定义符号后跟一个非弱定义符号会导致所有引用附加到非弱定义符号，而没有错误。行为上的差异是由于 ELF ABI 中的模糊性，不同的人有不同的解读。GNU 链接器遵循 Solaris 的行为。 ELF 符号的类型如下所示： STT_NOTYPE: no particular type. STT_OBJECT: a data object, such as a variable. STT_FUNC: a function STT_SECTION: a local symbol associated with a section. This type of symbol is used to reduce the number of local symbols required, by changing all relocations against local symbols in a specific section to use the STT_SECTION symbol instead. STT_FILE: a special symbol whose name is the name of the source file which produced the object file. STT_COMMON: a common symbol. This is the same as setting the section index to SHN_COMMON, except in a shared object. The program linker will normally have allocated space for the common symbol in the shared object, so it will have a real section index. The STT_COMMON type tells the dynamic linker that although the symbol has a regular definition, it is a common symbol. STT_TLS: a symbol in the Thread Local Storage area. I will describe this in more detail some other day. ELF 符号的可见性是为提供更好的控制符号在共享库之外的可访问性而发明的。基本思想是符号在共享库内可能是全局的，但在共享库外是本地的。 STV_DEFAULT: the usual visibility rules apply: global symbols are visible everywhere. STV_INTERNAL: the symbol is not accessible outside the current executable or shared library. STV_HIDDEN: the symbol is not visible outside the current executable or shared library, but it may be accessed indirectly, probably because some code took its address. STV_PROTECTED: the symbol is visible outside the current executable or shared object, but it may not be overridden. That is, if a protected symbol in a shared library is referenced by other code in the shared library, that other code will always reference the symbol in the shared library, even if the executable defines a symbol with the same name. ","date":"2025-08-08","objectID":"/www_airs_com_archives_38/:5:2","tags":["linkers","lianjieqi"],"title":"Linkers","uri":"/www_airs_com_archives_38/"},{"categories":null,"content":"6 Linkers part 6 ","date":"2025-08-08","objectID":"/www_airs_com_archives_38/:6:0","tags":["linkers","lianjieqi"],"title":"Linkers","uri":"/www_airs_com_archives_38/"},{"categories":null,"content":"6.1 重定位 (Relocations) 重定位是在内容上执行的计算，重定位还可以指示链接器采取其他操作，比如创建 PLT 或 GOT 条目。让我们仔细看看这个计算。 一般来说，重定位有一个类型、一个符号、一个偏移量和一个增量。从链接器的角度来看，内容仅仅是一系列未解释的字节。重定位会根据需要更改这些字节，以生成正确的最终可执行文件。例如，考虑 C 代码 g = 0; 其中 g 是一个全局变量。在 i386 上，编译器会将其转换为汇编语言指令，这很可能是 movl $0, g=（对于位置相关代码-位置无关代码将从 GOT 加载 g 的地址）。现在，C 代码中的 =g 是一个全局变量，我们或多或少都知道这意味着什么。而汇编代码中的 g 并不是那个变量，它是一个符号，表示该变量的地址。 汇编器不知道全局变量 g 的地址，换句话说就是汇编器不知道符号 g 的值。链接器将负责选择那个地址。因此，汇编器必须告诉链接器它在这条指令中需要使用 g 的地址。汇编器实现这一点的方法是创建一个重定位（relocation）。我们不为每条指令使用单独的重定位类型；相反，每个处理器将具有一组适合其机器架构的自然重定位类型。每种重定位类型表示一个特定的计算。 在 i386 的情况下，汇编器将生成这些字节： c7 05 00 00 00 00 00 00 00 00 c7 05 是指令（ movl , 将常量移动到地址）。 前四个 00 字节是 32 位常量 0 。 后四个 00 字节是地址。 汇编器通过生成（在这种情况下）一个 R_386_32 重定位告诉链接器将符号 g 的值放入那四个字节。对于这个重定位，符号将是 g ，偏移量将是指令的最后四个字节，类型将是 R_386_32 ，增量将是 0=（在 i386 的情况下，增量存储在内容中，而不是在重定位本身中，但这是一个细节）。类型 =R_386_32 表示一个特定的计算，即：将符号的值与增量的 32 位和放入偏移量中。由于对于 i386 增量存储在内容中，这也可以表示为：将符号的值加到偏移位置的 32 位字段中。当链接器执行这个计算时，指令中的地址将是全局变量 g 的地址。无论细节如何，重要的一点是重定位通过应用根据类型选择的特定计算来调整内容。 一个使用加数的简单案例示例是： char a[10]; // 一个全局数组。 char* p = \u0026a[1]; // 在一个函数中。 对 p 的赋值最终需要对符号 a 进行重定位。在这里，加数将是 1，以便生成的指令引用 a + 1 而不是 a + 0 。 为了指出重定位是如何依赖于处理器的，我们来考虑在 RISC 处理器上执行 g = 0; 的情况：PowerPC（在 32 位模式下）。在这种情况下，需要多个汇编语言指令： li 1,0 // 将寄存器 1 设置为 0 lis 9,g@ha // 将 g 的高调整部分加载到寄存器 9 中 stw 1,g@l(9) // 将寄存器 1 的值存储到寄存器 9 中地址加上 g 的低调整部分的地址 lis 指令将一个值加载到寄存器 9 的高 16 位中，将低 16 位设置为零。 stw 指令将一个带符号的 16 位值添加到寄存器 9，以形成一个地址，然后将寄存器 1 的值存储到该地址。 操作数的 @ha 部分指示汇编器生成一个 R_PPC_ADDR16_HA 重定位。 @l 生成一个 R_PPC_ADDR16_LO 重定位。 这些重定位的目标是计算符号 g 的值并将其用作存储地址。 这些信息足够确定这些重定位所执行的计算。 R_PPC_ADDR16_HA 重定位计算为 (SYMBOL \u003e\u003e 16) + ((SYMBOL \u0026 0x8000) ? 1 : 0) 。 R_PPC_ADDR16_LO 计算为 SYMBOL \u0026 0xffff 。 R_PPC_ADDR16_HA 的额外计算是因为 stw 指令添加的是带符号的 16 位值，这意味着如果低 16 位出现负数，我们必须相应地调整高 16 位。重定位的偏移量使得 16 位结果值被存储到机器指令的适当部分。 我在这里讨论的具体重定位示例是针对 ELF 格式的，但同样类型的重定位在任何对象文件格式中都会出现。 我展示的示例是出现在对象文件中的重定位。如第 4 部分所述，这些类型的重定位也可能出现在共享库中，如果它们被程序链接器复制到那里。在 ELF 中，还有一些特定的重定位类型只出现在共享库或可执行文件中，而从未出现在对象文件中。这些是先前讨论的 JMP_SLOT、GLOB_DAT 和 RELATIVE 重定位。另一种只出现在可执行文件中的重定位类型是 COPY 重定位，我将在后面讨论。 ","date":"2025-08-08","objectID":"/www_airs_com_archives_38/:6:1","tags":["linkers","lianjieqi"],"title":"Linkers","uri":"/www_airs_com_archives_38/"},{"categories":null,"content":"6.2 Position Dependent Shared Libraries 我意识到在第 4 部分中，我忘记提到 ELF 共享库使用 PLT 和 GOT 表的一个重要原因。共享库的概念是允许将相同的共享库映射到不同的进程中。只有当共享库代码在每个进程中看起来都一样时，这种做法才能达到最大的效率。如果看起来不一样，那么每个进程将需要自己的私有副本，这样就会失去在物理内存和共享上的节省。 如第 4 部分所讨论，当动态链接器加载一个包含位置依赖代码的共享库时，它必须应用一组动态重定位。这些重定位将改变共享库中的代码，从而使其不再可共享。 PLT 和 GOT 的优点在于它们将重定位移到其他地方，即 PLT 和 GOT 表本身。这些表可以放入共享库的读写部分。这个共享库的这一部分将远小于代码。使用共享库的每个进程中的 PLT 和 GOT 表会有所不同，但代码将是相同的。 ","date":"2025-08-08","objectID":"/www_airs_com_archives_38/:6:2","tags":["linkers","lianjieqi"],"title":"Linkers","uri":"/www_airs_com_archives_38/"},{"categories":null,"content":"7 Linkers part 7: classic small optimization: Thread Local Storage 我假设你知道什么是线程。通常情况下，拥有一个全局变量在每个线程中可以取不同的值是非常有用的（如果你不明白这有什么用，听我说就行）。也就是说，这个变量对程序是全局的，但具体的值是线程局部的。如果线程 A 将线程局部变量设置为 1，而线程 B 随后将其设置为 2，那么在线程 A 中运行的代码将继续看到变量的值为 1，而在线程 B 中运行的代码看到的值为 2。在 Posix 线程中，这种类型的变量可以通过 pthread_key_create 创建，通过 pthread_getspecific 和 pthread_setspecific 访问。 这些函数的工作效果还不错，但每次访问都要进行一次函数调用是很麻烦也很不方便。如果你可以只是声明一个普通的全局变量并将其标记为线程局部，那将更有用。这就是线程局部存储（Thread Local Storage， TLS）的概念，我相信这是在 Sun 发明的。在支持 TLS 的系统上，任何全局（或静态）变量都可以用 __thread 注解。这样，变量就是线程局部的。 显然，这需要编译器的支持。它还需要程序链接器和动态链接器的支持。为了获得最大效率——如果不追求最大效率，那为什么要这样做呢？——还需要一些内核支持。在 ELF 系统上，线程局部存储（TLS）的设计完全支持共享库，包括多个共享库和可执行文件本身使用相同的名称来引用单个 TLS 变量。TLS 变量可以初始化。程序可以获取 TLS 变量的地址，并在线程之间传递指针，因此 TLS 变量的地址是一个动态值，必须是全局唯一的。 这个是怎么实现的？第一步：为 TLS 变量定义不同的存储模型。 这些存储模型按灵活性递减的顺序定义。为了提高效率和简化，支持 TLS 的编译器允许开发者指定使用的适当 TLS 模型（在 gcc 中，可以使用-ftls-model 选项来实现，尽管全局动态和局部动态模型还需要使用-fpic）。因此，当编译将被放入可执行文件且永远不会在共享库中的代码时，开发者可以选择将 TLS 存储模型设置为初始可执行文件。 当然，在实践中，开发者往往不知道代码将如何使用。开发者也可能对 TLS 模型的复杂性不够了解。另一方面，程序链接器知道它是在创建一个可执行文件还是一个共享库，并且知道 TLS 变量是否在本地定义。因此，程序链接器负责在可能的情况下自动优化对 TLS 变量的引用。这些引用以重定位的形式出现，链接器通过以不同的方式更改代码来优化引用。 程序链接器还负责将所有 TLS 变量汇总到一个单独的 TLS 段中（稍后我会更多地谈论段，暂时可以将它们视为一个节）。动态链接器必须将可执行文件和所有包含的共享库的 TLS 段进行分组，解决动态 TLS 重定位，并在使用 dlopen 时动态构建 TLS 段。内核必须确保对 TLS 段的访问是高效的。 以上都是相当一般性的内容。我们做一个例子，再次以 i386 ELF 为例。i386 ELF TLS 有三种不同的实现；我将着眼于 gnu 实现。考虑这段简单代码： __thread int i; int foo() { return i; } 在全局动态模式下，这会生成类似于以下的 i386 汇编代码： leal i@TLSGD(,%ebx,1), %eax call ___tls_get_addr@PLT movl (%eax), %eax 回想一下第 4 部分， %ebx 保存了 GOT 表的地址。第一条指令将对变量 i 具有 R_386_TLS_GD 重定位；重定位将应用于 leal 指令的偏移量。当程序链接器看到这个重定位时，它将为 TLS 变量 i 在 GOT 表中创建两个连续的条目。第一个条目会获得一个 R_386_TLS_DTPMOD32 动态重定位，第二个条目会获得一个 R_386_TLS_DTPOFF32 动态重定位。动态链接器将把 DTPMOD32 GOT 条目设置为保存定义该变量的对象的模块 ID。模块 ID 是在动态链接器表中标识可执行文件或特定共享库的索引。动态链接器将把 DTPOFF32 GOT 条目设置为该模块在 TLS 段中的偏移量。 _tls_get_addr 函数将使用这些值来计算地址（该函数还处理 TLS 变量的延迟分配，这是动态链接器特有的进一步优化）。注意， __tls_get_addr 实际上是由动态链接器本身实现的；因此，全局动态 TLS 变量在静态链接的可执行文件中不被支持（也没有必要）。 在这个时候，你可能在想 pthread_getspecific 有什么效率问题。TLS 的真正优势在于当你看到程序链接器可以做什么时。上面显示的 leal; call 序列是经典的：编译器总是会生成相同的序列来访问全局动态模式下的 TLS 变量。程序链接器利用了这一事实。如果程序链接器看到上面的代码将进入到一个可执行文件中，它知道访问不必被视为全局动态；可以将其视为初始可执行文件。程序链接器实际上会将代码重写为如下： movl %gs:0, %eax subl $i@GOTTPOFF(%ebx), %eax 在这里我们看到，TLS 系统利用 %gs 段寄存器（在操作系统的配合下），指向可执行文件的 TLS 段。对于每个支持 TLS 的处理器，都会做一些类似的效率优化。由于程序链接器在构建可执行文件，它构建 TLS 段，并知道 i 在该段中的偏移量。 GOTTPOFF 并不是一个真正的重定位；它是在程序链接器中创建并解析的。它当然是从 GOT 表到 TLS 段中 i 的地址的偏移量。原始序列中的 movl (%eax), %eax 仍然保留，用于实际加载变量的值。 实际上，如果 i 没有在可执行文件中定义，那就是会发生的情况。在我展示的例子中，i在可执行文件中定义，因此程序链接器可以真正从全局动态访问一直到局部可执行访问。这看起来如下： movl %gs:0,%eax subl $i@TPOFF,%eax 这里 i@TPOFF 仅仅是 i 在 TLS 段中的已知偏移量。我不会深入探讨为什么使用 subl 而不是 addl ；只需说这又是动态链接器中的一个效率优化。 如果你关注到这些，你会看到，当一个可执行文件访问在该可执行文件中定义的 TLS 变量时，通常需要两个指令来计算地址，通常后面还有另一个指令来实际加载或存储值。这比调用 pthread_getspecific 高效得多。可以承认，当共享库访问 TLS 变量时，结果与 pthread_getspecific 并没有什么太大区别，但也不应该更差。而且使用__thread 的代码更容易编写和阅读。 这是一场真正的疾风之旅。i386 上有三种独立但相关的 TLS 实现（称为 sun、gnu 和 gnu2），定义了 23 种不同的重定位类型。我当然不会尝试描述所有细节；无论如何我也不知道所有细节。所有这些都旨在为给定存储模型提供高效访问 TLS 变量。 TLS 是否值得在程序链接器和动态链接器中增加额外的复杂性？由于这些工具被每个程序使用，并且由于 C 标准全局变量 errno 尤其可以使用 TLS 实现，因此答案很可能是肯定的。 ","date":"2025-08-08","objectID":"/www_airs_com_archives_38/:7:0","tags":["linkers","lianjieqi"],"title":"Linkers","uri":"/www_airs_com_archives_38/"},{"categories":null,"content":"8 Linkers part 8: ELF Segments 我之前说过可执行文件格式通常与目标文件格式相同。对于 ELF 来说，这是正确的，但有一个翻转。 在 ELF 中，目标文件由段组成：文件中的所有数据通过段表访问。可执行文件和共享库通常包含一个段表，程序如 nm 会使用它。 但是，操作系统和动态链接器不使用段表。相反，它们使用段表，提供了文件的另一种视图。 ","date":"2025-08-08","objectID":"/www_airs_com_archives_38/:8:0","tags":["linkers","lianjieqi"],"title":"Linkers","uri":"/www_airs_com_archives_38/"},{"categories":null,"content":"9 Linkers part 9 ","date":"2025-08-08","objectID":"/www_airs_com_archives_38/:9:0","tags":["linkers","lianjieqi"],"title":"Linkers","uri":"/www_airs_com_archives_38/"},{"categories":null,"content":"9.1 Symbol Versions 共享库提供了一个 API。因为可执行文件是使用一组特定的头文件构建的，并且链接了特定实例的共享库，它还提供了一个 ABI。能够独立于可执行文件更新共享库是非常 desirable。这允许修复共享库中的错误，并且允许共享库和可执行文件分开分发。有时更新共享库需要更改 API，有时更改 API 又需要更改 ABI。当共享库的 ABI 发生变化时，便无法在不更新可执行文件的情况下更新共享库。这是一个不幸的情况。 例如，考虑系统 C 库和 stat 函数。当文件系统升级以支持 64 位文件偏移时，必须更改 stat 结构中某些字段的类型。这是 stat 的 ABI 的变化。新版本的系统库应该提供返回 64 位值的 stat。但是旧的现有可执行文件却期望调用返回 32 位值的 stat。这可以通过在系统头文件中使用复杂的宏来解决。但还有更好的方法。 更好的方法是符号版本(symbol version)，这是一种由 Sun 公司引入并由 GNU 工具扩展的机制。每个共享库可以定义一组(多个)符号版本，并为每个定义的符号分配特定的版本。版本和符号分配是通过在创建共享库时传递给程序链接器的脚本完成的。 当一个可执行文件或共享库 A 链接到另一个共享库 B 时，A 引用了在 B 中定义的具有特定版本的符号 S，A 中的未定义动态符号引用 S 被赋予 B 中符号 S 的版本。当动态链接器看到 A 引用的是 S 的特定版本时，它会将其链接到 B 中的该特定版本。如果 B 后来引入了 S 的新版本，只要 B 继续提供旧版本的 S，这将不会影响 A。 例如，当 stat 发生变化时，C库将提供两个版本的 stat，一个是旧版本（例如，LIBC_1.0），另一个是新版本（LIBC_2.0）。新版本的 stat 将被标记为默认版本——程序链接器将使用它来满足对象文件中对 stat 的引用。链接到旧版本的可执行文件将需要 LIBC_1.0 版本的 stat，因此将继续正常工作。请注意，甚至可以在单个程序中使用两个版本的 stat，通过不同的共享库进行访问。 如您所见，版本实际上是符号名称的一部分。最大的不同在于，共享库可以定义一个特定的版本，用于满足没有版本的引用。 版本也可以在目标文件中使用（这是对原始 Sun 实现的 GNU 扩展）。这对于在不需要版本脚本的情况下指定版本非常有用。当符号名称包含@字符时，@之前的字符串是符号的名称，@之后的字符串是版本。如果有两个连续的@字符，那么这就是默认版本。 ","date":"2025-08-08","objectID":"/www_airs_com_archives_38/:9:1","tags":["linkers","lianjieqi"],"title":"Linkers","uri":"/www_airs_com_archives_38/"},{"categories":null,"content":"9.2 Relaxation 一般来说，程序链接器不会改变内容，除了应用重定位。然而，程序链接器在链接时可以执行一些优化。其中之一就是松弛。 放松本质上是处理器特定的。它包括优化代码序列，当最终地址已知时，这些序列可以变得更小或更有效率。最常见的放松类型是对调用指令的处理。像 m68k 这样的处理器支持不同的 PC 相对调用指令：一种具有 16 位偏移量，另一种具有 32 位偏移量。当调用一个在 16 位偏移范围内的函数时，使用较短的指令更有效率。在链接时缩小这些指令的优化被称为放松。 放松是基于重定位条目应用的。链接器查找可能被放松的重定位，并检查它们是否在范围内。如果在范围内，链接器将应用放松，可能会缩小内容的大小。放松通常只能在链接器识别出被重定位的指令时进行。应用放松可能会使其他重定位也在范围内，因此放松通常在循环中进行，直到没有更多的机会为止。 当链接器在内容中间放松一个重定位时，它可能需要调整任何跨过放松点的相对程序计数器（PC）引用。因此，汇编器需要为所有的 PC 相对引用生成重定位条目。在不进行放松时，这些重定位可能并不是必需的，因为在单个内容内的 PC 相对引用在内容最终位置的任何地方都是有效的。然而在放松时，链接器需要查看所有适用于该内容的其他重定位，并在适当的地方调整 PC 相对引用。这个调整将只是重新计算 PC 相对偏移量。 当然，也可以应用不会改变内容大小的放松。例如，在 MIPS 架构中，位置无关调用序列通常是将函数的地址加载到$25 寄存器中，然后通过该寄存器进行间接调用。当调用的目标在分支和调用指令的 18 位范围内时，通常使用分支和调用会更加高效，因为这样处理器在开始调用之前不必等待$25 的加载完成。这个放松改变了指令序列而不改变大小。 ","date":"2025-08-08","objectID":"/www_airs_com_archives_38/:9:2","tags":["linkers","lianjieqi"],"title":"Linkers","uri":"/www_airs_com_archives_38/"},{"categories":null,"content":"10 Linkers part 10： Parallel Linking 链接过程在一定程度上可以并行化。这可以帮助隐藏 I/O 延迟，并更好地利用现代多核系统。我对 gold 的意图是利用这些想法加速链接过程。 可以并行化的第一个领域是读取所有输入文件的符号和重定位项。符号必须按顺序处理；否则，对于链接器来说，将很难正确解析多个定义。尤其是，在处理某个归档文件之前，必须完全处理掉所有在归档之前使用的符号，否则链接器无法知道在链接中应该包含归档的哪些成员（我想我还没有谈到归档文件）。然而，尽管有这些顺序要求，实际的 I/O 并行执行仍然是有益的。 在所有符号和重定位项读取完成后，链接器必须完成所有输入内容的布局。这其中大部分无法并行完成，因为设置某种类型内容的位置需要知道所有前置类型内容的大小。在进行布局时，链接器可以确定所有需要写入输出文件的数据的最终位置。 布局完成后，读取内容、应用重定位并将内容写入输出文件的过程可以完全并行化。每个输入文件可以单独处理。 由于在布局阶段已知输出文件的最终大小，因此可以对输出文件使用 mmap。当不进行放松时，可以将输入内容直接读取到输出文件中的指定位置，并在该位置进行重定位。这减少了所需的系统调用数量，并理想地允许操作系统为输出文件执行最佳的磁盘 I/O。 ","date":"2025-08-08","objectID":"/www_airs_com_archives_38/:10:0","tags":["linkers","lianjieqi"],"title":"Linkers","uri":"/www_airs_com_archives_38/"},{"categories":null,"content":"11 Linkers part 11 ","date":"2025-08-08","objectID":"/www_airs_com_archives_38/:11:0","tags":["linkers","lianjieqi"],"title":"Linkers","uri":"/www_airs_com_archives_38/"},{"categories":null,"content":" Table of Contents 1 弃长安 2 长安的荔枝 3 桃花源没事儿 4 流俗地 ","date":"2025-08-08","objectID":"/%E4%B8%83%E6%9C%88%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:0:0","tags":["weixin"],"title":"七月读书笔记","uri":"/%E4%B8%83%E6%9C%88%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"1 弃长安 从唐明皇弃长安开始，到李亨最终收回长安，从盛世到衰败，真的不需要多长时间，让人感慨。 诗人、盛唐与长安，一起凋零，失落在唐诗与历史记忆之中。 在大时代的丕变中，帝王、宠妃、储君、宰相、边将、诗人、宦官、枭雄、叛将、贰臣……每个人都深陷于走不出的盛世困境，每个人都在寻路突围，每个人都付出了自己的代价。每个人都回不到长安。 我的写作激情是什么？ 大概，是大唐盛世在天宝十四载的轰然倾圮，是长安这座世界之都在渔阳鼙鼓声中的脆弱与窘迫无计，是李隆基君臣从自负颟顸到仓皇辞庙的骤然切换，是李林甫和杨国忠这两位宰相的逢君之恶，是杨玉环的“明眸皓齿今何在”，是太子李亨的隐忍与浮夸表演，是安禄山的胡旋舞与曳落河，是血色残阳中的张睢阳齿与颜常山舌，是李白、杜甫、王维等人的盛世求不得与乱世离散…… 海燕何微眇，乘春亦暂来。 岂知泥滓贱，只见玉堂开。 绣户时双入，华轩日几回。 无心与物竞，鹰隼莫相猜 以这本书为引，又开启了 《长安的荔枝》、《长安十二时辰》。。。 ","date":"2025-08-08","objectID":"/%E4%B8%83%E6%9C%88%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:1:0","tags":["weixin"],"title":"七月读书笔记","uri":"/%E4%B8%83%E6%9C%88%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"2 长安的荔枝 这两月很火，电视、电影扎堆上了，所以把书找来看了一遍。书不长，写了李善德成为荔枝转运使、费尽心思从岭南运送荔枝到长安的故事。 个人感觉，马王爷写的书，最近看的都感觉是为改编成影视而写的似的，不太具有文学上的鉴赏价值。。。 ","date":"2025-08-08","objectID":"/%E4%B8%83%E6%9C%88%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:2:0","tags":["weixin"],"title":"七月读书笔记","uri":"/%E4%B8%83%E6%9C%88%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"3 桃花源没事儿 依旧是马王爷的书，篇幅不长，但是说攒了很长的时间写成的。跟 《太白金星有点烦》 类似的风格，一般吧。 ","date":"2025-08-08","objectID":"/%E4%B8%83%E6%9C%88%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:3:0","tags":["weixin"],"title":"七月读书笔记","uri":"/%E4%B8%83%E6%9C%88%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"4 流俗地 马来西亚的华语小说，以盲女银霞的视角，描写了一幅马来人的日常生活画卷。网上评分很高，写的确实也细腻，很多遣词造句出人意料。。。 莲珠的声音，银霞听着舒服。尽管只是一般的市井口吻，莲珠说话还带着渔村的乡音，听着却像被太阳熏了一整天的海潮，灌得人耳道里暖暖的。 那一辆国产车买来已一年多，虽然车里放了气味极浓的熏香膏，仍还透着一股如胶似漆的新车味道。 或者长叹一声，一口气悠长得像是来自五脏六腑。 逃离陈家的那一日，马票嫂记得陈家门前的阳光撒得均匀，天空一片和颜悦色。 诸如此类。。。 ","date":"2025-08-08","objectID":"/%E4%B8%83%E6%9C%88%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:4:0","tags":["weixin"],"title":"七月读书笔记","uri":"/%E4%B8%83%E6%9C%88%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":" 109-110, 标注, 2025 年 5 月 25 日星期日 下午 10:54:10 中国古人推崇“三不朽”：立德、立功与立言。但在中国历史上真正做到三不朽的却为数极少，“ 172-176, 标注, 2025 年 6 月 29 日星期日 上午 10:16:12 这不是曾国藩第一次应对生死局，也不是他最后一次。此前有两次：四十四岁，兵败靖港，跳河自裁；九江又败，二度投湖；此后还有两次：五十岁时，兵困祁门，生机渺茫，悬剑帐中，随时自裁；五十六岁，北上剿捻，河遇风暴，险些身溺。历经种种困局，太平军终于被平息下来，曾国藩功成名就。 819-820, 标注, 2025 年 6 月 30 日星期一 上午 8:34:20 忠义之气”的“君子”是曾国藩最看重的，当然他也提出了四个具体标准：一要才堪治民，二要不怕死，三要不汲汲名利，四要耐受辛苦。四者缺一，都不能带勇成将。 839-841, 标注, 2025 年 6 月 30 日星期一 上午 8:35:54 如果把湘军比作一棵大树，勇丁、营官、统带等各阶层人员通过招募形式和组织架构连为一体，统领为根，营官为干，哨弁、勇丁即为枝、叶，而乡土、师生等私人关系和儒家思想则为水分、养料、阳光，让湘军这棵大树上下贯通，生机勃勃。 1237-1237, 标注, 2025 年 6 月 30 日星期一 下午 7:08:58 见其意气满溢，精神上浮，言事太易，心窃虑其难与谋大事” 1765-1766, 标注, 2025 年 6 月 30 日星期一 下午 9:35:46 称清朝统治者为“妖人”，“反盗神州，驱我中国悉变妖魔，罄南山之竹简，写不尽满地淫污，决东海之波涛，洗不净弥天罪孽”。 1813-1820, 标注, 2025 年 6 月 30 日星期一 下午 9:38:27 然而，时事弄人，期望有多大，打击就有多大。 曾国藩率湘军赶到长沙以北，一遇太平军，没有旗开得胜，而是一连串的失败。一败于宁乡，再败于岳州，三败于靖港。尤其是在他亲自指挥的靖港水战中，曾国藩惨败，愤而跳河自杀。 那么问题来了，曾国藩当时到底面临怎样的情景，有哪些心理感受，致使他义无反顾地自杀呢？是在作秀，还是真有必死之心呢？ [1]《报东征起程日期折》，咸丰四年二月初二日，《曾国藩全集·奏稿之一》，岳麓书社 2012 年第 2 版，第 125 页。 1813-1816, 标注, 2025 年 6 月 30 日星期一 下午 9:38:35 然而，时事弄人，期望有多大，打击就有多大。 曾国藩率湘军赶到长沙以北，一遇太平军，没有旗开得胜，而是一连串的失败。一败于宁乡，再败于岳州，三败于靖港。尤其是在他亲自指挥的靖港水战中，曾国藩惨败，愤而跳河自杀。 2032-2032, 标注, 2025 年 7 月 1 日星期二 上午 8:15:40 胜败，是兵家常事；生死，却在一念之间。 2131-2131, 标注, 2025 年 7 月 1 日星期二 上午 8:24:08 惟谨慎谦虚，时时省惕而已”。 10665-10665, 标注, 2025 年 7 月 1 日星期二 下午 9:14:13 未死先学死，有生即杀生”。 11497-11499, 标注, 2025 年 7 月 2 日星期三 上午 8:07:56 他不敢不看书，因为一间断，心中便感觉不安。 [19]为此，他劝勉儿子，争取在五十岁之前把应该看的书都看完，别像自己一样到老年后悔。 11967-11968, 标注, 2025 年 7 月 2 日星期三 上午 8:10:42 春华说，“人到难时得读曾国藩”，鞠老师和我们都觉得这句话甚好。 11967-11968, 标注, 2025 年 7 月 2 日星期三 上午 8:11:00 春华说，“人到难时得读曾国藩”，鞠老师和我们都觉得这句话甚好 ","date":"2025-07-31","objectID":"/%E7%AC%94%E8%AE%B0%E5%A4%B9%E7%BC%9D%E4%B8%AD%E7%9A%84%E6%80%BB%E7%9D%A3%E6%9B%BE%E5%9B%BD%E8%97%A9%E7%9A%84%E4%BA%94%E6%AC%A1%E7%94%9F%E6%AD%BB%E5%B1%80-%E9%9E%A0%E6%B5%B7/:0:0","tags":["jiafengzhong","note","ireader"],"title":"[笔记]夹缝中的总督:曾国藩的五次生死局 鞠海","uri":"/%E7%AC%94%E8%AE%B0%E5%A4%B9%E7%BC%9D%E4%B8%AD%E7%9A%84%E6%80%BB%E7%9D%A3%E6%9B%BE%E5%9B%BD%E8%97%A9%E7%9A%84%E4%BA%94%E6%AC%A1%E7%94%9F%E6%AD%BB%E5%B1%80-%E9%9E%A0%E6%B5%B7/"},{"categories":null,"content":" 347-348, 标注, 2025 年 7 月 2 日星期三 上午 8:39:34 大辉那时还很年轻呢，嫩得细皮白肉，瘦得随风摆柳。 411-412, 标注, 2025 年 7 月 2 日星期三 下午 12:47:22 莲珠的声音，银霞听着舒服。尽管只是一般的市井口吻，莲珠说话还带着渔村的乡音，听着却像被太阳熏了一整天的海潮，灌得人耳道里暖暖的。 456-457, 标注, 2025 年 7 月 2 日星期三 下午 6:43:46 大伯公千字图》， 495-498, 标注, 2025 年 7 月 2 日星期三 下午 6:50:50 尽管搬离组屋以后，他再没有回去过那里，但有时候他会在梦中走很远的路，顶着大太阳回到那只得半丬店面的理发店。那店在组屋脚下。组屋巍峨，像是背着半边天；无论日升日落，太阳攀爬或滑坐到了哪个角度，店里也总像灯下黑，大白天依然光线不足，日照稀薄得像鱼缸里飘浮的微生物。 586-587, 标注, 2025 年 7 月 2 日星期三 下午 8:27:15 直至细辉打来电话，身旁的印尼女孩用手肘撞她一下，将她那逐渐融化的意识从越来越浓稠的梦中拽起来。 622-623, 标注, 2025 年 7 月 2 日星期三 下午 8:29:47 她怔怔地凝视车窗外的夜色，这城市已难掩倦容了，街上车子稀疏，商店都拉下卷门，只剩下电子广告牌灯火璀璨，沿路的街灯点点滴滴，像用廉价水钻串起的项链，明知虚假仍觉华美。 631-635, 标注, 2025 年 7 月 2 日星期三 下午 8:31:27 那是一栋单层排屋，老屋子，门前有破败的长形庭院，半边沙土半边水泥。沙土处杂草丛生，各种野草有如八方来的难民，高高低低，全簇拥在那小小的一方土地上。有些善于攀附的已沿墙爬上了头房的窗户，抱着锈迹斑斑的铁花在呼吸自由的空气。荒地中间有个久未被清除的空蚁巢，野冢似的巍巍耸立。一旁的水泥地大概是当初施工时用料不足或水泥砂浆拌得比例不匀，时日一久，抵挡不住杂草在地下蔓延过来的野性，已处处龟裂，远看像被摔破了却还凑合着躺在门前的一块巨形碑石。 698-699, 标注, 2025 年 7 月 2 日星期三 下午 8:42:18 每一回她这么从梦中撤出，丈夫细辉都躺在她身边，打着微鼾，一点没察觉她惊魂未定，总觉得自己并未全身而退，像是有些什么遗落在梦里了。 863-864, 标注, 2025 年 7 月 2 日星期三 下午 8:55:24 就是在那种身体动弹不了的时刻，银霞放任自己的思绪随波逐流，像一个漂浮的空瓶子，从某条水沟或浅溪出发，往往几个转折便又被卷到记忆的汪洋，再一次听到那一对印度姊妹花的声音。 940-942, 标注, 2025 年 7 月 3 日星期四 上午 8:05:31 除了送礼促销让读者捡便宜以外，地方增版更是全彩印刷，随便翻开一页，都只教人觉得歌舞升平；里头的色彩毫无节制，把新闻照片里的男人一个两个灌得脑满肠肥；妇人亦多丰美，携儿如抱肥藕。细辉回想，那时候他真觉得人们都圆磙磙，像五彩缤粉的气球满街飘浮。 968-969, 标注, 2025 年 7 月 3 日星期四 上午 8:08:46 那些年，银霞像个犯了什么天条的织女，终日坐在她家客厅里唧唧复唧唧，将一轮一轮的尼龙绳变成一摞一摞编织得扎扎实实的网兜子。 1035-1037, 标注, 2025 年 7 月 3 日星期四 上午 8:14:20 她忘不了的是那天拉祖追问她何时又如何学会下的象棋。银霞彼时年幼词穷，尽管费尽唇舌，却越说越觉得世间道理越简单，便超出人类的语言越远，最后唯有放弃解说，对着黑暗中的拉祖傻笑。 1050-1052, 标注, 2025 年 7 月 3 日星期四 上午 8:15:59 细辉记得后来学校的校长忽然出现，在校舍三楼大声呼叫拉祖，声音之洪亮，犹如晴天霹雳，又像高空中的一盏探照灯，突然把强光打在了他们三人的身上。 1055-1056, 标注, 2025 年 7 月 3 日星期四 上午 8:16:18 说到无话时，银霞抬起头，微笑着让阳光敷在脸上，似是在领受某种神圣的施予；他则低下头，看着他们的四条腿悬在池畔一晃一晃，节奏整齐得像四根钟摆。 1204-1205, 标注, 2025 年 7 月 3 日星期四 下午 12:36:43 或者长叹一声，一口气悠长得像是来自五脏六腑。 1222-1223, 标注, 2025 年 7 月 3 日星期四 下午 7:13:28 那一辆国产车买来已一年多，虽然车里放了气味极浓的熏香膏，仍还透着一股如胶似漆的新车味道。 1223-1223, 笔记, 2025 年 7 月 3 日星期四 下午 7:13:51 这成语… 1502-1503, 标注, 2025 年 7 月 3 日星期四 下午 7:28:59 逃离陈家的那一日，马票嫂记得陈家门前的阳光撒得均匀，天空一片和颜悦色。 1520-1521, 标注, 2025 年 7 月 3 日星期四 下午 9:15:23 当日天色祥和，天空湛蓝得像蕴含着一个美好的隐喻。马票嫂打开前门，阳光如一群撒欢的白鸟朝她飞扑过来。她抱紧怀中的男孩，匆匆穿过院子。那些 1520-1520, 标注, 2025 年 7 月 3 日星期四 下午 9:15:27 当日天色祥和，天空湛蓝得像蕴含着一个美好的隐喻。马票嫂打开前门， 1520-1521, 标注, 2025 年 7 月 3 日星期四 下午 9:15:35 当日天色祥和，天空湛蓝得像蕴含着一个美好的隐喻。马票嫂打开前门，阳光如一群撒欢的白鸟朝她飞扑过来。 1524-1525, 标注, 2025 年 7 月 3 日星期四 下午 9:19:00 那橡胶厂的烟囱正冒着白烟，烟极浓稠，一团一团地输送到天上，像是在给天空制造云朵。 1548-1549, 标注, 2025 年 7 月 3 日星期四 下午 9:21:47 那店铺光顾者稀，连盲头苍蝇也过门不入，他因而十分清闲，镇日对着满壁停摆的挂钟，店里似乎因此囤积了过多的时光，他只有不断找人聊天，近乎无助地将时间一点一点消耗了去。 1754-1757, 标注, 2025 年 7 月 5 日星期六 下午 6:35:06 总是在这种时候，明明四周再无人挤兑，细辉却觉得世界像个铜墙铁壁的机关，不断的往里收，把他迫得寸步难移；无论他面向哪里，都只能面对一堵冷冰冰的欺人太甚的墙壁。他带着这种感受入眠，经常会做恶梦，在梦中屡屡掉入水里或被卷进流沙之中，最终在梦里窒息，于现实中醒来。 1896-1899, 标注, 2025 年 7 月 5 日星期六 下午 7:35:14 只要不在周末，一日中的这种时分，光阴总像特别黏稠，楼上楼里所有的生物都特别慵懒；蟑螂和老鼠都酣睡在不可及之处，连鬼魂也像被黏鼠板逮住，出不来活动。银霞在这片浓稠的静寂中，清楚听到楼上响起行李箱在走道上拖行的声音。硬梆梆的塑胶轮子磙过水泥地，辘辘作响，从电梯门口一直吵到细辉家门外。 2388-2389, 标注, 2025 年 7 月 7 日星期一 上午 8:04:14 这些事情本该保密，却总是老古当作韵事，在外头对别的的士司机自吹自擂，传闻遂如涟漪一圈一圈荡开，最终传回家里来。 2532-2534, 标注, 2025 年 7 月 7 日星期一 上午 8:16:49 他们的女儿被蕙兰抱在怀中，是个刚出生没两天的小东西；皮肤赤红，脸上有点皱皱的，没有眉毛；看起来很丑，像造物者十分草率，用一个过大的皮囊随便装了一点血肉和骨头便塞给她，敷衍她。 2670-2672, 标注, 2025 年 7 月 7 日星期一 上午 8:30:51 春分出生前那一场金融风暴，几年里摧枯拉朽，弄垮了许多半大不小的酒楼。那些挺得下来，也多半裁员减薪，还得像小餐馆似的推出许多偷工减料薄利多销的优惠套餐才能熬过去。 2676-2678, 标注, 2025 年 7 月 7 日星期一 上午 8:31:26 了。他们每天一起乘的轻快铁，叶公先到转换站，蕙兰总在拥挤的车厢里向父亲昂一昂下巴，等于说了再见。然后车门阖上，她的视线穿过车厢里人与人之间的缝隙，盯着父亲在站台上的身影，见他显得特别瘦小，总在人来人往中举目张望，像是毫无方向感的样子，心里便厘不清一股什么酸酸苦苦的滋味。 2997-2998, 标注, 2025 年 7 月 7 日星期一 下午 10:56:19 细辉不知怎么记起以前听过拉祖与银霞讨论印尼语与马来语的差别；银霞的形容极妙，说印尼语比马来语黏腻；人们说话像在嚼着麦芽糖，有一种亲昵的，像是在向亲密的人嘟哝的味道。 3009-3011, 标注, 2025 年 7 月 7 日星期一 下午 10:57:21 那张床是一潭沼泽，细辉躺下去便缓缓下沉，被浓稠得让人睁不开眼睛的黑暗所淹没。他睡得极沉，梦也被灌饱了墨汁，如鱼睡在水中，没听到梦境外头的声响，也没发觉身旁的婵娟掀开被子，嘀嘀咕咕的爬起床来，像过去许多个晚上那样走进浴室，仿佛要灭口，又狰狞着脸逐一对付那些守不住秘密的水龙头。 3096-3098, 标注, 2025 年 7 月 8 日星期二 上午 6:55:43 反正这些车一路残喘，像在喊痛，令银霞听着觉得整个锡都已破旧失修，不知丢了哪些零件。当然也有的司机因老因病，不能不退下；城中的的士越来越少，而打电话来召车的，除了没有交通工具 3096-3097, 标注, 2025 年 7 月 8 日星期二 上午 6:55:48 反正这些车一路残喘，像在喊痛，令银霞听着觉得整个锡都已破旧失修，不知丢了哪些零件。 3216-3217, 标注, 2025 年 7 月 8 日星期二 上午 7:48:43 事情已过去七、八年，那女孩留在她记忆","date":"2025-07-31","objectID":"/%E7%AC%94%E8%AE%B0%E6%B5%81%E4%BF%97%E5%9C%B0-%E9%BB%8E%E7%B4%AB%E6%9B%B8/:0:0","tags":["liusudi","note","ireader"],"title":"[笔记]流俗地 黎紫書","uri":"/%E7%AC%94%E8%AE%B0%E6%B5%81%E4%BF%97%E5%9C%B0-%E9%BB%8E%E7%B4%AB%E6%9B%B8/"},{"categories":null,"content":" 368-368, 标注, 2025 年 7 月 14 日星期一 下午 12:41:20 朝乾夕惕已 384-387, 标注, 2025 年 7 月 14 日星期一 下午 12:45:30 据说就在被贬这一年，厌烦了政治争斗的张九龄送给了李林甫一首“求和诗”： 海燕何微眇，乘春亦暂来。 岂知泥滓贱，只见玉堂开。 绣户时双入，华轩日几回。 无心与物竞，鹰隼莫相猜。 ——《归燕诗》 495-497, 标注, 2025 年 7 月 14 日星期一 下午 6:32:47 离别家乡岁月多，近来人事半销磨。 惟有门前镜湖水，春风不改旧时波。 ——《回乡偶书二首》之二 519-520, 标注, 2025 年 7 月 14 日星期一 下午 6:35:28 千里黄云白日曛，北风吹雁雪纷纷。莫愁前路无知己，天下谁人不识君？”（《别董大》） 531-533, 标注, 2025 年 7 月 14 日星期一 下午 6:36:52 李白本质上是一个精神上的独行者，杜甫是李白喜欢的一个年轻朋友，但李白是杜甫的生命之光。这或许是一种并不对等的友情，但杜甫并不在意，他敬重、崇拜、依恋李白，他在同眠时听到了李白的痛苦和嘶叫。 647-650, 标注, 2025 年 7 月 14 日星期一 下午 6:51:56 李林甫的确得罪了太多人，形成了一种无法自拔的恶性循环：他越忧虑自己位置不稳，就越致力于铲除各路潜在的威胁者，而动手越频越狠，就更会在官僚阶层中滋生仇恨与动员反对者。仇恨的圈套之所以无法解脱，就在于它把一个人和他的敌人拴得太紧了。 668-668, 标注, 2025 年 7 月 14 日星期一 下午 6:54:32 终究意难平。 772-772, 标注, 2025 年 7 月 14 日星期一 下午 10:48:11 盛世将逝未逝之时，风暴将起未起之刻，是局中人最为焦虑的时刻，这不是唱衰，这是恐惧。 863-870, 标注, 2025 年 7 月 14 日星期一 下午 11:01:37 天宝十三载，岑参还写下了号称盛唐边塞诗压卷之作的《白雪歌送武判官归京》，这种慷慨豪迈、奇伟壮丽只属于盛唐： 北风卷地白草折，胡天八月即飞雪。 忽如一夜春风来，千树万树梨花开。 散入珠帘湿罗幕，狐裘不暖锦衾薄。 将军角弓不得控，都护铁衣冷难着。 瀚海阑干百丈冰，愁云惨淡万里凝。 中军置酒饮归客，胡琴琵琶与羌笛。 纷纷暮雪下辕门，风掣红旗冻不翻。 轮台东门送君去，去时雪满天山路。 山回路转不见君，雪上空留马行处。 ——《白雪歌送武判官归京》 897-898, 标注, 2025 年 7 月 15 日星期二 上午 8:08:53 但使龙城飞将在，不教胡马度阴山”“前军夜战洮河北，已报生擒吐谷浑”“黄沙百战穿金甲，不破楼兰终不还” 906-907, 标注, 2025 年 7 月 15 日星期二 上午 8:18:27 这也正如菲茨杰拉德在《了不起的盖茨比》中所说：“检验一个人的智力是否属于上乘，只需看其脑子里能否同时容纳两种相反的思想而无碍于其处世行事。” 909-911, 标注, 2025 年 7 月 15 日星期二 上午 8:19:11 单车欲问边，属国过居延。 征蓬出汉塞，归雁入胡天。 大漠孤烟直，长河落日圆。 萧关逢候骑，都护在燕然。——《使至塞上》 949-951, 标注, 2025 年 7 月 15 日星期二 上午 8:22:57 可以说，霓裳羽衣舞曲的创作与风行，既是李隆基和杨玉环这对歌舞知音的爱情结晶，也是对盛世的盛大献祭。 1262-1263, 标注, 2025 年 7 月 15 日星期二 下午 11:13:01 人类过于厌恶不确定性，所以对成败都希冀找到符合自我叙事的归因。 1320-1322, 标注, 2025 年 7 月 16 日星期三 上午 8:08:08 作为中国古代战争的一个基本规律，如“私兵”“部曲”和“家军”这样建构在私人关系上的军队，其黏性、凝聚力乃至战斗力，要远比依托于“国家—个人”这种虚无联系上的所谓“正规军”要强得多。事实上，历代所谓“正规军”更多的时候就是“混口饭吃者”的集合体， 1350-1353, 标注, 2025 年 7 月 16 日星期三 上午 8:12:50 以封常清为代表的这批西北系将领，由于既往开边战功之辉煌远超安禄山，无论是对西北军还是个人能力都自视甚高，相应地对安禄山的东北军也有了不切实际的轻敌和贬抑。但封常清等人以往的军功是建立在精锐的西北边军之上，当脱离了西北边军这个军事平台，单凭他们这些将领的将略，可能远不足以力挽狂澜。 1512-1514, 标注, 2025 年 7 月 16 日星期三 下午 12:42:56 可见忠奸即使在一个家族内部都是门玄学。如果不是洛阳城破，你能说曾点破安禄山狼子野心的达奚珣不是一名忠臣吗？待到长安失守，将会看到更多颠倒乾坤的众生相，哪里是忠奸二字就可以轻易界定清楚的？ 1596-1598, 标注, 2025 年 7 月 17 日星期四 上午 7:44:42 颜真卿觉察到安禄山起兵前的欲盖弥彰，料定其必反，就开始秘密做一些应变战备。他假托阴雨不断，暗中加高城墙，疏通护城河，招募壮丁，储备粮草，但表面上装得岁月静好，天天与一帮文人泛舟饮酒，赋诗唱和。 1613-1614, 标注, 2025 年 7 月 17 日星期四 上午 7:47:49 颜氏兄弟相约起兵时正值叛军刚刚攻陷洛阳时，叛军势力如日中天，但他们还是在李唐国运最晦暗的时刻，对强大的安史叛军拔刀相向，其胸中又有勃然不可磨灭之气。 1726-1727, 标注, 2025 年 7 月 17 日星期四 上午 7:57:57 北斗七星高，哥舒夜带刀。至今窥牧马，不敢过临洮。 1975-1975, 标注, 2025 年 7 月 17 日星期四 上午 8:23:27 死亡是一面镜子，反射出生命在它面前做的各种姿态是如此的徒劳。 2062-2064, 标注, 2025 年 7 月 17 日星期四 下午 1:23:57 高力士派人将贵妃用紫色的被褥包裹，草草下葬在马嵬驿西面的路边。一年多后，当李隆基秘密下令改葬贵妃，太监们发现贵妃“肌肤已坏，而香囊仍在”；将香囊呈给李隆基时，“上皇视之凄惋”，老泪纵横，往昔欢爱唯余一香囊。 2493-2496, 标注, 2025 年 7 月 18 日星期五 上午 7:19:16 爆发了信念危机的李亨问计于李泌：“现在敌人这样强大，什么时候才能平定？”李泌的回答出乎意料地乐观：“臣听说叛军只要俘获了金帛奴婢，全部运回老巢范阳，这哪里有半点儿雄踞四海之志呢？现在， 效忠安禄山的主要是那批胡将，汉人只有高尚和严庄等数人而已，其他人都是被迫从贼。以臣之判断，不出两年，天下无寇矣！” 2805-2807, 标注, 2025 年 7 月 19 日星期六 上午 8:05:46 据《旧唐书·张巡传》所载，在睢阳守军的最后时光里，“所食人口二三万”。 为了守睢阳，张巡被迫放弃的东西实在太多了，包括作为一个儒家士大夫的道德底线。千秋功罪，谁人评说？ 3174-3175, 标注, 2025 年 7 月 19 日星期六 下午 8:42:11 回忆是一条没有归途的路，以往的一切春天都无法复原。 3262-3265, 标注, 2025 年 7 月 20 日星期日 下午 3:08:04 在巫州时，高力士看到当地盛产荠菜却无人食用，“因感伤而咏之”： 两京作斤卖，五溪无人采。 夷夏虽有殊，气味终不改。 ——《感巫州荠菜》 这个“气味终不改”的荠菜就是他高力士啊。 3312-3313, 标注, 2025 年 7 月 21 日星期一 上午 7:47:39 乾元二年三四月间，史思明以替安禄山报仇为由设计杀掉了安庆绪，自立为大燕皇帝，改范阳为燕京，这也是历史上北京第一次正式使用燕京这个名称。 3359-3360, 标注, 2025 年 7 月 21 日星期一 上午 7:56:33 因永王案被流放夜郎的李白至白帝城遇赦，立即返舟东下江陵，途中快船快意地写下了《早发白帝城》。 3371-3373, 标注, 2025 年 7 月 21 日星期一 上午 7:58:07 关于李白之死，除了“病死说”之外，还有“醉死说”和“溺死说”。按照最浪漫的“溺死说”，李白是大醉后跳入水中捉月而死。 3391-3395, 标注, 2025 年 7 月 21 日星期一 上午 8:00:04 广德元年（763）春天，杜甫在蜀地听闻安史之乱平叛成功的消息，惊喜欲狂，“生平第一快诗”喷涌而出： 剑外忽传收蓟北，初闻涕泪满衣裳。 却看妻子愁何在，漫卷诗书喜欲狂。 白日放歌须纵酒，青春作伴好还乡。 即从巴峡穿巫峡，便下襄阳向洛阳。 ——《闻官军收河南河北》 3408-3410, 标注, 2025 年 7 月 21 日星期一 上午 8:01:43 长安是盛世怒放之都，是乱世离散之城，是唐王朝由盛转衰的猝不及防。 长安是念念不忘，是求之不得，是心底最深处的炽烈欲望，杜甫、李白、王维，至死也没有抵达他们梦想中的长安。 3413-3416, 标注, 2025 年 7 月 21 日星期一 上午 8:02:20 诗人、盛唐与长安，一起凋零，失落在唐诗与历史记忆之中。 在大时代的丕变中，帝王、宠妃、储君、宰相、边将、诗人、宦官、枭雄、叛将、贰臣……每个人都深陷于走不出的盛世困境，每个人都在寻路突围，每个人都付出了自己的代价。每个人都回不到长安。 3480-3483, 标注, 2025 年 7 月 21 日星期一 上午 8:03:35 我的写作激情是什么？ 大概，是大唐盛世在天宝十四载的轰然倾圮，是长安这座世界之都在渔阳鼙鼓声中的脆弱与","date":"2025-07-31","objectID":"/%E7%AC%94%E8%AE%B0%E5%BC%83%E9%95%BF%E5%AE%89-%E5%BC%A0%E6%98%8E%E6%89%AC/:0:0","tags":["qichangan","note","ireader"],"title":"[笔记]弃长安 张明扬","uri":"/%E7%AC%94%E8%AE%B0%E5%BC%83%E9%95%BF%E5%AE%89-%E5%BC%A0%E6%98%8E%E6%89%AC/"},{"categories":null,"content":" 225-225, 标注, 2025 年 7 月 10 日星期四 下午 7:06:27 “记住，勿染大因果，攒点小功德。”云洞诚心诚意劝了一句。 733-734, 标注, 2025 年 7 月 11 日星期五 上午 7:04:56 机缘是执念所引，执念为意念所凝，你从小到大什么都不缺，没有执念，自然也就没有机缘啰。 1683-1685, 标注, 2025 年 7 月 12 日星期六 下午 10:09:37 世间生灵的所想所念，乃是本因；所言所行，则是本因演化出的末果。只要洞悉本因，便可以控制末果。譬如一条池中小鱼，它的执念就是吃，只消拿捏住这个本因，抛一团诱饵下去，它就会毫不犹豫地咬钩。 1929-1929, 标注, 2025 年 7 月 12 日星期六 下午 10:31:59 兵法讲究以奇胜，以正合，修持己身才是不二正途…… 2352-2354, 标注, 2025 年 7 月 12 日星期六 下午 11:02:15 其实我也不是什么天才，无非是他们休息时，我还在修炼罢了。天道酬勤，修为最终能到哪一步，还是要取决于你努力多少。须知宝剑锋从磨砺出，梅花香自…… 3184-3184, 标注, 2025 年 7 月 13 日星期日 上午 9:08:19 道经有云，命者性也，运者情也。性情决定命运。 ","date":"2025-07-31","objectID":"/%E7%AC%94%E8%AE%B0%E6%A1%83%E8%8A%B1%E6%BA%90%E6%B2%A1%E4%BA%8B%E5%84%BF-%E9%A9%AC%E4%BC%AF%E5%BA%B8/:0:0","tags":["taohuayuanme","note","ireader"],"title":"[笔记]桃花源没事儿 马伯庸","uri":"/%E7%AC%94%E8%AE%B0%E6%A1%83%E8%8A%B1%E6%BA%90%E6%B2%A1%E4%BA%8B%E5%84%BF-%E9%A9%AC%E4%BC%AF%E5%BA%B8/"},{"categories":null,"content":" 45-46, 标注, 2025 年 7 月 21 日星期一 上午 8:17:30 一股淡淡的喜悦，像古井里莫名泛起的小水泡，在李善德心中咕嘟咕嘟地浮起来。 45-47, 标注, 2025 年 7 月 21 日星期一 上午 8:17:38 一股淡淡的喜悦，像古井里莫名泛起的小水泡，在李善德心中咕嘟咕嘟地浮起来。二十八年了，他终于在长安城有了一席之地，一家人可以高枕无忧了。庭中桂树仿佛提前开放了一般，香馥浓郁之味，扑鼻而来，浸沁全身。 291-295, 标注, 2025 年 7 月 21 日星期一 上午 8:36:13 他一个年轻孩子，日夜惶恐惊惧，简直绝望到了极点。有一天，他在战场上被一个凶狠的敌人压住，眼看被杀，他发起狠来，用牙齿撕掉了对方的脸颊肉，这才侥幸反杀。老兵突然明白了，既是身临绝境，退无可退，何不向前拼死一搏，说不定还能搏出一点微茫希望。从那以后，他拼命地练习刀术、练习骑术，每天从高山一路冲下，俯身去拔取军旗。凭着这一口不退之气，他百战幸存，终于从西域安然回到这长安城里。” 293-295, 标注, 2025 年 7 月 21 日星期一 上午 8:36:22 既是身临绝境，退无可退，何不向前拼死一搏，说不定还能搏出一点微茫希望。从那以后，他拼命地练习刀术、练习骑术，每天从高山一路冲下，俯身去拔取军旗。凭着这一口不退之气，他百战幸存，终于从西域安然回到这长安城里。” 293-294, 标注, 2025 年 7 月 21 日星期一 上午 8:36:34 既是身临绝境，退无可退，何不向前拼死一搏，说不定还能搏出一点微茫希望。 304-305, 标注, 2025 年 7 月 21 日星期一 上午 8:38:04 “骨肉恩岂断，男儿死无时。既是退无可退，何不向前拼死一搏？” 310-314, 标注, 2025 年 7 月 21 日星期一 上午 8:39:01 二月春风，柳色初青。每到这个时节，长安以东的大片郊野便会被一大片碧色所沁染，一条条绿绦在官道两旁依依垂下，积枝成行，有若十里步障。唯有灞桥附近，是个例外。 只因天宝盛世，客旅繁盛，长安城又有一个折柳送别的风俗，每日离开的人太多，桥头柳树早早被薅秃了。后来之客，无枝可折，只好三枚铜钱一枝从当地孩童手里买。一番铜臭交易之后，心中那点“昔我往矣”的淡淡离愁，也便没了踪影，倒省了很多苦情文章。 664-665, 标注, 2025 年 7 月 21 日星期一 下午 12:58:08 “就算失败，我也想知道，自己倒在距离终点多远的地方。” 704-705, 标注, 2025 年 7 月 21 日星期一 下午 6:43:57 “先生要记得。跳胡旋舞的要诀，不是随乐班而动，而是旋出自己的节奏。” 老胡商笑吟吟地叮嘱了一句。 853-859, 标注, 2025 年 7 月 21 日星期一 下午 6:52:37 阿僮家的个头大如鸡子，他按照她的指点，按住一处凹槽，轻轻剥开红鳞状的薄果皮，露出里面晶莹剔透的果肉，颤巍巍的，直如软玉一般。他放入嘴中，合齿一咬，汁水四溅，一道甘甜醇香的快感霎时流遍百脉，不由得浑身酥麻，泛起一层鸡皮疙瘩。 那一瞬间，让他想起十八岁那年在华山的鬼见愁。当时一个少女脚扭伤了，哭泣不已，他自告奋勇把她背下山去。少女柔软的身躯紧紧贴在脊背，脚下是千仞的悬崖，掺杂着危险警示与水粉香气的味道，令他产生一种微妙的愉悦感。 后来两人成婚，他还时时回味起那一天奔走在华山上的感觉。今日这荔枝的口感，竟和那时如此相似。 969-969, 标注, 2025 年 7 月 22 日星期二 上午 7:50:50 “做生意，赌得便是个先机。若等试验成了再来报效，哪里还有小老的机会？” 1275-1278, 标注, 2025 年 7 月 22 日星期二 上午 8:08:54 你若在呈上转运法之时，附上一份谢表，说明此事有岭南经略使着力推动、度支同仁大力支持、太府司、司农寺、尚食局助力良多，你猜鱼朝恩还敢不敢抢你的功——良元兄呐，做官之道，其实就三句话：和光同尘，好处均沾，花花轿子众人齐抬。一个人吃独食，是吃不长久的。” 1375-1377, 标注, 2025 年 7 月 22 日星期二 上午 8:17:21 “下官德薄力微，何敢觍颜承此重任。愿献与卫国公，乐见族亲和睦，足慰圣心。” 这一刻，古来谄媚之臣浮现在李善德背后，齐齐鼓掌。 1392-1393, 标注, 2025 年 7 月 22 日星期二 上午 8:18:33 李善德接了牌子，又讨问手书，以方便给相关衙署行去文牒。杨国忠一怔，不由得哈哈大笑：“你拿了我的牌子，还要照章发牒，岂不坏了本相的名声？——流程，是弱者才要遵循的规矩。” 2017-2018, 标注, 2025 年 7 月 22 日星期二 上午 8:59:54 他奔忙一场，那些人若心存歹意，已死无葬身之地；若尚念一份人情，抬手也便救了。生死与否，皆操于那些神仙，自己可是没有半点掌握，直如柳絮浮萍。 ","date":"2025-07-31","objectID":"/%E7%AC%94%E8%AE%B0%E9%95%BF%E5%AE%89%E7%9A%84%E8%8D%94%E6%9E%9D-%E9%A9%AC%E4%BC%AF%E5%BA%B8/:0:0","tags":["changandeliz","note","ireader"],"title":"[笔记]长安的荔枝 马伯庸","uri":"/%E7%AC%94%E8%AE%B0%E9%95%BF%E5%AE%89%E7%9A%84%E8%8D%94%E6%9E%9D-%E9%A9%AC%E4%BC%AF%E5%BA%B8/"},{"categories":null,"content":" 383-386, 标注, 2025 年 7 月 23 日星期三 上午 8:01:29 开元十三年，有个叫李泌的七岁神童入宫朝觐。天子正在和中书令张说弈棋。天子令张说、李泌二人以“方圆动静”为题吟棋。张说写的是：“方如棋局，圆如棋子。动如棋生，静如棋死。”而李泌则开口说道：“方如行义，圆如用智。动如逞才，静如遂意。”大得天子赞赏，送其入东宫陪太子读书。 1411-1412, 标注, 2025 年 7 月 24 日星期四 上午 8:09:11 棚屋的顶上铺着厚薄不均的茅草，行走其间，透射下来的阳光忽明忽暗，让每个人的表情都显得有些迷离。 1416-1418, 标注, 2025 年 7 月 24 日星期四 上午 8:09:48 外人都道平康里是个天上销魂处，个个都是仙女神姝，却不知这背后多少污秽。得了淋疮的姑娘、毁了容的凤魁、生来畸残的娃娃……无处可去，无人收容，全都如污水一样流聚到了此处，坐等转生。老奴坏事做尽，从不怕下什么无间地狱——嘿，已然身在其中羯磨，早不觉新鲜了。” 4363-4364, 标注, 2025 年 7 月 29 日星期二 上午 8:36:19 檀棋觉得整件事太荒唐。阙勒霍多去向不明，长安危如累卵，他们却被一个不知所谓的景僧执事，用不知所谓的理由关在这个不知所谓的鬼地方。 ","date":"2025-07-31","objectID":"/%E7%AC%94%E8%AE%B0%E9%95%BF%E5%AE%89%E5%8D%81%E4%BA%8C%E6%97%B6%E8%BE%B0-%E9%A9%AC%E4%BC%AF%E5%BA%B8/:0:0","tags":["changanshier","note","ireader","unwashed"],"title":"[笔记]长安十二时辰 马伯庸","uri":"/%E7%AC%94%E8%AE%B0%E9%95%BF%E5%AE%89%E5%8D%81%E4%BA%8C%E6%97%B6%E8%BE%B0-%E9%A9%AC%E4%BC%AF%E5%BA%B8/"},{"categories":null,"content":" 121-122, 标注, 2025 年 5 月 21 日星期三 上午 8:30:29 每个人的人生中都会做出无数次选择，这些选择是会改变你的一生，还是无论如何选择都会走向同一种命运呢？ 124-127, 标注, 2025 年 5 月 21 日星期三 上午 8:30:57 我还是很怀念当年那个带着随身听在夜间的校园里疾走、沉迷在音乐中的我；那个可以在图书馆坐一晚上，看各种文史资料、纪实文学，梦想着能写出一部《战争与和平》的我；那个每月生活费五百还能省下三百来买书和磁带的我。 127-131, 标注, 2025 年 5 月 21 日星期三 上午 8:31:42 回忆我的人生，最幸福的还是大学时光。尽管在当时，你感受到的只是各种情绪的冲撞——空虚、无聊、迷惑、愤怒、渴望爱情、畅谈理想……然后看见平庸的现实。 但那时，我拥有时间。 时间是人生最珍贵的东西，这是我从小就听到的话，却直到现在才理解。 而时间偏偏是最公平的，不论你如何待它，它都那样不紧不慢地流过，绝不会为你改变分毫。 160-161, 标注, 2025 年 5 月 21 日星期三 上午 8:34:00 阴谋，不论你怎么做，都是死路一条。你不服从神，不向西走，整死你；你向西走，一路上九九八十一难，都是神安排的，依然整死你。 166-168, 标注, 2025 年 5 月 21 日星期三 上午 8:34:21 佛是什么，佛就是虚无，四大皆空，什么都没有了，没有感情没有欲望没有思想，当你放弃这些，你就不会痛苦了。但问题是，放弃了这些，人还剩下什么？什么都没了，直接就死了。所以成佛就是消亡，西天就是寂灭，西游就是一场被精心安排成自杀的谋杀。 169-173, 标注, 2025 年 5 月 21 日星期三 上午 8:34:44 我心目中的西游，就是人的道路。每个人都有一条自己的西游路，我们都在向西走，到了西天，大家就虚无了，就同归来处了，所有人都不可避免要奔向那个归宿，你没办法选择，没办法回头，那怎么办呢？你只有在这条路上，尽量走得精彩一些，走得抬头挺胸一些，多经历一些，多想一些，多看一些，去做好你想做的事，最后，你能说，这个世界我来过，我爱过，我战斗过，我不后悔。 147-149, 标注, 2025 年 5 月 21 日星期三 下午 10:01:36 当你老去的时候，回想一生，你会不会遗憾？似乎不论如何去苦苦追求，总有一些你必须放弃，总有一些你只能怀念，还有一些永远只在梦想中。我们永远在计算成败、取舍与得失，却没有人能找到正确答案。 160-161, 标注, 2025 年 5 月 21 日星期三 下午 10:03:53 所以整个西游就是一出悲剧，是一场阴谋，不论你怎么做，都是死路一条。你不服从神，不向西走，整死你；你向西走，一路上九九八十一难，都是神安排的，依然整死你。 173-174, 标注, 2025 年 5 月 21 日星期三 下午 10:07:18 人生最有价值的时刻，不是最后的功成名就，而是对未来正充满期待与不安之时。 175-177, 标注, 2025 年 5 月 21 日星期三 下午 10:07:52 成败，其实并不是最重要的。因为你去追求理想时你就会明白，你很可能不会成功。最关键就在于，当你深知这一点时，你还要不要去追求。 我没有答案。也不需要答案。 464-465, 标注, 2025 年 5 月 23 日星期五 下午 9:04:07 漫天的云雾，白色的，充满了整个世界，却又不在任何地方，像那阳光，天地间所有的光线与色彩从它而来，可它却是白色的。 703-704, 标注, 2025 年 5 月 23 日星期五 下午 9:13:27 她选了一个方向顺意游去了。 是不是选择任何一个方向，都会游向同一个宿命呢？ 818-819, 标注, 2025 年 5 月 23 日星期五 下午 9:43:29 我要这天，再遮不住我眼， 要这地，再埋不了我心， 要这众生，都明白我意， 要那诸佛，都烟消云散！ 1064-1064, 标注, 2025 年 5 月 23 日星期五 下午 10:14:13 一个人而存在的，当他发现自己错的时候，他便开始长大 1064-1064, 标注, 2025 年 5 月 23 日星期五 下午 10:14:17 也许每个人出生时都以为这天地是为他一个人而存在的，当他发现自己错的时候，他便开始长大了。 1380-1382, 标注, 2025 年 5 月 23 日星期五 下午 11:01:34 一个声音狂笑着，他大笑着殴打神仙，大笑着毁灭一切，他知道神永远杀不完，他知道天宫无边无际。这战斗将无法终止，直到他倒下，他仍然狂笑，笑出了眼泪。 这个天地，我来过，我奋战过，我深爱过，我不在乎结局。 1548-1549, 标注, 2025 年 5 月 24 日星期六 上午 10:34:36 只有绝望，能毁灭一颗不死的心。 1824-1825, 标注, 2025 年 5 月 24 日星期六 上午 10:46:26 孙悟空在林中走着，脚下是柔软的落叶与蔓草，他想了想，甩掉了他的靴子，赤足踩在湿漉漉的土地上，凉丝丝的感觉从足心传上来，脚下的土地仿佛是有了生命的，那些小草在轻挠他的脚 1824-1825, 标注, 2025 年 5 月 24 日星期六 上午 10:46:38 孙悟空在林中走着，脚下是柔软的落叶与蔓草，他想了想，甩掉了他的靴子，赤足踩在湿漉漉的土地上，凉丝丝的感觉从足心传上来，脚下的土地仿佛是有了生命的，那些小草在轻挠他的脚心。 2373-2373, 标注, 2025 年 5 月 24 日星期六 上午 11:17:18 这个天地，我来过，我奋战过，我深爱过，我不在乎结局。 2373-2375, 标注, 2025 年 5 月 24 日星期六 上午 11:17:31 这个天地，我来过，我奋战过，我深爱过，我不在乎结局。 纷纷落叶飘向大地，白雪下种子沉睡，一朵花开了又迅速枯萎，在流转的光的阴影中，星图不断变幻，海水中矗起高山，草木几百代的荣枯，总有一片片迎风挺立，酷似它们的祖先。 2373-2375, 标注, 2025 年 5 月 24 日星期六 上午 11:17:41 这个天地，我来过，我奋战过，我深爱过，我不在乎结局。 纷纷落叶飘向大地，白雪下种子沉睡，一朵花开了又迅速枯萎，在流转的光的阴影中，星图不断变幻，海水中矗起高山，草木几百代的荣枯，总有一片片迎风挺立，酷似它们的祖先。怎能忘了西游？ 3133-3135, 标注, 2025 年 5 月 24 日星期六 下午 8:30:08 “那酒是用水帘瀑布的水酿的，纯得照透人心，用了千种花百种果，蕴了万物的芳醇，用太阳的光刻入七种色彩，开坛时，全山都弥漫着香气，凡人喝了一口，要醉上一百年。那一天，我们全喝醉了，他拍着我的肩膀笑着说，他不记得自己是谁了，我说，不要紧，记得这杯酒就行了。” 3321-3323, 标注, 2025 年 5 月 25 日星期日 上午 10:17:57 “西天，我要去西天了，可是我到了西天我就不能再记着你，我不能去西天，我不去西天，我永远见不到你了，我迷了路，我要死在路上了，但我会想着你，我答应过你……” 3320-3323, 标注, 2025 年 5 月 25 日星期日 上午 10:18:07 云散开，月亮重现天空。猪爬起来，泪流满面，抖个不停，分不清方向，他抬头，月光轻抚他的脸。 “西天，我要去西天了，可是我到了西天我就不能再记着你，我不能去西天，我不去西天，我永远见不到你了，我迷了路，我要死在路上了，但我会想着你，我答应过你……” 3390-3393, 标注, 2025 年 5 月 25 日星期日 上午 10:21:17 “哪有这样？菩萨指了明路你不走，现成三年五载可取回的经卷你不要，却要自己去找？” “有三年五载可取的经文，哪有三年五载可得的无上法？若心中不明了，取回万卷经文，也无异白纸几箱！陛下要取那样经文，自可派使前去。天下经文千万，真解其中意者又有几个？真正奥义，又岂能纸上得来？” 3435-3436, 标注, 2025 年 5 月 25 日星期日 上午 10:23:42 若天压我，劈开那天，若地拘我，踏碎那地，我等生来自由身，谁敢高高在上？” 3503-3504, 标注, 2025 年 5 月 25 日星期日 上午 11:34:01 我常在那块大石上看日落月升，看满天银辉把大海绚成繁星万点，与银河连成一片。明月下，快活的身影在山间跳跃，自在的啸声漫山呼应。 3502-3504, 标注, 2025 年 5 月 25 日星期日 上午 11:34:06 堤草色新。 这便是我的家园。 我常在那块大石上看日落月升，看满天银辉把大海绚成繁星万点，与银河连成一片。明月下，快活的身影在山间跳跃，自在的啸声漫山呼应。 3502-3504, 标注, 2025 年 5 月 25 日星期日 上午 11:34:19 这便是我的家园。 我常在那块大石上看日落月升，看满天银辉把大海绚成繁星万点，与银河连成一片。明月下，快活的身影在山间跳跃，自在的啸声漫山呼应。 3514-3515, 标注, 2025 年 5 月 25 日星期日 上午 11:36:15 没有，我想成为神是为了拥有，可我却只有放弃才能成为神。 ","date":"2025-06-29","objectID":"/%E7%AC%94%E8%AE%B0%E6%82%9F%E7%A9%BA%E4%BC%A0%E5%AE%8C%E7%BE%8E%E7%BA%AA%E5%BF%B5%E7%89%88-%E4%BB%8A%E4%BD%95%E5%9C%A8/:0:0","tags":["wukongchuan","","note","ireader"],"title":"[笔记]悟空传:完美纪念版 今何在","uri":"/%E7%AC%94%E8%AE%B0%E6%82%9F%E7%A9%BA%E4%BC%A0%E5%AE%8C%E7%BE%8E%E7%BA%AA%E5%BF%B5%E7%89%88-%E4%BB%8A%E4%BD%95%E5%9C%A8/"},{"categories":null,"content":" Table of Contents 1 亵渎 2 源代码 ","date":"2025-06-29","objectID":"/%E5%85%AD%E6%9C%88%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:0:0","tags":["weixin"],"title":"六月读书笔记","uri":"/%E5%85%AD%E6%9C%88%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"1 亵渎 时过境迁，十九年后重读此书，完全没有了当时追书的快乐，只有面对命运洪流时的困苦与无奈，以及，深藏其中的，一点点希望。 ","date":"2025-06-29","objectID":"/%E5%85%AD%E6%9C%88%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:1:0","tags":["weixin"],"title":"六月读书笔记","uri":"/%E5%85%AD%E6%9C%88%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"2 源代码 看着也比较又感触，还专门给孩子买了一本纸质书，当作暑假的阅读材料。 看的时候，时常感慨，那个黄金时代的美国教育真的很让人羡慕。天才总是与众不同，那种不刻板、不千篇一律的教育，才能发掘他们，让他们成长。 如果我成长于今时今日，很可能会被诊断为孤独症谱系障碍患者。在我的童年时期，一些人大脑处理信息的方式有异于旁人的这一事实并没有得到广泛的理解。（“神经多样性”这个术语直到 20 世纪 90 年代才出现。）我父母当时没有可参考的指南或教科书，以帮他们理解为什么自己的儿子对某些项目极度痴迷（比如“弹丸之地”特拉华州），为什么不懂察言观色，又为什么有时候粗鲁无礼却似乎完全注意不到自身行为对其他人产生的影响。 ","date":"2025-06-29","objectID":"/%E5%85%AD%E6%9C%88%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:2:0","tags":["weixin"],"title":"六月读书笔记","uri":"/%E5%85%AD%E6%9C%88%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":" 207-209, 标注, 2025 年 5 月 26 日星期一 下午 12:45:07 我已经太多的烙上了这个世界的印记，所能做到的只是毁灭。也许对这个世界来说，创造才是最重要的。当一个苹果跳入棋盘，并开始横冲直撞时，对整局棋的影响，比一个跳出棋盘的棋子，要大的多吧。” 425-426, 标注, 2025 年 5 月 26 日星期一 下午 6:42:32 夕阳越发的红了，万里江山如血。 439-442, 标注, 2025 年 5 月 26 日星期一 下午 6:43:49 说赚钱，这学问自也不小。赚钱之道，首在识势，次在得人。识天下大势，知道大势所趋，顺势而为，自然处处逢源。谈到识人，要知道人力有时而穷，任你聪明绝顶，也不会无所不能。能聚天下英贤为我所用，财源滚滚自不待言。最后一点在于能弃。人贵有自知之明，能进能退，见事不可为，要有断腕认输之勇。输一次两次，只要不伤筋动骨，何愁不能卷土重来。 1386-1387, 标注, 2025 年 5 月 26 日星期一 下午 9:36:13 一片金色波浪中，罗格等人显得十分咋眼，就如同一道清澈的泉水中漂着的一块五颜六色的垃圾。 2058-2059, 标注, 2025 年 5 月 27 日星期二 上午 7:45:41 山区的冬天还是十分寒冷的。几日前的一场大雪将整个山区妆点成一片银白。午后的阳光照耀在成片的树挂上，折射成七彩的光晕，宛如水晶宫一般。 2083-2085, 标注, 2025 年 5 月 27 日星期二 上午 7:47:55 存在就是合理的。哪一位古哲曾经这样说过。 存在的合理性是在于只有合理的才能存在。有人争论。 就算不合理，只要存在下来了，那也就是合理了吗？ 什么是合理呢？理又是何物？ 2194-2198, 标注, 2025 年 5 月 27 日星期二 上午 7:56:00 这个小小院落被整治得清雅幽静，大见匠心。一棵古树夏日可以荫凉大半个院子，冬天时的树挂也可能为院落一景。碎石辅就的一条曲曲弯弯的小路连接起了院门和房门。门厅上搭了个花架，已经干枯的藤蔓类的植物仍然盘绕在花架上，静静等待开春的时刻。冬季院中的草坪已经干枯了，上面错落摆着两盏漆成黑色的马车车灯。入夜的时候点上，淡淡的黄色光晕让夜归的人感觉到格外的温暖。 2332-2333, 标注, 2025 年 5 月 27 日星期二 上午 8:06:25 依莎贝拉愉快的在贫民区的街道里穿行着，仿佛是一个跳动着的音符。 2354-2357, 标注, 2025 年 5 月 27 日星期二 上午 8:08:24 女孩儿来到一个小小的院落前，如果这五六个平方米大的地方也能称为院落的话。这么小的院子里也有一棵古树，树干盘曲着，看得出来它的一生，也必如大多数生长在树荫下的人一样，坎坷痛苦。小院由一道篱笆围成。构成篱笆的不过是普通的木条罢了，可是不知怎的，看了却让人心中无比的平静。院落中积雪扫得干干净净，一尘不染的。喧嚣脏乱的环境都被那一道篱笆隔了开来。 2389-2390, 标注, 2025 年 5 月 27 日星期二 上午 8:10:30 “所以，你要好好的干啊！”胖子笑得狼尾巴乱晃。 2537-2539, 标注, 2025 年 5 月 27 日星期二 上午 8:21:24 罗格淡淡一笑，柔声道：“那存在的，都是幻影；那永恒的，终将毁灭；世界万物，缤纷色彩，都是被蒙蔽的人心罢了。终有一日，天上人间，青山绿水，存在只依我心！” 2811-2812, 标注, 2025 年 5 月 27 日星期二 下午 1:05:47 早起的鸟有虫吃，早起的虫呢？自然是被鸟吃了。 这么多早起的人，谁是虫，谁又是鸟呢？ 3431-3435, 标注, 2025 年 5 月 27 日星期二 下午 6:55:14 只是那高高在上的父神啊，你宣称为众生之父，你身为慈爱祥和之身，圣光照耀之下，众生莫不分享你的荣光。无人敢大声颂念你的名，只会全心意的聆听你的教诲，遵从你的指示，将你的福音带至每一个角落。 只要信仰你的名，那苦痛的，必得救赎；那饥饿的，必会饱食；那寒冷的，必将温暖。 这种种恩赐之下，何以容不下一点点的异端呢？ 3452-3454, 标注, 2025 年 5 月 27 日星期二 下午 6:56:53 地板上刻着：“活着”，用的是大贵族间和教会常用的哥德花体。 是啊，活着。只要活着就还有希望，只要活着明天就永远是个未知。管他什么意义、理他什么主义，先要活着，还得活得好些才成。 4042-4044, 标注, 2025 年 5 月 27 日星期二 下午 9:14:15 我今天跟你说了这么多东西，是因为你胸中谋略还是不错的。只是书读得多了，又没机会发挥，显得过于死板了。这韬略嘛，是要将你肚里那些兵书加上人情世故才能形成的。所以眼光放得长远些，心胸弄得开阔点。知道天下大势，我们才能顺势而为，就中取利。” 4962-4963, 标注, 2025 年 5 月 28 日星期三 上午 8:01:42 雄鹰三天不在天空中翱翔，就会变成肥胖的鹌鹑；骏马三天不在草原上奔驰，将会跑不过愚蠢的牛羊。” 5911-5912, 标注, 2025 年 5 月 28 日星期三 下午 8:22:21 然而再强大肥壮的青虫也不是蝴蝶。 罗德里格斯期待的是有朝一日罗格可以破茧而出，而不是永世作一条青虫。 6010-6014, 标注, 2025 年 5 月 28 日星期三 下午 8:30:44 老夫看过很多青年才俊，才华横溢，神力高强。他们都很聪明，也都很有野心。可是他们一个个的倒下去了，还没有我这个一无是处的老头子来得长久，就是因为太心急了。好比一头强壮的牧羊犬，所有的羊都怕它，于是它就真以为自己是无比强壮的，出去挑战狼群。而老夫则知道自己的力量有多大，所以选择了呆在羊群里，依靠其它牧羊犬和牧羊人的力量来抵御狼群，才活到了现在。所以人哪，就得知道自己能干点什么，会干点什么，手能够伸多长。总是望着、想着那些不属于自己的东西，总有一天，会忘了看脚下的路，走到悬崖上去。” 6765-6765, 标注, 2025 年 5 月 28 日星期三 下午 10:22:34 谣言有自己的生存方式，不管自己是多么的清白，最后一定会被传得面目全非。 8226-8229, 标注, 2025 年 5 月 29 日星期四 上午 8:46:34 想改变命运的人很多，可是大多数人都茫然不知命运的存在，也不知道自己的努力会有怎样的结果。也许改变命运的努力正是命运的一部分呢。好比河流中的一个鱼群，整群都向左游，只有少数几条想向右游，结果往往是被鱼群挤死或者又被挤带回原先的方向。真有一两条成功改变了方向的鱼，也多半会因为落了单而无法生存。而且，仅仅凭鱼看到的有限几种未来，又怎么能知道那种就是真正幸运的未来呢？” 8574-8577, 标注, 2025 年 5 月 29 日星期四 下午 1:12:48 任何计划，断没有一成不变、毫不修改的道理。历史上那些名将，都具备了根据战场情况随时修改计划的能力。要知道，这世界上的事物千变万化，一个死的计划不可能将所有的变化都计算在内。制订得越精细的计划，往往要修改的地方就会越多。准备战略预备队的意义正在于此……” 10099-10102, 标注, 2025 年 5 月 29 日星期四 下午 9:42:32 “奥菲，你不该回来的……” “我若不回来，就再也见不到你了……” “奥菲，你终于选择了我，我好高兴……” “若是没有你，我就是得到整个世界，又如何会快乐……” 生当如夏花，只为绚烂一瞬。 10096-10102, 标注, 2025 年 5 月 29 日星期四 下午 9:42:43 烈焰已经扑上埃丽西斯的身躯，她的黑袍在火焰中化作了飞灰。 奥菲罗克眼中亮起最后一点火焰，他的身躯突然向上一升，划过了一道弧线，投入了烈焰之中。 他的手指终于触到了埃丽西斯，紧紧地抱住了她。 烈焰升腾，吞没了两个缠绕着的身躯…… “奥菲，你不该回来的……” “我若不回来，就再也见不到你了……” “奥菲，你终于选择了我，我好高兴……” “若是没有你，我就是得到整个世界，又如何会快乐……” 生当如夏花，只为绚烂一瞬。 17005-17005, 标注, 2025 年 6 月 3 日星期二 下午 12:14:59 杀戮只要开了头，就会以仇恨的方式一代代传下去。 18692-18692, 标注, 2025 年 6 月 3 日星期二 下午 5:58:19 人生总有许多不如意，就是在绝望之中也不应该放弃希望，不要轻言牺牲。 18854-18855, 标注, 2025 年 6 月 3 日星期二 下午 6:25:30 文化和传统是基于文明之上形成的，但是它们一旦形成，就会倾向于自我巩固、自我加强，并且自发地排斥会引发变革的事物。 18918-18919, 标注, 2025 年 6 月 3 日星期二 下午 6:28:49 大多数人都会选择一个未知的将来，这样他们虽然可能会付出更大的代价，但还有着获利的希望。而我不同，我宁可选择付出已知的代价。我知道自己承受得起这代价。” 19380-19382, 标注, 2025 年 6 月 3 日星期二 下午 10:15:58 夕阳如血。 晚霞将浓得好似化不开的艳红涂抹在本来是银色的、一望无际的山林上。大群大群的宿鸟正飞回窝巢中，鸣叫声此起彼伏。 急骤的马蹄声打破了山林的详和，数十骑风雷般从远方的山岭上奔驰下来，毫不减速地冲入密林之中！ 19683-19684, 标注, 2025 年 6 月 3 日星期二 下午 11:16:53 不知怎么的，罗格总是觉得阿佳妮的斗气火焰燃烧得太过绚烂了，绚烂得如同一朵拼命展示着刹那芳华的鲜花……","date":"2025-06-29","objectID":"/%E7%AC%94%E8%AE%B0%E4%BA%B5%E6%B8%8E-%E7%83%9F%E9%9B%A8%E6%B1%9F%E5%8D%97/:0:0","tags":["笔记","xiedu","note","ireader"],"title":"亵渎-烟雨江南","uri":"/%E7%AC%94%E8%AE%B0%E4%BA%B5%E6%B8%8E-%E7%83%9F%E9%9B%A8%E6%B1%9F%E5%8D%97/"},{"categories":null,"content":" 248-250, 标注, 2025 年 6 月 24 日星期二 下午 9:23:32 玩纸牌教会我：无论某些事情看起来多复杂、多神秘，我们通常都能最终琢磨出个究竟。这个世界是可以被理解的。我出生于 1955 年 10 月 28 日，在家里 248-249, 标注, 2025 年 6 月 24 日星期二 下午 9:23:37 玩纸牌教会我：无论某些事情看起来多复杂、多神秘，我们通常都能最终琢磨出个究竟。这个世界是可以被理解的。 385-387, 标注, 2025 年 6 月 25 日星期三 上午 7:57:23 我祖父和多尔姆都是辍学者，但他们应对这一挑战的方式截然不同，随后的人生际遇也大相径庭。我祖父一直生活在焦虑之中，紧紧抓着他那些刻板的规矩不放；多尔姆不执着于欠缺之物，而是专注于自身发展的可能性。 533-536, 标注, 2025 年 6 月 25 日星期三 下午 12:39:50 肯尼迪总统在为世博会致开幕词时说：“我们展示的这一切，是在科学、技术和工业领域付出巨大的努力后取得的成就。”他的这番话是从佛罗里达借助卫星通信链路传送而来的，“这充分体现了和平与合作的精神，秉承着这种精神，我们将迈向未来的几十年”。 562-565, 标注, 2025 年 6 月 25 日星期三 下午 6:57:29 从沃尔特·克朗凯特（哥伦比亚广播公司《晚间新闻》节目主持人）和《生活》周刊那里，我们获知了源源不断的新奇迹：第一台激光器、第一盘盒式录音带、第一个工厂机器人、第一块硅芯片。那时候，作为一个小孩子，很难不对此感到兴奋。这种潜能无限的氛围是我早年生活的背景，也是我母亲为我们设定的抱负。 645-648, 标注, 2025 年 6 月 25 日星期三 下午 7:04:19 我父母的朋友行事方式也是如此，这些人不是那种渴望离开家乡、到纽约或洛杉矶寻找更刺激的生活的人，他们毕业于华盛顿大学，拿到法学、工程学和商学学位后，就在离母校和老朋友几英里远的地方安顿下来。他们生儿育女，创立企业，或加入公司，或竞选公职，然后把闲暇时间花在各种类型的公益事业上，就像是学校附加税和基督教青年会董事会之于我父亲。 692-696, 标注, 2025 年 6 月 25 日星期三 下午 7:14:44 日本汽车制造商以注重“持续改善”的企业精神而著称，他们在第二次世界大战后奉行的这种不断完善的哲学令日本汽车的品质逐年提升。与丰田相比，我母亲绝对是有过之而无不及，至少在对待节日方面肯定如此。比如说圣诞节，在我们家，它是从初秋就开始的。我母亲会阅读她前一年过节时记下的笔记，看看上一年做错了哪些事，然后就此加以改善。 818-819, 标注, 2025 年 6 月 25 日星期三 下午 8:59:16 通过阅读，我能找到针对各种问题的答案。当然，一个答案往往又会引发更多的问题；越是深入挖掘，想要知道的东西就越 818-819, 标注, 2025 年 6 月 25 日星期三 下午 8:59:23 通过阅读，我能找到针对各种问题的答案。当然，一个答案往往又会引发更多的问题；越是深入挖掘，想要知道的东西就越多。 1206-1210, 标注, 2025 年 6 月 25 日星期三 下午 10:21:09 克雷西博士建议，与其浪费精力跟父母对着干，不如更多地专注于获取那些将来踏入社会时能用得上的技能。 多年后，我才知道克雷西博士的童年颇为不幸，曾经遭受的身体虐待让他一直愤恨难平。二战后，他决定不再被愤怒的情绪掌控，转而将其毕生的精力投入传播爱的事业。他显然知道，我的问题和他儿时的经历及许多来访者的问题相比，实在是小事一桩。然而，他从不会看轻我所经历的一切。 1229-1231, 标注, 2025 年 6 月 25 日星期三 下午 10:23:12 随着时间的推移，我终究接受了我母亲就是这样一个人的事实，而我母亲也明白了我永远都达不到她为我设定的标准。我越来越多地将自身能量放在为真正独立的那一天做好准备上，而不是与母亲对着干。这种视角的转变恰逢其时，我逐渐感知到那个更广阔的成人世界。 1277-1279, 标注, 2025 年 6 月 25 日星期三 下午 10:27:42 这个故事让我着迷，它让我了解到一个身兼医生和发明家双重身份的人如何通过制造仪器来挽救生命。我这个六年级学生的小脑袋瓜也借此汲取了关于融资、专利、利润和研发的相关信息。 1299-1300, 标注, 2025 年 6 月 25 日星期三 下午 10:29:54 离开巴特尔时，我想这就是聪明人该做的事，他们和其他聪明人凑在一起，解决真正的难题。 1394-1395, 标注, 2025 年 6 月 26 日星期四 上午 7:51:42 和我不一样的是，他根本不在乎，肯特对社会地位及别人对他的看法毫不介怀。他只为自己和自己感兴趣的事物而活，兴之所至，辄全力以赴，远远超出人们对一个 12 岁男孩的想象。 1460-1462, 标注, 2025 年 6 月 26 日星期四 上午 8:04:34 一年后升任校长的丹·艾罗尔特曾经把湖滨中学描述为“一所规矩不太多的学校”。规矩不太多意味着湖滨中学的教师们可以自由地开展各种实验性工作，如果学生对一个话题极其感兴趣，其授课老师可以不拘泥于教学方案，探索新的教学方向。招聘教师时，湖滨中学特别看重那些对自身领域兴趣浓厚且有真才实学的人。 1470-1471, 标注, 2025 年 6 月 26 日星期四 上午 8:05:34 杜格尔老师曾在第二次世界大战中当过海军飞行员，后来 1470-1473, 标注, 2025 年 6 月 26 日星期四 上午 8:05:44 杜格尔老师曾在第二次世界大战中当过海军飞行员，后来任职于波音公司，是航空工程专家。除了拥有工程学和教育学的研究生学位，在人生的某个阶段，他还在巴黎索邦大学学习过法国文学。作为登山迷和探险家，他曾于公休假期间在加德满都建起过一座风车。 1562-1563, 标注, 2025 年 6 月 26 日星期四 上午 8:16:51 我事后才意识到，这种创造力的爆发是高明的领导术有意促成的结果，更确切地说，是一种无为而治的领导。 1562-1565, 标注, 2025 年 6 月 26 日星期四 上午 8:17:06 我事后才意识到，这种创造力的爆发是高明的领导术有意促成的结果，更确切地说，是一种无为而治的领导。身为数学教师的弗雷德·赖特是计算机房事实上的监管者，他很年轻，当时还不到 30 岁，两年前才被湖滨中学聘用的他和这所学校的气质完美契合。他是一个会因学生自行发现解题之道而欣喜的老师。 1568-1569, 标注, 2025 年 6 月 26 日星期四 上午 8:17:34 他敞开计算机房的大门，让我们来去自如，他相信在不设限的情况下，我们必然能发挥创意，找出自学之道。 1573-1575, 标注, 2025 年 6 月 26 日星期四 上午 8:18:50 那年秋天，我们几乎整天泡在那个房间里，写程序，测试失败，从头再来，如此周而复始。我们的成绩一落千丈，我们的父母忧心忡忡，但我们的确在学习，而且学得很快。这是我在学校里度过的最快乐的时光。 1879-1881, 标注, 2025 年 6 月 26 日星期四 下午 7:16:23 在我逐渐成形的世界观中，数学所需的逻辑和理性思维是可以用来掌握任何学科的万用技能。这个世界上存在一个智力等级体系：你的数学成绩有多好，其他科目的成绩就有多好，生物、化学、历史甚至语言学习皆是如此。 1935-1937, 标注, 2025 年 6 月 26 日星期四 下午 7:22:36 梅斯特里蒂老师抨击了那种将科学视为一堆已经验证的事实、只需死记硬背即可的观点，他认为科学是一种审视世界的方式，它是一个永不间断的故事，一直在挑战那些积年累月、深植人心的事实与理论。 1972-1973, 标注, 2025 年 6 月 26 日星期四 下午 7:26:22 我在湖滨中学的老师赋予我一种不同的视角：质疑你所知道的、你信以为真的东西，这个世界就是如此进步的。在我那个可塑性极强的年纪，这无疑是一则充满乐观主义精神的信息。 2102-2105, 标注, 2025 年 6 月 26 日星期四 下午 9:21:35 丹·艾罗尔特在休长假期间游历了美国各地，考察了多所私立学校，他得出结论：学生在不受束缚的情况下表现得最为出色。那年秋天，他在校报上表示，他想要看到一个“没有强制性学校教育”的世界；学生应当发现自己学习的动力，一旦他们找到了，就会成功；增加没有固定排课的时间，增加选修课，增加非传统的学习方式，所有这些加在一起，便会培养出更加积极主动的学生。 2354-2356, 标注, 2025 年 6 月 26 日星期四 下午 10:33:59 上完一个滑雪季的课后，他骄傲地告诉我们，因为自己在一群水平极差的滑雪者中表现最佳，他赢得了一座奖杯。他所需要的就只是那一点点进步。 2353-2356, 标注, 2025 年 6 月 26 日星期四 下午 10:34:16 肯特并不擅长体育运动，任何涉及力量或协调性的运动对他来说都是一场考验，但他无所畏惧，在充分了解自身不足的同时，仍坚定地表示会努力克服种种困难。他已经在滑雪运动上证明了这一点，上完一个滑雪季的课后，他骄傲地告诉我们，因为自己在一群水平极差的滑雪者中表现最佳，他赢得了一座奖杯。他所需要的就只是那一点点进步。 2521-2523, 标注, 2025 年 6 月 26 日星期四 下午 10:47:28 在我这一生中，我往往会通过回避的方式来面对失去的痛苦：把它强压下去，扛过最初的悲痛阶","date":"2025-06-29","objectID":"/%E7%AC%94%E8%AE%B0%E6%BA%90%E4%BB%A3%E7%A0%81/:0:0","tags":["比尔·盖茨首部自传-[美","笔记]源代码","yuandaima","bi","note","ireader"],"title":"源代码","uri":"/%E7%AC%94%E8%AE%B0%E6%BA%90%E4%BB%A3%E7%A0%81/"},{"categories":null,"content":"here: https://unix.stackexchange.com/questions/758076/how-to-effectively-alias-a-user-on-linux Users can share their UID, giving them the same user permissions. Some quick testing reveals that no matter which alias you are logged in as, the system will recognize you as the first user which matches the UID from the passwd database (normally /etc/passwd but can be elsewhere in advanced setups). I have not seen that groups behave the same way, each alias needs to be added to each group explicitly. It would seem that while users are mapped from UID, the groups look to be mapped from the name (check the contents of /etc/group to get a sense of what I mean). Quick example based on what you started with: #!/bin/sh USER1=primary USER2=alias sudo adduser $USER1 sudo useradd -d /home/$USER1 -G $USER1 -K UMASK=022 --non-unique --uid $(id -u $USER1) --no-create-home --no-user-group $USER2 sudo passwd $USER2 # --non-unique: Allow the creation of a user account with duplicate UID # --uid: The numerical value of the user's ID # --no-create-home: Do not create the user's home directory. # --no-user-group: Do not create a group with the same name as the user. Then how to set password non-interactively? https://stackoverflow.com/questions/65226720/setting-password-of-the-new-user-in-non-interactive-way-in-shell-script-on-ubunt echo \"v3rystrongpassword\" | passwd username --stdin ","date":"2025-06-20","objectID":"/how-to-create-alias-for-user-in-linux/:0:0","tags":[""],"title":"how to create alias for user in Linux","uri":"/how-to-create-alias-for-user-in-linux/"},{"categories":null,"content":" Table of Contents 1 欢乐英雄 2 悟空传 这个月仍然没有读那些严肃的作品，重读了两本书，新开了两本。 ","date":"2025-06-01","objectID":"/%E4%BA%94%E6%9C%88%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:0:0","tags":["weixin"],"title":"五月读书笔记","uri":"/%E4%BA%94%E6%9C%88%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"1 欢乐英雄 古龙的经典之作。第一次读的时候是高中时候，几个主角被同学戏称为“几个小痞子”。古龙用其独特的笔锋，描写了“几个小痞子”的生死友谊。其中还不忘顺便调侃一下金庸： 乞丐大多属于丐帮，也就是俗称的穷家帮，他们用的短杖，通常叫作打狗棒，这名字据说是昔日一位姓查的帮主起的，但真的来源究竟出自何处，谁也没有认真去考据过。 ","date":"2025-06-01","objectID":"/%E4%BA%94%E6%9C%88%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:1:0","tags":["weixin"],"title":"五月读书笔记","uri":"/%E4%BA%94%E6%9C%88%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"2 悟空传 曾经红极一时的网文，可能当时只读过一点半点。故事背后对西游的理解独特，但是文笔、以及人物对话，太过无厘头，大话西游风格严重。 不太推荐。 最近又重新把烟雨江南的 《亵渎》捡起来了，相比之下，真是经典。 ","date":"2025-06-01","objectID":"/%E4%BA%94%E6%9C%88%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:2:0","tags":["weixin"],"title":"五月读书笔记","uri":"/%E4%BA%94%E6%9C%88%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":" 121-122, 标注, 2025 年 5 月 21 日星期三 上午 8:30:29 每个人的人生中都会做出无数次选择，这些选择是会改变你的一生，还是无论如何选择都会走向同一种命运呢？ 703-704, 标注, 2025 年 5 月 23 日星期五 下午 9:13:27 她选了一个方向顺意游去了。 是不是选择任何一个方向，都会游向同一个宿命呢？ 124-127, 标注, 2025 年 5 月 21 日星期三 上午 8:30:57 我还是很怀念当年那个带着随身听在夜间的校园里疾走、沉迷在音乐中的我；那个可以在图书馆坐一晚上，看各种文史资料、纪实文学，梦想着能写出一部《战争与和平》的我；那个每月生活费五百还能省下三百来买书和磁带的我。 127-131, 标注, 2025 年 5 月 21 日星期三 上午 8:31:42 回忆我的人生，最幸福的还是大学时光。尽管在当时，你感受到的只是各种情绪的冲撞——空虚、无聊、迷惑、愤怒、渴望爱情、畅谈理想……然后看见平庸的现实。 但那时，我拥有时间。 时间是人生最珍贵的东西，这是我从小就听到的话，却直到现在才理解。 而时间偏偏是最公平的，不论你如何待它，它都那样不紧不慢地流过，绝不会为你改变分毫。 166-168, 标注, 2025 年 5 月 21 日星期三 上午 8:34:21 佛是什么，佛就是虚无，四大皆空，什么都没有了，没有感情没有欲望没有思想，当你放弃这些，你就不会痛苦了。但问题是，放弃了这些，人还剩下什么？什么都没了，直接就死了。所以成佛就是消亡，西天就是寂灭，西游就是一场被精心安排成自杀的谋杀。 169-173, 标注, 2025 年 5 月 21 日星期三 上午 8:34:44 我心目中的西游，就是人的道路。每个人都有一条自己的西游路，我们都在向西走，到了西天，大家就虚无了，就同归来处了，所有人都不可避免要奔向那个归宿，你没办法选择，没办法回头，那怎么办呢？你只有在这条路上，尽量走得精彩一些，走得抬头挺胸一些，多经历一些，多想一些，多看一些，去做好你想做的事，最后，你能说，这个世界我来过，我爱过，我战斗过，我不后悔。 147-149, 标注, 2025 年 5 月 21 日星期三 下午 10:01:36 当你老去的时候，回想一生，你会不会遗憾？似乎不论如何去苦苦追求，总有一些你必须放弃，总有一些你只能怀念，还有一些永远只在梦想中。我们永远在计算成败、取舍与得失，却没有人能找到正确答案。 160-161, 标注, 2025 年 5 月 21 日星期三 下午 10:03:53 所以整个西游就是一出悲剧，是一场阴谋，不论你怎么做，都是死路一条。你不服从神，不向西走，整死你；你向西走，一路上九九八十一难，都是神安排的，依然整死你。 173-174, 标注, 2025 年 5 月 21 日星期三 下午 10:07:18 人生最有价值的时刻，不是最后的功成名就，而是对未来正充满期待与不安之时。 175-177, 标注, 2025 年 5 月 21 日星期三 下午 10:07:52 成败，其实并不是最重要的。因为你去追求理想时你就会明白，你很可能不会成功。最关键就在于，当你深知这一点时，你还要不要去追求。 我没有答案。也不需要答案。 464-465, 标注, 2025 年 5 月 23 日星期五 下午 9:04:07 漫天的云雾，白色的，充满了整个世界，却又不在任何地方，像那阳光，天地间所有的光线与色彩从它而来，可它却是白色的。 818-819, 标注, 2025 年 5 月 23 日星期五 下午 9:43:29 我要这天，再遮不住我眼， 要这地，再埋不了我心， 要这众生，都明白我意， 要那诸佛，都烟消云散！ 1064-1064, 标注, 2025 年 5 月 23 日星期五 下午 10:14:13 一个人而存在的，当他发现自己错的时候，他便开始长大 1064-1064, 标注, 2025 年 5 月 23 日星期五 下午 10:14:17 也许每个人出生时都以为这天地是为他一个人而存在的，当他发现自己错的时候，他便开始长大了。 1380-1382, 标注, 2025 年 5 月 23 日星期五 下午 11:01:34 一个声音狂笑着，他大笑着殴打神仙，大笑着毁灭一切，他知道神永远杀不完，他知道天宫无边无际。这战斗将无法终止，直到他倒下，他仍然狂笑，笑出了眼泪。 这个天地，我来过，我奋战过，我深爱过，我不在乎结局。 1548-1549, 标注, 2025 年 5 月 24 日星期六 上午 10:34:36 只有绝望，能毁灭一颗不死的心。 1824-1825, 标注, 2025 年 5 月 24 日星期六 上午 10:46:38 孙悟空在林中走着，脚下是柔软的落叶与蔓草，他想了想，甩掉了他的靴子，赤足踩在湿漉漉的土地上，凉丝丝的感觉从足心传上来，脚下的土地仿佛是有了生命的，那些小草在轻挠他的脚心。 2373-2375, 标注, 2025 年 5 月 24 日星期六 上午 11:17:41 这个天地，我来过，我奋战过，我深爱过，我不在乎结局。 纷纷落叶飘向大地，白雪下种子沉睡，一朵花开了又迅速枯萎，在流转的光的阴影中，星图不断变幻，海水中矗起高山，草木几百代的荣枯，总有一片片迎风挺立，酷似它们的祖先。怎能忘了西游？ 3133-3135, 标注, 2025 年 5 月 24 日星期六 下午 8:30:08 “那酒是用水帘瀑布的水酿的，纯得照透人心，用了千种花百种果，蕴了万物的芳醇，用太阳的光刻入七种色彩，开坛时，全山都弥漫着香气，凡人喝了一口，要醉上一百年。那一天，我们全喝醉了，他拍着我的肩膀笑着说，他不记得自己是谁了，我说，不要紧，记得这杯酒就行了。” ","date":"2025-05-25","objectID":"/%E7%AC%94%E8%AE%B0%E6%82%9F%E7%A9%BA%E4%BC%A0/:0:0","tags":["笔记","wukongchuan","","note","ireader"],"title":"悟空传:完美纪念版-今何在","uri":"/%E7%AC%94%E8%AE%B0%E6%82%9F%E7%A9%BA%E4%BC%A0/"},{"categories":null,"content":" 188-189, 标注, 2025 年 5 月 15 日星期四 下午 1:24:06 “明天，又是另外一天了。”无论什么事，到了明天，总会有办法的，今天晚上若就为明天的事担心，岂非划不来？ 315-318, 标注, 2025 年 5 月 15 日星期四 下午 1:30:03 他们虽然穷，却穷得快乐。 因为他们既没有对不起别人，也没有对不起自己。 因为他们既不怨天，也不尤人，无论他们遇到多么大的困难，多么大的挫折，都不会令他们丧失勇气。他们不怕克服困难时所经历的艰苦，却懂得享受克服困难后那种成功的欢愉。 341-342, 标注, 2025 年 5 月 15 日星期四 下午 6:34:31 “穿威风，赌对冲，嫖成空”，只有“吃”最实惠，这是王动的原则，也是他最大的享受。 822-823, 标注, 2025 年 5 月 15 日星期四 下午 8:59:43 四个光棍的男人中若是忽然多了个女人，那情况简直就像一只筷子忽然伸到装着四个生鸡蛋的碗里去，想不搅得一塌糊涂都不行。 825-826, 标注, 2025 年 5 月 15 日星期四 下午 8:59:58 他们每天早上起来的时候都觉得很快乐，因为那倒霉的“昨天”总算已过去，今天又充满了希望。 993-995, 标注, 2025 年 5 月 15 日星期四 下午 9:06:55 他们放弃了财富，却留下了良心。 这也许就是富贵离他们最近的时候，但他们并不贪图富贵，也不要以贪婪、卑鄙、欺诈的方法去攫取富贵，所以他们永远快乐，就像沐浴在春日阳光中的花草一样。 他们知道快乐远比财富可爱得多。 1557-1560, 标注, 2025 年 5 月 15 日星期四 下午 9:31:21 也许就因为我们谁都没有往床这边瞧过一眼，所以他才会怀疑。” 这也是结论。 你愈是故意装着对一件事全不关心，反而显得你对它特别关心。 尤其是女孩子。 一个女孩子若是对别人全都很和气，只有对你不理不睬，那也许就是说她心里没有别人，只有你。 1571-1573, 标注, 2025 年 5 月 15 日星期四 下午 9:32:21 他笑得很特别，也很好看。 别人开始笑的时候，有的是眼睛先笑，有的是嘴先笑。 他开始笑的时候，却是鼻子先笑，鼻子先轻轻地皱起一点点，然后面颊上再慢慢地现出两个很深很深的酒窝。 1792-1793, 标注, 2025 年 5 月 15 日星期四 下午 10:01:14 黎明。城里又恢复宁静，风还是那么吹，雪还是那么落。世上有些东西本就不是其他任何事所能改变的。有些人也一样。 1907-1912, 标注, 2025 年 5 月 15 日星期四 下午 10:09:27 郭大路找了个破庙，坐在神案前，望着那泥菩萨发怔。泥菩萨好像也正望着他发怔。 他本来已计划得很好，准备先舒舒服服地吃一顿，再舒舒服服地洗个澡，他甚至已想象到一双玉手替他擦背时的旖旎风光。 可是现在呢？现在替他擦背的是只臭虫，也许还不止一只，他坐着的蒲团就好像是臭虫的大本营，好像全世界的臭虫都已集中到这里，正一队一队地钻入他衣服，准备在他背上开饭。 2076-2078, 标注, 2025 年 5 月 15 日星期四 下午 10:48:11 林太平道：“你们认为这件事很可笑？” 王动忽然翻了翻白眼道：“不笑怎么办？哭么？” 这就是他们做人的哲学。他们会笑，敢笑，也懂得笑。 笑不但可以令人欢愉，也可以增加你对人生的信心和勇气。 “笑的人有福了，因为生命是属于他们的。” 郭大路道：“笑就算不能解决问题，至少总不会增加烦恼。” 他又笑了笑，接着道：“何况，你若学会了用笑去面对人生，渐渐就会发觉人生本没有什么真正不能解决的问题。” 2096-2097, 标注, 2025 年 5 月 15 日星期四 下午 10:49:53 燕七道：“我的嘴很忙。” 郭大路道：“忙什么？” 燕七道：“忙着把想说的话吞回肚子里去。” 2245-2249, 标注, 2025 年 5 月 16 日星期五 上午 7:59:25 黄昏。 夕阳满山。 半枯的秋草在夕阳下看来宛如黄金，遍地的黄金；石板砌成的小径斜向前方伸展，宛如黄金堆中的一串白玉。 风在吹，鸟在啼，秋虫在低语，混合成一种比音乐还美妙的声音，它美妙得宛如情人的耳畔低语。 满山弥漫着花的香气、草的香气、风的香气。甚至连夕阳都仿佛被染上了芬芳，芬芳得宛如情人鬓边的柔发。 人生原来竟如此芬芳，如此美妙。 2699-2701, 标注, 2025 年 5 月 16 日星期五 下午 12:38:57 狗不像人，狗不记仇，只记得住别人的恩惠。” 郭大路道：“不错，你只要给狗吃过一块骨头，它下次见了你，一定会摇尾巴；但有些忘恩负义的人，你无论给过他多少好处，他回过头来反而会咬你一口， 2708-2710, 标注, 2025 年 5 月 16 日星期五 下午 12:39:23 猪不能太肥，人不能太聪明。 肥猪总是先挨宰，人若要活得愉快些，也得带几分傻气，做几件傻事。那并不表示他们就是傻子。 3144-3147, 标注, 2025 年 5 月 16 日星期五 下午 6:38:48 月光很美。 也许很少有人会注意到，但冬天的月光并不一定就不如春天的月光那么动人，冬天的月光也一样能打动少女的心。 圆圆的月亮挂在树梢，梅汝男就站在树下。月光照着她的脸，她的眼睛。她的眼睛比月光更美。 3209-3210, 标注, 2025 年 5 月 16 日星期五 下午 6:41:02 其实，燕七的眼睛非但不丑，而且很好看，尤其是在眼睛带着笑意的时候，看来就像是春风中清澈的湖水。 6020-6024, 标注, 2025 年 5 月 17 日星期六 下午 7:24:31 红娘子道：“你有把握能诱我们到这里来？” 王动道：“只有一点，不太多。” 红娘子道：“但你还是要这么样做？” 王动道：“一个人若只肯做绝对有把握的事，那么他就连一样事都做不成。” 红娘子道：“哦？” 王动道：“因为世上本没有绝对有把握的事。” 6306-6309, 标注, 2025 年 5 月 17 日星期六 下午 8:14:53 世上有些地方的春天，到得总好像特别迟些。 还有些地方甚至好像永无春天。 其实你若要知道春天是否来了，用不着去看枝头的新绿，也用不着去问春江的野鸭。 你只要问你自己。 因为真正的春天既不在绿枝上，也不在暖水中。真正的春天就在你心里。 7873-7875, 标注, 2025 年 5 月 17 日星期六 下午 9:48:58 郭大路道：“你想这麻烦什么时候会来呢？” 燕七目光凝视着远方，缓缓道：“就因为你不知道那是什么样的麻烦，也不知道它什么时候会来，所以那才是真正的麻烦，否则就也用不着担心了。” 9142-9144, 标注, 2025 年 5 月 18 日星期日 上午 7:40:31 乞丐大多属于丐帮，也就是俗称的穷家帮，他们用的短杖，通常叫作打狗棒，这名字据说是昔日一位姓查的帮主起的，但真的来源究竟出自何处，谁也没有认真去考据过。 莫不是查良庸… ","date":"2025-05-19","objectID":"/%E7%AC%94%E8%AE%B0%E6%AC%A2%E4%B9%90%E8%8B%B1%E9%9B%84-%E5%8F%A4%E9%BE%99/:0:0","tags":["笔记","huanleyingxi","note","ireader"],"title":"欢乐英雄-古龙","uri":"/%E7%AC%94%E8%AE%B0%E6%AC%A2%E4%B9%90%E8%8B%B1%E9%9B%84-%E5%8F%A4%E9%BE%99/"},{"categories":null,"content":" Table of Contents 1 《沪上烟火》 2 数学的雨伞下 从四月底开始，一到周末就忙着看到处看装修、看设计、看家电，没有抽出时间来写四月的总结，一直拖到了今天。 四月份阅读的不太多，由于沉迷暗黑，通勤的时间被用来玩游戏了，最近才又恢复回来。 四月份读完了两本书。 ","date":"2025-05-18","objectID":"/%E5%9B%9B%E6%9C%88%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93/:0:0","tags":["weixin"],"title":"四月阅读总结","uri":"/%E5%9B%9B%E6%9C%88%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"1 《沪上烟火》 Figure 1: 沪上烟火 这本书是三月份看了基本“严肃”的书之后作为调剂看的，比较轻松，感觉像是用爽文的方式来描写了上世纪知青返城后的事情，读起来就想一口气读完，但是读完也就完了，对我而言除了勾起若干回忆，没有什么能感慨的地方。 知青，一个历史，影响了无数人。我身边就有几个人被卷入了这历史的洪流，一个小学同学，一个初中同学，一个大学同事。 小学那个同学，父亲是村民，母亲是北京的知青，那个年代讲究“扎根”农村，于是二人结合，结果孩子生下来没多久，政策一变，人便走了，将父子二人仍在了原地。父亲终身未再婚。至于后来是否有联系，外人不得而知。后来那个孩子独自外出闯荡，前些年他父亲去世，孩子回乡将父亲遗骨带走，似乎永远不会再回来了。 初中那个同学与之类似，不同之处是后来其父重新组建家庭，其后母对其不好；至今父亲仍在，他每年回来探望。 同事就比较好了，是从天津下放到秦皇岛，没有下乡，家庭完整，比较顺利。 ","date":"2025-05-18","objectID":"/%E5%9B%9B%E6%9C%88%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93/:1:0","tags":["weixin"],"title":"四月阅读总结","uri":"/%E5%9B%9B%E6%9C%88%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"2 数学的雨伞下 Figure 2: 数学的雨伞下 科普读物？有趣的揭示了数学、天文、物理等知识。 ","date":"2025-05-18","objectID":"/%E5%9B%9B%E6%9C%88%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93/:2:0","tags":["weixin"],"title":"四月阅读总结","uri":"/%E5%9B%9B%E6%9C%88%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93/"},{"categories":null,"content":" 47-48, 标注, 2025 年 4 月 21 日星期一 下午 10:27:58 正是农历的九月初头，正是九月初头的一个标准的秋夜，正是一个标准的秋夜的半夜时分，肃杀的秋气虽不说冷得厉害，但也尽够人受的。 52-53, 标注, 2025 年 4 月 21 日星期一 下午 10:29:23 她的前前后后都闪烁着车老板挂在辕杆上的风雨灯发出的昏黄的光亮，骡马驴牛都在吃着草料，一片窸窸窣窣的声响，使这冰凉的秋夜显得更加漫长和不可捉摸。 54-55, 标注, 2025 年 4 月 21 日星期一 下午 10:30:27 时间仿佛凝固了，黑夜仿佛永远走不到尽头似的，杜秋妹仿佛等了几年似的。但夜色依然是那么厚重沉郁，绝没有半点曦光出现。 57-61, 标注, 2025 年 4 月 21 日星期一 下午 10:32:22 这时，天忽然格外黑起来，暗蓝的天幕变成黝黑。天幕上寒星点点，空气冰冷潮湿。一会儿，黑暗渐渐褪去，天色也变淡了，天空也变高了。半边天空是海水般的深蓝，半边天空是鸭蛋壳般的淡青。不久，星星隐去了，东边地平线下仿佛燃起了一堆大火，把半个天空又染成橘红色，几条呈辐射状的长云则一直伸展到西半边天空，像几支横扫长天的巨笔。太阳虽然还没出来，但天已经亮了。 64-66, 标注, 2025 年 4 月 21 日星期一 下午 10:33:47 太阳升起来了，通红的光线照耀着落在大地上的、车辆上的以及杜秋妹头上的那层薄薄的白霜，一切都反射出令人感到温暖的红色光辉，连杜秋妹周围的人和骡马驴牛嘴里喷出的热气也带着迷人的色彩。 75-76, 标注, 2025 年 4 月 21 日星期一 下午 10:36:12 他的脸平常得像一块方方正正的砖坯，浑身上下都好像带棱带角。 177-179, 标注, 2025 年 4 月 29 日星期二 下午 10:00:40 东北风愈刮愈大，风里夹杂着潮气和泥土腥味，马路两旁收获后的庄稼地袒露着胸膛，苍茫辽远，风刮着焦干的豆叶在道沟里滚动，唰啦唰啦响个不停。 197-200, 标注, 2025 年 4 月 29 日星期二 下午 10:05:48 大家都抬头看天，天果然有些不妙，风利飕有劲，潮气很重，东北方向的天空像有千军万马在集结待命，乌压压，黑沉沉，仿佛只要一声令下，就会冲过来，就会遮天盖地。没有被阴云吞噬的晴空中，还有几个星星在发抖；西边林梢上那一勾细眉般的新月，也好像在打着哆嗦。一会儿，神使鬼差似的，就在东北方向遥远的地方，一道贼亮的闪电划开了夜幕，很久，才响起了一阵沉闷的雷声。 209-215, 标注, 2025 年 4 月 29 日星期二 下午 10:09:02 人无处躲藏，就一齐坐在马车上，静候着雷雨的到来。车把式的风雨灯熬干了油，不死不活地跳动了几下，熄灭了。风也突然停了。一只雨信鸟尖叫着从空中掠过，翅膀扇动的声音都听得清清楚楚。原先一直低唱浅吟的秋虫也歇了歌喉。一切都仿佛在耐心地等待；一切都仿佛进入了超生脱死的涅槃境界。就这样不知呆了多长时间，突然，一种窸窸窣窣、呼呼噜噜、轰轰隆隆的声音从东北方向滚滚而来，一时间天地之间仿佛有无数只春蚕在野咬桑叶，无数只家猫在打着鼾，无数匹野马掠过原野。紧接着，一直在东北方横劈竖砍的闪电亮到了头顶，震耳的雷声也在人们耳边响起。顷刻之间，风声大作，风里夹杂着稀疏但极有力的雨点横扫下来，像鞭子一样抽打着人的颜面。 236-237, 标注, 2025 年 4 月 29 日星期二 下午 10:12:38 她们满腹的感激话一句也说不出，只将一行行热泪挂到冰冷的腮上。 385-393, 标注, 2025 年 5 月 8 日星期四 下午 10:36:06 八隆河清脆细微的流水声从人们耳畔流过，间或有几只青蛙“嘎嘎”叫几声，然后又是寂静。突然，从院子里响起了一种马桑镇居民多少年没听过的声音，这是小瞎子在吹箫！那最初吹出的几声像是一个少妇深沉而轻软的叹息，接着，叹息声变成了委婉曲折的呜咽，呜咽声像八隆河水与天上的流云一样舒展从容，这声音逐渐低落，仿佛沉入了悲哀的无边大海……忽而，凄楚婉转一变又为悲壮苍凉，声音也愈来愈大，仿佛有滔滔洪水奔涌而来，堤上人的感情在音乐的波浪中起伏。这时，瘸子方六仰着脸，眼睛似闭非闭；黄眼把头低垂着，“呼哧呼哧”喘着粗气；麻子杜双手捂着眼睛；三斜的眼睛睁得比平时大了一倍……箫声愈加苍凉，竟有穿云裂石之声。这声音有力地拨动着最纤细最柔和的人心之弦，使人们沉浸在一种迷离恍惚的感觉之中。 箫声停止了，袅袅余音萦回不绝。人们怀着一种甜蜜的惆怅，悄悄地走下堤去，消失在小镇的四面八方。 418-421, 标注, 2025 年 5 月 11 日星期日 下午 10:42:28 人们忘了天，忘了地，忘了一切烦恼与忧愁。花茉莉俯身在柜台上，双手捧着腮，眼睛迷离着，面色如桃花般鲜艳。后来，小瞎子眼前幻化出枯树寒鸦，古寺疏钟，平沙落雁，残月似弓，那曲子也就悲怆起来，马桑镇的听众们突然想起苍茫的深秋原野与在秋风中瑟瑟发抖的槐树枯枝…… 425-427, 标注, 2025 年 5 月 11 日星期日 下午 10:44:06 窄窄的麻石街上阒无人迹。雨丝落到麻石板上，溅起小小的银色水珠。偶尔有几只羽毛蓬松的家燕掠着水汪飞过去。间或一阵风起，八隆河堤上开始凋谢的槐花瓣儿纷纷跌落在街道上。 462-465, 标注, 2025 年 5 月 12 日星期一 下午 10:20:55 小瞎子对花茉莉来说，好像是挂在八月枝头上一颗成熟的果子，她随时都可以把它摘下来一口吞掉。然而她不愿意这样做。她更愿意看着这颗果子挂在枝头闪烁诱人的光彩，她欣赏着这颗果子并且耐心地等待着，一直等到这颗熟透的果子散发着扑鼻的清香自动向地面降落时，她再伸手把它接住。那么，现在最重要的任务就是要保护这颗果子，以免落入他人之手。 476-478, 标注, 2025 年 5 月 12 日星期一 下午 10:24:11 时间飞驰前进，不觉已是农历八月尽头。秋风把成熟的气息从田野里吹来，马桑镇四周的旷野上，青翠的绿色已逐渐被苍褐的黄色代替。八隆河堤上的槐叶滴溜溜地打着旋飘落，飘落在河中便起起伏伏地顺水流去。 869-871, 标注, 2025 年 5 月 20 日星期二 下午 10:20:39 我们都不说话了，磨房里静下来。一缕阳光从西边的窗棂里射进来，东墙上印着明亮的窗格子。屋里斜着几道笔直的光柱，光柱里满是小纤尘，像闪亮的针尖一样飞快游动着。墙角上落满灰尘的破蛛网在轻轻地抖动着。一只壁虎一动不动地趴在墙壁上。 873-875, 标注, 2025 年 5 月 20 日星期二 下午 10:21:45 那道斜射的光柱周期性地照着她的脸，光柱照着她的脸时，她便眯起细长的眼睛，嘴角儿一抽一抽的，很好看。走出光柱，她的脸便晦暗了，我愿意看她辉煌的脸不愿意看她晦暗的脸，但辉煌和晦暗总是交替着出现，晦暗又总是长于辉煌，辉煌总是一刹那的事，一下子就过去了。 996-998, 标注, 2025 年 5 月 26 日星期一 上午 7:53:32 母亲在灶下烧火，干豆秸烧得噼噼啪啪响。火苗映着母亲清癯的脸，映着供桌上的祖先牌位，映着被炊烟熏得黝黑发亮的墙壁，一种酸楚的庄严神圣感攫住了我的心…… 1127-1128, 标注, 2025 年 5 月 26 日星期一 上午 8:19:21 隔老远就看到了一片粉红色的彩霞溶在时疏时密的、如烟如雾的雨丝里。绿柳、红桃、细雨，还有我们俩，和谐而融洽地交织在一起，分也分不开，割也割不断…… ","date":"2025-05-07","objectID":"/%E7%AC%94%E8%AE%B0%E8%8E%AB%E8%A8%80%E7%9F%AD%E7%AF%87%E5%B0%8F%E8%AF%B4%E7%B2%BE%E5%93%81%E7%B3%BB%E5%88%97/:0:0","tags":["moyanduanpia","note","ireader","unwashed"],"title":"莫言短篇小说精品系列","uri":"/%E7%AC%94%E8%AE%B0%E8%8E%AB%E8%A8%80%E7%9F%AD%E7%AF%87%E5%B0%8F%E8%AF%B4%E7%B2%BE%E5%93%81%E7%B3%BB%E5%88%97/"},{"categories":null,"content":" 19-22, 标注, 2025 年 4 月 11 日星期五 下午 1:21:01 作为成年人，我们不会再落入孩提时代的陷阱。但认为我们从此可以免于其他窥伺在侧的偏见，那就错了。我们的直觉会欺骗我们，而我们认为理所当然的事情有时候是错误的。我想，我在自己 35 岁这年可以这么说，从小学开始，我在生命中的每一年都会意识到，我对一些事情自以为是的理解是错误的。 35-35, 标注, 2025 年 4 月 11 日星期五 下午 1:23:40 理解的乐趣会让你为此付出的努力得到千百倍的回报。 450-452, 标注, 2025 年 4 月 15 日星期二 上午 7:45:55 “切中要点”总会带来一种挖掘出某些深刻而珍贵之物的兴奋感、一种揭开了神秘面纱的兴奋感。不变量揭示了将不同先验事物聚集在一起的东西。这是一种共同点，就像隐藏在后台的齿轮，一旦让它露出真容，你就会因为了解了事物的运转原理而获得这种既欢欣又从容的满足感。 482-483, 标注, 2025 年 4 月 15 日星期二 上午 7:48:25 这是一幢方形建筑，古老的石块上布满岁月的痕迹，几扇窄而深的窗户不规则地镶嵌在上面。锯齿形的屋顶犹如一顶王冠，让塔楼在不知曾多少次濒临坍塌的墙壁的掩映下，露出一副自豪而高贵的身姿。 499-501, 标注, 2025 年 4 月 15 日星期二 上午 7:49:35 有时候，你只需要改变视角就能找到解决办法。如果找到了正确的视角，最棘手的情况也会变得易如反掌。如果你不如鸽子灵巧，那就让鸽子变得不如你灵巧。解决重大问题并不总是得更聪明、更强大或更迅速。最重要的是找到窍门。 635-636, 标注, 2025 年 4 月 15 日星期二 上午 8:01:00 纽科姆的文章很有启发性，值得我们为它停留片刻。文章的结论很简单：世间的数是均匀分布的，而且是从乘法角度来看的均匀分布！ 651-652, 标注, 2025 年 4 月 15 日星期二 上午 8:06:16 是的，这个世界青睐乘法，但为什么？为什么现实似乎在所有的情况下都偏爱这种分布呢？ 659-661, 标注, 2025 年 4 月 15 日星期二 上午 8:06:53 公里和英里都是人类的发明，而大自然并不在乎我们使用哪种计量单位去测量它。从法国或英国的角度去看，每一条被分别丈量的河流，其长度不会有相同的首位数字，但如果我们制定出世界上河流长度的完整列表，则首位数字的总体分布应当会保持不变。 669-672, 标注, 2025 年 4 月 15 日星期二 上午 8:07:47 计量单位改变了，乘法的差距不变。因此，在任意数据列表中，我们都会发现介于 1 和 2、2 和 4 或 4 和 8 之间的数比例是相同的。所以，我们需要关注的是这种乘法的差距。 这就是为什么世界是乘法的。这就是为什么对数标度如此适切。 675-679, 标注, 2025 年 4 月 15 日星期二 上午 8:08:41 美国经济学家哈尔·瓦里安(Hal Varian)在 1972 年提出用本福特定律来检测舞弊。原理很简单：当舞弊者把一份数据列表篡改成利于自己的时候，他们会露出马脚。也就是说，他们伪造的数据会有不同的首位数字分布。尤其是，伪造的数据会更频繁地以 5 或 6 开头，这与本福特定律不符。这或许是因为舞弊者倾向于认为，相较于以 1 或 9 开头的数，一个中等大小的数看起来不会那么可疑，或是更正常。尽管如此，这种偏差仍会导致首位数字中的 5 和 6 远远多于应有的数量。这种偏差的幅度可以用来估算潜在舞弊者的数量。 682-684, 标注, 2025 年 4 月 15 日星期二 上午 8:11:43 知道各国的人口、世界上的河流或天空中的天体都遵循这一定律，也没有太大用处。“没用处”究竟是好是坏，由你来定夺。但是，我们因好奇而踏足的这条道路上充满了惊喜。当然了，出于纯粹的智力挑战，出于体验 682-686, 标注, 2025 年 4 月 15 日星期二 上午 8:11:58 知道各国的人口、世界上的河流或天空中的天体都遵循这一定律，也没有太大用处。“没用处”究竟是好是坏，由你来定夺。但是，我们因好奇而踏足的这条道路上充满了惊喜。当然了，出于纯粹的智力挑战，出于体验数学的形式之美，出于让我们的思维变得多姿多彩，不带任何期待地去理解一件事，未必不会让人获得极大的满足。然而，即便是最无用的事情，有时也会暗藏意料之外的宝藏。可不要低估了这些定理。 687-688, 标注, 2025 年 4 月 15 日星期二 上午 8:12:14 或许有一天，在你完全没有想到的那一刻，“有用之处”会不期而至。它们会像成熟而甜美的果实那样，自然而然地落入你的手中。 769-772, 标注, 2025 年 4 月 15 日星期二 下午 1:21:41 这个时候，最为微妙的时刻或许就来了。这一刻最让人感到不舒服，但也最令人陶醉。那就是超脱的时刻。那是当事物变得如此清晰以至于再次变得模糊的时刻。那是我们对事物理解得足够多以至于知道自己理解得其实没有那么多的时刻。就像一张漂亮的照片，因为看的时候凑得太近，变成了一个个像素块。 904-905, 标注, 2025 年 4 月 16 日星期三 上午 7:52:37 知道如何讨论理想对象而不必知道如何将它们与它们所源自的具体情况相联系，这就是数学的伟大力量。 926-930, 标注, 2025 年 4 月 16 日星期三 上午 7:54:24 这是数学颠覆我们三观的优点之一：可以用不存在的东西去恰当地思考。实际上，思考不存在的东西甚至可以说是数学的特性。不存在的东西也就是抽象的东西。 数字显然是最引人注目的例子之一。一旦脱离了被它们模型化的现实，数字就成了纯抽象的概念。它们是想法，是我们用作思维中间环节的想象之物。 947-950, 标注, 2025 年 4 月 16 日星期三 上午 7:55:51 这种解决问题的模式叫作“雨伞定理”。如果你在雨天想要在不被淋湿的情况下从一个地方前往另一个地方，请按照以下步骤操作（图 2.9）： 撑开你的雨伞； 开始你的行程； 收起你的雨伞。 步骤 1 和步骤 3 的操作是相反的，如果你能够在雨伞为你打开的特定世界中达成预期的目标，那么你在操作结束时就会恢复到开始时的状态。 957-958, 标注, 2025 年 4 月 16 日星期三 上午 7:56:32 雨伞，是观点的改变，是差异，是从另一个角度看待事物的艺术，一种更适合、更有效的角度。 958-961, 标注, 2025 年 4 月 16 日星期三 上午 7:56:53 走得更远，并不总是意味着长久而乏味的努力，而是首先要找到解决所面临的问题的正确方法。如果我们以正确的方式看待问题，那么最错综复杂的问题也会在一瞬间变得简单明了。伟大的智者能尽显其才，首先是因为他们拥有在正确的时间发明正确的雨伞的能力。 965-967, 标注, 2025 年 4 月 16 日星期三 上午 7:57:56 不要惧怕与众不同，这就是雨伞的智慧。让我们无所畏惧，既不感到羞耻，也不抱有偏见。一旦接受在头顶撑起抽象的雨伞并进入数学的世界，我们就不会再全然依赖现实。不必让自己陷在无用的限制或令人尴尬的既有观念之中。 971-979, 标注, 2025 年 4 月 16 日星期三 上午 7:59:59 选择太多，就难以做出选择了。 懂得如何在数学世界里自我驾驭，是一种需要实践和直觉的能力。 为此，数学家制造出很多导航工具，其中有两个指南针：一个名叫“实用”，一个名叫“优雅”。 “实用”引导我们创造出最贴近现实的抽象世界， 在这些抽象世界中进行的研究能够轻松地转化为关于我们宇宙的知识。 “优雅”告诉我们要完全抛开现实， 并沉醉在抽象世界的奇观中。那里有许许多多美丽的事情要做——如果一件事是无用的，那它就更美了。 每个人都能以自己的方式使用这两个指南针。有些人偏爱其中的某一个，有些人则两个一起用，并不断在两个指南针指示的方向之间寻找完美的平衡。但世界充满奥秘，因此，探索实用之人和探索优雅之人常常会在走过不同的道路之后，在同一个地方不期而遇。 1207-1210, 标注, 2025 年 4 月 16 日星期三 下午 9:56:59 并不是每一个人都会在初次接触牛顿思想的时候就接受它，而当年既有的理论在《原理》问世近一个世纪后仍然难以被撼动。我们应该对那些诋毁引力的学者保持宽容。事后对失败者进行评判，总是很容易，但针锋相对的论战绝对是知识进步的必要条件。 1362-1369, 标注, 2025 年 4 月 17 日星期四 上午 7:50:57 这就是问题的核心所在：细节越小，其数量就越多，而它们的累计长度值却绝不会小。 曼德博的结论毋庸置疑，我们越是精确地测量英国的海岸线，其长度就会越长。添加越来越小的细节只会令测量值无限度地增加（图 3.2）。如果我们不想做出任何让步，那么这个问题的唯一答案就是：英国的海岸线无限长。 图 3.2 这个现象在今天被称为理查森效应，或是更常说的海岸线悖论。当一根自然线条沿着大自然划定的路线，比如河流、山脊或悬崖蜿蜒而行的时候，这条线就会产生理查森效应。 1381-1382, 标注, 2025 年 4 月 17 日星期四 上午 7:52:28 曼德博认为是时候发明一个词语来指称这些既如此美丽又如此神秘的形状了。他把它们称为“分形”。 1377-1382, 标注, 2025 年 4 月 17 日星期四 上午 7:52:46 本华·曼德博的大部分时间专注于研究符合海岸线悖论的形状，也就是那些轮廓尺寸不一且极为零碎的几何形状。你想把这些形状放","date":"2025-05-07","objectID":"/%E7%AC%94%E8%AE%B0%E6%95%B0%E5%AD%A6%E7%9A%84%E9%9B%A8%E4%BC%9E%E4%B8%8B/:0:0","tags":["shuxuedeyusa","note","ireader"],"title":"数学的雨伞下","uri":"/%E7%AC%94%E8%AE%B0%E6%95%B0%E5%AD%A6%E7%9A%84%E9%9B%A8%E4%BC%9E%E4%B8%8B/"},{"categories":null,"content":" 314-315, 标注, 2025 年 4 月 5 日星期六 上午 11:24:13 在那一刻，我感觉自己就像一只有缺口的碗——那是我妹妹埃莉莎用来喂猫的碗，后来那只猫再也没有出现，那只空碗落满灰尘，被遗忘在楼梯间。我感觉到一种强烈的焦虑， ","date":"2025-05-07","objectID":"/%E7%AC%94%E8%AE%B0%E6%96%B0%E5%90%8D%E5%AD%97%E7%9A%84%E6%95%85%E4%BA%8B%E9%82%A3%E4%B8%8D%E5%8B%92%E6%96%AF%E5%9B%9B%E9%83%A8%E6%9B%B22/:0:0","tags":["xinmingzideg","note","ireader"],"title":"新名字的故事","uri":"/%E7%AC%94%E8%AE%B0%E6%96%B0%E5%90%8D%E5%AD%97%E7%9A%84%E6%95%85%E4%BA%8B%E9%82%A3%E4%B8%8D%E5%8B%92%E6%96%AF%E5%9B%9B%E9%83%A8%E6%9B%B22/"},{"categories":null,"content":" 182-184, 标注, 2025 年 4 月 5 日星期六 上午 11:38:11 1780 年，亚当斯太太的来信对此多有抱怨。收到夫人的信件以后，亚当斯回了一封信，信中这样说：“为了我们的孩子们能够自由地研究数学与哲学，我必须研究政治与战争。”亚当斯用这句后来很出名的话强调了政治的重要性。 187-190, 标注, 2025 年 4 月 5 日星期六 上午 11:38:58 在中纪委十八届二次全会上，习近平说：“要从严治党，惩治这手绝不能放松，要坚持老虎、苍蝇一起打。要加强对权力的制约和监督，把权力关进制度的笼子里。”这是 1949 年以后党的最高领导人首次明确表示要“把权力关进制度的笼子里”。 190-191, 标注, 2025 年 4 月 5 日星期六 上午 11:39:14 呢？“把权力关进制度的笼子里”意指政治权力必须要受到制约，这种制约应该是有效的制度约束。 201-203, 标注, 2025 年 4 月 5 日星期六 上午 11:42:34 这个新闻似乎还揭示出，美国是世界上最富有的国家，但他们却有一个最缺钱的政府；奥巴马总统是世界上最具权势的政治家，但他在国内却处处受到掣肘。 272-274, 标注, 2025 年 4 月 5 日星期六 上午 11:49:12 医善吮人之伤，含人之血，非骨肉之亲也，利所加也。故舆人成舆，则欲人之富贵；匠人成棺，则欲人之夭死。人不贵，则舆不售；人不死，则棺不买，情非憎人也，利在人之死也。 ——韩非 274-277, 标注, 2025 年 4 月 5 日星期六 上午 11:49:54 自由主义的系统理论几乎只关心国内反对国家权力的斗争。为了实现保护个人自由和私有财产的目的，自由主义提出了一套阻碍并限制国家和政府权力的方法。……由此，我们看到了一个完整的非军事化、非政治化的概念体系。——卡尔·施米特 298-299, 标注, 2025 年 4 月 5 日星期六 上午 11:58:52 流寇统治的最大问题是破坏了一个社会的正常激励机制。简单地说，农民之所以春天播种，是因为预期秋天能够收获。 298-300, 标注, 2025 年 4 月 5 日星期六 上午 11:59:02 流寇统治的最大问题是破坏了一个社会的正常激励机制。简单地说，农民之所以春天播种，是因为预期秋天能够收获。流寇统治带来了什么问题呢？种地的是一个人，收获的是另一个人。因此，流寇统治会导致整个社会生产的迅速下滑。 316-317, 标注, 2025 年 4 月 5 日星期六 下午 12:01:20 大家都听过法国国王路易十五的名言——“在我之后，哪管洪水滔天”。结果，在路易十六的时代，法国大革命就爆发了。 319-321, 标注, 2025 年 4 月 5 日星期六 下午 12:01:58 只有把统治者的权力放到宪政民主的框架中，统治者才不会胡作非为，长期持续的繁荣才有保证。换句话说，坐寇或统治者的权力必须受到制约，统治者不是想干什么就可以干什么。这是宪政的基本原则，宪政的简单理解就是“限政”，即限制政治权力。 356-357, 标注, 2025 年 4 月 5 日星期六 下午 12:05:35 诺思认为：“国家既是经济增长的关键，也是人为的经济衰退的根源。”这句话后来被称为国家问题的“诺思悖论”。 396-397, 标注, 2025 年 4 月 5 日星期六 下午 12:10:47 儒家更多地从伦理角度来理解政治，强调政治的伦理观或政治的道德观。政治本身就包含了端正、正直和正确的意思，这是孔子的重要立场。《 409-410, 标注, 2025 年 4 月 5 日星期六 下午 12:11:52 儒家学说中还有“修身、齐家、治国、平天下”的说法，“修身”被放在首位。孔子追求的人生境界则是“内圣外王”。 561-562, 标注, 2025 年 4 月 5 日星期六 下午 1:51:35 说到底，经济发展的过程同样是权力的斗争，因此经济政策必须为之服务的最终决定性利益乃是民族权力的利益。…… 563-567, 标注, 2025 年 4 月 5 日星期六 下午 1:51:59 在德国经济政策的一切问题上，包括国家是否多大程度上应当干预经济生活，要否以及何时开放国家的经济自由化并在经济发展过程中拆除关税保护，最终的决定性因素端视它们是否有利于我们全民族的经济和政治的权力利益，以及是否有利于我们民族的担纲者——德国民族国家。 589-591, 标注, 2025 年 4 月 5 日星期六 下午 1:54:18 作者也希望借此提醒读者，观察世界有不同的方法和路径。每个人应该自己去判断和选择，从多样化的视角去理解政治、理解自己的国家以及不同肤色的人生活于其中的世界。 1436-1438, 标注, 2025 年 4 月 5 日星期六 下午 1:56:56 作者把市场机制的力量比喻成“一只看不见的手”——自利的个人会受到这只“看不见的手”的引导“有效地促进社会的利益”。这是英国著名经济学家亚当·斯密在《国富论》中最为著名的两段话。 1436-1438, 标注, 2025 年 4 月 5 日星期六 下午 1:57:00 作者把市场机制的力量比喻成“一只看不见的手”——自利的个人会受到这只“看不见的手”的引导“有效地促进社会的利益”。这是英国著名经济学家亚当·斯密在《国富论》中最为著名的两段话。他信奉的意识形态被称为自由主义 1447-1451, 标注, 2025 年 4 月 5 日星期六 下午 1:58:02 马克思在劳资关系中发明了剩余价值的概念，提出了剥削学说。在 19 世纪的欧洲，这是富有“革命性”的见解。当然，按照这种观点，很多毕业生争相到世界 500 强公司工作，不过是在努力争取一种被“剥削”的资格。而亚当·斯密完全不这样看。斯密认为，用劳动力去换取报酬不过是一种正常的市场交易行为；而资方并非不劳而获或平白无故就能挣钱，利润被视为经营的回报。两种不同的观点，大家可以自己去比较和判断。 ","date":"2025-05-07","objectID":"/%E7%AC%94%E8%AE%B0%E6%94%BF%E6%B2%BB%E5%AD%A6%E9%80%9A%E8%AF%86/:0:0","tags":["zhengzhixuet","note","ireader"],"title":"政治学通识-包刚升","uri":"/%E7%AC%94%E8%AE%B0%E6%94%BF%E6%B2%BB%E5%AD%A6%E9%80%9A%E8%AF%86/"},{"categories":null,"content":" Table of Contents 1 PostgreSQL LDAP 认证的好处 2 在 PostgreSQL 中配置 LDAP 身份验证 2.1 修改 pg_hba.conf 文件 2.2 配置 PostgreSQL 服务器参数 2.3 创建角色和授予权限 3 安全评分：PostgreSQL LDAP 身份验证安全吗？ 4 设置 PostgreSQL LDAP 身份验证的逐步指南 5 结论 6 常见问题解答 本文为摘录(或转载)，侵删，原文为： https://goteleport.com/learn/postgresql-ldap-authentication/ PostgreSQL LDAP 认证允许您直接从现有的 LDAP 服务器（如 Active Directory 或 OpenLDAP）管理用户访问。这消除了单独的数据库用户账户的需要，并简化了用户管理。 ","date":"2025-04-08","objectID":"/goteleport_com_postgresql-ldap-authentication/:0:0","tags":["pg","ldap","authentication"],"title":"PostgreSQL LDAP Authentication: A Step-by-Step Guide","uri":"/goteleport_com_postgresql-ldap-authentication/"},{"categories":null,"content":"1 PostgreSQL LDAP 认证的好处 为 PostgreSQL 实施 LDAP 认证为您的组织带来了众多好处： 集中用户管理： 从单一的 LDAP 目录管理所有数据库用户，而不是在 PostgreSQL 中创建和维护单独的凭证。这简化了新用户入职的过程，以及在必要时撤销访问权限。 增强安全性： 利用您 LDAP 服务器现有的安全策略和控制，例如密码复杂性要求和多因素认证。 减少行政开销： 自动化用户配置和撤销配置任务，使您的 IT 团队能专注于其他关键任务。 改善用户体验： 用户可以使用熟悉的 LDAP 凭证访问 PostgreSQL 数据库，无需记住多个用户名和密码。 ","date":"2025-04-08","objectID":"/goteleport_com_postgresql-ldap-authentication/:1:0","tags":["pg","ldap","authentication"],"title":"PostgreSQL LDAP Authentication: A Step-by-Step Guide","uri":"/goteleport_com_postgresql-ldap-authentication/"},{"categories":null,"content":"2 在 PostgreSQL 中配置 LDAP 身份验证 让我们探讨如何为您的 PostgreSQL 数据库启用和配置 LDAP 身份验证。 ","date":"2025-04-08","objectID":"/goteleport_com_postgresql-ldap-authentication/:2:0","tags":["pg","ldap","authentication"],"title":"PostgreSQL LDAP Authentication: A Step-by-Step Guide","uri":"/goteleport_com_postgresql-ldap-authentication/"},{"categories":null,"content":"2.1 修改 pg_hba.conf 文件 pg_hba.conf 文件充当门卫，控制对您的 PostgreSQL 服务器的访问。您需要修改此配置文件以启用 LDAP 身份验证方法。 – 打开位于您的 PostgreSQL 数据目录中的 pg_hba.conf 文件。– 添加新行，指定身份验证方法为 ldap，并包括必要的参数，例如您的 LDAP 服务器地址、端口和搜索基础。 例如： host all all 192.168.1.0/24 ldap ldapserver=ldap.example.com ldapport=389 ldapbinddn=\"cn=admin,dc=example,dc=com\" ldapbindpasswd=\"password\" ","date":"2025-04-08","objectID":"/goteleport_com_postgresql-ldap-authentication/:2:1","tags":["pg","ldap","authentication"],"title":"PostgreSQL LDAP Authentication: A Step-by-Step Guide","uri":"/goteleport_com_postgresql-ldap-authentication/"},{"categories":null,"content":"2.2 配置 PostgreSQL 服务器参数 接下来，您需要在 PostgreSQL 服务器内部配置特定的参数。这包括： – ldapserver: 指定您的 LDAP 服务器地址（例如， ldapserver = 'ldap.example.com' ）。– ldapport: 定义 LDAP 服务器端口（默认为 389 ）。– ldapbinddn: （可选）指定用于绑定和搜索目录的 LDAP 用户。– ldapbindpasswd: （可选）ldapbinddn 用户的密码。– ldapbasedn: 设置 LDAP 搜索的基础 DN（例如， ldapbasedn = 'dc=example,dc=com' ）。– ldapsearchattribute: 确定用于匹配 PostgreSQL 用户名的属性（例如， ldapsearchattribute = 'uid' ）。 ","date":"2025-04-08","objectID":"/goteleport_com_postgresql-ldap-authentication/:2:2","tags":["pg","ldap","authentication"],"title":"PostgreSQL LDAP Authentication: A Step-by-Step Guide","uri":"/goteleport_com_postgresql-ldap-authentication/"},{"categories":null,"content":"2.3 创建角色和授予权限 – 以超级用户身份连接到您的 PostgreSQL 数据库。– 创建与您 LDAP 目录中的组或用户相对应的角色。例如： CREATE ROLE developers WITH LOGIN; 。– 使用标准 SQL GRANT 语句向这些角色授予适当的权限。这使您能够控制每个 LDAP 用户或组可以访问哪些数据库对象。 通过遵循这些步骤，您成功地将 PostgreSQL LDAP 身份验证集成到您的环境中。这增强了您 PostgreSQL 数据库的安全性，并简化了您组织内的用户管理。 ","date":"2025-04-08","objectID":"/goteleport_com_postgresql-ldap-authentication/:2:3","tags":["pg","ldap","authentication"],"title":"PostgreSQL LDAP Authentication: A Step-by-Step Guide","uri":"/goteleport_com_postgresql-ldap-authentication/"},{"categories":null,"content":"3 安全评分：PostgreSQL LDAP 身份验证安全吗？ 评分：4分（满分 5 分） 从安全团队的角度来看，PostgreSQL LDAP 身份验证提供了一层强大的安全保障，尤其是与在本地管理数据库用户相比。利用 LDAP 服务器的集中认证机制、密码策略和潜在的多因素认证功能，显著增强了数据库的安全状态。 然而，像任何系统一样，它也有潜在的漏洞： – LDAP 服务器被攻击：如果你的 LDAP 服务器被攻陷，攻击者可能获得对你的 PostgreSQL 数据库的访问权限。– 明文通信：标准 LDAP 通信是在明文中进行的，可能在传输过程中暴露凭证。考虑实施 LDAPS（SSL/TLS 上的 LDAP）或 StartTLS 以进行加密通信。 ","date":"2025-04-08","objectID":"/goteleport_com_postgresql-ldap-authentication/:3:0","tags":["pg","ldap","authentication"],"title":"PostgreSQL LDAP Authentication: A Step-by-Step Guide","uri":"/goteleport_com_postgresql-ldap-authentication/"},{"categories":null,"content":"4 设置 PostgreSQL LDAP 身份验证的逐步指南 这里提供一个简化的指南，假设您有一个正常工作的 PostgreSQL 和 LDAP 环境： 安装必要的软件包：确保你的 PostgreSQL 服务器安装了 LDAP 客户端库。软件包名称可能因操作系统而异（例如，Debian/Ubuntu 上的 postgresql-contrib）。 修改 pg_hba.conf ：编辑你的 pg_hba.conf 文件（通常位于/var/lib/postgresql/data/）以包含 LDAP 身份验证的条目。以下是一个基本示例： host all all 192.168.1.0/24 ldap ldapserver=ldap.example.com ldapport=389 ldapbinddn=\"cn=postgres_bind,ou=users,dc=example,dc=com\" ldapbindpasswd=\"your_ldap_password\" ldapbasedn=\"ou=users,dc=example,dc=com\" 配置 PostgreSQL 服务器参数：在 postgresql.conf 文件中添加或修改本文第 2 节中提到的参数（ldapserver、ldapport 等）。 重启 PostgreSQL：重启你的 PostgreSQL 服务以应用更改。 测试你的配置：尝试使用 LDAP 目录中存在的用户帐户登录，以确认 LDAP 身份验证是否正常工作。 ","date":"2025-04-08","objectID":"/goteleport_com_postgresql-ldap-authentication/:4:0","tags":["pg","ldap","authentication"],"title":"PostgreSQL LDAP Authentication: A Step-by-Step Guide","uri":"/goteleport_com_postgresql-ldap-authentication/"},{"categories":null,"content":"5 结论 PostgreSQL LDAP 身份验证为寻求加强数据库安全和简化用户管理的组织提供了显著的优势。通过利用现有的 LDAP 基础设施，您简化了认证过程，减少了管理负担，并增强了 PostgreSQL 数据库的整体安全状态。 ","date":"2025-04-08","objectID":"/goteleport_com_postgresql-ldap-authentication/:5:0","tags":["pg","ldap","authentication"],"title":"PostgreSQL LDAP Authentication: A Step-by-Step Guide","uri":"/goteleport_com_postgresql-ldap-authentication/"},{"categories":null,"content":"6 常见问题解答 我可以将 LDAP 身份验证与 Active Directory 结合使用吗？ 绝对可以！Active Directory 是 LDAP 协议的广泛使用实现。配置方式与其他 LDAP 服务器类似，只需确保使用正确的域详细信息和连接设置。 我是否可以强制从 LDAP 服务器对 PostgreSQL 用户实施密码复杂度规则？ 是的，当您实施 LDAP 身份验证时，PostgreSQL 会继承中央 LDAP 服务器强制的密码策略、复杂度要求和账户锁定设置。 如何排查 PostgreSQL 与 LDAP 服务器之间的 LDAP 连接问题？ 验证网络连接：确保你的 PostgreSQL 服务器能够通过网络访问你的 LDAP 服务器。使用=ping=或=telnet=等工具测试指定端口的连接性。 检查 PostgreSQL 日志：检查 PostgreSQL 服务器日志中的任何与 LDAP 身份验证相关的错误消息。这些日志通常提供有关连接问题或配置错误的有价值的见解。 使用调试工具：可以考虑使用 LDAP 调试工具来分析 PostgreSQL 服务器与 LDAP 服务器之间的通信流程，帮助定位任何问题的根本原因。 ","date":"2025-04-08","objectID":"/goteleport_com_postgresql-ldap-authentication/:6:0","tags":["pg","ldap","authentication"],"title":"PostgreSQL LDAP Authentication: A Step-by-Step Guide","uri":"/goteleport_com_postgresql-ldap-authentication/"},{"categories":null,"content":" 84-88, 标注, 2025 年 4 月 2 日星期三 上午 7:50:37 玉宝不语，开始一趟趟往楼上搬行李，第一趟上去下来，薛金花将面糊搓成粒，用筷子拨进钢钟锅内，再搅散，第二趟上去下来，薛金花将红番茄，切成小块摆进去、拿铁勺滑动滚汤。第三趟上去下来，薛金花洒一撮盐、打散蛋花，滴几滴小磨香油，红红黄黄白白一小锅，香味散开，蒸汽爬满油烟窗。第四趟上去下来，玉宝前脖后颈皆是黏汗，薛金花在和邻居搬弄事非，习惯性压低声音，嘀嘀咕咕，糊满油烟的电灯泡，令面孔蜡蜡黄，媚眼眯细， 111-112, 标注, 2025 年 4 月 2 日星期三 上午 7:53:50 玉宝浑身白里透红，像煮熟的一尾虾子，氤氲着腾腾热汽从里间出来到外室， 797-798, 标注, 2025 年 4 月 2 日星期三 下午 6:51:35 人生海海，起起伏伏，要学会随遇而安，方得始终。 788-789, 标注, 2025 年 4 月 2 日星期三 下午 6:51:53 上海很精彩，上海也无奈 ，纵然无奈再多，我们也要活的精彩。 805-805, 标注, 2025 年 4 月 2 日星期三 下午 6:52:41 总之一句话，无论到何时何地，都勿要放弃希望。 1345-1346, 标注, 2025 年 4 月 2 日星期三 下午 10:12:27 恰好湖边的长椅空出来，俩人坐下，但见清风抚柳，柳尖蘸水，水起涟漪，景色怡人。 1463-1464, 标注, 2025 年 4 月 2 日星期三 下午 10:37:14 英国古话，婚姻仿佛金漆鸟笼。外面的鸟想进去，笼内的鸟想出来，结而离，离而结，没个局。 1617-1618, 标注, 2025 年 4 月 2 日星期三 下午 10:51:22 发现，虽然哈哈镜，能将人变短变长，变胖变瘦，任凭再如何变幻，大人脸上愁绪不会走形，唯有小朋友的快乐，出自真心。 2057-2059, 标注, 2025 年 4 月 3 日星期四 上午 7:49:11 广播电台里，单田芳在讲评书，人生在世天天天，日月如梭年年年，富贵之家有有有，贫困之人寒寒寒，升官发财得得得，俩腿一蹬完完完。沧桑沙音甚是缥缈。 2076-2077, 标注, 2025 年 4 月 3 日星期四 上午 7:50:19 无线电在放评书，单田芳嗓音沙哑， 酒是穿肠毒药，色是刮骨钢刀。财是惹祸根苗，气是雷烟火炮。 3605-3605, 标注, 2025 年 4 月 3 日星期四 下午 7:01:39 秋生说，谈啥。泉英笑说，谈秋生的工资。 3659-3662, 标注, 2025 年 4 月 3 日星期四 下午 7:06:43 潘逸年从手包里，拿出个文具盒，笑说，送给小桃。小桃接过，不是平常铁制文具盒，摸上去，滑滑软软，文化商店见过，营业员介绍说，表面一层塑料，内里一层海绵。深蓝天空色，小河、荷花、青蛙，岸边卧着小花猫，眼珠子可以动。打开双层，铅笔、原子笔、橡皮、尺子、卷笔刀一应齐全。 ","date":"2025-04-05","objectID":"/%E7%AC%94%E8%AE%B0%E6%B2%AA%E4%B8%8A%E7%83%9F%E7%81%AB-%E5%A4%A7%E5%A7%91%E5%A8%98%E6%B5%AA/:0:0","tags":["笔记","hushangyanhu","note","ireader"],"title":"沪上烟火-大姑娘浪","uri":"/%E7%AC%94%E8%AE%B0%E6%B2%AA%E4%B8%8A%E7%83%9F%E7%81%AB-%E5%A4%A7%E5%A7%91%E5%A8%98%E6%B5%AA/"},{"categories":null,"content":"上一篇 blog 中，介绍了怎样使用 pandoc 将 org 文件转换成为 docx 文件，以及用到的 filter 和 word 模板。这解决了我再实际使用过程中遇到的大部分问题，比如基本的格式、表格边框、表格图片标号之类的。但当时还有一个问题没有解决，就是列表 （list） 的显示不理想。 例如下面的 org 文件 ： #+TITLE: test #+AUTHOR: Yang,Ying-chao #+DATE: 2025-03-29 #+OPTIONS: ^:nil H:5 num:t toc:2 \\n:nil ::t |:t -:t f:t *:t tex:t d:(HIDE) tags:not-in-toc #+STARTUP: oddeven lognotestate #+SEQ_TODO: TODO(t) INPROGRESS(i) WAITING(w@) | DONE(d) CANCELED(c@) #+TAGS: noexport(n) #+EXCLUDE_TAGS: noexport #+FILETAGS: :tag1:tag2: Normal text - unordered item 1 + unordered item 2 * unordered item 3 + unordered item 4 Normal text 1. ordered item 1 1. ordered item 2 2. ordered item 3 生成的 word 文档截图如下： Figure 1: 默认生成的列表 也不能说错，但是看着有点别扭： 前面的 bullets 和 word 默认的不一致 每行的缩进太大，也和默认不一样 花时间研究了一下，发现 word 中列表不是在 style.xml 中定义的，而是在 numbering.xml 里面，而且貌似 pandocx 在生成 docx 的时候，会自动生成 numbering.xml ，而不使用 custom-rerference.docx 文件。 那就只好生成之后再做处理了： 先把生成的文件解压 使用自定义的 numbering.xml 做模板 再补上自动生成的部分 最后重新 zip 成 docx elisp 代码如下: (file (yc/generate-script :infix \"update-docx\" :popup 'auto (insert \"cd \" dir \"\\n 7z x '\" output \"' cd word mv numbering.xml numbering_bak.xml HEAD=head which ghead \u0026\u0026 HEAD=ghead ${HEAD} -n -3 ~/.local/share/pandoc/custom-reference/word/numbering.xml \u003e numbering.xml tail -n 2 numbering_bak.xml \u003e\u003e numbering.xml cd .. zip -r '\" output\"' * rm -rf \" dir))) 完整代码可在 这里 找到。 修改以后的效果： Figure 2: 修改以后的效果 ","date":"2025-03-29","objectID":"/pandoc-%E7%94%9F%E6%88%90-docx-%E4%B8%AD%E7%9A%84-list-%E5%A4%84%E7%90%86/:0:0","tags":null,"title":"pandoc 生成 docx 中的 list 处理","uri":"/pandoc-%E7%94%9F%E6%88%90-docx-%E4%B8%AD%E7%9A%84-list-%E5%A4%84%E7%90%86/"},{"categories":null,"content":" Table of Contents 1 《人间词话》 2 1984 3 翦商 4 后记 转眼又是月底。 三月份看完了《人间词话》、《1984》、《翦商:殷周之变与华夏新生》，新开了《诡秘之主》和《不能承受的生命之轻》。 ","date":"2025-03-29","objectID":"/weixin%E4%B8%89%E6%9C%88%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93/:0:0","tags":["weixin"],"title":"三月阅读总结","uri":"/weixin%E4%B8%89%E6%9C%88%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"1 《人间词话》 第一次听说这本书，还是 25 年前。 记忆里那是上高中的第一节语文课，白发苍苍的语文老师，开堂先讲了学问的三层境界： 昨夜西风凋碧树，独上高楼，望尽天涯路。（晏殊《蝶恋花》） 衣带渐宽终不悔，为伊消得人憔悴。（柳永《凤栖梧》） 众里寻她千百度、蓦然回首，那人却在灯火阑珊处。（辛弃疾《青玉案》） 然后说这是王国维在《人间词话》中总结的。自此牢牢记住了《人间词话》，但是却因为种种原因一直没有机会去看这本书。 直到多年以后，在一个极为艰辛的时期，等着办事的时候看见书架上有这本书，拿起读了一会，然后买了一本这才看了起来直到最近、才连读带抄写的读完了。 这本书没有做电子版的摘抄，都是当做练字写在了纸上。 ","date":"2025-03-29","objectID":"/weixin%E4%B8%89%E6%9C%88%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93/:1:0","tags":["weixin"],"title":"三月阅读总结","uri":"/weixin%E4%B8%89%E6%9C%88%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"2 1984 《1984》是乔治·奥威尔（George Orwell）所著的一本小说，出版于 1949 年。这本小说描写了一个类似于极权主义社会的未来世界，人民被强制接受一种叫做“新话”的语言，并被日常生活中的各种监视手段所控制，一个名叫温斯顿·史密斯的官员试图反抗政府，但最终被政府抓捕并被迫接受思想改造。 小说的故事背景设定在 2044 年的伦敦，那时的政权是一个叫做“英国社会党”的政府，由“大哥”（大哥是政府的领袖，他被塑造成一个超越人类的存在。政府通过宣传大哥和党的教义来控制人民的思想）领导。 摘抄在这里 ，不评论。 ","date":"2025-03-29","objectID":"/weixin%E4%B8%89%E6%9C%88%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93/:2:0","tags":["weixin"],"title":"三月阅读总结","uri":"/weixin%E4%B8%89%E6%9C%88%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"3 翦商 这本书比较有意思，对商朝的人祭现象和文王、武王的翦商过程做了做了详细的描述。其中有很多让人耳目一新的看法，比如上古传说中为什么先贤都是母亲做个梦或者踩个巨人的脚印就生了孩子，周文王的八卦意味着什么，武王伐纣过程中有什么隐秘，周公旦为中华文明的奠基做了那些贡献等等。 如果基于作者的某些推断，把翦商拍成电视剧，一定能颠覆大家对商周交替的印象（恐怕绝大多数人的印象，只会是“让生命化作那朵莲花”。。。） 摘抄在 这里 。 ","date":"2025-03-29","objectID":"/weixin%E4%B8%89%E6%9C%88%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93/:3:0","tags":["weixin"],"title":"三月阅读总结","uri":"/weixin%E4%B8%89%E6%9C%88%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"4 后记 正在看的《不能承受的生命之轻》这本书，说起来也是上高中时候就听说过的书，也是一直没有机会看，我记得那个时候好像名字不一样，叫作《生命中不能承受之轻》，对应的貌似还有一本《生命中不能承受之重》，不知道是谁写的了。 ","date":"2025-03-29","objectID":"/weixin%E4%B8%89%E6%9C%88%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93/:4:0","tags":["weixin"],"title":"三月阅读总结","uri":"/weixin%E4%B8%89%E6%9C%88%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93/"},{"categories":null,"content":" 30-31, 标注, 2025 年 3 月 26 日星期三 下午 1:09:56 那些转瞬即逝的事物，我们能去谴责吗？橘黄色的落日余晖给一切都带上一丝怀旧的温情，哪怕是断头台。 37-38, 标注, 2025 年 3 月 26 日星期三 下午 1:11:32 在永恒轮回的世界里，一举一动都承受着不能承受的责任重负。这就是尼采说永恒轮回的想法是最沉重的负担（das schwerste Gewicht）的缘故吧。 39-40, 标注, 2025 年 3 月 26 日星期三 下午 1:11:40 如果永恒轮回是最沉重的负担，那么我们的生活，在这一背景下，却可在其整个的灿烂轻盈之中得以展现。 40-45, 标注, 2025 年 3 月 26 日星期三 下午 1:12:28 最沉重的负担压迫着我们，让我们屈服于它，把我们压到地上。但在历代的爱情诗中，女人总渴望承受一个男性身体的重量。于是，最沉重的负担同时也成了最强盛的生命力的影像。负担越重，我们的生命越贴近大地，它就越真切实在。 相反，当负担完全缺失，人就会变得比空气还轻，就会飘起来，就会远离大地和地上的生命，人也就只是一个半真的存在，其运动也会变得自由而没有意义。 那么，到底选择什么？是重还是轻？ 320-321, 标注, 2025 年 3 月 26 日星期三 下午 6:42:20 他自言自语，带着一种幸福感，说他这种生活方式是走到哪儿带到哪儿，就像蜗牛驮着整个家。 345-347, 标注, 2025 年 3 月 26 日星期三 下午 6:45:47 他跟特蕾莎捆在一起生活了七年，七年里，他每走一步，她都在盯着。仿佛她在他的脚踝上套了铁球。现在，他的脚步突然间变得轻盈了许多。他几乎都要飞起来了。此时此刻，他置身于巴门尼德的神奇空间：他在品尝着温馨的生命之轻。 351-353, 标注, 2025 年 3 月 26 日星期三 下午 6:46:36 特蕾莎突然闯入他的脑海：他感受到她在写告别信时的那种感觉；他感到她的手在颤抖；他看见了她，一只手拖着沉重的行李箱，另一只手用皮带牵着卡列宁；他想象着她把钥匙插进了布拉格的那套公寓的锁眼里转动，当门打开的那一刹那，扑面而来的是废弃的凄凉气息，而此时，这气息直钻他的心扉。 378-379, 标注, 2025 年 3 月 26 日星期三 下午 6:49:29 对于我们所有人来说，人的伟大在于他扛起命运，就像用肩膀顶住天穹的巨神阿特拉斯一样。贝多芬的英雄，是托起形而上之重担的健将。 397-399, 标注, 2025 年 3 月 26 日星期三 下午 6:51:22 我们都觉得，我们生命中的爱情若没有分量、无足轻重，那简直不可思议；我们总是想象我们的爱情是它应该存在的那种，没有了爱情，我们的生命将不再是我们应有的生命。我们都坚信，满腹忧郁、留着吓人的长发的贝多芬本人，是在为我们伟大的爱情演奏《Es muss sein！》。 (Es muss sein , 非要如此) 409-410, 标注, 2025 年 3 月 26 日星期三 下午 6:52:23 托马斯感到自己的胃开始痛起来，每逢绝望的时刻，他都会胃痛。 426-428, 标注, 2025 年 3 月 26 日星期三 下午 6:53:03 作者要想让读者相信他笔下的人物确实存在，无疑是愚蠢的。这些人物并非脱胎于母体，而是源于一些让人浮想联翩的句子或者某个关键情景。 436-438, 标注, 2025 年 3 月 27 日星期四 下午 12:53:02 传出有节奏的咚咚声，想知道到底是什么。人当然不会把自己完全等同于像肉体那样奇异、陌生的东西。肉体是囚笼，里面有个东西在看、在听，在害怕，在思索，在惊奇；这东西在肉体消失之后还在，还残存，它就是灵魂。 520-522, 标注, 2025 年 3 月 27 日星期四 下午 1:12:12 这些书为她提供了一个机会，在虚幻中逃避，摆脱那种毫无快乐可言的生活。作为一种物品，这些书对于她还有一种意义：她喜欢抱着书在大街上行走。它们对她来说，就像上个世纪花花公子的漂亮手杖，使她显得与众不同。 572-576, 标注, 2025 年 3 月 27 日星期四 下午 1:16:09 人生如同谱写乐章。人在美感的引导下，把偶然的事件（贝多芬的一首乐曲、车站的一次死亡）变成一个主题，然后记录在生命的乐章中。犹如作曲家谱写奏鸣曲的主旋律，人生的主题也在反复出现、重演、修正、延展。安娜可以用任何一种别的方式结束生命，但是车站、死亡这个难忘的主题和爱情的萌生结合在一起，在她绝望的一刹那，以凄凉之美诱惑着她。人就是根据美的法则在谱写生命乐章，直至深深的绝望时刻的到来，然而自己却一无所知。 669-669, 标注, 2025 年 3 月 27 日星期四 下午 6:43:20 这份无助的感觉，让她感到发晕，产生了一种强烈的往下坠落的愿望。 700-702, 标注, 2025 年 3 月 27 日星期四 下午 6:47:48 那些画表面总是一个完美无瑕的现实主义世界，而背后呢，就像是舞台背景的那块破布后面，人们看到的是不同的东西，某种神秘的或者抽象的东西。” 她停顿了一下，然后接着说：“表面是清晰明了的谎言，背后却是晦涩难懂的真相。” 703-706, 标注, 2025 年 3 月 27 日星期四 下午 6:48:16 她注意到萨比娜所有的画，无论以前的还是现在的，实际上都在传达着某种同样的东西，是两个主题、两个世界的即时融合，就像一些经过两次曝光制作出来的照片。表面是一幅风景画，可深处却是一盏点亮的床头灯，隐隐约约。一幅画着苹果、胡桃和灯火闪烁的圣诞树，牧歌般的静物画，背后却是一只痛苦挣扎的手。 740-742, 标注, 2025 年 3 月 27 日星期四 下午 6:51:50 沙俄帝国过去所犯下的罪行都隐藏在秘密的阴影中。五十万立陶宛人被放逐，成千上万的波兰人被杀戮，对克里米亚的鞑靼人进行灭绝种族的屠杀，所有这一切只留在记忆里，却没有留下任何图片作为证据，就像一件无法论证的事情，迟早会被说成是骗人的谎言。 851-853, 标注, 2025 年 3 月 27 日星期四 下午 6:58:39 眩晕是沉醉于自身的软弱之中。意识到自己的软弱，却并不去抗争，反而自暴自弃。人一旦迷醉于自身的软弱，便会一味软弱下去，会在众人的目光下倒在街头，倒在地上，倒在比地面更低的地方。 972-974, 标注, 2025 年 3 月 27 日星期四 下午 9:50:53 也许现在更容易理解萨比娜与弗兰茨之间相隔的鸿沟了：他热切地聆听她讲述自己的人生，她也怀着同样的热望听他倾诉。他们完全明白彼此所说的话语在逻辑上的意思，却听不到话语间流淌着的那条语义之河的低声密语。 1004-1005, 标注, 2025 年 3 月 27 日星期四 下午 9:59:04 他坚持这样一个信念：忠诚是第一美德，它使我们的生命完整统一。若没有忠诚，人生就会分散成千万个转瞬即逝的印迹。 1037-1038, 标注, 2025 年 3 月 28 日星期五 上午 7:37:28 从早上五点到晚上九点，高音喇叭里不断喀啦喀啦地放出尖厉的音乐。她想哭，但那音乐是欢闹的，无处可逃，躲在厕所里不行，蒙在床上的被子里也不行，到处都是高音喇叭。音乐仿佛是一群放出来扑向她的猎犬。 1043-1047, 标注, 2025 年 3 月 28 日星期五 上午 7:38:31 噪声有一个好处，让人听不清词语。”从青年时代开始，他所做的一切，就是说话，写字，讲课，编句子，找说法，不断修正，改到最后，每个词都弄得不再准确，意义模糊，内涵尽失，只余下碎片、杂屑和尘埃，像沙砾一样在他的脑子里翻飞，令他偏头痛，睡不着觉，最终得了失眠的痼疾。他朦朦胧胧而又不可遏制地渴望着一种巨大的乐声，一种绝对的噪音，一片美妙欢腾的喧嚣，将所有的一切吞噬，淹没，窒息，令话语带来的苦痛、虚幻和空洞永远消失。音乐是对词句的否定，音乐是反话语。 1051-1052, 标注, 2025 年 3 月 28 日星期五 上午 7:39:24 极端标志着生命的终极之界，极端主义的激情，不论是政治上的，还是艺术上的，都是一种改头换面的对死的渴望。 1055-1056, 标注, 2025 年 3 月 28 日星期五 上午 8:01:32 但在进入萨比娜身体的那一瞬，他还是闭上了双眼。吞噬着他的极度快感企求的是黑暗。那黑暗是彻底的，绝对的，没有形象也没有幻影，无穷无尽，无边无际。那黑暗是我们每个人内心所在的无限。 1075-1077, 标注, 2025 年 3 月 28 日星期五 上午 8:03:39 身为画家，她精于观察人的脸部。自从到了布拉格，对热衷于监察及评判他人的那类人的长相，她已经相当熟悉。这类人全都长着比中指稍长的食指，说话时专用来指戳对方。 1096-1098, 标注, 2025 年 3 月 28 日星期五 上午 8:07:14 当初背叛父亲，她脚下展开的人生就如同一条漫长的背叛之路，每一次新的背叛，既像一桩罪恶又似一场胜利，时刻在诱惑着她。她不愿固定在自己的位置上，决不！ 1118-1121, 标注, 2025 年 3 月 28 日星期五 上午 8:09:25 弗兰茨认为限于书本之间的生活是不现实的。他渴望真实的生活，渴望与同他并肩行进的男女接触，渴望听到他们的呼喊。他没有觉悟到，他以为不现实的（图书馆里离群的工作），其实是他的现实生活，而被他视作现实的游行不过只是一场戏，一支舞，一个节日，或者换句话说：一个梦。 1168-1173, 标注, 2025 年 3 月 28 日星期五 下午 12:45:25 波","date":"2025-03-28","objectID":"/%E7%AC%94%E8%AE%B0%E4%B8%8D%E8%83%BD%E6%89%BF%E5%8F%97%E7%9A%84%E7%94%9F%E5%91%BD%E4%B9%8B%E8%BD%BB-%E6%8D%B7%E5%85%8B-%E7%B1%B3%E5%85%B0%E6%98%86%E5%BE%B7%E6%8B%89%E8%AE%B8%E9%92%A7/:0:0","tags":["bunengchengs","note","ireader"],"title":"[笔记]不能承受的生命之轻-[捷克] 米兰·昆德拉;许钧","uri":"/%E7%AC%94%E8%AE%B0%E4%B8%8D%E8%83%BD%E6%89%BF%E5%8F%97%E7%9A%84%E7%94%9F%E5%91%BD%E4%B9%8B%E8%BD%BB-%E6%8D%B7%E5%85%8B-%E7%B1%B3%E5%85%B0%E6%98%86%E5%BE%B7%E6%8B%89%E8%AE%B8%E9%92%A7/"},{"categories":null,"content":" Table of Contents 1 我还有多少自由空间？ 2 将未使用的分配转换为自由空间 3 如果您已经用尽空间 本文为摘录(或转载)，侵删，原文为： https://ohthehugemanatee.org/blog/2019/02/11/btrfs-out-of-space-emergency-response/ 我在我的根文件系统（Linux 上）上使用 BTRFS，主要是为了快速快照和恢复的功能。昨天我遇到了一个常见的问题：我的驱动器突然满了。我从系统驱动器上的 4GB 的可用空间瞬间变为 0，导致我的系统出现各种混乱。 这个问题发生在许多人身上，因为 BTRFS 与“可用的空闲空间”之间没有线性关系。有几个概念会妨碍这一点： – 压缩：BTRFS 支持在写入时压缩数据。这显然改变了可以存储的数据量。– 50MB 的文本可能只占用驱动器上的 5MB“空间”。– 元数据：BTRFS 将数据与元数据分开存储。数据和元数据都会占用“空间”。– 块分配：BTRFS 以块的方式为数据分配空间。– 多个设备：BTRFS 支持多个设备共同工作，类似 RAID。这意味着每个文件都需要存储额外的信息。例如，RAID-1 会存储每个文件的两个副本，因此一个 50MB 的文件需要占用 100MB 的空间。– 快照：BTRFS 可以存储设备的快照，实际上类似于当前状态的差异。差异中的数据量取决于您的当前状态……因此快照本身的大小并不一致。– 嵌套卷：BTRFS 允许您将文件系统划分为“子卷”，每个子卷都可以（在某个时候）具有自己的 RAID 配置。 很容易查看驱动器并告诉我还有多少 MiB 的空间没有使用。但准确地说出在这些空间中可以写入多少数据则非常困难。因此，系统工具如 df 报告的 BRFS 卷上的“自由空间”数量可能会经历很大的波动——就像我消失的 4GiB 一样。更糟糕的是，通用工具报告的可用空间可能会误导。BTRFS 可能会耗尽空间，而 df 仍然认为您有很多空间可用。 让我们一起了解一下 BTRFS 如何存储数据，以更好地理解这个问题。然后我们可以使用一些 BTRFS 自己的工具来解决它。 ","date":"2025-03-25","objectID":"/ohthehugemanatee_org_btrfs-out-of-space-emergency-response/:0:0","tags":["btrfs","space"],"title":"BTRFS and free space - emergency response","uri":"/ohthehugemanatee_org_btrfs-out-of-space-emergency-response/"},{"categories":null,"content":"1 我还有多少自由空间？ 与其使用像 df 这样的通用工具来回答这个问题，不如使用 btrfs CLI 工具获得更多细节。 BTRFS 从一个大的原始存储池开始，并在此基础上动态分配。您可以通过以下命令列出块设备中所有的设备： $ sudo btrfs fi show Label: 'OS' uuid: c0d21ade-5570-41a3-b0cf-a5ce219e7a8e Total devices 1 FS bytes used 31.74GiB devid 1 size 48.83GiB used 47.80GiB path /dev/nvme0n1p2 在这种情况下，我只有一个物理设备。您可以看到它给出了已分配字节的总数，以及总大小。在另一个文件系统中，这可能是报告给 df 的数字。BTRFS 可不如此！让我们深入了解。 $ btrfs fi df / Data, single: total=45.75GiB, used=30.56GiB System, single: total=32.00MiB, used=16.00KiB Metadata, single: total=2.02GiB, used=1.17GiB GlobalReserve, single: total=89.31MiB, used=0.00B 这里的“总计”值是第一个命令计为“使用”的内容的细分。btrfs fi df 显示已分配空间中实际存储数据的多少，以及多少只是空的分配。在这种情况下：在我的 48GiB 设备上，47GiB 是已分配的。在分配中，31GiB 实际上是存储数据的。附注：如果您处于多驱动器的情况下，此命令会考虑 RAID 元数据。 以下是更简单的视图： $ sudo btrfs fi usage / Overall: Device size: 48.83GiB Device allocated: 47.80GiB Device unallocated: 1.03GiB Device missing: 0.00B Used: 31.74GiB Free (estimated): 16.22GiB (min: 16.22GiB) Data ratio: 1.00 Metadata ratio: 1.00 Global reserve: 89.31MiB (used: 0.00B) Data,single: Size:45.75GiB, Used:30.56GiB /dev/nvme0n1p2 45.75GiB Metadata,single: Size:2.02GiB, Used:1.18GiB /dev/nvme0n1p2 2.02GiB System,single: Size:32.00MiB, Used:16.00KiB /dev/nvme0n1p2 32.00MiB Unallocated: /dev/nvme0n1p2 1.03GiB 这显示了在该块设备中所有设备上分配和使用的空间细分。“总体”是针对整个块设备，而“空闲（估计）”的数字是报告给 df 的内容。 这很有问题：我的大多数正常工具告诉我有 15GB 的自由空间。但是如果我再写 1GiB 的数据，BTRFS 将仍然耗尽空间。这个问题很麻烦并且很难诊断。修复起来也更困难，因为大多数解决方案需要设备上有一些额外的空间。 ","date":"2025-03-25","objectID":"/ohthehugemanatee_org_btrfs-out-of-space-emergency-response/:1:0","tags":["btrfs","space"],"title":"BTRFS and free space - emergency response","uri":"/ohthehugemanatee_org_btrfs-out-of-space-emergency-response/"},{"categories":null,"content":"2 将未使用的分配转换为自由空间 那么，为什么 BTRFS 分配如此多的空间来存储少量数据呢？我在 47GiB 的分配中存储了 31GiB 的数据，使用/总比率为 0.66！这非常低效。这是不幸的结果，因为它是一个写时复制的文件系统——BTRFS 在每次写入时都在新分配的块中开始。然而，块大小是静态的，而文件各不相同。因此，很多时候，一个块是未完全填满的。这就是我们所抱怨的“已分配但未使用”的空间。 幸运的是，有一种方法可以解决这个问题：BTRFS 有一个工具可以“再平衡”您的文件系统。它最初是为了平衡跨多个驱动器存储的数据（因此得名）设计的。然而，在单驱动器配置中，它也很有用，可以重新平衡数据在分配中的存储。 默认情况下，平衡将重写磁盘上的所有数据。这可能是不必要的。块的填满程度会不均匀，但我们在上面看到的，平均应该约为 66％使用。因此，我们将根据数据（-d）使用情况进行过滤，并仅重新平衡使用少于 66％的块。这样将留下任何高于平均水平的部分填充块。 在后台运行，因为这需要很长时间。 $ sudo btrfs balance start -dusage=66 / \u0026 检查状态 $ sudo btrfs balance status -v / Balance on '/' is running 1 out of about 27 chunks balanced (5 considered), 96% left Dumping filters: flags 0x1, state 0x1, 或者懒惰一点，让 bash 每 60 秒报告一次状态。 while :; do sudo btrfs balance status -v / ; sleep 60; done Balance on '/' is running 3 out of about 27 chunks balanced (12 considered), 89% left Dumping filters: flags 0x1, state 0x1, force is off DATA (flags 0x2): balancing, usage=66 Balance on '/' is running 4 out of about 27 chunks balanced (13 considered), 85% left Dumping filters: flags 0x1, state 0x1, force is off DATA (flags 0x2): balancing, usage=66 ... #当平衡操作完成时： Done, had to relocate 19 out of 59 chunks 完成，需重新定位 59 块中的 19 块 一旦完成，就会有很大的区别： $ btrfs filesystem df / Data, single: total=32.53GiB, used=30.83GiB System, single: total=32.00MiB, used=16.00KiB Metadata, single: total=2.02GiB, used=1.17GiB GlobalReserve, single: total=84.67MiB, used=0.00B 这就是为其他用途分配的 15GiB 空间。我的使用比率现在为 0.94。好耶！在某些罕见情况下，您可能需要对元数据分配执行此操作（使用-musage 而不是上面的-dusage）。 ","date":"2025-03-25","objectID":"/ohthehugemanatee_org_btrfs-out-of-space-emergency-response/:2:0","tags":["btrfs","space"],"title":"BTRFS and free space - emergency response","uri":"/ohthehugemanatee_org_btrfs-out-of-space-emergency-response/"},{"categories":null,"content":"3 如果您已经用尽空间 如果您已经用尽空间，就无法运行平衡！在这种情况下，您必须得聪明一点。以下是您的选择： ▶ 1) 释放空间 这比听起来要难。如果您只是删除数据，它可能会留下那些部分填满的块，因此仍然是已分配的。您真正需要的是未分配的空间。获取此空间的最简单方法是删除快照。从最旧的开始，因为它将是最大的。 一旦您有一点喘息的空间，就重新平衡小段，比如元数据。然后继续按照上面描述的方法重新平衡数据。 ▶ 2) 添加一些空间 不要忘了，BTRFS 卷可以跨多个设备！我最近不得不使用这个选项。添加一个设备——一个闪存驱动器也可以，但请选择最快的东西——并将其添加到 BTRFS 卷中。 添加您的额外驱动器 (/dev/sda)。 $ sudo btrfs device add -f /dev/sda / 现在运行您能做的最小平衡操作。 $ sudo btrfs balance start -dusage=1 / 完成，需重新定位 59 块中的 1 块 移除设备，并运行正式的平衡。 $ sudo btrfs device remove /dev/sda / $ sudo btrfs balance start -dusage=66 / 完成，需重新定位 59 块中的 18 块 平衡操作通常需要很长时间——超过一个小时并不少见。在涉及缓慢的闪存介质时，会需要更长时间。因此，我在这个例子中使用了非常低的平衡过滤器（-dusage=）。我们只需要释放一点空间，以便在不参与闪存驱动器的情况下再次运行平衡。 而这个最后的选项就是我昨晚拯救我的计算机的方法。我希望这能帮助到今后遭遇类似困境的某个人。 更新：请不要这样做！来自 BTRFS 社区的友好评论者告诉我，这其实是个非常糟糕的主意，因为任何中断 RAM 的情况都会不可挽回地破坏您的文件系统。坚持上面的 USB 驱动器解决方案。感谢@Zygo 的纠正，抱歉让任何人为我的学习而受苦。 更新：现在我已经不得不这样做几次，通过向文件系统添加一个 ramdisk 来平衡一个满的文件系统要好得多。这不仅比闪存设备更快，而且在大多数情况下更可靠……而且对于我这种使用案例（开发者笔记本电脑），重要的前提条件都存在：大量的 RAM，可靠的电源。以下是步骤： 创建一个 ramdisk。在执行此操作之前，请确保/dev/ram0 未被使用！ $ sudo mknod -m 660 /dev/ram0 b 1 0 $ sudo chown root:disk /dev/ram0 以具体大小挂载 ramdisk。否则，它将增长到所需的大小。 $ sudo mkdir /mnt/ramdisk $ sudo mount -t ramfs -o size=4G,maxsize=4G /dev/ram0 /mnt/ramdisk 在 ramdisk 上创建一个文件以用作回环设备。 $ sudo dd if=/dev/zero of /mnt/ramdisk/extend.img bs=4M count=1000 $ sudo losetup -fP /mnt/ramdisk/extend.img 找出哪个回环设备 ID 是您的 $ sudo losetup -a |grep extend.img /dev/loop10: [5243078]:8563965 (/mnt/ramdisk/extend.img) 将回环设备添加到 btrfs 文件系统 $ sudo btrfs device add /dev/loop10 / 确定您的平衡比率，并按往常一样进行平衡。 $ sudo btrfs fi usage / |head -n 6 Overall: Device size: 400.91GiB Device allocated: 396.36GiB Device unallocated: 4.55GiB Device missing: 0.00B Used: 348.91GiB $ echo 'scale=2;348/396' |bc .87 完成，需重新定位 400 块中的 46 块 移除设备并销毁它。 $ sudo btrfs device delete /dev/loop0 / $ sudo losetup -d /dev/loop10 $ sudo umount /mnt/ramdisk $ sudo rm -rf /dev/ram0 ","date":"2025-03-25","objectID":"/ohthehugemanatee_org_btrfs-out-of-space-emergency-response/:3:0","tags":["btrfs","space"],"title":"BTRFS and free space - emergency response","uri":"/ohthehugemanatee_org_btrfs-out-of-space-emergency-response/"},{"categories":null,"content":" 35-36, 标注, 2025 年 3 月 12 日星期三 下午 6:43:44 然而，半睡半醒之时，意志总是飘忽如同烟雾，难以控制，难以收束，他再怎么努力，依旧忍不住思维发散，杂念浮现。 1398-1399, 标注, 2025 年 3 月 19 日星期三 上午 7:55:33 最大的恐惧来自未知，我们可以让未知变成已知。” 1401-1401, 标注, 2025 年 3 月 19 日星期三 上午 7:55:46 人类从历史中学到的唯一教训就是，人类无法从历史中学到任何教训，总是重复同样的悲剧。” 1502-1503, 标注, 2025 年 3 月 19 日星期三 上午 8:01:11 遇见困扰，我会一条一条地列出坏和好两方面内容，列完以后，再比较一下，就能得到应该怎么做的‘提示’了。 2559-2561, 标注, 2025 年 3 月 19 日星期三 下午 6:53:36 各种混杂的香味谱写成了浓郁的食物序曲，那是煮牛肉弥漫的勾魂，那是土豆泥明显而持久的刺激，那是豌豆浓汤甜腻的纠缠，那是炖大黄微妙而中正的调和，那是黑麦面包上奶油清甜的环绕。 5382-5385, 标注, 2025 年 3 月 20 日星期四 下午 6:51:23 他放下怀表，取出抽屉内的一盒火柴，刷地划亮一根，凑近了那四页笔记。 橘红色的火焰咬住了纸张，飞快蔓延。克莱恩将这四页笔记放到了木制的垃圾桶上，看见灰烬漂浮掉落。 5382-5386, 标注, 2025 年 3 月 20 日星期四 下午 6:51:37 他放下怀表，取出抽屉内的一盒火柴，刷地划亮一根，凑近了那四页笔记。 橘红色的火焰咬住了纸张，飞快蔓延。克莱恩将这四页笔记放到了木制的垃圾桶上，看见灰烬漂浮掉落。 他松开手指，任由纸张坠下，不过十来秒的工夫，一切都消失不见，只有那还略微盘旋的灰烬和木桶底部的焦痕述说着往事。 9033-9034, 标注, 2025 年 3 月 21 日星期五 下午 10:17:25 每当想到这些，我就仿佛触及了历史的尘埃，被那种无法扭转的沧桑和宿命震撼，心中有诗篇在酝酿，在涌动， 15203-15206, 标注, 2025 年 3 月 24 日星期一 上午 7:53:45 他只觉这一切更像梦境，不敢相信事情就这样发生了，就这样结束了。 他木然又无言地看着邓恩上前两步，看到了队长略微佝偻的背影。 身穿黑色风衣的邓恩望着前方老尼尔的“尸体”，自言自语般沉声说道： “我们是守护者，也是一群时刻对抗着危险和疯狂的可怜虫。” 17254-17255, 标注, 2025 年 3 月 24 日星期一 下午 10:52:32 那就是，有预案的情况下，做事谨慎而理智，可一旦遇到不在预案内的情况，遇到灵光一闪的状态，就很容易只考虑好的方面，忽视坏的可能。 简单的描述是，一冲动就容易作死…… 17922-17924, 标注, 2025 年 3 月 25 日星期二 上午 8:08:08 整个房间内最吸引人眼球的则是一副未完工的油画，上面是裸露着身躯的雪伦夫人自己，她褐发如瀑，棕眸仿佛林中小鹿的眼睛，纯洁水润，但弯眉翘眼，挺鼻娇唇，又勾勒出了成熟女性的妩媚，两者以一种矛盾的姿态被糅合在一起，却散发出惊人的魅惑力。 18754-18756, 标注, 2025 年 3 月 25 日星期二 下午 12:51:14 “不断夭折的童工，因环境和辛苦很少活过十年的工厂工人，冒着重病风险又只能拿到微薄薪水的女工，我看见每一座工厂都笼罩着无数的怨念，让周围都变得压抑和昏暗，这是最坏的时代，也是最好的时代， 23076-23077, 标注, 2025 年 3 月 26 日星期三 上午 7:56:48 “占卜是启示，必须配合本身的小心、谨慎和克制。” 23078-23079, 标注, 2025 年 3 月 26 日星期三 上午 7:57:08 这同样也是对我的提醒，即使我有灰雾隔绝干扰，也不能大意，再笃定的行动也要留点余地…… 37198-37198, 标注, 2025 年 4 月 7 日星期一 上午 7:56:43 只要我疯了，你就肯定猜不出我在想什么？ 40401-40402, 标注, 2025 年 4 月 8 日星期二 下午 6:41:50 “也许可以用一个比喻来相对准确地描述，某些怪物是肉体上的缝合怪，他则是精神上的缝合怪。” 51247-51250, 标注, 2025 年 4 月 14 日星期一 上午 8:19:12 沿着山路下行时，他看见了整座拜亚姆： 海水淡蓝近绿，一望无垠，港口船帆层叠，烟囱高耸，街道纵横交错，人来人往，四周庄园密布，植物众多，远处公路宽阔，铁轨笔直……这就像一副出自大师之手的美丽油画，充满蓬勃的朝气，有着难以言喻的活力。 55922-55923, 标注, 2025 年 4 月 16 日星期三 上午 8:16:51 哎，我对它不够了解啊，果然是什么都懂一点什么都只懂一点的键盘强者…… 56638-56642, 标注, 2025 年 4 月 16 日星期三 下午 6:35:11 时间一分一秒流逝，太阳渐渐落下，将山峰左侧的蔚蓝海洋染得如同火烧，让右方碧绿的树林和广袤的田野蒙上了一片金黄。所有的颜色都在这一刻绽放出最后的明亮，接着便逐渐黯淡，直至昏暗。 船只入港，马车进城，忙碌的人们沿着麦田间果园旁的道路陆续返家。 当黑暗开始笼罩这片大地，城内城外相继亮起了一点点温暖的光芒，它们就像黑色天鹅绒上的璀璨宝石。 61955-61956, 标注, 2025 年 4 月 18 日星期五 下午 9:33:33 “什么烦恼也不能影响吃饭和睡觉！” 66852-66852, 标注, 2025 年 4 月 21 日星期一 上午 8:11:25 “每一段旅行都有终点。” 69796-69800, 标注, 2025 年 4 月 22 日星期二 上午 8:00:10 值夜者”们还是太过相信“梦魇”的能力了，换做是我主导此事，肯定会提前设计不同角度不同方面的一系列问题，彼此对照，寻找不协调有漏洞的地方……呵，最好的办法是联合“正义”小姐，出好几份专业的心理测评问卷，让目标在梦境里全部做完，他若是有伪装，心理状态和想表现出来的形象，肯定会在不同测评的结论里有矛盾之处，除非，他也是心理学专家，能注意到每一组问题的实质目的…… 72887-72887, 标注, 2025 年 4 月 24 日星期四 下午 6:47:18 自从得了精神病，我精神好多了…… 72956-72957, 标注, 2025 年 4 月 24 日星期四 下午 6:49:47 “每个人每件物品都有自己的尽头，都会回到大地，深埋于土中，重新再发芽，抽长和开花，一世又一世。”“这就是万物的命运， 77139-77140, 标注, 2025 年 4 月 29 日星期二 下午 12:10:01 “梦境里的恐惧往往来源于内心潜藏的情绪，而内心潜藏的恐惧绝大部分时候只有两个来源，一是未知，二是无法抗拒。” 77179-77180, 标注, 2025 年 4 月 29 日星期二 下午 6:28:52 “不管怎么样，总得做点什么，努力地做点什么，不能就那样放弃，不做反抗。” 82192-82193, 标注, 2025 年 5 月 6 日星期二 下午 11:09:23 你知道了它，它也就知道了你。” 突然，克莱恩“咦”了一声，觉得这样的描述有点眼熟！ “这很像黄昏隐士会啊，凡有言，必被知…… 95927-95929, 标注, 2025 年 5 月 20 日星期二 下午 10:34:08 那是在漫长黑夜后，于晨曦薄雾里，看见自家花园内有一朵花正缓慢绽放的喜悦，那是离开大都市，前往郊外，在雨后的树林里呼吸清爽空气，目睹蘑菇长出的喜悦，那是万物滋长，新生降临的喜悦。 96424-96424, 标注, 2025 年 5 月 21 日星期三 上午 8:15:53 不是没脑子，只是懒得用…… 124835-124837, 标注, 2025 年 5 月 23 日星期五 下午 12:40:35 克莱恩的意识在“福生玄黄天尊”复苏的意志和安提哥努斯的自我认知、精神烙印连番冲击下，如同暴风雨中的帆船，时而被抛高，时而被拍下，时而被侵蚀，时而被横推。 126857-126859, 标注, 2025 年 5 月 23 日星期五 下午 8:51:05 一本小说，世界观是骨架，剧情是肉，人物则是血，没有好的人物，那这本小说就会死沉沉的，很难让一个大长篇在每个部分都有意思，足够吸引人，也很难去营造共鸣、感动和各种情绪。 ","date":"2025-03-18","objectID":"/%E7%AC%94%E8%AE%B0%E8%AF%A1%E7%A7%98%E4%B9%8B%E4%B8%BB-%E7%88%B1%E6%BD%9C%E6%B0%B4%E7%9A%84%E4%B9%8C%E8%B4%BC/:0:0","tags":["guimizhizhu","note","ireader"],"title":"[笔记]诡秘之主-爱潜水的乌贼","uri":"/%E7%AC%94%E8%AE%B0%E8%AF%A1%E7%A7%98%E4%B9%8B%E4%B8%BB-%E7%88%B1%E6%BD%9C%E6%B0%B4%E7%9A%84%E4%B9%8C%E8%B4%BC/"},{"categories":null,"content":"本文为摘录(或转载)，侵删，原文为： https://learn.microsoft.com/zh-cn/training/modules/tm-introduction-to-threat-modeling/1b-threat-modeling-phases https://learn.microsoft.com/zh-cn/training/modules/tm-introduction-to-threat-modeling ","date":"2025-03-12","objectID":"/learn_microsoft_com_tm-introduction-to-threat-modeling/:0:0","tags":["threat","model","stride","microsoft","ms"],"title":"威胁建模简介","uri":"/learn_microsoft_com_tm-introduction-to-threat-modeling/"},{"categories":null,"content":"《1984》是乔治·奥威尔（George Orwell）所著的一本小说，出版于 1949 年。这本小说描写了一个类似于极权主义社会的未来世界，人民被强制接受一种叫做“新话”的语言，并被日常生活中的各种监视手段所控制，一个名叫温斯顿·史密斯的官员试图反抗政府，但最终被政府抓捕并被迫接受思想改造。 小说的故事背景设定在 2044 年的伦敦，那时的政权是一个叫做“英国社会党”的政府，由“大哥”（大哥是政府的领袖，他被塑造成一个超越人类的存在。政府通过宣传大哥和党的教义来控制人民的思想）领导。 声明：以下内容为摘要，其中的党为英国社会党，又称“英设”。 54-55, 标注, 2025 年 2 月 28 日星期五 上午 7:56:15 他表达的是一种对于人类未来近乎绝望的情绪，同时也预兆，除非历史的进程改变，否则全世界的人都会在不知不觉中失去大部分人类的特质，变成没有灵魂的机器人。 59-61, 标注, 2025 年 2 月 28 日星期五 上午 7:57:17 普遍的和平和正义是人类的目标，先知们坚信错误和罪恶即使有得势之时，“末日审判”最终还是会到来，救世主便是这种信念的象征。 72-74, 标注, 2025 年 2 月 28 日星期五 上午 7:59:02 紧随托马斯·莫尔的《乌托邦》之后，还有两部同类作品，分别是修道士康帕内拉的《太阳城》和德国人文主义者安德里亚的《基督城》。后者是三者之中最具现代性的作品。乌托邦三部曲之间有着不同的观点和创意，但是与它们的共同点相比起来，这些差异就显得十分渺小。 91-95, 标注, 2025 年 2 月 28 日星期五 上午 8:02:10 奥威尔并不是做这种尝试的唯一一人。另外两个作家，俄国的扎米亚京在他的书《我们》和阿道斯·赫胥黎在他的《美妙的新世界》中，都用跟奥威尔作品非常相似的方式表达了当时的这种情绪并对未来提出警示。这三部写于 20 世纪中叶的作品被我们称为“反乌托邦”三部曲，这是为了和上文提到的写于 16、17 世纪的“乌托邦”进行对应[ 95-96, 标注, 2025 年 2 月 28 日星期五 上午 8:03:03 早期乌托邦作品描述充满自信的情绪和充满希望的后中世纪的人一样，反乌托邦描述的是一种无能为力的情绪和绝望的现代人。 100-102, 标注, 2025 年 2 月 28 日星期五 上午 8:03:42 就在人们感受到所有的希望即将实现的这一刻，他们开始失去了它。这就是反乌托邦三部曲的核心，它们不仅仅描述了我们的未来走向，同时也解释了历史的悖论。 145-149, 标注, 2025 年 2 月 28 日星期五 上午 8:12:14 党的领袖甚至都不去假装他们的体系是为了使人们快乐，因为人是脆弱和怯懦的的生物，他们都想逃避自由而不敢去面对真理。领袖们都清醒地意识到，他们事实上只有一个目标，那就是权力。对他们来说“权力不是手段，而是目的，权力意味着他们有能力制造无限的痛苦和去折磨他人”[2]。权力，可以为他们创造事实，创造真理。在这里，奥威尔对于权利精英的态度可以说是唯心主义的极端形式， 156-159, 标注, 2025 年 2 月 28 日星期五 上午 8:13:49 只要经过大多数人的认可就是真理，口号在“几百万人怎么可能犯错”的基础上增加了“一个人怎么可能正确”。奥威尔已经明确指出，在一个团体中，已经彻底废除真理作为一个有关现实的客观判断这个概念，任何一个在这个团体中的异端都会被视为精神错乱。 184-187, 标注, 2025 年 2 月 28 日星期五 上午 8:19:34 在成功的思想控制之下，一个人再也不会有他想法的对立面，而只知道什么才是“真理”的对立面。因此，举个例子说，如果他已经丧失了他自身的独立性和完整性，如果他把自身当作是一个从属于国家、政党或者公司的物体，那么二加二就是五，或者认为“奴役即自由”，他之所以感到自由，是因为他再也不会意识到真理与谬误之间的矛盾。这特别适用于意识形态领域。 189-192, 标注, 2025 年 2 月 28 日星期五 上午 8:20:58 奥威尔在这方面，很明显是指当局所伪造的社会主义，但是必须指出，西方社会也犯了同样的错误。我们说我们的社会就是一个行动自由、个人主义和理想主义的社会，然而事实上这些大部分是一些托词。我们处于一个中央集权的工业社会，本质上是官僚主义，由唯物主义提供动力，轻微的精神和宗教关怀仅仅是起缓和作用。 201-203, 标注, 2025 年 2 月 28 日星期五 上午 8:23:30 我确信奥威尔、赫胥黎和扎米亚京三个都不想坚持认为这样的世界必定会到来。正相反，他们指出我们正在向着危险的方向走去，除非我们可以成功地让西方文化的根源中那些人道主义精神和个人尊严重新复苏。 206-207, 标注, 2025 年 2 月 28 日星期五 上午 8:23:51 个作者都暗示这种危险并不仅仅存在于像苏联那样的社会主义国家，这种危险是现代生产和组织模式所固有的，它完全独立于各种各样的意识形态之外。 203-207, 标注, 2025 年 2 月 28 日星期五 上午 8:24:05 威尔和其他两位作者，暗示着在我们新的工业管理制度下，人制造出像人一样的机器，而人却发展得像越来越像机器，这将是一个人性丧失、全面异化的时代，人变成了物品，变成了生产和消费过程之中的一个附件[6]。三个作者都暗示这种危险并不仅仅存在于像苏联那样的社会主义国家，这种危险是现代生产和组织模式所固有的，它完全独立于各种各样的意识形态之外。 265-266, 标注, 2025 年 2 月 28 日星期五 下午 12:40:12 战争即和平 自由即奴役 无知即力量 502-504, 标注, 2025 年 3 月 1 日星期六 下午 2:25:50 突然，他们两个开始围着他跳跃，嘴里还喊着“卖国贼”和“思想犯”。小女孩的一招一式都在模仿她哥哥。他们就像不久便会长成食人兽的老虎崽子一样嬉戏着，不知怎的，那有点令人恐惧。男孩的眼里，有种狡猾而残忍的神色。 522-525, 标注, 2025 年 3 月 1 日星期六 下午 2:27:40 年过三十的人会害怕自己的孩子，这几乎已经变成一种普遍现象。很合理的是，《泰晤士报》几乎每星期都会登出一篇文章，关于某个偷听别人说话的小告密者——一般用的是“小英雄”这个词——如何无意听到父母的某句不敬言论，然后去思想警察那里告发的事迹。 726-728, 标注, 2025 年 3 月 1 日星期六 下午 10:59:16 甚至在温斯顿收到并在处理完之后被一律销毁的文字指令上，也不会说明或暗示要进行伪造活动，提到的总是笔误、错误、错印或错误引用，为准确起见，需要对其进行改正。 730-736, 标注, 2025 年 3 月 1 日星期六 下午 11:00:18 修改前和修改后的统计数字都是异想天开的产物，绝大多数情况下，那些数字都是指望你在脑子里杜撰出来的。例如，富足部预测本季度的靴子产量为一亿四千五百万双，而实际产量为六千两百万双，但温斯顿在重写预测数字时，将其降至五千七百万双，这样就可以照例声称超额完成定额。可是无论如何，六千两百万或五千七百万或一亿四千五百万跟真实数字比起来，在离谱程度上都是一样的，很有可能一双靴子也没有生产出来，更有可能的是谁也不知道生产了几双，更不用说关心了。你所知道的，只是每季度在纸上生产出天文数字的靴子，而在大洋国，可能一半人都打着赤脚。每一类被记录下来的事实都是如此，无论重要与否。一切退色成了一个影子世界，到最后，连年份也变得不确定了。 782-784, 标注, 2025 年 3 月 1 日星期六 下午 11:12:00 很有可能有多达十几人这时正在编写老大哥实际讲话的相反版本。不久，内党里的某位高参会选择这个或那个版本，对之进行再编辑。接着进入必要的相互参照的复杂程序。最后被选中的谎言将被载入永久档案，并成为事实。 884-886, 标注, 2025 年 3 月 2 日星期日 下午 9:51:40 或早或晚，塞姆会被蒸发掉，温斯顿忽然想到这一点并对此深信不疑。他太聪明了，他看得太明白，说得太露骨。党不喜欢这种人，总有一天他会失踪，这明明白白写在他脸 905-905, 标注, 2025 年 3 月 2 日星期日 下午 10:39:11 塞姆身上有点隐隐约约不对劲的地方，他缺少某种东西：谨慎，超脱，一种藏拙的能力。 1005-1007, 标注, 2025 年 3 月 3 日星期一 上午 7:52:47 那是因为他们看到她用一张 B.B.的宣传画裹香肠。他们悄悄溜到她身后，用一盒火柴把她裙子点着了。我想她给烧得够戗。还是小崽子啊，是不是？可真是热情万丈！ 1057-1058, 标注, 2025 年 3 月 3 日星期一 上午 7:57:04 他每次一碰她，她就好像往后缩，而且绷紧了身体，抱着她就像抱着一个有关节的木头人。奇怪的是，即使在她紧搂他时，他还是有种她同时也在用尽全力推开他的感觉，她紧绷的肌肉给他造成了这种印象。 1108-1109, 标注, 2025 年 3 月 3 日星期一 上午 8:00:51 除非他们觉醒，否则永远不会反抗；但除非他们反抗，否则不会觉醒。 1113-1117, 标注, 2025 年 3 月 3 日星期一 上午 8:04:45 事实上对于群众，人们了解得很少，也没必要了解很多。只要他们继续干活、繁衍，他们别的行为就无关紧要。他们被放任自流，就像阿根廷的平原上没有笼缰的牛群。他们过着似乎是返璞归真、类似他们祖先所过的生活。他们在贫民窟出生、长大，十二岁开始干活，度过蓬勃却短暂的健","date":"2025-03-11","objectID":"/%E7%AC%94%E8%AE%B01984%E5%8F%8D%E4%B9%8C%E6%89%98%E9%82%A6%E4%B8%89%E9%83%A8%E6%9B%B2-%E8%8B%B1-%E4%B9%94%E6%B2%BB%E5%A5%A5%E5%A8%81%E5%B0%94%E5%AD%99%E4%BB%B2%E6%97%AD/:0:0","tags":[1984,"fanwutu","note","ireader"],"title":"[笔记]1984:反乌托邦三部曲 [英] 乔治·奥威尔;孙仲旭","uri":"/%E7%AC%94%E8%AE%B01984%E5%8F%8D%E4%B9%8C%E6%89%98%E9%82%A6%E4%B8%89%E9%83%A8%E6%9B%B2-%E8%8B%B1-%E4%B9%94%E6%B2%BB%E5%A5%A5%E5%A8%81%E5%B0%94%E5%AD%99%E4%BB%B2%E6%97%AD/"},{"categories":null,"content":" 93-94, 标注, 2025 年 3 月 9 日星期日 下午 8:35:46 也许，我们至今也还难以完全了解我们自己。考古，就犹如一面深埋地下的镜子，倒映出我们陌生的形象。 301-301, 标注, 2025 年 3 月 10 日星期一 上午 7:56:27 中国古文明的重要特征是实用和低成本，不重视公共参与性。 306-308, 标注, 2025 年 3 月 10 日星期一 上午 7:58:13 周灭商后，人祭被周人消除，但周人并未开创一种新的宗教，而是采用世俗的人文主义立场，与极端宗教行为保持距离，不允许其干预现实生活，所谓“敬鬼神而远之”。这奠定了后世中国的文化基础。 317-318, 标注, 2025 年 3 月 10 日星期一 上午 7:59:35 故而，《易经》的内容多是文王的翦商谋略，也正因此，这部分内容最为隐晦。 346-347, 标注, 2025 年 3 月 10 日星期一 上午 8:03:24 也许，我们至今也还难以完全了解我们自己。考古，就犹如一面深埋地下的镜子，倒映出我们陌生的形象。 349-351, 标注, 2025 年 3 月 10 日星期一 上午 8:03:47 广义的人祭，可以界定为出于宗教理念而杀人奉献给神灵的行为。这里的神灵包含上帝（帝和上帝在商人甲骨文中多次出现）、各种自然神以及尊贵的死者亡灵。 389-390, 标注, 2025 年 3 月 10 日星期一 上午 8:05:57 商代甲骨卜辞中的“羌「主要是山西、陕西地区的土著居民，这些人在周代逐渐汇聚成为华夏族。在后世的汉语中，“羌”字又演变成汉人对位居西方的少数族群的称谓，这和商代的“羌”已经不是同一种人。 431-432, 标注, 2025 年 3 月 10 日星期一 上午 8:08:09 六千多年前的仰韶半坡文化新石器时代，比如陕西临潼的姜寨遗址， 487-489, 标注, 2025 年 3 月 10 日星期一 上午 8:15:02 以上两千年历程，是新石器中晚期到文明（青铜）时代前夜的变化大趋势：从村落到部落再到早期国家。通俗一点说，就是从村级到乡级、县级的递增升级。 551-554, 标注, 2025 年 3 月 10 日星期一 上午 8:29:25 在新石器时代，华北地区之所以动辄爆发冲突或战争，人祭兴盛，可能和旱作农业不需要水利设施 11、人群之间没有协作的动因有关。而伴随着征服的，是人群共同体规模的不断扩大，从而催生了众多古城和早期国家。 976-979, 标注, 2025 年 3 月 10 日星期一 下午 7:03:24 石器时代和青铜时代都是常用的词，但这两个词的含义并不对等。青铜器从未完全淘汰石器，它更多体现的是上层人生活的改变，就像 古人发明文字后，社会上的多数人仍是文盲。社会的发展水平往往是被占人口少数的精英阶层代表的。但我们不能因其数量少而低估青铜，正是它铸造了华夏的最初文明和第一王朝。 988-990, 标注, 2025 年 3 月 10 日星期一 下午 7:04:39 学术界以往对“文明”的界定比较严格，其中有三个关键要素： 城市、冶金技术和文字。按这种标准，商代晚期的殷商阶段属于文明，因为有可以释读的甲骨文；后来也发现过早商阶段的甲骨文材料，但极为稀少。总体来说，商代符合严格的文明标准，争议不大。 988-992, 标注, 2025 年 3 月 10 日星期一 下午 7:04:52 学术界以往对“文明”的界定比较严格，其中有三个关键要素： 城市、冶金技术和文字。按这种标准，商代晚期的殷商阶段属于文明，因为有可以释读的甲骨文；后来也发现过早商阶段的甲骨文材料，但极为稀少。总体来说，商代符合严格的文明标准，争议不大。 但商代之前的夏-二里头，缺少文字要素；再早的新石器末期古国，如石御、陶寺和良渚等，有万人聚居的大型聚落及明显的阶级分层和宏大建筑，却没有或极少有铜器。这些都不符合严格的文明标准。 1066-1067, 标注, 2025 年 3 月 10 日星期一 下午 7:11:46 二里头-夏朝建成了一个大型聚落和复杂社会，而且依靠青铜技术保持着长期稳定；由此，一千多年来古国兴废无常的难题终于被破解。 1080-1084, 标注, 2025 年 3 月 10 日星期一 下午 7:13:21 石器时代通往青铜时代的大门看似很宽，实则很窄。这些困难和偶然性，又催生了关于金属冶炼的神秘玄学观念，认为某些神灵会影 响冶炼的成效，所以人们会用不同的形式进行祈福，请神赐予高质量的产品——从夏到商，冶铜区的人祭遗存都比较密集，直到钢铁时代，冶炼仍是充满着不确定性和神秘色彩的活动，甚至有工匠舍身投入炼炉、获得高质量金属的传说。 1362-1364, 标注, 2025 年 3 月 11 日星期二 上午 7:54:41 据说，商人始祖是一名叫简狄的女子，有次在野外洗澡时，她见到玄鸟产下一枚卵，就吞了下去，结果生下儿子契，繁衍出后来的商族。上古时代，常有女子未婚生育的神话，据说这是母系时代“知其母， 不知其父”的特征。 1375-1376, 标注, 2025 年 3 月 11 日星期二 上午 7:56:04 杜甫诗云：“人生不相见，动如参与商 1375-1377, 标注, 2025 年 3 月 11 日星期二 上午 7:56:24 杜甫诗云：“人生不相见，动如参与商商星都是黎明时在东方出现，参星总是黄昏时在西方出现，永远一东一西，所以人生分离难聚也被称为“参商”。 1403-1405, 标注, 2025 年 3 月 11 日星期二 上午 8:00:26 对商族来说，王亥遇难和上甲微复仇是生死攸关的事件，也是商族历史上的重要分水岭。 在殷墟甲骨卜辞中，后世商王称王亥为“高祖王亥”，经常单独祭祀他；而上甲微多是和之后的历代先君、先王一起接受祭祀，卜辞写作“自上甲”或者“自上甲至（某先王） 1412-1415, 标注, 2025 年 3 月 11 日星期二 上午 8:01:30 史书中并没有王亥牧羊的记载。周族人原本在西部高地放牧羊和黄牛，所以，周文王可能是用自己熟悉的生活来想象王亥时代，错误地增加了一条“丧羊于易”：羊不适应潮湿环境，不适合王亥时代的商族人。这也说明，《易经》卦爻辞中的商代史事并不完全可信，周文王可能会基于西土周人的环境错误地理解商人历史。 1452-1456, 标注, 2025 年 3 月 11 日星期二 上午 8:07:20 在灭夏之前，商族人很可能已经发明了最初的文字。商业贸易需要记账和远程传递信息，而这都会刺激数字和文字的发明。在商人创造文字之前，很多部落已经有了初步的记事符号，比如，对良渚文化和龙山文化的考古，就曾发掘出一些刻划符号的陶片。而商族人在迁徙和贸易中与较多部族打过交道，有机会见到各种记事符号的用法，所以，在此基础上进行汇总是完全有可能积累起完整记录语言的字符体系的。 1480-1484, 标注, 2025 年 3 月 11 日星期二 上午 8:09:58 《易经》中也多次出现过鸟。周人和商族起源不同，并不崇拜鸟，但在创作《易经》时，周文王引用了一些与鸟有关的商人的历史掌故，如《旅》卦上九爻辞： 鸟焚其巢，旅人先笑后号啖。丧牛于易。凶。这条爻辞涉及王亥在有易氏丧牛和被杀之事。“旅人先笑后号眺”是关于王亥旅行在外的遭遇；而鸟巢被焚毁，则象征王亥的命运。长期以来，人们都没有发现《易经》里隐藏的这段掌故，直到民国时期才被顾颉刚破解：“丧牛于易”是说王亥在有易氏部落遇难，牛 群被夺走。 1548-1549, 标注, 2025 年 3 月 11 日星期二 上午 8:23:39 但其实，早商的奇迹更多，它在二百年左右的时间里创造的成就，其后一千年都难以再现。那是一种几乎抵达秦汉大一统王朝的气象。 1548-1551, 标注, 2025 年 3 月 11 日星期二 上午 8:23:56 但其实，早商的奇迹更多，它在二百年左右的时间里创造的成就，其后一千年都难以再现。那是一种几乎抵达秦汉大一统王朝的气象。比如，它拥有地跨千里的遥远殖民城邑，有规模庞大到脱离当时人口总量和经济水平的大型仓储设施。 可以这么说，在早期青铜时代，早商堪称一场“现代化”奇迹。 1589-1591, 标注, 2025 年 3 月 11 日星期二 上午 8:29:48 灭夏时，商人已有了初步的文字。这是建立真正王朝统治的必要工具。商人应当也会利用宗教的神秘感和威慑力，虽然我们目前对于商初宗教的了解还很少，但从后来其在商朝的重要地位看，早期的商王们肯定在宗教上投入过相当大的精力。 2349-2352, 标注, 2025 年 3 月 12 日星期三 上午 7:52:56 到这里，一切似乎都很自然，但考古发掘揭开了惊悚的一幕。 一座两间连体的房子（F2）西墙的基槽里，埋着一件陶罐，里面是一具不满三岁的幼儿尸骨。显然，这是给新房奠基的巫术，用幼儿向土地之神献祭，以保佑家宅平安。献祭的死者不止幼儿，朝东的屋前还有四座祭祀坑，其中三座各埋入一只猪、牛、羊，第四座坑（H104）埋的则是人。 2371-2373, 标注, 2025 年 3 月 12 日星期三 上午 7:56:39 屋檐下悬挂人头的不止 F2，紧挨着的 F6 亦是如此：F6 由两间北屋和四间西屋构成，西墙内夯筑了一颗人头，是一名大约十八岁的女性的；在房子坍塌的泥土中散落着五枚人头骨，之前应当也是悬挂在屋檐之下的。 2947-2948, 标注, 2025 年 3 月 12 日星期三 下午 10:54:49 后来的周人史诗把他们的灭商事业称为“翦商”，也是取其宏大之意。 3082-3084, 标注, 2025 年 ","date":"2025-03-11","objectID":"/%E7%AC%94%E8%AE%B0%E7%BF%A6%E5%95%86%E6%AE%B7%E5%91%A8%E4%B9%8B%E5%8F%98%E4%B8%8E%E5%8D%8E%E5%A4%8F%E6%96%B0%E7%94%9F-%E6%9D%8E%E7%A1%95/:0:0","tags":["jianshang","yi","note","ireader"],"title":"[笔记]翦商:殷周之变与华夏新生 李硕","uri":"/%E7%AC%94%E8%AE%B0%E7%BF%A6%E5%95%86%E6%AE%B7%E5%91%A8%E4%B9%8B%E5%8F%98%E4%B8%8E%E5%8D%8E%E5%A4%8F%E6%96%B0%E7%94%9F-%E6%9D%8E%E7%A1%95/"},{"categories":null,"content":"本文为摘录(或转载)，侵删，原文为： https://www.cnblogs.com/maijin/p/17301190.html ","date":"2025-03-06","objectID":"/www_cnblogs_com_p_17301190/:0:0","tags":["win","key"],"title":"转载的激活","uri":"/www_cnblogs_com_p_17301190/"},{"categories":null,"content":"本文为摘录(或转载)，侵删，原文为： https://emacsredux.com/blog/2025/03/01/debugging-errors-in-emacs/ 我最近写了一篇关于调试 Emacs 命令的文章。在文章中，我简要提到了 M-x toggle-debug-on-error 和 =debug-on-error=，但在发布文章后，我意识到许多人可能不太理解它的具体工作原理。 当 debug-on-error 被启用时，显而易见的事情是，当发生错误时，你会看到其回溯（或堆栈跟踪，具体取决于你喜欢的术语）。不那么明显的是（即使它在名称中），这个缓冲区实际上是一个调试器缓冲区，你可以在其中做很多事情。以下是一些示例： 导航堆栈跟踪：在*Backtrace*缓冲区的不同行中移动光标，这些行代表不同的堆栈帧。 检查局部变量：在堆栈帧上按 v（debugger-toggle-locals）以显示该帧的局部变量。 评估表达式：使用 e（debugger-eval-expression）在当前帧的上下文中评估 Lisp 表达式。 单步执行代码：使用 d 逐步进入函数调用，并逐一评估表达式。 继续执行：按 c 以继续正常执行。（注意，除非你更改了某些内容，否则这将导致你正在调试的错误） 退出调试：输入 q 以退出调试器并中止当前命令。 查看帮助：输入?以查看可用调试器命令的列表。 记录评估：使用 E 来评估一个表达式并将结果保存在 Debugger-record 缓冲区中。 重要的是要理解，调试器在错误的环境中运行，允许你精确检查错误发生时的变量值。这使得它成为理解和修复 Emacs Lisp 代码中问题的强大工具。 这种调试体验是 Lisp 的一大强大特性，也是开发和调试 Emacs 包的愉快和高效体验的原因之一。前提是你熟悉如何在这样的情况下使用调试器。 在 Emacs 中，你可以通过在调试器缓冲区中按 C-h m 获取更多帮助。 所以，综述一下——如果你遇到一些错误，你应该运行命令 =M-x toggle-debug-on-error=，重新运行导致错误的操作，然后在调试器中导航堆栈跟踪，以准确找出出错的地方。 要调试在加载初始化文件期间发生的错误，请使用选项 --debug-init=。这会在加载初始化文件时将 =debug-on-error 绑定为 t，并绕过通常捕获初始化文件中的错误的 condition-case。 今天我就讲到这里。希望你今天学到了一些有用的东西，下次遇到错误时，你能迅速解决它！ ","date":"2025-03-04","objectID":"/emacsredux_com_debugging-errors-in-emacs/:0:0","tags":["debug","backtrace","emacs"],"title":"Debugging Errors in Emacs","uri":"/emacsredux_com_debugging-errors-in-emacs/"},{"categories":null,"content":"最近读完了亚当·希金博特姆的《切尔诺贝利的午夜》一书，这是一部关于切尔诺贝利核事故的纪实作品。素材是来自作者十多年来进行的数百小时采访，以及许多信件，未出版的回忆录和近年来刚刚解密的档案。读这本书的时候，我每每被其中英勇无畏的英雄感动，同时也对为了维护自己地位而不顾他人生死、尸位素餐的 人们 感到愤慨，而每当能够从中看到某些现状的影子时候，又感到无奈和悲凉。 以下皆为原文摘录： 事故的根源在于设计缺陷以及其他： 中央政治局的决议也坦率承认了导致四号反应堆毁灭的那场事故的真正源头。决议指出，这场浩劫，“是因为 RBMK 反应堆建造中的缺陷，它没有满足全部安全要求”。 向整个世界披露这场灾难的真正根源：反应堆的自身设计；苏联核项目中存在的系统性的、长期的失误，以及神神秘秘、凡事抵赖的文化；监督这个项目具体实施的高级科学家们的傲慢自大。 “这场事故是不可避免的……即便没有发生在此时此地，也会发生在其他某个地方。”总理雷日科夫说。他认为，落在亚历山德罗夫和斯拉夫斯基手中的巨大权力冲昏了他们的头脑，导致他们造成了灾难性的后果。“在很长的一段时间里，我们一直在走向这个结局。” 这个核能大国的中心已经堕落到了何种程度：秘而不宣、漠不关心，傲慢自大、玩忽职守，以及设计和施工的低劣标准，早已成为一种文化。他看到，无论是 RBMK 反应堆，还是与之竞争的压水式 VVER 反应堆，都带着与生俱来的危险。 这场事故的根源，不仅在于那些设计了反应堆的人，也在于那个默许反应堆投入运行、欺瞒成风、官官相护的官僚体制。 有些地方很讽刺： 斥巨资研发的东西，实用起来不如玩具店的玩具： 一个耗费巨资开发出来、用于探查废墟的设备，第一次投入测试，便进退失据，哪怕是在面对最小的障碍时。操作人员必须反复地将它救出困境，直到它最后在一个高辐射区域彻底一动不动地停下来。 最后，初步的侦察工作终于在一台塑料坦克模型的帮助下开始了，它是一位科学家花了 12 卢布（相当于当时的 5 美元）在基辅的儿童世界玩具店买来的。这个玩具可以用一根长长的电线末端的电池动力操作盒加以控制，上面加装了辐射剂量计、温度计和一支高功率手电筒。 1970 年，他开始在莫斯科郊外的诺金斯克（Noginsk）军事试验基地进行实际演练。那里建起了一个遍地瓦砾、处处废墟的小城，专门用于模拟核毁灭之后的城市环境。他在那儿制定出了众多技术规范，并研发出许多大型工程设备，比如装甲挖掘机和推土机，以及带有伸缩臂和机械钳的 IMR-2 战斗工程车。5月初，这些设备已经部署到了切尔诺贝利特别禁区中放射性最强的区域。但现在，已经是 9 月份了。在 M 区，所有的计划和技术都失败了，塔拉卡诺夫不得不派出手下的战士参战，而他们手中的武器，只是铁锹而已。 对普通人性命的漠视： 中型机械制造部认为，自己的技术专家，比如建筑师、工程师、科学家、电气专家和放射剂量测定师，都是不可替代的人才，需要被保护起来，以避免过度暴露，这样才能够在禁区中工作尽可能长的时间。而那些通常已经人到中年的“游击队员”，却被当成愚昧、缺乏技能、可以牺牲的炮灰，被编制成排，一批接一批地扔到需要在高辐射区域出苦力的最前线。这些人在几个小时或几分钟内，就暴露于最大剂量的辐射之下，然后便被打发回家，用新的一批人肉炮弹取代。 在切尔诺贝利核电厂，值守 3 台幸存反应堆的操作人员，因为死去的同事被当成事故的罪魁祸首而士气大挫。尽管他们仍每天尽职尽责地干着工作，但许多人相信，真正的灾难原因并没有得到充分考虑，一些人认为，同样的事很可能会发生在他们头上。几乎没有人想要住在斯拉夫蒂奇。 面临巨大危险时候，却仍歌舞升平： 10 点刚过，兴高采烈的人群便开始大步走过宽阔的十字大街。太阳暖洋洋的，空气中洋溢着节日的气息。红旗汇成了一片海洋，在春日中盛放的各色牡丹，魏紫姚黄，绚烂无比。一身灰色戎装、披着鲜红色饰带的党员老兵们整齐地列队走过，穿着白色队服、系着红领巾的女少先队员挥舞着樱花枝，身着乌克兰哥萨克人的传统服装、绣花上衣配阔腿灯笼裤的年轻舞者，时而手拉手排成长列，时而转着圈儿胡旋前进。 谎言和欺骗充斥于整个系统，在上下级之间双向传递：下属提交给上级的报告中充满虚假的统计数字和夸大的预测结果，不可能实现的目标被圆满达成，不可能达到的定额被英雄主义地超过。为了保住自己的位置，每一级的管理者不是将谎言层层上报，就是自己参与到编造谎言中去。 令人感慨： 在这里，事故发生一年多之后，街灯依然会在夜晚亮起，安装在库尔恰托夫大街两边的音箱，有时也会奏出歌剧音乐。但悬挂在中央广场上方那些曾经鲜艳的三角旗，已经被太阳晒褪了颜色，渐渐残破；晾晒在公寓阳台上的那些洗干净的衣物也开始腐烂。然而，苏联当局仍努力维持着这座城市并未死亡，只是暂时睡去的幻象，仿佛不知哪天早上，它就会被归人们的脚步声惊醒。 活下来的清理员们，也带着同样的恐惧，他们担心，从战场归来的自己，身上带着没人能看见的致命伤口。“我们知道，那个看不见的敌人正在身体内部像虫子一样吞食着我们。”尼古拉·安托什金将军说，他手下的直升机部队曾参与扑灭核燃料大火。“对我们来说，战争还在继续，我们正一点一点地从这个世界消失。” 与他从少年时代起就坚信的所有政治教条划地绝交，这位院士说，苏联科学已经迷失了方向。那些创造了苏联技术的辉煌壮举的人们，那些建成了第一座核电站、将尤里·加加林送上太空的人们，一直在为一个崭新的、更美好的社会而奋斗，其所作所为都秉承着源自普希金和托尔斯泰的崇高道德和勇敢坚毅。但这一源远流长的传统美德，却在他们手中断了线，只留下了一代技术精湛却道德败坏的年轻人。列加索夫认为，正是这种苏联社会实验的彻底失败，而不仅仅是几个冒失莽撞的反应堆操作人员，应当为四号反应堆爆炸所引发的那场巨大灾难负责。 也许人类只是过客： 深入这片废土之上的密林沼泽探险时，加夏克开始零星发现，很早以前就因捕猎和集体农业的影响而从乌克兰和白俄罗斯其他地区消失的生物，如狼，驼鹿，棕熊，珍稀猛禽，居然在这里出现了。他的观测记录，促使人们开始以新的视角打量这片隔离区，尽管看起来十分有悖直觉：事实证明，大自然能够以全新的、不可预测的方式完成自愈。在没有人存在的情况下，植物和动物在一个放射性伊甸园里茁壮成长，欣欣向荣。 在这里的野生动物身上，科学家们开始注意到奇怪的新现象：刺猬、田鼠和鼩鼱都带上了放射性；绿头鸭开始出现遗传变异；在核电厂的冷却剂蓄水池中，鲢鱼长成了庞然大物；红树林周围的树木，叶子胀大到不正常的比例，巨型针叶树的松针变为正常尺寸的 10 倍，金合欢树的“叶片大如儿童的手掌”。 ","date":"2025-03-01","objectID":"/wexin%E5%88%87%E5%B0%94%E8%AF%BA%E8%B4%9D%E5%88%A9%E7%9A%84%E5%8D%88%E5%A4%9C/:0:0","tags":["weixin","biji"],"title":"切尔诺贝利的午夜","uri":"/wexin%E5%88%87%E5%B0%94%E8%AF%BA%E8%B4%9D%E5%88%A9%E7%9A%84%E5%8D%88%E5%A4%9C/"},{"categories":null,"content":" Table of Contents 1 给 git 添加新的文本转换处理器 2 指示 git 为每种文件类型应用正确的处理器 本文为摘录(或转载)，侵删，原文为： https://www.onwebsecurity.com/configuration/diff-binary-files-docx-odt-pdf-with-git.html 处理二进制文件类型，如 Microsoft Word XML 格式的文档 docx、OpenDocument 文本 odt 格式和便携式文档格式 pdf，搭配 git 使用时会遇到一些困难。默认情况下，git 仅提供文本格式的差异比较。不支持以文本格式比较二进制文件。 通过简单的配置更改和一些开源的跨平台工具，git 可以适应这些格式的差异比较。 ","date":"2025-02-27","objectID":"/www_onwebsecurity_com_configuration_diff-binary-files-docx-odt-pdf-with-git/:0:0","tags":["git","docx","diff"],"title":"Diff binary files like docx, odt and pdf with git","uri":"/www_onwebsecurity_com_configuration_diff-binary-files-docx-odt-pdf-with-git/"},{"categories":null,"content":"1 给 git 添加新的文本转换处理器 在安装了这两个程序和封装器之后，接下来需要告诉 git 如何将二进制文件类型转换为文本格式。可以通过修改全局 git 配置来完成： git config --global diff.docx.textconv pandoc --to=rst git config --global diff.odt.textconv pandoc --to=rst git config --global diff.pdf.textconv pdftostdout 这为每种文件类型创建了新的差异处理器。 注意 使用参数 –to=rst 指定 pandoc 使用 reStructuredText 格式。这使得比较层级比仅使用纯文本格式更容易。 ","date":"2025-02-27","objectID":"/www_onwebsecurity_com_configuration_diff-binary-files-docx-odt-pdf-with-git/:1:0","tags":["git","docx","diff"],"title":"Diff binary files like docx, odt and pdf with git","uri":"/www_onwebsecurity_com_configuration_diff-binary-files-docx-odt-pdf-with-git/"},{"categories":null,"content":"2 指示 git 为每种文件类型应用正确的处理器 最后，git 需要知道使用哪个转换处理器来处理哪种文件类型。这可以通过修改全局 gitattributes [4] 文件来完成。 gitattributes 文件定义了每个路径或每个文件的属性。这意味着您可以为每种文件类型指定处理器，它将自动使用正确的工具将二进制格式转换为文本格式。 gitattributes 文件可以在本地（每个 git 仓库）、每个系统或全局作用域中指定。全局通常是首选选项，因为这意味着每个用户只需配置一次，在每个仓库中使用。全局 gitattributes 文件可以在 $HOME/.config/git/attributes 中找到。 注意: 由于全局和系统 git 属性文件具有最低的优先级，它们可以在本地轻松被覆盖。这可以通过在仓库的根目录创建 .gitattributes 文件来完成。 以下代码片段将为每种文件类型添加正确的转换处理器到全局 git 配置： echo \"*.docx diff=docx\" \u003e\u003e ~/.config/git/attributes echo \"*.odt diff=odt\" \u003e\u003e ~/.config/git/attributes echo \"*.pdf diff=pdf\" \u003e\u003e ~/.config/git/attributes 这就是全部内容。现在 git diff 将以纯文本格式显示 docx、odt 和 pdf 的所有更改。 任何二进制格式都可以使用 git 进行差异比较，只要有工具将二进制格式转换为纯文本。只需以相同的方式添加转换处理器和属性即可。 [1] https://pandoc.org/ [2] http://docutils.sourceforge.net/rst.html [3] https://poppler.freedesktop.org/ [4] https://git-scm.com/docs/gitattributes ","date":"2025-02-27","objectID":"/www_onwebsecurity_com_configuration_diff-binary-files-docx-odt-pdf-with-git/:2:0","tags":["git","docx","diff"],"title":"Diff binary files like docx, odt and pdf with git","uri":"/www_onwebsecurity_com_configuration_diff-binary-files-docx-odt-pdf-with-git/"},{"categories":null,"content":" Table of Contents 1 准备威胁建模 1.1 组建虚拟团队 1.2 威胁建模的四个阶段 2 注册功能威胁建模例子 2.1 我们在做什么？ 2.2 会出什么问题？识别功能威胁 2.3 3、我们要怎么做？确定威胁的优先级并选择缓解措施 2.4 4、我们做得足够好吗？评估威胁建模过程的有效性 3 附录 3.1 威胁建模模板 3.2 参考资料 本文为摘录(或转载)，侵删，原文为： https://cloud.tencent.com/developer/article/2159953 ","date":"2025-02-22","objectID":"/cloud_tencent_com_article_2159953/:0:0","tags":["stride","model","weixie"],"title":"AWS教你如何做威胁建模-腾讯云开发者社区-腾讯云","uri":"/cloud_tencent_com_article_2159953/"},{"categories":null,"content":"1 准备威胁建模 ","date":"2025-02-22","objectID":"/cloud_tencent_com_article_2159953/:1:0","tags":["stride","model","weixie"],"title":"AWS教你如何做威胁建模-腾讯云开发者社区-腾讯云","uri":"/cloud_tencent_com_article_2159953/"},{"categories":null,"content":"1.1 组建虚拟团队 威胁建模需要听取多种不同观点和经验才能进行，每个团队成员的意见都需要重视，最终在安全、交付、业务之间取得权衡。不能仅仅是安全和技术参与，checklist，卡点反而是阻碍威胁建模效果的瓶颈。 具体来说需要五个角色： 威胁建模专家： 是一次威胁建模活动的主导者，经验丰富、洞察威胁建模的过程和控制讨论边界，这个主持人、教练、顾问要参与一线，最终总结材料文档，平时同时兼职攻击者和防守者两个角色。 攻击者： 发现设计类安全缺陷，类似于沙盘方式设身处地从攻击角度进行头脑风暴。 防守者： 避免安全防御措施过度设计，设计威胁控制措施。 开发人员： 主力模块开发者或者系统架构师，有了解当前服务具体如何设计和实现的背景，负责清楚明白威胁和缓解措施。 产品经理： 类似于交付经理，避免安全措施导致产品需求无法实现，达到安全、效率和体验的平衡。 ","date":"2025-02-22","objectID":"/cloud_tencent_com_article_2159953/:1:1","tags":["stride","model","weixie"],"title":"AWS教你如何做威胁建模-腾讯云开发者社区-腾讯云","uri":"/cloud_tencent_com_article_2159953/"},{"categories":null,"content":"1.2 威胁建模的四个阶段 通过在不同的阶段尝试结构化思考回答四个问题： 我们在做什么？ 参与者：全部虚拟团队成员 交付和设计更安全的软件 会出什么问题？ 参与者：攻击者、开发者 STRIDE 助记符、内部人员风险、OWASPTop10、数据安全风险、组织内部的威胁列表 我们要怎么做？ 参与者：防守者、开发者、产品经理 代码控制方案、引入纵深防御、借助云服务的安全措施，评估改进后的方案不影响需求。 我们做得足够好吗？ 参与者：威胁建模专家，开发人员 威胁建模是对风险的分析，这个判断是否足够好的阶段区分： 威胁建模专家审核威胁已经“足够全”，认可缓解措施； 开发者交付缓解措施，进行再次 code review； 威胁建模专家评估验收标准，根据威胁建模的结果引入安全测试、结项； 威胁建模专家归档建模结果、更新知识库，整合各项缓解措施到平台级别的安全基线中，与 SDLC 工具深度集成。 ","date":"2025-02-22","objectID":"/cloud_tencent_com_article_2159953/:1:2","tags":["stride","model","weixie"],"title":"AWS教你如何做威胁建模-腾讯云开发者社区-腾讯云","uri":"/cloud_tencent_com_article_2159953/"},{"categories":null,"content":"2 注册功能威胁建模例子 接下来以在 AWS 上的一个车联网服务解决方案为例解答如何创建系统模型和威胁模型，以及评估模型的有用性。车联网解决方案通常包括物联网车辆、驾驶员、车辆登记、遥测数据等多种模块，这是一个复杂的系统，所以要分解到功能、应用服务模块进行建模，而不是一开始为整个系统创建威胁模型。 本次的例子拆分到 story 维度，简化为“作为⻋队经理，我想注册现有的物联⽹连接⻋辆以使其投⼊使⽤。”具体场景技术设计上，⻋队经理将使⽤标准 Web 浏览器访问 Web ⻔⼾、进行⾝份验证，并能够将新⻋辆注册到系统中并投⼊使⽤。 Figure 1: 车辆注册模块流程图 ","date":"2025-02-22","objectID":"/cloud_tencent_com_article_2159953/:2:0","tags":["stride","model","weixie"],"title":"AWS教你如何做威胁建模-腾讯云开发者社区-腾讯云","uri":"/cloud_tencent_com_article_2159953/"},{"categories":null,"content":"2.1 我们在做什么？ 为车辆登记功能创建系统模型。我们需要完成下面任务。 2.1.1 首先将准备创建数据流图表示上述车辆登记功能的元素，以及它们之间的数据流。 需要的工具就可以是白纸、白板，或者是 draw.io 或者 PlantUML。根据上述系统设计图中了解到系统以 AWS Amplify 托管前端静态资源，Amazon Cognito 集成做身份验证，由 AWS Lambda 和 Amazon API Gateway 提供的基于 REST 的 API，后端通过 DynamoDBTable 和 S3 进行存储。 2.1.2 绘制系统元素、数据流和信任边界 在元素之间，通过绘制箭头来表示数据如果通过车辆登记功能流动，箭头的方向就是数据流的方向，对于 http、rpc 请求意味着必然会向调用者返回响应，不必添加返回箭头，存储和查询可以是单向的。 2.1.3 1.3、绘制信任边界 确定车辆注册功能的哪些区域和元素组可以被认为是同等受信任的，化为同一信任域，在每个区域周围绘制虚线框来显示信任边界的未知，并添加标签来显示信任域的用途，以下绘制完成的车辆注册功能数据流图。 ","date":"2025-02-22","objectID":"/cloud_tencent_com_article_2159953/:2:1","tags":["stride","model","weixie"],"title":"AWS教你如何做威胁建模-腾讯云开发者社区-腾讯云","uri":"/cloud_tencent_com_article_2159953/"},{"categories":null,"content":"2.2 会出什么问题？识别功能威胁 开始你的威胁建模头脑风暴，没有错误的答案，我们的目标是尽可能完整得涵盖可能的威胁，不预设可能已经会被缓解的威胁。 2.2.1 2.1 使⽤ STRIDE-per-Element 查找对⻋辆登记功能的威胁 每个元素，即人类参与者、外部实体、流程、数据存储和数据流可以被对应到不同的 STRIDE 威胁。 2.1.1 外部实体的威胁由于是注册功能，所以有外部实体 User，从上述的 STRIDE-per-Element 图表中，我们看到会有 Spoofing（欺骗）和 Repudiation （否认）威胁，这里不再详述。 2.1.2 对 Process 的威胁： 欺骗:进程的⾝份欺骗是指与其连接的每个元素，比如在同 Amazon S3 通信时可以假装（欺骗）为 Lambda 的身份，恶意连接数据库。 篡改：如果进程的代码、配置或执行环境（如内存空间）以意想不到的⽅式被修改，则可能会篡改进程。考虑如何篡改⻋辆登记功能中的流程。例如是否可以向 Lambda 函数提供输⼊以修改函数的行为？ 否认：Lambda 函数是否可以在不⽣成审计跟踪条⽬的情况下删除存储桶对象，从⽽不归因于执行了该操作？ 信息泄露：Lambda 函数如何返回对错误 S3 对象的引⽤？ 拒绝服务：⾮常⼤的对象是否会导致 Lambda 函数出现问题？ 权限提升：车辆注册一般不存在普通用户和管理的区别，这里忽略威胁。 2.1.3 对数据存储的威胁：数据存储可能面临篡改、信息泄露和拒绝服务的风险。 拒绝：如果系统设计中没有对系统日志进行存储，应该不会有拒绝威胁。 否认：系统本身没有日志记录，所以没有否认威胁。 泄露泄露：恶意人员如何从 DynamoDB 表中读取数据，或读取存储在 Amazon S3 存储桶内的对象中的数据？ 拒绝服务：恶意人员如何从 Amazon S3 存储桶中删除对象？ 2.1.4 数据流：当数据流过可能被恶意破坏的通道时比如共享⽹络、中间人，该数据可能会在传输过程中被修改。 信息泄露：当敏感数据流经不被认为是完全可信的⽹络（如共享⽹络）时，该数据可能会泄露给⾮预期的接收者。 拒绝服务：数据流也可能是拒绝服务威胁的⽬标，通常表⽰为影响连接的事件，例如⽹络隔离事件或严重的数据包丢失，阻⽌⽤⼾与 API Gateway 通信。 2.2.2 2.2、确定优先级 检查完威胁是否存在重复或者漏过的情况后，通过估算与影响相比的缓解成本来分高、中、低优先级，威胁发生的影响*可能性=风险程度，OWASP Risk Rating Methodology 提供类似于 DREAD 的风险判断方法。 OWASP 的风险评估模型 ","date":"2025-02-22","objectID":"/cloud_tencent_com_article_2159953/:2:2","tags":["stride","model","weixie"],"title":"AWS教你如何做威胁建模-腾讯云开发者社区-腾讯云","uri":"/cloud_tencent_com_article_2159953/"},{"categories":null,"content":"2.3 3、我们要怎么做？确定威胁的优先级并选择缓解措施 通过一些安全设计原则和最佳实践将⻛险缓解资源集中在特定服务的威胁上。采用一些基础的安全服务如 AWS IAM、CLoudWatch Log、 CloudTrail、SecurityHub、KMS、加密 SDK 等。 如果不能解决，选择是减轻⻛险、接受⻛险或将两者结合起来。 如果由于缓解的成本或复杂性⽽⽆法合理缓解⻛险，那么接受⻛险是唯⼀的选择，无论风险大小时，接受风险要取得上级的审核，不同管理层对安全的态度是不一样的。 ","date":"2025-02-22","objectID":"/cloud_tencent_com_article_2159953/:2:3","tags":["stride","model","weixie"],"title":"AWS教你如何做威胁建模-腾讯云开发者社区-腾讯云","uri":"/cloud_tencent_com_article_2159953/"},{"categories":null,"content":"2.4 4、我们做得足够好吗？评估威胁建模过程的有效性 威胁建模是一项“安全社交活动”，结尾通过以下问题思考威胁建模过程对组织的有效性： 1、我们知道我们在做什么吗？–是否有合适的资源、工具、流程、文化来执行威胁建模？ 2、我们知道会出什么问题吗？–发现的威胁数量是否符合预期？发现的威胁是否⽐预期的更多、相同或更少？ 3、我们做了什么？–缓解措施是否充分缓解了发现的威胁？ 4、我们执行得好吗？–威胁建模过程是否可以改进？能否真正改进了“车辆登记功能”的安全性？今后是否会为其他功能模块进行威胁建模？ 总而言之，威胁建模是一项投资——在笔者看来，这是一项很好的投资，因为与以后发现威胁相比，在功能的设计阶段发现和缓解威胁可以降低缓解的相对成本。随着时间的推移，持续实施威胁建模也可能会改善组织的安全状况。 ","date":"2025-02-22","objectID":"/cloud_tencent_com_article_2159953/:2:4","tags":["stride","model","weixie"],"title":"AWS教你如何做威胁建模-腾讯云开发者社区-腾讯云","uri":"/cloud_tencent_com_article_2159953/"},{"categories":null,"content":"3 附录 ","date":"2025-02-22","objectID":"/cloud_tencent_com_article_2159953/:3:0","tags":["stride","model","weixie"],"title":"AWS教你如何做威胁建模-腾讯云开发者社区-腾讯云","uri":"/cloud_tencent_com_article_2159953/"},{"categories":null,"content":"3.1 威胁建模模板 3.1.1 1、威胁假设 ID 描述假设-1 3.1.2 2、威胁模型 优先级 威胁 ID 标题 细节 潜在的威胁措施 选定的威胁措施 是否有缓解措施 （是/否）威胁用户 1 攻击者将合法用户的 未经⾝份验证的攻击身份欺骗到 API 网关 者可以通过向 API Gateway 发出请求来列出、存储、检 索或搜索⽂档。威胁-KMS-1 攻击者伪造 KMS 的身份 攻击者可以伪装成 lambda KMS，例如通过篡改 DNS，以诱骗 Lambda 使⽤它来加 密/解密对象⽽不是真正的 KMS ","date":"2025-02-22","objectID":"/cloud_tencent_com_article_2159953/:3:1","tags":["stride","model","weixie"],"title":"AWS教你如何做威胁建模-腾讯云开发者社区-腾讯云","uri":"/cloud_tencent_com_article_2159953/"},{"categories":null,"content":"3.2 参考资料 https://www.youtube.com/watch?v=Yt0PhyEdZXU\u0026ab_channel=AdamShostack https://github.com/adamshostack/4QuestionFrame https://www.youtube.com/watch?v=GuhIefIGeuA\u0026ab_channel=AWSEvents https://github.com/michenriksen/drawio-threatmodeling https://owasp.org/www-community/Application_Threat_Modeling https://owasp.org/www-community/OWASP_Risk_Rating_Methodology ","date":"2025-02-22","objectID":"/cloud_tencent_com_article_2159953/:3:2","tags":["stride","model","weixie"],"title":"AWS教你如何做威胁建模-腾讯云开发者社区-腾讯云","uri":"/cloud_tencent_com_article_2159953/"},{"categories":null,"content":" Table of Contents 1 Entries ","date":"2025-02-19","objectID":"/%E7%AC%94%E8%AE%B0%E5%88%87%E5%B0%94%E8%AF%BA%E8%B4%9D%E5%88%A9%E7%9A%84%E5%8D%88%E5%A4%9C-%E8%8B%B1-%E4%BA%9A%E5%BD%93%E5%B8%8C%E9%87%91%E5%8D%9A%E7%89%B9%E5%A7%86%E9%B2%81%E4%BC%8A/:0:0","tags":["qieernuobeil","note","ireader"],"title":"[笔记]切尔诺贝利的午夜-[英] 亚当·希金博特姆;鲁伊","uri":"/%E7%AC%94%E8%AE%B0%E5%88%87%E5%B0%94%E8%AF%BA%E8%B4%9D%E5%88%A9%E7%9A%84%E5%8D%88%E5%A4%9C-%E8%8B%B1-%E4%BA%9A%E5%BD%93%E5%B8%8C%E9%87%91%E5%8D%9A%E7%89%B9%E5%A7%86%E9%B2%81%E4%BC%8A/"},{"categories":null,"content":"1 Entries 188-190, 标注, 2025 年 2 月 13 日星期四 上午 8:33:36 1969 年 7 月，美国宇航员完成登月的最后准备，苏联能源与电气化部部长发出了大力发展核能建设的号召。他设立了雄心勃勃的目标，苏联的欧洲部分将建起一个由全新的核电站串起的电网，从芬兰湾到里海，众多规模巨大、发电能力惊人的反应堆将拔地而起。 217-219, 标注, 2025 年 2 月 13 日星期四 上午 8:38:34 劳动突击队员挖好了第一座反应堆坑室，在沙壤中开凿出一个巨大的蓄水池，那是一个 11 公里长、2.5 公里宽的人工湖，未来会为运行中的 4 座巨型反应堆提供至为关键的数百万立方米的冷却水。 239-242, 标注, 2025 年 2 月 13 日星期四 下午 1:14:39 这是通病吗… 年轻的厂长在切尔诺贝利开始工作的时候，社会主义的经济试验正在开倒车。长达数十年的中央计划经济、昏庸的官僚主义、庞大的军费开支和泛滥的贪污腐败，已经令苏联不堪重负，开始进入“停滞时期”（Era of Stagnation）。在几乎每个行业，都是一幕物资短缺、生产停滞、盗窃公物和挪用公款蔓延成风的衰败景象。核工程自然也不例外。 255-256, 标注, 2025 年 2 月 13 日星期四 下午 1:19:11 在苏联停滞时期犯下的所有大错背后，是那些计划经济下的疯狂夺权、任人唯亲、人浮于事和铺张浪费…… 275-279, 标注, 2025 年 2 月 13 日星期四 下午 6:32:42 用小说家和历史学家皮尔斯·保罗·里德的话来说，这些杀人不眨眼的官僚“有着一张卡车司机的脸，却长着钢琴师的手”。日复一日地忍受领导们夹杂着污言秽语的尖声训话所带来的羞辱，在几乎每个工作单位都是司空见惯之事。这助长了一种自下而上的文化，溜须拍马之徒学会了揣摩领导的意图，对他们说的每一句话都唯唯诺诺，同时又对自己的下级耀武扬威，百般威胁。当领导的提议需要投票表决时，他会理所应当地认为，每一次都能全票通过——暴力诚然战胜了理性。 282-284, 标注, 2025 年 2 月 13 日星期四 下午 6:40:02 谎言和欺骗充斥于整个系统，在上下级之间双向传递：下属提交给上级的报告中充满虚假的统计数字和夸大的预测结果，不可能实现的目标被圆满达成，不可能达到的定额被英雄主义地超过。为了保住自己的位置，每一级的管理者不是将谎言层层上报，就是自己参与到编造谎言中去。 355-356, 标注, 2025 年 2 月 13 日星期四 下午 6:51:05 遭到反复敲打，不断屈从于上级意志，昔日博学强记、直率坦诚的年轻专家，已经变成了党政大员们听话的工具。 354-356, 标注, 2025 年 2 月 13 日星期四 下午 6:51:14 维克托·布留哈诺夫慢慢学会了面对官僚系统里的现实。遭到反复敲打，不断屈从于上级意志，昔日博学强记、直率坦诚的年轻专家，已经变成了党政大员们听话的工具。 486-488, 标注, 2025 年 2 月 14 日星期五 下午 12:50:54 严重暴露于所有三种致电离辐射之下，会导致急性辐射综合症（ARS），人体就如同一只布偶，被拆个稀烂再重新拢在一起，每一丝每一缕都遭到摧毁。急性辐射综合症的症状包括恶心、呕吐、出血和脱发，接着是整个免疫系统崩溃，骨髓失去功能，内脏器官破碎，最终死亡。 595-595, 标注, 2025 年 2 月 14 日星期五 下午 1:26:56 中子慢化剂——水或石墨，它们可以令铀的中子运动减速，从而实现彼此撞击—— 663-665, 标注, 2025 年 2 月 14 日星期五 下午 1:30:32 经济形势也不站在他们这一边：建造核反应堆投资浩大，而苏联又是个化石燃料储量丰富的国家，尤其是在西伯利亚广袤无垠的荒原之下，几乎每天都会发现新的石油和天然气储藏。 845-847, 标注, 2025 年 2 月 17 日星期一 上午 8:04:41 1957 年，就是在那里，人造地球卫星（Sputnik）横空出世。外人眼中的一个由粗手大脚的庄稼汉组成的帝国，第一次粉碎了美国对自身技术优越性的傲慢偏见。 1042-1045, 标注, 2025 年 2 月 17 日星期一 上午 8:29:51 工程计算表明，如果 1600 个压力管中超过 2 根，哪怕只是 3 到 4 根压力管同时破裂的话，瞬间释放出的高压蒸汽就可能将 2000 吨的叶连娜和“猪鼻子”掀离原位，切断剩下的每一根蒸汽管和压力管，导致一场破坏力惊人的爆炸。然而，设计师们觉得没有必要为这种情况做出准备，在他们看来，那完全是在可能范围以外的事。不过，他们还是为这种情况起了个名字，超设计基准事故（beyond design-basis accident）。 1095-1097, 标注, 2025 年 2 月 17 日星期一 下午 6:37:47 要将这些 AZ-5 控制棒从反应堆上方完全抽出的位置彻底插入堆芯，需要 18—21 秒的时间。设计师们希望，控制棒缓慢的插入速度可以通过其庞大数量予以弥补。但在中子物理中，18 秒是一段相当长的时间，而在一个处于高度正空泡效应下的核反应堆里，这几乎相当于永恒。 1209-1211, 标注, 2025 年 2 月 17 日星期一 下午 6:50:26 能源技术科学研究与设计院发布了一份通知，提醒所有 RBMK 核电厂高级管理人员注意正紧急停堆效应。然而，混杂在雪片般纷飞的官僚主义文件材料中，再加上措辞神神秘秘、欲说还休，这些消息从来就没能传到反应堆操作人员的耳中。 1440-1443, 标注, 2025 年 2 月 22 日星期六 上午 8:41:20 巨大的主循环泵上的止回阀关闭了，所有困在堆芯的残留水分，瞬间化为蒸汽。一道中子脉冲从将死的反应堆中激涌而出，热能达到了超过 120 亿瓦的峰值。密封的反应堆内部空间中的蒸汽压力呈指数级剧增，每秒钟 8 个大气压，将 2000 吨重的钢筋混凝土上部生物屏障“叶连娜”顶离原位，并将焊接其上的压力管齐齐切断。反应堆内部的温度升高到了摄氏 4650 度，只略微逊色于太阳表面温度。 1443-1443, 笔记, 2025 年 2 月 22 日星期六 上午 8:42:13 这个力量,是不是不应该由人类掌控。 2086-2088, 标注, 2025 年 2 月 24 日星期一 上午 7:00:47 核电厂操作人员试图用水冷却已经炸碎的反应堆堆芯的英勇而又徒劳的做法，只是令三号机组和四号机组的地下室空间中注满了被污染的水，从而令放射性蒸汽云不断地涌入大气。此外， 2086-2088, 标注, 2025 年 2 月 24 日星期一 上午 7:00:55 核电厂操作人员试图用水冷却已经炸碎的反应堆堆芯的英勇而又徒劳的做法，只是令三号机组和四号机组的地下室空间中注满了被污染的水，从而令放射性蒸汽云不断地涌入大气。此外，放射性悬浮颗粒的毒潮也从四号反应堆的大坑中，汹涌地散入空气。 2108-2110, 标注, 2025 年 2 月 24 日星期一 上午 8:00:03 更紧迫的，是国家对保密的强制要求。到星期六黎明拂晓时，内务部警察部队已经用路障封锁了整个地区，克格勃随后也切断了这个城市的长途电话线。等到黄昏降临时，本地的电话线路也被切断了， 2208-2212, 标注, 2025 年 2 月 24 日星期一 上午 8:12:48 从 604 房间被同事救出的弗拉基米尔·沙什诺克，是第一批送到的伤员。他的身上满是烧伤和水疱，肋骨塌陷，背上显然还有骨折。然而，当他被抬进来时，护士看见他的嘴唇在动，他正努力说话。她俯下身去。“离我远点儿——我是从反应堆隔间里出来的。”他说。 护士剪开粘在他皮肤上的已经成了碎片的脏衣服，把他安顿在重症监护室的病床上，但她们几乎什么都做不了。凌晨 6 点，沙什诺克死了。 2232-2235, 标注, 2025 年 2 月 24 日星期一 上午 8:17:43 普里皮亚季的许多公寓楼和主要建筑，文化宫、旅馆、市执行委员会大楼等，都是根据出自莫斯科的标准化图纸而建造的，它们的设计初衷，就是为了让苏联境内的每一个城市可以原封不动地照搬。但普罗岑科想方设法让自己的建筑尽可能地独特。尽管主流的国家主义审美呼唤“无产阶级美学”，出于经济实惠的考虑而拒绝放纵的西方个人主义，她却希望建筑物是美丽的。 2273-2275, 标注, 2025 年 2 月 24 日星期一 上午 8:22:51 在白房子二楼，一批人找到了普罗岑科。她手头有城市地图，但没办法复印。复印机可以被用来印制非法出版物，因此在苏联，使用为数极少的那些复印机的权力，牢牢掌握在克格勃手中。 2413-2413, 笔记, 2025 年 2 月 24 日星期一 下午 12:17:24 1984? 2528-2531, 标注, 2025 年 2 月 24 日星期一 下午 12:28:34 请注意！请注意！亲爱的同志们！市人民代表大会敬告各位，因为在普里皮亚季市的切尔诺贝利核电厂发生了一起事故，不利的辐射条件正在形成中。党和苏联的各级组织及武装部队已经采取了必要的措施。然而，为了确保人民群众，尤其是少年儿童的彻底安全，将城市居民暂时疏散到基辅附近地区势在必行…… 2605-2607, 标注, 2025 年 2 月 24 日星期一 下午 1:09:08 这位委员会主席对待辐射危险的傲慢轻蔑态度，就如同一名骑兵军官纵马穿过炮火连天的战场。委员会中所有的人都以他为榜样：监测身边的放射性似乎成了不明智的做法。在这些部长中，洋溢着一股苏联式的英雄主义","date":"2025-02-19","objectID":"/%E7%AC%94%E8%AE%B0%E5%88%87%E5%B0%94%E8%AF%BA%E8%B4%9D%E5%88%A9%E7%9A%84%E5%8D%88%E5%A4%9C-%E8%8B%B1-%E4%BA%9A%E5%BD%93%E5%B8%8C%E9%87%91%E5%8D%9A%E7%89%B9%E5%A7%86%E9%B2%81%E4%BC%8A/:1:0","tags":["qieernuobeil","note","ireader"],"title":"[笔记]切尔诺贝利的午夜-[英] 亚当·希金博特姆;鲁伊","uri":"/%E7%AC%94%E8%AE%B0%E5%88%87%E5%B0%94%E8%AF%BA%E8%B4%9D%E5%88%A9%E7%9A%84%E5%8D%88%E5%A4%9C-%E8%8B%B1-%E4%BA%9A%E5%BD%93%E5%B8%8C%E9%87%91%E5%8D%9A%E7%89%B9%E5%A7%86%E9%B2%81%E4%BC%8A/"},{"categories":null,"content":" Table of Contents 1 配置 Github 仓库 2 使配置好的仓库安装 Giscus 3 从官网获取配置信息 4 参考文章 本文为摘录(或转载)，侵删，原文为： https://stilig.me/posts/hugo-adds-giscus/ 捣鼓了这么多天，看见别人的博客都有评论功能，十分羡慕，所以我在想有什么轻量又简单的方法，能让我的博客也能有评论功能，而这时我找到了 Giscus。 Giscus 是一个由 Github Discussions 驱动的评论系统，无需自己单独配置，直接白嫖 Github 的资源即可，而且 UI 和功能都十分的合适我，配合 LoveIt 的配置可以做到十分美观。 ","date":"2025-02-16","objectID":"/stilig_me_hugo-adds-giscus/:0:0","tags":["comment","hugo","giscus"],"title":"（转载）Hugo 添加 Giscus 评论","uri":"/stilig_me_hugo-adds-giscus/"},{"categories":null,"content":"1 配置 Github 仓库 如下图，创建一个公开的 Github 仓库 找到 Settings -\u003e General -\u003e Features -\u003e Discussions 勾选，为仓库启动 Discussions 功能 ，如下图 ","date":"2025-02-16","objectID":"/stilig_me_hugo-adds-giscus/:1:0","tags":["comment","hugo","giscus"],"title":"（转载）Hugo 添加 Giscus 评论","uri":"/stilig_me_hugo-adds-giscus/"},{"categories":null,"content":"2 使配置好的仓库安装 Giscus 点击这里，我们将会看到下面的界面，我们点击安装 点击安装后，要选择一个仓库，如下图，选择我们之前创造的仓库即可 我遇到的问题 我创了个新号打算试试，但是发现点击安装后直接 404 ，估计是对新创的号有限制吧。 ","date":"2025-02-16","objectID":"/stilig_me_hugo-adds-giscus/:2:0","tags":["comment","hugo","giscus"],"title":"（转载）Hugo 添加 Giscus 评论","uri":"/stilig_me_hugo-adds-giscus/"},{"categories":null,"content":"3 从官网获取配置信息 接下来，我们只需到 Giscus 官网获取配置信息，然后将配置信息填到 Hugo 的配置文件中即可。但是由于主题的不同，所以配置文件的填写也不同，这里以 LoveIt 为例。 来到 Giscus 官网 填写你的仓库名，如下图 选择页面与嵌入的 discussion 之间的映射关系，如下图 pic-06 直接选第一个就行 选择 Discussion 分类，如下图 我们选择 Announcements 类型即可，官方也是这样推荐的，因为这样便于管理。 其他选项默认，我们往下滑，找到配置文件，如下图 pic-08 我们要记下 data-repo，data-repo-id，data-category，data-category-id，data-mapping 这几个值。 修改 Hugo 配置文件 注意 这里使用的 Hugo 一定要是最新的版本，不然是不支持 Giscus 的（比如 release 的版本就是不支持的，因此要下载源码）。 打开配置文件 config.toml，找到# 评论系统设置的第一个 enable 参量，将其改为 true，如下图： 找到# giscus comment 评论系统设置,并把其配置按照下面代码块修改。 [params.page.comment.giscus] # 你可以参考官方文档来使用下列配置 enable = true repo = \"\u003cyour_repo\u003e\" repoId = \"\u003cyour_repoId\u003e\" category = \"\u003cyour_category\u003e\" categoryId = \"\u003cyour_categoryId\u003e\" # \u003cyour_repo\u003e 对应官网的 data-repo # \u003cyour_repoId\u003e 对应官网的 data-repo-id # \u003cyour_category\u003e 对应官网的 data-category # \u003cyour_categoryId\u003e 对应官网的 data-category-id # 为空时自动适配当前主题 i18n 配置 lang = \"\" mapping = \"\u003cyour_mapping\u003e\" # \u003cyour_mapping\u003e 对应官网的 data-mapping reactionsEnabled = \"1\" emitMetadata = \"0\" inputPosition = \"bottom\" lazyLoading = false lightTheme = \"light\" darkTheme = \"dark_dimmed\" 配置好后,就可以开启 Giscus 评论系统了。 ","date":"2025-02-16","objectID":"/stilig_me_hugo-adds-giscus/:3:0","tags":["comment","hugo","giscus"],"title":"（转载）Hugo 添加 Giscus 评论","uri":"/stilig_me_hugo-adds-giscus/"},{"categories":null,"content":"4 参考文章 Hugo 博客引入 Giscus 评论系统 迁移博客评论系统从 Utteranc.es 到 Giscus Giscus 官网 ","date":"2025-02-16","objectID":"/stilig_me_hugo-adds-giscus/:4:0","tags":["comment","hugo","giscus"],"title":"（转载）Hugo 添加 Giscus 评论","uri":"/stilig_me_hugo-adds-giscus/"},{"categories":null,"content":" Table of Contents 1 所需软件 2 方法 2.1 advice to org-odt-export-to-odt 2.2 用到的资源文件 最近需要写一些 word 文档，因为一直在用 Emacs 的 org-mode, 不想离开 Emacs 环境，也不想去手动调整 word 格式，所以花些时间研究了一下怎么使用 pandoc 将 org 转换成 docx 。 ","date":"2025-02-15","objectID":"/%E7%94%A8-pandoc-%E4%BB%8E-org-%E7%94%9F%E6%88%90-docx/:0:0","tags":["org","pandoc","lua"],"title":"用 pandoc 从 org 生成 docx","uri":"/%E7%94%A8-pandoc-%E4%BB%8E-org-%E7%94%9F%E6%88%90-docx/"},{"categories":null,"content":"1 所需软件 emacs : i live in emacs pandoc : 文档转换界的瑞士军刀 pandoc-crossref : 一个 pandoc 过滤器，用于对图形、方程、表格进行编号以及对它们进行交叉引用 ","date":"2025-02-15","objectID":"/%E7%94%A8-pandoc-%E4%BB%8E-org-%E7%94%9F%E6%88%90-docx/:1:0","tags":["org","pandoc","lua"],"title":"用 pandoc 从 org 生成 docx","uri":"/%E7%94%A8-pandoc-%E4%BB%8E-org-%E7%94%9F%E6%88%90-docx/"},{"categories":null,"content":"2 方法 ","date":"2025-02-15","objectID":"/%E7%94%A8-pandoc-%E4%BB%8E-org-%E7%94%9F%E6%88%90-docx/:2:0","tags":["org","pandoc","lua"],"title":"用 pandoc 从 org 生成 docx","uri":"/%E7%94%A8-pandoc-%E4%BB%8E-org-%E7%94%9F%E6%88%90-docx/"},{"categories":null,"content":"2.1 advice to org-odt-export-to-odt Emacs 内置有命令 org-odt-export-to-odt 可以把 org 转换成 odt 格式，也可以再通过内置命令 org-odt-convert 来把 odt 转换成 docx ， 但这种方式生成的 word 文档在 wps 打开后，总是怪怪的，还是直接使用 pandoc 配合过滤器以及 reference-document 生成的文档看起来更舒服。所以我给 org-odt-export-to-odt 加了个 advice ，让他在转换成 odt 之后，直接调用 pandoc 来生成 docx 。之所以先生成 odt ，是为了在生成 odt 过程中 evaluate 各种 babel ，以便生成图片之类。 (yc/defmacro defadvice! (how places symbol arglist \u0026optional docstring \u0026rest body) \"Define an advice called SYMBOL and add it to PLACES. ARGLIST is as in `defun'. HOW is a keyword as passed to `advice-add', and PLACE is the function to which to add the advice, like in `advice-add'. DOCSTRING and BODY are as in `defun'.\" (declare (doc-string 5) (indent defun)) (unless (stringp docstring) (push docstring body) (setq docstring nil)) `(progn (defun ,symbol ,arglist ,docstring ,@body) (dolist (target (ensure-list ,places)) (advice-add target ,how #',symbol)))) (defadvice! :after 'org-odt-export-to-odt yc/org-odt-export-to-odt-a (\u0026rest args) \"Export to docx, then convert with pandoc. With prefix-arg, open after converted.\" (let* ((curr (buffer-file-name)) (tmp (s-concat curr \"_tmp.org\")) (r-link (rx \"[[\" (group (or \"fig\" \"tbl\") \":\" (+? nonl)) \"]]\"))) (with-temp-file tmp (insert (s-replace-regexp r-link \"[cite:@\\\\1]\" (yc/buffer-content :file curr)))) (yc/pandoc-convert-to-docx tmp (f-swap-ext curr \"docx\") t (s-contains? \"toc:nil\" (or (cadar (org-collect-keywords '(\"options\") nil '(\"options\"))) \"\"))))) 这里函数 yc/org-odt-export-to-odt-a 在 org-odt-export-to-odt 后执行，它会首先使用原始 org 文件生成一个临时文件，并将内置的 org 格式的引用替换成 pandoc 支持更好的 cite 方式，然后再根据 org header 中声明的是否自动生成 toc 来调用 yc/pandoc-convert-to-docx ： (defun yc/pandoc-convert-to-docx (\u0026optional ifile ofile delete no-toc) \"Convert FILES to docx.\" (interactive) (let ((it (or ifile (yc/choose (yc/get-files)))) (ofile (or ofile (f-swap-ext ifile \"docx\")))) (yc/interpret-command (s-join \" \" (list (yc/executable-find \"pandoc\" t) (unless no-toc \"--toc\") \"--filter=pandoc-crossref\" (format \"--lua-filter='%s'\" (yc/-locate-aux it \"doc_filter.lua\" \"~/.local/share/pandoc/doc_filter.lua\")) (format \"--metadata-file='%s'\" (yc/-locate-aux it \"metadata.yaml\" \"~/.local/share/pandoc/metadata.yaml\")) (format \"--reference-doc='%s'\" (yc/-locate-aux it \"custom-reference.docx\" \"~/.local/share/pandoc/custom-reference.docx\")) (format \"'%s' --from %s+east_asian_line_breaks -t docx -o \\\"%s\\\"\" it (pcase (f-ext it) (\"md\" \"markdown\") (_ (f-ext ifile))) ofile) (if delete (list \"; rm \" ifile)))) :infix \"convert-docx\" :popup 'auto :callback (lambda (f s) (if (not s) (error \"Convert failed...\") (message \"Convert finished...\" ) (if current-prefix-arg (let ((current-prefix-arg nil)) (yc/open-with-external-app ofile)))))))) 这个函数会检查本地的一些辅助文件，最终生成了一个 shell 脚本去执行，生成的脚本类似： /home/yyc/.emacs.d/lsp/bin/pandoc \\ --toc \\ --filter=pandoc-crossref \\ --lua-filter='/home/yyc/.local/share/pandoc/doc_filter.lua'\\ --metadata-file='/home/yyc/.local/share/pandoc/metadata.yaml' \\ --reference-doc='/home/yyc/.local/share/pandoc/custom-reference.docx' \\ 'tonydeng_github_io_threat-modeling-was-conducted-based-on-STRIDE.org_tmp.org' \\ --from org+east_asian_line_breaks \\ -t docx \\ -o \"tonydeng_github_io_threat-modeling-was-conducted-based-on-STRIDE.docx\" rm tonydeng_github_io_threat-modeling-was-conducted-based-on-STRIDE.org_tmp.org 用到的参数的具体含义，可以直接查看 pandoc --help 。 ","date":"2025-02-15","objectID":"/%E7%94%A8-pandoc-%E4%BB%8E-org-%E7%94%9F%E6%88%90-docx/:2:1","tags":["org","pandoc","lua"],"title":"用 pandoc 从 org 生成 docx","uri":"/%E7%94%A8-pandoc-%E4%BB%8E-org-%E7%94%9F%E6%88%90-docx/"},{"categories":null,"content":"2.2 用到的资源文件 doc_filter.lua 自己写的一个针对 docx 输出的过滤器,主要功能： 可以向 world 中插入分页符，只需要在 org 中插入下面这行即可： #+LATEX: \\newpage 可以手动生成 toc, 只需要在 org 中插入下面这行即可： #+LATEX: \\tableofcontents 可以手动添加多个空行： #+LATEX: \\vspace{90 mm} 10 mm 会替换成一个空行。 手动执行忽略某些内容 如果一个 header 中包含标签 nodocx ，那么它的内容将不会输出到 word 中。 custom-reference.docx 根据我自己的需要调整过的 word 模板，其中比较坑的表格的边框，开始时候不管怎样调，边框都是透明的，用 wps 和 libreoffice 都不行，直到最后用 ms office 调整过才生效。 metadata.yaml 其中含有 pandoc 和 pandoc-crossref 用的配置，主要是中文本土化。 ","date":"2025-02-15","objectID":"/%E7%94%A8-pandoc-%E4%BB%8E-org-%E7%94%9F%E6%88%90-docx/:2:2","tags":["org","pandoc","lua"],"title":"用 pandoc 从 org 生成 docx","uri":"/%E7%94%A8-pandoc-%E4%BB%8E-org-%E7%94%9F%E6%88%90-docx/"},{"categories":null,"content":" Table of Contents 1 Stop drawing, Start coding 2 Threat modeling and beyond 3 REFERENCE: 本文为摘录(或转载)，侵删，原文为： https://medium.com/flat-pack-tech/threat-modeling-as-code-f3555f5d9024 这个图解释了它为什么叫 C4: Figure 1: C4 ","date":"2025-02-14","objectID":"/c4-model/:0:0","tags":null,"title":"C4 \u0026 Plantuml","uri":"/c4-model/"},{"categories":null,"content":"1 Stop drawing, Start coding @startuml !include \u003cC4/C4_Container.puml\u003e Person(person1, \"Person 1\",\"\") System(system1, System 1, \"Description System 1\") System_Boundary(bounday1, \"Cloud Boundary 1\") { Container(container1, Container 1, \"Description Container 1\") ContainerDb(database1, Database 1, \"Description Database 1\") } Rel(person1, container1, Uses, \"HTTPS Request with JWT token\") Rel(container1, system1, Uses, \"Request to external API with Access Token\") Rel(container1, database1, \"Queries\", \"Data information per user identifier\") @enduml Figure 2: simple c4 In this example, we have used C4 Container level with the following entities: Person: Developers, end-users or attackers. System: External platforms. System Boundary: Cloud environments. Container: Our backend/frontend application. ContainerDb: Databases. ","date":"2025-02-14","objectID":"/c4-model/:1:0","tags":null,"title":"C4 \u0026 Plantuml","uri":"/c4-model/"},{"categories":null,"content":"2 Threat modeling and beyond @startuml !include \u003cC4/C4_Container.puml\u003e !include iuml_files/stride.puml Person(person1, \"Person 1\",\"\") System(system1, System 1, \"Description System 1\") System_Boundary(bounday1, \"Cloud Boundary 1\") { Container(container1, Container 1, \"Description Container 1\") ContainerDb(database1, $Stride(\"RI\")\\n===Database 1, \"Description Database 1\") } Rel(person1, container1, $AggregatedRisk(\"R1\") Uses, \"HTTPS Request with JWT token\") Rel(container1, system1, $AggregatedRisk(\"R2\") Uses, \"Request to external API with Access Token\") Rel(container1, database1, \"Queries\", \"Data information per user identifier\") $RiskTable() [ === Aggregated Risks ---- $AggregatedRisk(\"R1\") Details of aggregated risk number 1. ---- $AggregatedRisk(\"R2\") Details of aggregated risk number 2 ] @enduml Figure 3: stride model 通过这种方法，我们正在将信任边界从经典的威胁建模扩展到任何类型的系统表示。然而，我们并没有提供一种清晰的方法来表示模型中每个组件的信任和价值，因此我们需要创建一个信任:价值比率。 信任 是一个信心、完整性和可用性的评分模式，范围从 1 到 5，但下限和上限可以由您定义。例如，外围可能是 1，DMZ 也许是 3，而后端服务是 5。 价值 表示一种确定敏感数据在存储、转发和处理方面重要性的方法。 您的评分模式的边界应与信任比率中的边界相同。 @startuml !include \u003cC4/C4_Container.puml\u003e !include iuml_files/stride.puml Person(person1, \"Person 1\",\"\") System(system1, \u003csize:5\u003e$TrustValueRatio(\"1:3\")\\n===System 1, \"Description System 1\") System_Boundary(bounday1, \"Cloud Boundary 1\") { Container(container1, \u003csize:5\u003e$TrustValueRatio(\"2:5\")\\n===Container 1, \"Description Container 1\") ContainerDb(database1, \u003csize:5\u003e$TrustValueRatio(\"2:5\")\\n$Stride(\"RI\")\\n===Database 1, \"Description Database 1\") } Rel(person1, container1, $AggregatedRisk(\"R1\") Uses, \"HTTPS Request with JWT token\") Rel(container1, system1, $AggregatedRisk(\"R2\") Uses, \"Request to external API with Access Token\") Rel(container1, database1, \"Queries\", \"Data information per user identifier\") $RiskTable() [ === Aggregated Risks ---- $AggregatedRisk(\"R1\") Details of aggregated risk number 1. ---- $AggregatedRisk(\"R2\") Details of aggregated risk number 2 ] @enduml Figure 4: stride-with-trust-value ","date":"2025-02-14","objectID":"/c4-model/:2:0","tags":null,"title":"C4 \u0026 Plantuml","uri":"/c4-model/"},{"categories":null,"content":"3 REFERENCE: https://www.oreilly.com/library/view/threat-modeling/9781492056546/ch04.html ","date":"2025-02-14","objectID":"/c4-model/:3:0","tags":null,"title":"C4 \u0026 Plantuml","uri":"/c4-model/"},{"categories":null,"content":" 431-431, 标注, 2025 年 1 月 5 日星期日 下午 6:43:37 见其牝牡骊黄而弃其所谓千里者， 431-432, 标注, 2025 年 1 月 5 日星期日 下午 6:43:47 见其牝牡骊黄而弃其所谓千里者，意为：只见到马的雌雄黑黄而见不到其能驰骋千里的特质。比喻只看到事物的外表而看不到其本质。典出《淮南子·道应训》。 538-538, 标注, 2025 年 1 月 6 日星期一 下午 1:28:03 吾辈用功，只求日减，不求日增。减得一分人欲，便是复得一分天理”。（《 606-607, 标注, 2025 年 1 月 8 日星期三 下午 9:51:42 某尝说知是行的主意，行是知的功夫；知是行之始，行是知之成。 607-609, 标注, 2025 年 1 月 8 日星期三 下午 9:53:12 古人所以既说一个知又说一个行者，只为世间有一种人，懵懵懂懂的任意去做，全不解思惟省察，也只是个冥行妄作，所以必说个知，方才行得是；又有一种人，茫茫荡荡悬空去思索，全不肯着实躬行，也只是个揣摸影响，所以必说一个行，方才知得真。此 635-635, 标注, 2025 年 1 月 8 日星期三 下午 9:54:32 如好好色，如恶恶臭”， 677-678, 标注, 2025 年 1 月 9 日星期四 上午 8:18:53 也。‘知天’，如知州、知县之知，是自己分上事，已与天为一；‘ 677-678, 标注, 2025 年 1 月 9 日星期四 上午 8:19:08 也。‘知天’，如知州、知县之知，是自己分上事，已与天为一；‘事天’，如子之事父、臣之事君，须是恭敬奉承，然后能无失，尚与天为二。 677-678, 标注, 2025 年 1 月 9 日星期四 上午 8:19:19 也。‘知天’，如知州、知县之知，是自己分上事，已与天为一；‘事天’，如子之事父、臣之事君，须是恭敬奉承，然后能无失，尚与天为二。此便是圣、贤之别。 688-690, 标注, 2025 年 1 月 9 日星期四 上午 8:22:22 朱子解释“致知在格物”云，“致，推极也；知，犹识也。推极吾之知识，欲其所知无不尽也。格，至也；物，犹事也。穷至事物之理，欲其极处无不到也”。在朱子看来，格物就是探究事物的原理， 688-690, 标注, 2025 年 1 月 9 日星期四 上午 8:22:34 朱子解释“致知在格物”云，“致，推极也；知，犹识也。推极吾之知识，欲其所知无不尽也。格，至也；物，犹事也。穷至事物之理，欲其极处无不到也”。在朱子看来，格物就是探究事物的原理，用其《大学章句》“格物补传”的话说就是，“即物而穷其理也”。 694-695, 标注, 2025 年 1 月 9 日星期四 上午 8:24:28 孟子·尽心上》：“孟子曰：‘尽其心者，知其性也。知其性，则知天矣。存其心，养其性，所以事天也。夭寿不贰，修身以俟之，所以立命也。’” 698-698, 标注, 2025 年 1 月 9 日星期四 上午 8:26:58 ［四］“子夏笃信圣人，曾子反求诸己”，语出朱熹《孟子集注》。 714-715, 标注, 2025 年 1 月 9 日星期四 上午 8:29:38 阳明先生说：“朱子曾说‘子夏笃信圣人，曾子反求诸己’。笃信固然也是对的，然而不如反求于心那样切实。你如今既然不能自得于心，怎么可以拘泥于旧闻、不讲求个妥当无误呢？ ","date":"2025-02-07","objectID":"/%E7%AC%94%E8%AE%B0%E4%BC%A0%E4%B9%A0%E5%BD%95%E4%B8%AD%E5%8D%8E%E7%BB%8F%E5%85%B8%E5%90%8D%E8%91%97%E5%85%A8%E6%9C%AC%E5%85%A8%E6%B3%A8%E5%85%A8%E8%AF%91-%E4%B8%89%E5%85%A8%E6%9C%AC-%E7%8E%8B%E9%98%B3%E6%98%8E%E9%99%86%E6%B0%B8%E8%83%9C/:0:0","tags":null,"title":"[笔记]传习录（中华经典名著全本全注全译/三全本）-王阳明;陆永胜","uri":"/%E7%AC%94%E8%AE%B0%E4%BC%A0%E4%B9%A0%E5%BD%95%E4%B8%AD%E5%8D%8E%E7%BB%8F%E5%85%B8%E5%90%8D%E8%91%97%E5%85%A8%E6%9C%AC%E5%85%A8%E6%B3%A8%E5%85%A8%E8%AF%91-%E4%B8%89%E5%85%A8%E6%9C%AC-%E7%8E%8B%E9%98%B3%E6%98%8E%E9%99%86%E6%B0%B8%E8%83%9C/"},{"categories":null,"content":" Table of Contents 1 Entries ","date":"2025-02-07","objectID":"/%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B8%80%E6%80%A7%E5%8E%9F%E7%90%8621%E5%A0%82%E7%A7%91%E5%AD%A6%E9%80%9A%E8%AF%86%E8%AF%BE-%E8%8B%B1%E9%A9%AC%E5%BA%93%E6%96%AF%E4%B9%94%E6%81%A9marcus-chown%E5%91%A8%E8%87%AA%E6%81%92/:0:0","tags":null,"title":"[笔记]第一性原理:21堂科学通识课-[英]马库斯·乔恩(marcus Chown);周自恒","uri":"/%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B8%80%E6%80%A7%E5%8E%9F%E7%90%8621%E5%A0%82%E7%A7%91%E5%AD%A6%E9%80%9A%E8%AF%86%E8%AF%BE-%E8%8B%B1%E9%A9%AC%E5%BA%93%E6%96%AF%E4%B9%94%E6%81%A9marcus-chown%E5%91%A8%E8%87%AA%E6%81%92/"},{"categories":null,"content":"1 Entries 31-32, 标注, 2025 年 1 月 23 日星期四 上午 8:10:22 所谓第一性原理，就是由它可以引出其他所有相关的知识。 33-35, 标注, 2025 年 1 月 23 日星期四 上午 8:12:58 也可以采用相同的思路，在这个大家都没有多少空闲时间的世界中，告诉他们要理解某个话题所需要知道的第一性原理，然后告诉他们其他知识是如何从第一性原理出发，沿着逻辑的链条被推导出来的。 65-68, 标注, 2025 年 1 月 23 日星期四 上午 8:17:14 氢原子中，只有一个质子和一个围绕其旋转的电子，它们之间的引力非常微弱，只有它们之间电磁力的 1040 分之一。这意味着，如果一个物体所包含的原子数量超过 1040 个，那么引力的大小就会超过电磁力。 72-72, 标注, 2025 年 1 月 23 日星期四 上午 8:17:25 当引力占据主导地位时，所有物质都会在引力的作用下形成最紧密的结构，也就是球形。 86-87, 标注, 2025 年 1 月 23 日星期四 上午 8:19:25 开普勒行星运动第二定律指出，行星在距离太阳较近时运动速度较快，而距离太阳较远时运动速度较 86-87, 标注, 2025 年 1 月 23 日星期四 上午 8:19:30 开普勒行星运动第二定律指出，行星在距离太阳较近时运动速度较快，而距离太阳较远时运动速度较慢。 88-89, 标注, 2025 年 1 月 23 日星期四 上午 8:19:36 行星与太阳的连线在相等时间内扫过的面积相等，且这一面积与行星运动速度及其与太阳的距离的乘积成正比， 88-89, 标注, 2025 年 1 月 23 日星期四 上午 8:19:43 行星与太阳的连线在相等时间内扫过的面积相等，且这一面积与行星运动速度及其与太阳的距离的乘积成正比，这个量用现代术语来说，就是行星的轨道角动量。 89-90, 标注, 2025 年 1 月 23 日星期四 上午 8:20:04 在其路径上没有任何分量 110-111, 标注, 2025 年 1 月 23 日星期四 上午 8:22:55 对于“为什么月球以及地球的其他卫星不会掉下来”这个问题，答案是出乎意料的——它们真的在往下掉，只不过永远掉不到地面上而已。 167-168, 标注, 2025 年 1 月 23 日星期四 上午 8:43:33 不仅海洋会产生潮汐现象，岩石也会，这通常称为“固体潮汐”。 171-172, 标注, 2025 年 1 月 23 日星期四 上午 8:43:52 井水水位的高低变化取决于若干变量的影响，在某些情况下这种水位差可以高达一米左右。 170-172, 标注, 2025 年 1 月 23 日星期四 上午 8:43:56 水井通常挖掘于含水丰富的地层，在高潮时，地层向上隆起，便会像海绵一样将井水吸走；而在低潮时，地层回落，又会将之前吸收的水挤回到井里。井水水位的高低变化取决于若干变量的影响，在某些情况下这种水位差可以高达一米左右。 168-169, 标注, 2025 年 1 月 23 日星期四 上午 8:44:12 古希腊哲学家波希多尼（Posidonius）发现了一个奇怪的现象：在低潮时，井水水位会上升，而在高潮时，井水水位会下降。 181-183, 标注, 2025 年 1 月 23 日星期四 上午 10:19:55 爱因斯坦（Albert Einstein）发现引力的来源并非质量而是能量（参见第 12 章）。质能的确是能量的一种形式，但还有其他形式的能量，它们也具有引力，尤其是在太阳附近，其引力比太阳系中其他任何地方都要强。 259-260, 标注, 2025 年 1 月 23 日星期四 下午 4:59:22 变化的电场产生磁场，而变化的磁场产生电场。 634-634, 标注, 2025 年 1 月 24 日星期五 上午 8:18:53 在于，支配世界运行的物理学基本定律同时允许一个过程正向和反向发生。 652-652, 标注, 2025 年 1 月 24 日星期五 上午 8:20:23 无序总是在增加，或者说，至少无序永远不会 652-653, 标注, 2025 年 1 月 24 日星期五 上午 8:20:45 无序总是在增加，或者说，至少无序永远不会减少，于是便得到了热力学第二定律。 662-663, 标注, 2025 年 1 月 24 日星期五 上午 8:22:10 指出：“熵永远不会减少。” 660-662, 标注, 2025 年 1 月 24 日星期五 上午 8:22:31 物理学家使用一个专门的术语来称呼无序。他们将无序称为熵，它指的是与一个宏观状态（在花瓶的例子中，就是其保持完整的状态）相对应的所有微观状态数量的总和，即它能变得破碎的所有情况的数量。 682-684, 标注, 2025 年 1 月 24 日星期五 上午 8:24:06 热力学第二定律只规定熵在总体上是增加的，但并没有规定熵不能在某个局部环境中减少。 741-741, 标注, 2025 年 1 月 24 日星期五 上午 8:29:57 世界的终结将“不是嘭的一响，而是嘘的一声”。 739-741, 标注, 2025 年 1 月 24 日星期五 上午 8:30:04 恒星最终会将所有热量辐射到宇宙空间中，使得宇宙各处的温度趋于平均。没有温差这一驱动蒸汽机的核心要素，宇宙就不能继续做功，一切活动将陷入停滞。宇宙这台巨大的机器停止工作，这种状态被称为“宇宙热寂”。用诗人 T.S.艾略特（T.S.Eliot）的话来说，世界的终结将“不是嘭的一响，而是嘘的一声”。 752-754, 标注, 2025 年 1 月 24 日星期五 上午 8:32:02 如果在将来，宇宙膨胀到达极限，然后开始进入相反的过程而向内收缩，即“大坍缩”，这个过程就像是“大爆炸”的镜像，而时间的方向也会逆转。坍塌的城堡会重新耸立起来，破碎的花瓶会重新拼合完整，所有生物都会返老还童！ 759-761, 标注, 2025 年 1 月 24 日星期五 上午 8:43:00 热力学是个有趣的东西。你第一次看过之后，会觉得完全不懂。第二次看过之后，会觉得基本懂了，只有一两处不懂。第三次看过之后，你知道你确实不懂，但那时你已经习惯了，懂不懂对你已经无所谓了。” 929-931, 标注, 2025 年 1 月 24 日星期五 下午 6:23:07 量子世界的唯一可取之处在于，尽管它本质上是不可预测的，但这一不可预测性则是可以预测的！量子理论正是这样一种用来预测不可预测性的方法。 1385-1385, 标注, 2025 年 1 月 26 日星期日 上午 8:26:07 光速是宇宙的基石，而空间和时间只是流沙。 1428-1429, 标注, 2025 年 1 月 26 日星期日 上午 8:32:02 时间和空间可以互换，因为它们都不是 1428-1429, 标注, 2025 年 1 月 26 日星期日 上午 8:32:07 时间和空间可以互换，因为它们都不是本体，真正的本体是时空。 1446-1447, 标注, 2025 年 1 月 26 日星期日 上午 8:32:26 从现在起，空间本身和时间本身都将只是影子，只有它们结合在一起才能真正存在。” 1449-1451, 标注, 2025 年 1 月 26 日星期日 上午 8:32:50 当我们接近光速时，会发现空间和时间的统一是一个显而易见的事实。只不过我们生活在大自然的慢行道上，我们所经历的只是时空的影子，就像一个物体在洞穴壁上投下的平面影子——空间是一个影子，时间是另一个影子。 1455-1457, 标注, 2025 年 1 月 26 日星期日 上午 8:34:12 它。这种对移动的阻抗称为“惯性”，实际上惯性就是我们对质量的定义。一个结论就是，一个物体被加速到越快的速度，它所产生的阻抗就越大，因为实际上它的质量会变得越来越大。 1510-1511, 标注, 2025 年 1 月 26 日星期日 上午 8:41:16 用旧方案来解决新问题是演化的一个常见特性， 1515-1517, 标注, 2025 年 1 月 26 日星期日 上午 8:42:01 不过，逻辑门只是输入两个电信号，并根据输入的电流产生一个输出信号，而神经元则可以接受来自一万多个树突的输入，其输出的信号取决于所有这些输入信号与神经突触处的大量神经递质和受体之间的复杂相互作用。因此，神经元是一台生物计算机的基本构件，正如逻辑门是硅基计算机的基本构件一样， 1521-1521, 标注, 2025 年 1 月 26 日星期日 上午 8:43:20 在演化过程中依次产生了 3 种不同的脑，它们一层一层叠加起来形成了现在的人脑。 1523-1529, 标注, 2025 年 1 月 26 日星期日 上午 8:43:31 我们那 1.4 千克的“小宇宙”中最原始的部分是脑干和小脑，它们是爬行动物的脑的主要结构。我们的“爬行动物脑”负责控制自动化的生命功能，如体温、呼吸、心率和平衡。包裹在爬行动物脑外面的是在大约 2000 万年前由最早的哺乳动物所演化出的结构，这一被称为“边缘系统”的结构主要组成部分包括海马体、杏仁核和下丘脑，它们负责将或好或坏的经历作为记忆保存下来，因此它们也负责控制情绪。包裹在边缘脑外面的是所有结构中最大的，它就是“大脑”，或称为“新皮质”，它最早是在灵长类中开始发挥重要作用的。它可以驳回膝跳反射这类由原始脑结构所产生的反应，并负责语言、抽象思维、想象以及意识。它具有近乎无限的学习能力，也是我们人格的载体。简而言之，新皮质让我","date":"2025-02-07","objectID":"/%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B8%80%E6%80%A7%E5%8E%9F%E7%90%8621%E5%A0%82%E7%A7%91%E5%AD%A6%E9%80%9A%E8%AF%86%E8%AF%BE-%E8%8B%B1%E9%A9%AC%E5%BA%93%E6%96%AF%E4%B9%94%E6%81%A9marcus-chown%E5%91%A8%E8%87%AA%E6%81%92/:1:0","tags":null,"title":"[笔记]第一性原理:21堂科学通识课-[英]马库斯·乔恩(marcus Chown);周自恒","uri":"/%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B8%80%E6%80%A7%E5%8E%9F%E7%90%8621%E5%A0%82%E7%A7%91%E5%AD%A6%E9%80%9A%E8%AF%86%E8%AF%BE-%E8%8B%B1%E9%A9%AC%E5%BA%93%E6%96%AF%E4%B9%94%E6%81%A9marcus-chown%E5%91%A8%E8%87%AA%E6%81%92/"},{"categories":null,"content":" 1043-1046, 标注, 2025 年 1 月 23 日星期四 下午 8:36:06 叔本华认为每个人都跳不出意欲的圈子，不过每个人目光的广狭和远近都不相同。一般人为庸俗浅薄的东西所吸引，而成大事业的人则意欲远大。所以，一个人要追求更高远的理想，就一定要先打碎眼前五光十色的繁华世界，经过一个“昨夜西风凋碧树”的阶段，才能有“独上高楼，望尽天涯路”的目光。 1056-1059, 标注, 2025 年 1 月 23 日星期四 下午 9:00:34 真的这样来解释这些词，“恐晏、欧诸公所不许也。” “昨夜 1484-1484, 标注, 2025 年 2 月 1 日星期六 上午 10:18:50 别。 1738-1738, 标注, 2025 年 2 月 7 日星期五 下午 8:30:12 动罗箑清商， 2121-2122, 标注, 2025 年 2 月 16 日星期日 下午 12:22:47 雁：即小羊与大雁，为古代卿大夫相见时赠送的礼品。后泛指应酬礼品。 替：衰败，衰落。 2121-2121, 标注, 2025 年 2 月 16 日星期日 下午 12:22:56 羔雁：即小羊与大雁，为古代卿大夫相见时赠送的礼品。后泛指应酬礼品。 2389-2389, 标注, 2025 年 2 月 23 日星期日 下午 9:36:26 恨春去、不与人期，弄夜色，空余满地梨花雪。 2400-2400, 标注, 2025 年 2 月 23 日星期日 下午 9:56:35 岁华易老，衣带宽、懊恼心肠终窄。 2995-2996, 标注, 2025 年 3 月 16 日星期日 下午 7:57:16 有的人把人生悲欢看得很重：得意则“富贵不归故乡如锦衣夜行”； 2995-2996, 标注, 2025 年 3 月 16 日星期日 下午 7:57:21 有的人把人生悲欢看得很重：得意则“富贵不归故乡如锦衣夜行”；失意则“出门即有碍，谁谓天地宽”； 2995-2998, 标注, 2025 年 3 月 16 日星期日 下午 7:57:41 有的人把人生悲欢看得很重：得意则“富贵不归故乡如锦衣夜行”；失意则“出门即有碍，谁谓天地宽”；恋爱则“得成比翼何辞死，愿作鸳鸯不羡仙”；分离则“天长地久有时尽，此恨绵绵无绝期”。其实人生只不过像一场戏，纵然台上演得轰轰烈烈如醉如痴，观众却只是逢场作乐消愁解闷，散场之后又有几人把戏当真？“ 3048-3052, 标注, 2025 年 3 月 16 日星期日 下午 8:18:34 是“可怜心事太峥嵘”！“可怜”这个词用得很巧妙，因为它既有“值得怜悯”的意思，也有“可爱”的意思。因“心事太峥嵘”而造成一生的苦恼，值得自怜；为不同凡俗的理想而付出，虽苦犹甜，值得自傲。到底是自怜还是自傲？那种分辩是理性的事，现在他只是说出自己的感受，而这感觉里不知不觉地就渗透了作者清醒时意识形态里所存在的那种理智与感情的矛盾。 ","date":"2025-02-07","objectID":"/%E7%AC%94%E8%AE%B0%E4%BA%BA%E9%97%B4%E8%AF%8D%E8%AF%9D%E5%8F%B6%E5%98%89%E8%8E%B9%E8%AE%B2%E8%AF%84%E6%9C%AC%E8%AF%97%E8%AF%8D%E5%A4%A7%E5%AE%B6%E5%8F%B6%E5%98%89%E8%8E%B9%E9%80%90%E6%9D%A1%E8%AE%B2%E9%80%8F%E7%82%B9%E8%AF%84%E7%8E%8B%E5%9B%BD%E7%BB%B4%E8%AF%97%E8%AF%8D%E7%BE%8E%E5%AD%A6%E7%BB%8F%E5%85%B8%E8%AF%BB%E6%87%82%E4%BA%BA%E7%94%9F%E4%B8%89%E5%A2%83%E7%95%8C-%E7%8E%8B%E5%9B%BD%E7%BB%B4%E5%8F%B6%E5%98%89%E8%8E%B9/:0:0","tags":null,"title":"[笔记]人间词话：叶嘉莹讲评本","uri":"/%E7%AC%94%E8%AE%B0%E4%BA%BA%E9%97%B4%E8%AF%8D%E8%AF%9D%E5%8F%B6%E5%98%89%E8%8E%B9%E8%AE%B2%E8%AF%84%E6%9C%AC%E8%AF%97%E8%AF%8D%E5%A4%A7%E5%AE%B6%E5%8F%B6%E5%98%89%E8%8E%B9%E9%80%90%E6%9D%A1%E8%AE%B2%E9%80%8F%E7%82%B9%E8%AF%84%E7%8E%8B%E5%9B%BD%E7%BB%B4%E8%AF%97%E8%AF%8D%E7%BE%8E%E5%AD%A6%E7%BB%8F%E5%85%B8%E8%AF%BB%E6%87%82%E4%BA%BA%E7%94%9F%E4%B8%89%E5%A2%83%E7%95%8C-%E7%8E%8B%E5%9B%BD%E7%BB%B4%E5%8F%B6%E5%98%89%E8%8E%B9/"},{"categories":null,"content":" Table of Contents 1 Entries 2 简评 3 书摘 ","date":"2025-02-07","objectID":"/%E7%AC%94%E8%AE%B0%E6%88%91%E7%9C%8B%E8%A7%81%E7%9A%84%E4%B8%96%E7%95%8C%E6%9D%8E%E9%A3%9E%E9%A3%9E%E8%87%AA%E4%BC%A0-%E7%BE%8E-%E6%9D%8E%E9%A3%9E%E9%A3%9E%E8%B5%B5%E7%81%BF/:0:0","tags":null,"title":"[笔记]我看见的世界:李飞飞自传-[美] 李飞飞;赵灿","uri":"/%E7%AC%94%E8%AE%B0%E6%88%91%E7%9C%8B%E8%A7%81%E7%9A%84%E4%B8%96%E7%95%8C%E6%9D%8E%E9%A3%9E%E9%A3%9E%E8%87%AA%E4%BC%A0-%E7%BE%8E-%E6%9D%8E%E9%A3%9E%E9%A3%9E%E8%B5%B5%E7%81%BF/"},{"categories":null,"content":"1 Entries ","date":"2025-02-07","objectID":"/%E7%AC%94%E8%AE%B0%E6%88%91%E7%9C%8B%E8%A7%81%E7%9A%84%E4%B8%96%E7%95%8C%E6%9D%8E%E9%A3%9E%E9%A3%9E%E8%87%AA%E4%BC%A0-%E7%BE%8E-%E6%9D%8E%E9%A3%9E%E9%A3%9E%E8%B5%B5%E7%81%BF/:1:0","tags":null,"title":"[笔记]我看见的世界:李飞飞自传-[美] 李飞飞;赵灿","uri":"/%E7%AC%94%E8%AE%B0%E6%88%91%E7%9C%8B%E8%A7%81%E7%9A%84%E4%B8%96%E7%95%8C%E6%9D%8E%E9%A3%9E%E9%A3%9E%E8%87%AA%E4%BC%A0-%E7%BE%8E-%E6%9D%8E%E9%A3%9E%E9%A3%9E%E8%B5%B5%E7%81%BF/"},{"categories":null,"content":"2 简评 本书描写了人工智能领域专家李飞飞教授在 90 年代移居美国后的生活、学习和科研的事情。 读书的过程中，我经常为其中的种种环境感慨，经常会想，如果这个人是我，我会做出什么样的选择，我能不能像作者一样坚持按照自己的北极星指引的方向前向。。。 ","date":"2025-02-07","objectID":"/%E7%AC%94%E8%AE%B0%E6%88%91%E7%9C%8B%E8%A7%81%E7%9A%84%E4%B8%96%E7%95%8C%E6%9D%8E%E9%A3%9E%E9%A3%9E%E8%87%AA%E4%BC%A0-%E7%BE%8E-%E6%9D%8E%E9%A3%9E%E9%A3%9E%E8%B5%B5%E7%81%BF/:2:0","tags":null,"title":"[笔记]我看见的世界:李飞飞自传-[美] 李飞飞;赵灿","uri":"/%E7%AC%94%E8%AE%B0%E6%88%91%E7%9C%8B%E8%A7%81%E7%9A%84%E4%B8%96%E7%95%8C%E6%9D%8E%E9%A3%9E%E9%A3%9E%E8%87%AA%E4%BC%A0-%E7%BE%8E-%E6%9D%8E%E9%A3%9E%E9%A3%9E%E8%B5%B5%E7%81%BF/"},{"categories":null,"content":"3 书摘 94-96, 标注, 2025 年 2 月 6 日星期四 下午 12:44:15 尽管美国的立国理念在过去几个世纪里并没有得到完美的实践，但这些理念看上去正是构建科技未来的智慧基石：尊重个人尊严，重视群体代表性的内在价值，相信人类努力的方向应该是由多数人的意志和利益引领，而不是少数人。 124-126, 标注, 2025 年 2 月 6 日星期四 下午 12:46:50 科技革命必须深深植根于人类奋斗的基础之上，必须尊重全球社会的集体尊严，必须始终牢记自己的起源：人类的身体素质在自然界中并不起眼，只是因为人类拥有无尽的想象力，人类社会才取得长足发展。 171-173, 标注, 2025 年 2 月 6 日星期四 下午 1:03:03 几十年来，他郁郁寡欢，无法释怀。这种情绪传递给了他的子女，也在某一天攫住了我：沉闷而无言，感觉家在他乡、活在别处。 214-214, 标注, 2025 年 2 月 6 日星期四 下午 1:06:57 偏见往往会缓慢而无声地吞噬一个人， 229-234, 标注, 2025 年 2 月 6 日星期四 下午 1:09:22 但我读的书越多，就越像她一样，热爱现实世界之外的幻想国度。每当读完一本书，那些故事就会在我的脑海中久久萦绕，仿佛是另一个现实世界在与我所处的世界相抗衡。无论是在步行上学的路上、骑车去公园的途中，还是去小卖部买东西的时候，我眼中看到的生活日常都与脑中遥远的景象交织在一起：狄更斯笔下英国的鹅卵石街道，海明威书中波涛汹涌的大海，大仲马描写的欧洲海岸的浪漫冒险。这些故事色彩斑斓，让我觉得自己与众不同，仿佛是母亲为我拉开了神秘的帷幕，向我展示了我从未想象过的可能性。 579-580, 标注, 2025 年 2 月 6 日星期四 下午 6:40:36 我突然进入了英语世界，即便是最简单的家庭作业也要花上几个小时，因为几乎每一步都需要求助于两本大词典，一本是中英词典，一本是英中词典。 588-591, 标注, 2025 年 2 月 6 日星期四 下午 6:41:39 一有空暇时间，我就会给国内的家人和朋友写信。每封信都是一个恳求。我希望他们能告诉我，虽然我已经离开了，但我爱的人和事，尤其是外祖母的厨艺，依然还在。他们总会回信告诉我我想听的话，每次收到回信，我都既兴奋又伤感。有生以来第一次，我梦中那个遥远的世界不是神秘的异域，也不是未被发现的科学前沿，而是我最熟悉的地方。 708-711, 标注, 2025 年 2 月 6 日星期四 下午 6:52:24 科学史往往是曲折、讽刺而又残酷的。新的思想被发现，然后被丢弃，接着又有新的思想被发现。被几代人视为基石的范式有时会在一夜之间被推翻，而推翻这一切的常常是显而易见的观察结果。恰恰因为这些观察太过简单，反而更容易被领域内最杰出的人物所忽视，从而为局外人发起革命创造了条件。正是这种既和谐又冲突的摇摆节奏，才使得科学追求如此戏剧化。 769-770, 标注, 2025 年 2 月 7 日星期五 上午 8:18:24 这是父亲真正的天赋所在——不是工程学，不是相机修理，甚至不是文字游戏，而是在任何情况下，哪怕再平淡无奇，都可以发现幸福和快乐。 804-806, 标注, 2025 年 2 月 7 日星期五 上午 8:21:34 我们一见到他，就立刻感觉他完全变了一个人，再也不是我们熟悉的那个男生了。以前他虽然英语不好，但总是幽默开朗，而现在变得孤僻阴郁。挨打的那一刻是残酷的——身体的疼痛、精神上的屈辱、纯粹的身体侵犯，但让人感觉最不人道的还是这种转变：他与生俱来的积极乐观被剥夺了。 844-845, 标注, 2025 年 2 月 7 日星期五 上午 8:24:06 我一遍又一遍地读着碑文，每一个字都让我身体发抖、心灵震颤，仿佛体内有一团火焰在燃烧。 916-918, 标注, 2025 年 2 月 7 日星期五 上午 8:28:44 家人总是嘲笑他的书生气和对科幻小说的痴迷。就算跟自己的兄弟姐妹，他也觉得格格不入。因为这样的家庭氛围，他开始从自己的思想中寻求庇护，在孤独的知识之旅中越走越远。我们两个的经历虽然不同，但精神上却有很多共鸣。 916-918, 标注, 2025 年 2 月 7 日星期五 上午 8:28:49 家人总是嘲笑他的书生气和对科幻小说的痴迷。就算跟自己的兄弟姐妹，他也觉得格格不入。因为这样的家庭氛围，他开始从自己的思想中寻求庇护，在孤独的知识之旅中越走越远 1381-1382, 标注, 2025 年 2 月 7 日星期五 下午 6:52:29 物理学的魅力并不在于方程式，甚至也不在于概念，而在于对其象征意义的追逐和探索。 1393-1397, 标注, 2025 年 2 月 7 日星期五 下午 6:53:54 父母对无限机会的追求是他们的北极星。这个愿景让他们焕发出无与伦比的活力，在他们的生命中打下了深深的烙印，是他们生而为人的定义。正是这种狂热的追求，让我心目中的英雄们一步步地从学者变为科学家，最终成为传奇。与真正的科学发现的第一次接触至今仍让我惊叹不已。与此同时，我发现自己开始在天宇中追寻属于自己的北极星，那是每一位科学家都会穷尽一切追逐的坐标，无论是一个问题、一个假设，还是一个赌注。哪怕要追到天涯海角，我也会毫不犹豫。 我只需要找到那颗北极星。 1599-1601, 标注, 2025 年 2 月 7 日星期五 下午 9:43:37 尤其是克里斯托夫，他经常沉浸在自己的思考中难以自拔，即使我们两个人在交谈，他似乎也更喜欢在自言自语中探索这些问题。但他的专注并不是因为冷漠，而是源于天真，就像一个被白日梦弄得神魂颠倒的孩子。 1850-1851, 标注, 2025 年 2 月 8 日星期六 上午 7:16:09 无论采取何种方法，我们将要让机器熟悉视觉世界。 1965-1968, 标注, 2025 年 2 月 8 日星期六 上午 8:17:51 一个新的现实正在浮现，它如此复杂，动摇了我以物理学专业学生的身份走进普林斯顿大学报告厅以来所做的每一个决定。毕生的好奇心把我带进了一个竞争激烈、薪酬低廉、无法保障长久职业生涯的领域，而我的父母现在需要我无法提供的支持。我每天都在追求自己的梦想，这让我觉得自私至极，甚至过于鲁莽。 2048-2049, 标注, 2025 年 2 月 8 日星期六 上午 8:23:16 发表自己的研究成果固然令人兴奋，但知道自己在为他人的构想做阶梯，哪怕只是在他们成功推动该领域发展的过程中扮演了微不足道的角色，也让人无比激动。 2082-2086, 标注, 2025 年 2 月 8 日星期六 上午 8:25:56 那些看似经过有效训练的算法，却无法将它们所学到的知识，或者说它们本应学到的知识，应用于现实世界。从本质上讲，这与人类的感知能力恰恰相反。人类的感知能力是由泛化能力决定的，泛化能力增强了我们的灵活性和适应性，甚至让我们富有创造力，让我们能够随时利用新想法的力量锐意进取，而不是停留在过去的经验中止步不前。任何缺乏泛化能力的生物都会很快被自然界的不可预测性击垮，因此这种能力是生物进化思维的关键特征。 2932-2933, 标注, 2025 年 2 月 10 日星期一 上午 8:39:04 数以百万计的图形处理器忙于渲染抖动的机枪、成群结队的僵尸和弹片飞溅的爆炸时，有两台图形处理器却正在多伦多的某个地方将一种新型神经网络从理论变为现实。 3509-3512, 标注, 2025 年 2 月 10 日星期一 下午 6:31:14 以北极星来比喻理想，其真正的价值不仅仅在于北极星可以指引方向，更在于无论怎样努力，到达北极星的距离永远是无限的。我们可以为之苦苦追求，可以为之痴迷一生，却永远无法抵达。北极星象征着科学家最独特的品质：充满永不停歇、永无止境的好奇心，这份好奇心跟满足感永远同极相斥。夜空中的一颗星，远方的海市蜃楼，没有尽头的道路。 3512-3513, 标注, 2025 年 2 月 10 日星期一 下午 6:31:35 一个转折点，当然值得庆祝，但它并不是旅程的终点。如果说有什么特别的意义，那么转折点只是一段更伟大旅程的开始。 3784-3786, 标注, 2025 年 2 月 10 日星期一 下午 6:44:26 在我们的第一批新成员中，有计算机科学的一年级研究生、电子工程的博士生，还有研究机器人对人类活动和社交导航感知的博士后。随后，针对我招募的团队，阿尼也挑选了一批年轻医生，有医院的儿科医生、老年病医学专家，还有重症监护专家。 3786-3786, 笔记, 2025 年 2 月 10 日星期一 下午 6:45:02 让人羡慕的研究环境 4023-4025, 标注, 2025 年 2 月 11 日星期二 上午 8:31:14 “请大家不要每天只从 arXiv 下载最新的预印本作品了。去读一读拉塞尔和诺维格的著作，去读明斯基、麦卡锡和威诺格拉德的书，读哈特利和西塞曼的作品，读一读帕尔默写的东西。不要因为这些材料距离现在时间久就忽略它们。我们就是要多读一些以前的东西，他们的理念经得起时间的考验，依然非常重要。” 4155-4158, 标注, 2025 年 2 月 11 日星期二 上午 8:41:52 还有就是人才。谷歌人才济济，令人叹为观止。回想起自己花了两年时间才招募到三位合作者来帮助建立医院环境智能，我不禁自愧不如。在谷歌，15 人的团队已经准备就绪，只等我立即加入。而这仅仅是个开始——在短短 18 个月内，我们的规模扩大了 20 倍。拥有优秀资历的博士似乎随处可见，让我觉得一切皆有可能。 4694-4696, 标注, 2025","date":"2025-02-07","objectID":"/%E7%AC%94%E8%AE%B0%E6%88%91%E7%9C%8B%E8%A7%81%E7%9A%84%E4%B8%96%E7%95%8C%E6%9D%8E%E9%A3%9E%E9%A3%9E%E8%87%AA%E4%BC%A0-%E7%BE%8E-%E6%9D%8E%E9%A3%9E%E9%A3%9E%E8%B5%B5%E7%81%BF/:3:0","tags":null,"title":"[笔记]我看见的世界:李飞飞自传-[美] 李飞飞;赵灿","uri":"/%E7%AC%94%E8%AE%B0%E6%88%91%E7%9C%8B%E8%A7%81%E7%9A%84%E4%B8%96%E7%95%8C%E6%9D%8E%E9%A3%9E%E9%A3%9E%E8%87%AA%E4%BC%A0-%E7%BE%8E-%E6%9D%8E%E9%A3%9E%E9%A3%9E%E8%B5%B5%E7%81%BF/"},{"categories":null,"content":" Table of Contents 1 简要介绍 2 威胁建模流程和步骤 3 威胁建模技术 3.1 数据流程图 3.2 过程流程图 3.3 攻击树 4 威胁建模框架和方法 4.1 STRIDE 威胁建模 4.2 DREAD 威胁建模 4.3 PASTA 威胁建模 4.4 VAST 威胁建模 4.5 Trike 威胁建模 4.6 OCTAVE 威胁建模 4.7 NIST 威胁建模 5 威胁建模最佳实践 6 威胁建模工具 本文为摘录(或转载)，侵删，原文为： https://blog.csdn.net/weixin_43965597/article/details/122882763 ","date":"2025-01-24","objectID":"/blog_csdn_net_details_122882763/:0:0","tags":["threaten","model","stride","nist"],"title":"威胁建模框架与技术：从STRIDE到NIST-CSDN博客","uri":"/blog_csdn_net_details_122882763/"},{"categories":null,"content":"1 简要介绍 了解威胁建模框架、方法和工具可以帮助更好地识别、量化和排序面临的威胁。威胁建模是一个结构化的过程，IT 专业人员可以通过该过程识别潜在的安全威胁和漏洞，量化每个威胁的严重性，并确定技术的优先级以缓解攻击并保护 IT 资产。威胁模型的重要之处在于它是系统的和结构化的。威胁建模人员将执行一系列具体步骤，以全面了解他们试图保护的 IT 环境，识别漏洞和潜在攻击者。 ","date":"2025-01-24","objectID":"/blog_csdn_net_details_122882763/:1:0","tags":["threaten","model","stride","nist"],"title":"威胁建模框架与技术：从STRIDE到NIST-CSDN博客","uri":"/blog_csdn_net_details_122882763/"},{"categories":null,"content":"2 威胁建模流程和步骤 每种的威胁建模方法都包含一系列步骤，不同的建模方法的每个步骤存在着细微差别。首先，看一下所有这些方法共有的基本逻辑流程。对威胁建模过程最简洁明了的概述指出，威胁模型的目的是回答四个问题： 我们面对的是什么？ 可能会有哪些问题（威胁）？ 我们该怎么做？ 我们做得好吗？ 反过来，威胁建模过程应包括四个主要步骤，每个步骤都会为这些问题之一提供答案。 分解应用程序或基础架构 确定威胁 确定对策和缓解措施 排序威胁 为了准确了解这些步骤中的每个步骤，我们需要讨论构成威胁建模基础的特定技术。 ","date":"2025-01-24","objectID":"/blog_csdn_net_details_122882763/:2:0","tags":["threaten","model","stride","nist"],"title":"威胁建模框架与技术：从STRIDE到NIST-CSDN博客","uri":"/blog_csdn_net_details_122882763/"},{"categories":null,"content":"3 威胁建模技术 上面列出的步骤中，最陌生的术语可能是分解（Decompose）。分解应用程序或基础架构意味着什么？ 广义上讲，分解应用程序包括 了解应用程序及其与外部实体的交互方式 。这涉及: 创建用例，以了解应用程序的使用方式， 确定入口点以查看潜在的攻击者可以在哪里与应用程序进行交互， 确定资产（即攻击者可能会感兴趣的项目/区域）， 并标识表示应用程序将授予外部实体的访问权限的信任级别。 （这里专门谈论应用程序安全性，但是显然，从广义上讲，这也适用于对基础结构的看法。） ","date":"2025-01-24","objectID":"/blog_csdn_net_details_122882763/:3:0","tags":["threaten","model","stride","nist"],"title":"威胁建模框架与技术：从STRIDE到NIST-CSDN博客","uri":"/blog_csdn_net_details_122882763/"},{"categories":null,"content":"3.1 数据流程图 分解应用程序的一种技术是 构建数据流程图 。这是 1970 年代开发的一种方法，以可视方式展示数据如何在应用程序或系统中移动，以及各个组件在何处更改或存储数据。 其中 信任边界 是在 2000 年代初期添加进来的概念，特指数据流中的卡点，在该点上需要对数据进行验证，然后数据才能被接收该数据的实体使用。信任边界是用数据流程图进行威胁建模的关键。 下图是在线银行应用程序的数据流程图；虚线表示信任边界，数据可能会在信任边界被更改，因此需要采取安全措施。 ","date":"2025-01-24","objectID":"/blog_csdn_net_details_122882763/:3:1","tags":["threaten","model","stride","nist"],"title":"威胁建模框架与技术：从STRIDE到NIST-CSDN博客","uri":"/blog_csdn_net_details_122882763/"},{"categories":null,"content":"3.2 过程流程图 由于数据流程图是由系统工程师而不是安全专家开发的，因此它们包含了许多威胁建模不需要的开销。数据流程图的一种替代方法是过程流程图。两者在总体概念上相似，但后者更加精简，并且侧重于用户和执行代码在系统中的移动方式，更紧密地反映了攻击者的思维方式（例如下图）。 ","date":"2025-01-24","objectID":"/blog_csdn_net_details_122882763/:3:2","tags":["threaten","model","stride","nist"],"title":"威胁建模框架与技术：从STRIDE到NIST-CSDN博客","uri":"/blog_csdn_net_details_122882763/"},{"categories":null,"content":"3.3 攻击树 绘制攻击树也是一种威胁建模技术，当您确定要对应用程序或基础结构潜在威胁的阶段时，它就变得非常重要。攻击树由 90 年代后期的信息安全传奇人物布鲁斯·施耐尔（Bruce Schneier）开创。 它们由代表不同事件的一系列父节点和子节点组成，子节点是必须满足的条件才能使父节点为真。根节点（图中的最高父节点）是攻击的总体目标。借助攻击树，威胁建模者可以看到必须组合哪些情况才能使威胁成功。下图显示了一个简单的银行应用攻击树，说明了病毒可能成功感染文件的不同方式。 下图是 Hackinthebox 从攻击者的角度构建的攻击树示例，可以帮助了解自己所面临的威胁。 ","date":"2025-01-24","objectID":"/blog_csdn_net_details_122882763/:3:3","tags":["threaten","model","stride","nist"],"title":"威胁建模框架与技术：从STRIDE到NIST-CSDN博客","uri":"/blog_csdn_net_details_122882763/"},{"categories":null,"content":"4 威胁建模框架和方法 威胁建模的各种结构化方法通常称为框架或方法论（本文中这两个术语基本上可以互换使用）。目前的威胁建模框架和方法有很多，我们挑几个最流行的介绍如下： 7 种顶级威胁建模方法 STRIDE DREAD PASTA VAST Trike OCTAVE NIST ","date":"2025-01-24","objectID":"/blog_csdn_net_details_122882763/:4:0","tags":["threaten","model","stride","nist"],"title":"威胁建模框架与技术：从STRIDE到NIST-CSDN博客","uri":"/blog_csdn_net_details_122882763/"},{"categories":null,"content":"4.1 STRIDE 威胁建模 如上所述，STRIDE 是威胁建模的祖父，最早于 90 年代末在 Microsoft 开发。 STRIDE 代表六种威胁，每种都对 CIA 三要素构成威胁，具体如下： Spoofing 欺骗或冒充他人或计算机，影响真实性 Tampering 篡改数据，这会破坏完整性 Repudiation 抵赖，或无法将执行的操作关联到操作者，违反了不可抵赖性 Information Disclosure 信息泄露，违反机密性 Denial of Service 拒绝服务，这违反了可用性 Elevation of Privilege 特权提升，违反授权 ","date":"2025-01-24","objectID":"/blog_csdn_net_details_122882763/:4:1","tags":["threaten","model","stride","nist"],"title":"威胁建模框架与技术：从STRIDE到NIST-CSDN博客","uri":"/blog_csdn_net_details_122882763/"},{"categories":null,"content":"4.2 DREAD 威胁建模 DREAD 被认为是 STRIDE 模型的一个附加组件，该模型使建模人员可以在确定威胁后对其进行排名。 对于每个潜在威胁，DREAD 代表六个问题,这些问题中的每一个都得到 1-3 分的评分： Damage 潜在损害：如果利用漏洞，造成的损害有多大？ Reproducibility 重现性：重现攻击有多容易？ Exploitability 可利用性：发动攻击有多容易？ Affexted users 受影响的用户：大概影响了多少用户？ Discoverability 可发现性：查找漏洞有多容易？ ","date":"2025-01-24","objectID":"/blog_csdn_net_details_122882763/:4:2","tags":["threaten","model","stride","nist"],"title":"威胁建模框架与技术：从STRIDE到NIST-CSDN博客","uri":"/blog_csdn_net_details_122882763/"},{"categories":null,"content":"4.3 PASTA 威胁建模 PASTA 代表攻击模拟和威胁分析过程，它是一个七步骤过程，致力于使技术安全要求与业务目标保持一致。每个步骤都非常复杂，由几个子步骤组成，但是总体顺序如下： 定义目标 定义技术范围 应用程序分解 威胁分析 漏洞和弱点分析 攻击建模 风险与影响分析 ","date":"2025-01-24","objectID":"/blog_csdn_net_details_122882763/:4:3","tags":["threaten","model","stride","nist"],"title":"威胁建模框架与技术：从STRIDE到NIST-CSDN博客","uri":"/blog_csdn_net_details_122882763/"},{"categories":null,"content":"4.4 VAST 威胁建模 VAST 代表可视化，敏捷威胁建模。该模型是 ThreatModeler（自动威胁建模平台）的基础，该平台可以区分应用程序和运营威胁模型。VAST 专为集成到围绕 devops 构建的工作流中而设计。 ","date":"2025-01-24","objectID":"/blog_csdn_net_details_122882763/:4:4","tags":["threaten","model","stride","nist"],"title":"威胁建模框架与技术：从STRIDE到NIST-CSDN博客","uri":"/blog_csdn_net_details_122882763/"},{"categories":null,"content":"4.5 Trike 威胁建模 Trike 是用于威胁建模和风险评估的框架的开源工具，它基于防御的角度，而不是试图模仿攻击者的思维过程。使用 Trike，您可以为要防御的系统建模，并通过 CRUD 的角度评估每个组件，也就是说，谁可以创建，读取，更新或删除该实体。通过遍历数据流程图来识别威胁，每种威胁仅分为两类：拒绝服务或特权提升。 ","date":"2025-01-24","objectID":"/blog_csdn_net_details_122882763/:4:5","tags":["threaten","model","stride","nist"],"title":"威胁建模框架与技术：从STRIDE到NIST-CSDN博客","uri":"/blog_csdn_net_details_122882763/"},{"categories":null,"content":"4.6 OCTAVE 威胁建模 OCTAVE 代表“运营关键威胁，资产和脆弱性评估”，是卡耐基梅隆大学开发的一种威胁建模方法，其重点是组织风险而不是技术风险。它包括三个阶段： 建立基于资产的威胁配置文件 识别基础架构漏洞 制定安全策略和计划 ","date":"2025-01-24","objectID":"/blog_csdn_net_details_122882763/:4:6","tags":["threaten","model","stride","nist"],"title":"威胁建模框架与技术：从STRIDE到NIST-CSDN博客","uri":"/blog_csdn_net_details_122882763/"},{"categories":null,"content":"4.7 NIST 威胁建模 美国国家标准技术研究院拥有自己的以数据为中心的威胁建模方法，该方法包括四个步骤： 系统和数据识别和表征 识别并选择要包含在模型中的攻击媒介 表征缓解攻击媒介的安全控件 分析威胁模型 该 NIST 草案还包括一个方法的具体应用实例。如果您正在寻找威胁建模示例，那么这是一个很棒的文档，可以阅读该文档以了解流程如何工作。 ","date":"2025-01-24","objectID":"/blog_csdn_net_details_122882763/:4:7","tags":["threaten","model","stride","nist"],"title":"威胁建模框架与技术：从STRIDE到NIST-CSDN博客","uri":"/blog_csdn_net_details_122882763/"},{"categories":null,"content":"5 威胁建模最佳实践 无论选择哪种框架，都应遵循一些实践方法。但最重要的（通常也是很难做到的）是将威胁建模作为系统开发过程中的优先事项。如果能在项目开发伊始就做到这一点，以后可以省去很多麻烦，因为安全性可以被深深“植入”到应用程序或系统中。 另一个最佳实践是不要将应用程序和系统彼此隔离。Michael Santarcangelo 写道： “如果各种威胁模型以相同的方式相互连接，并且应用程序和组件作为 IT 系统的一部分进行交互，那么结果将是一个全面的攻击面，CISO 可以使用该攻击面来理解整个企业的整体威胁组合。” ","date":"2025-01-24","objectID":"/blog_csdn_net_details_122882763/:5:0","tags":["threaten","model","stride","nist"],"title":"威胁建模框架与技术：从STRIDE到NIST-CSDN博客","uri":"/blog_csdn_net_details_122882763/"},{"categories":null,"content":"6 威胁建模工具 需要指出的是，上面列出的两种方法（VAST 和 Trike）实际上是围绕特定的软件工具构建的。还有一些支持其他方法的工具，例如，Microsoft 提供了免费的威胁建模工具，而 OWASP Foundation 也推出了自己的桌面和 web 版本的威胁建模工具——Threat Dragon³。 实际上，这里描述的许多方法都是概念性的，并未与任何软件联系在一起。攻击树或数据流程图可以用笔和纸绘制。正如 Luca Bongiorni 的演讲所解释的那样，用于威胁建模的一些最受欢迎的工具是 Microsoft Visio 和 Excel。开始为基础架构进行威胁建模的门槛很低，但回报却很高。 参考资料： 【1】最早的威胁建模论文： https://www.microsoft.com/security/blog/2009/08/27/the-threats-to-our-products/ 【2】Uncover Security Design Flaws Using The STRIDE Approach： https://docs.microsoft.com/en-us/archive/msdn-magazine/2006/november/uncover-security-design-flaws-using-the-stride-approach 【3】OWASP 威胁建模工具： Threat Dragon：https://owasp.org/www-project-threat-dragon/ ","date":"2025-01-24","objectID":"/blog_csdn_net_details_122882763/:6:0","tags":["threaten","model","stride","nist"],"title":"威胁建模框架与技术：从STRIDE到NIST-CSDN博客","uri":"/blog_csdn_net_details_122882763/"},{"categories":null,"content":" Table of Contents 1 Entries ","date":"2025-01-22","objectID":"/%E7%AC%94%E8%AE%B0%E5%A4%A7%E5%A5%89%E6%89%93%E6%9B%B4%E4%BA%BA-%E5%8D%96%E6%8A%A5%E5%B0%8F%E9%83%8E%E5%90%9B/:0:0","tags":null,"title":"[笔记]大奉打更人-卖报小郎君","uri":"/%E7%AC%94%E8%AE%B0%E5%A4%A7%E5%A5%89%E6%89%93%E6%9B%B4%E4%BA%BA-%E5%8D%96%E6%8A%A5%E5%B0%8F%E9%83%8E%E5%90%9B/"},{"categories":null,"content":"1 Entries 5976-5976, 标注, 2025 年 1 月 21 日星期二 上午 7:19:26 人性多变，光暗交织，不能因为见到过黑暗，就愤世妒俗，厌弃光明。 11115-11116, 标注, 2025 年 1 月 24 日星期五 上午 6:42:27 太阳还挂在西边天空，倔强的把云彩染成自己的形状和颜色。 14652-14653, 标注, 2025 年 1 月 25 日星期六 下午 1:25:07 免费的才是最贵的，因为取代交易的东西是感情。等彼此之间的交情越来越深厚，白嫖这个东西就出现了….不，朋友之间怎么能叫白嫖，是互相帮助。 19944-19944, 标注, 2025 年 1 月 27 日星期一 上午 7:22:44 这个人说的话，一个标点符号都不能信。 24018-24018, 标注, 2025 年 1 月 27 日星期一 下午 10:11:56 上帝把智慧洒满人间时，这位公主虽然和铃音一样，机智的打了把伞 43693-43694, 标注, 2025 年 2 月 4 日星期二 下午 7:07:54 在官场摸爬滚打，要三思：思危、思退、思变。 “做事之前，要考虑这件事带来的后果，明白其中利害，再去权衡做或不做。 “如果滚滚大势不可阻挡，就要思退，避其锋芒。只有避退了，安全了，你才能想，该怎么改变局势。 43946-43946, 标注, 2025 年 2 月 4 日星期二 下午 9:40:44 人类的悲欢并不相同，他们只觉得你吵闹。 44022-44023, 标注, 2025 年 2 月 4 日星期二 下午 9:47:11 没什么大不了，你读书太少，多读写史书，便知此为常事。越是血腥不公之事，越是寥寥几笔。 48481-48482, 标注, 2025 年 2 月 5 日星期三 下午 11:19:13 有约不来过夜半，闲敲棋子落灯花 48482-48483, 标注, 2025 年 2 月 5 日星期三 下午 11:19:32 圆月高挂，清冷的月辉被纱窗挡在屋外，尖细的虫鸣此起彼伏，彰显着夜的静谧。 50143-50145, 标注, 2025 年 2 月 6 日星期四 上午 11:58:48 听人说过，真正深切的悲伤不是爆发性的大哭一场，而是打开冰箱的那半盒牛奶、那窗台上随风微曳的绿箩、那折叠在床上的绒被，还有那安静的下午洗衣机传来的阵阵喧哗。 52188-52189, 标注, 2025 年 2 月 7 日星期五 上午 7:23:32 这世间，有人追求长生，有人追求荣华富贵，有人追求武道登顶。 “而我所追求的，是那个年少时，树影下，拈花微笑的姑娘。” 56789-56790, 标注, 2025 年 2 月 9 日星期日 下午 11:15:17 拉拢一批人，打压一批人，循环渐进。过程中，需要给敌人反扑和发泄的机会，一点点消磨对方的锐气和斗志。 57635-57636, 标注, 2025 年 2 月 10 日星期一 下午 12:51:48 “贪官无所谓，能做事就行。袖手空谈的清官才误国误民，即能做事，又刚正不阿的官太少，治理国家，不能指望这些凤毛麟角。 65290-65291, 标注, 2025 年 2 月 13 日星期四 下午 12:23:00 功名利禄一纸书，不过扬灰于尘土。” 76523-76524, 标注, 2025 年 2 月 19 日星期三 上午 8:25:47 “治国如烹小鲜，讲究一个徐徐图之。但若是国家病入膏肓，又该如何治理呢？陛下也好，王首辅也罢，以及朝堂诸公，都没有类似的经验。” 79398-79400, 标注, 2025 年 2 月 19 日星期三 下午 11:01:16 尽管上次在京城出手，回收气运失败，与嫡长子明面上的第一次交锋，失败了。 但其实回收龙气只是计划之一，他的另一个计划——杀贞德、碎龙气！ 进行的非常顺利。 他永远不会空手而归。 79497-79497, 标注, 2025 年 2 月 19 日星期三 下午 11:04:58 万事都要有两手准备，直奔着一个目标的话，容易让自己陷入绝境。 80233-80235, 标注, 2025 年 2 月 20 日星期四 上午 7:56:40 他身上有一股暮气，暮气并非贬义词，只是人们向往新生，所以这个词往往不符合人们的喜好。 老匹夫身上的暮气，是岁月沉淀出的，比沧桑更沧桑的气息。 81181-81183, 标注, 2025 年 2 月 20 日星期四 下午 6:53:08 许二叔见妻子不服气，就问小豆丁： “铃音啊，如果被人要欺负你，你怎么办？” “打回去！”小豆丁理直气壮。 “打不过呢？”许二叔道。 许铃音想了想：“那我和他们做朋友，他们就不会欺负我了。” 82741-82742, 标注, 2025 年 2 月 20 日星期四 下午 10:42:06 对，神殊说的是对的。一直以来，许平峰 84019-84021, 标注, 2025 年 2 月 21 日星期五 上午 8:33:17 人性是虚伪凶残的野兽，律法是禁锢它的牢笼，道德是束缚它的锁链。但秩序逐渐崩溃，这只凶残的野兽就会失去束缚，古人说礼崩乐坏，国家必亡，便是此意……….. 84254-84254, 标注, 2025 年 2 月 21 日星期五 下午 12:12:22 见状，慕南栀和白姬有些发怵，这群“淳朴” ","date":"2025-01-22","objectID":"/%E7%AC%94%E8%AE%B0%E5%A4%A7%E5%A5%89%E6%89%93%E6%9B%B4%E4%BA%BA-%E5%8D%96%E6%8A%A5%E5%B0%8F%E9%83%8E%E5%90%9B/:1:0","tags":null,"title":"[笔记]大奉打更人-卖报小郎君","uri":"/%E7%AC%94%E8%AE%B0%E5%A4%A7%E5%A5%89%E6%89%93%E6%9B%B4%E4%BA%BA-%E5%8D%96%E6%8A%A5%E5%B0%8F%E9%83%8E%E5%90%9B/"},{"categories":null,"content":" Table of Contents 1 Entries ","date":"2025-01-22","objectID":"/%E7%AC%94%E8%AE%B0%E6%B0%B4%E8%9B%87%E8%85%B0-%E6%B1%AA%E6%9B%BE%E7%A5%BA/:0:0","tags":["shuisheyao","note","ireader"],"title":"[笔记]水蛇腰-汪曾祺","uri":"/%E7%AC%94%E8%AE%B0%E6%B0%B4%E8%9B%87%E8%85%B0-%E6%B1%AA%E6%9B%BE%E7%A5%BA/"},{"categories":null,"content":"1 Entries 48-49, 标注, 2025 年 1 月 14 日星期二 下午 1:17:39 新麦、旧柳，抽了卷须的豌豆苗，散过了絮的蒲公英，全都欣然接受这点水气。 135-137, 标注, 2025 年 1 月 14 日星期二 下午 6:28:01 小鸡小鸭都很可爱。小鸡娇弱伶仃，小鸭傻气而固执。看它们在竹笼里挨挨挤挤，窜窜跳跳，令人感到生命的欢悦。捉在手里，那点轻微的挣扎搔挠，使人心中砰砰然，胸口痒痒的。 154-155, 标注, 2025 年 1 月 14 日星期二 下午 6:30:11 蚕豆花开得闹嚷嚷的，斑鸠在叫。 181-183, 标注, 2025 年 1 月 14 日星期二 下午 6:33:41 放鸭是很苦的事。问放鸭人，顶苦的是什么？“冷清”。放鸭和种地不一样。种地不是一个人，撒种、车水、薅草、打场，有歌声，有锣鼓，呼吸着人的气息。养鸭是一种游离，一种放逐，一种流浪。 295-295, 标注, 2025 年 1 月 14 日星期二 下午 6:51:52 手艺人都带着他那个行业特有的颜色。 298-299, 标注, 2025 年 1 月 14 日星期二 下午 9:06:11 不知道为什么，原来挺敞亮的店堂变得黑暗了，牌匾上的金字也都无精打采了。那座柜台显得特别的大。大，而空。 326-326, 标注, 2025 年 1 月 14 日星期二 下午 9:11:18 巴颜喀拉山”， 458-459, 标注, 2025 年 1 月 14 日星期二 下午 9:28:50 他隔个把月就要出一次门，四乡八镇，到处跑。像一只饥饿的鸟，到处飞，想给儿女们找一口食。回来时总带着满身的草屑灰尘； 539-539, 标注, 2025 年 1 月 14 日星期二 下午 9:57:21 吃不饱的时候，只要把这三块图章拿出来看看，他就觉得对这个世界没有什么可抱怨的了。 567-567, 标注, 2025 年 1 月 14 日星期二 下午 9:59:47 这些辛苦得近于麻木的人，是难得这样开怀一笑的呀。 753-753, 标注, 2025 年 1 月 15 日星期三 下午 10:34:04 麻木、半身不遂、膨胀噎嗝、吐血流红、对口搭背、 840-841, 标注, 2025 年 1 月 15 日星期三 下午 10:50:47 王四海站起来，沿着承志河，漫无目的地走着。夕阳把他的影子拉得很长。 905-907, 标注, 2025 年 1 月 18 日星期六 下午 12:32:03 丢失衣物的人家，如果对李三说，有几件重要的东西，本家愿出钱赎回，过些日子，李三真能把这些赃物追回来。但是是怎样追回来的，是什么人偷的，这些事是不作兴问的。这也是规矩。 1037-1037, 标注, 2025 年 1 月 23 日星期四 下午 10:53:39 夫天地者万物之逆旅，光阴者百代之过客” 1168-1168, 标注, 2025 年 2 月 2 日星期日 下午 9:12:51 一庭春雨瓢儿菜，满架秋风扁豆花。”他很 1222-1223, 标注, 2025 年 2 月 5 日星期三 下午 10:37:30 晚饭花就是野茉莉。因为是在黄昏时开花，晚饭前后开得最为热闹，故又名晚饭花。 1237-1238, 标注, 2025 年 2 月 5 日星期三 下午 10:41:44 尤其是那盏珠子灯，洒下一片淡绿的光。绿光中珠幡的影子轻轻地摇曳，如梦如水，显得异常安静。元宵的灯光扩散 1237-1238, 标注, 2025 年 2 月 5 日星期三 下午 10:41:51 尤其是那盏珠子灯，洒下一片淡绿的光。绿光中珠幡的影子轻轻地摇曳，如梦如水，显得异常安静。元宵的灯光扩散着吉祥、幸福和朦胧暧昧的希望。 1345-1346, 标注, 2025 年 2 月 9 日星期日 下午 11:01:38 不教白发催人老 更喜春风满面生 1371-1372, 标注, 2025 年 2 月 9 日星期日 下午 11:07:37 “靠本事吃饭，比谁也不低。麻油拌芥菜，各有心中爱，谁也不许笑话谁！” 1676-1677, 标注, 2025 年 2 月 20 日星期四 下午 10:15:31 座上客常满，杯中酒不空。 1854-1854, 标注, 2025 年 2 月 24 日星期一 下午 10:35:11 瓦罐不离井上破，大将难免阵头亡。 1888-1888, 笔记, 2025 年 2 月 26 日星期三 下午 10:30:05 哈哈 1888-1888, 标注, 2025 年 2 月 26 日星期三 下午 10:30:05 袼褙， 1898-1899, 标注, 2025 年 2 月 26 日星期三 下午 10:32:50 靠里的车床是一张大的，那还是戴车匠的父亲留下的。老一辈人打东西不怕费料，总是超过需要的粗壮。这张老车床用了两代人，坐板已经磨得很光润，所有的榫头都还是牢牢实实的，没有一点活动。 1910-1913, 标注, 2025 年 2 月 26 日星期三 下午 10:36:44 车匠用的木料都是坚实细致的，檀木——白檀、紫檀、红木、黄杨、枣木、梨木，最次的也是榆木的。戴车匠踩动踏板，执刀就料，旋刀轻轻地吟叫着，吐出细细的木花。木花如书带草，如韭菜叶，如番瓜瓤，有白的、浅黄的、粉红的、淡紫的，落在地面上，落在戴车匠的脚上，很好看。住在这条街上的孩子多爱上戴车匠家看戴车匠做活，一个一个，小傻子似的，聚精会神，一看看半天。 1996-1998, 标注, 2025 年 3 月 1 日星期六 下午 10:54:58 吴老二蹙着眉头想：我怎么就这么不走运呢？ 他不知道，他的买卖开不好，原因就是他的精神萎靡。他老是这么拖拖沓沓，没精打采，吃茶吃饭的顾客，一看见他的呆滞的目光，就倒了胃口了。 一个人要兴旺发达，得有那么一点精气神。 2458-2459, 标注, 2025 年 3 月 16 日星期日 下午 10:47:49 黑夜思量千条路，清早起来依旧磨豆腐”。 2714-2715, 标注, 2025 年 3 月 26 日星期三 下午 10:30:09 八月，他用莲子（不是用藕）种了一缸小荷花，从越塘捞了二、三十尾小鱼秧养在荷花缸里，看看它们悠然来去，真是万虑俱消，如同置身濠濮之间。 2742-2743, 标注, 2025 年 3 月 27 日星期四 下午 10:34:42 猫也瘦了，狗也瘦了，人也瘦了，花也瘦了。 2740-2743, 标注, 2025 年 3 月 27 日星期四 下午 10:34:59 ”二奶奶这样多疑，弄得所有的人都不舒服。原来有说有笑、和和气气的一家人，弄得清锅冷灶，寡淡无聊。谁都怕不定什么时候触动二奶奶的一根什么筋，二奶奶的脸上刷地一下就挂下了一层六月严霜。猫也瘦了，狗也瘦了，人也瘦了，花也瘦了。 ","date":"2025-01-22","objectID":"/%E7%AC%94%E8%AE%B0%E6%B0%B4%E8%9B%87%E8%85%B0-%E6%B1%AA%E6%9B%BE%E7%A5%BA/:1:0","tags":["shuisheyao","note","ireader"],"title":"[笔记]水蛇腰-汪曾祺","uri":"/%E7%AC%94%E8%AE%B0%E6%B0%B4%E8%9B%87%E8%85%B0-%E6%B1%AA%E6%9B%BE%E7%A5%BA/"},{"categories":null,"content":" 41-41, 标注, 2025 年 1 月 15 日星期三 上午 7:26:45 通往佳境的方式，需要在绝境中寻找。” 41-44, 标注, 2025 年 1 月 15 日星期三 上午 7:28:36 向我们展示了如何深入了解自己的内心，照亮其中被阴影遮盖的部分。他们将黑暗角落里的种种发现拖到亮处，与之对峙。他们在未知的道路上英勇地前行，寻求改变，即使遇到挫折也不放弃。他们提醒我们，虽然过程往往很不容易，但我们完全可以克服恐惧，突破自我设定的各种界限——我们置身其中时，往往将禁锢错认为安全感。 65-66, 标注, 2025 年 1 月 15 日星期三 上午 7:29:29 心理治疗并非由治疗师来解决问题，而是治疗师与来访者一个星期又一个星期地面对面交流，争取获得某种彼此能够达成共识的心理真相。 356-357, 标注, 2025 年 1 月 15 日星期三 下午 9:54:02 我也因此处于一种奇怪的境地：我对十九世纪的科学了如指掌，尤其是与达尔文和弗洛伊德有关的内容，对自己所处时代的流行文化则一窍不通。许多年以后，我并没有发现自己有任何遗憾，我有书看就足够了。 456-458, 标注, 2025 年 1 月 15 日星期三 下午 10:02:30 我在多年来的心理治疗中发现，每当儿童在小小年纪就担上成年人的责任且不可避免地失败以后，他们在长大成人后便会一直为此感到焦虑。他们似乎永远无法接受自己当时年纪太小无法胜任的现实，于是会将这种失败藏在心底。 555-557, 标注, 2025 年 1 月 16 日星期四 上午 8:15:17 心理边界（psychological boundaries）的问题。人们确立这样的界限，好让他人以安全合理的方式与自己打交道。一个人的边界感越强，心理也就越健康；他或她就能向别人表示自己能够接受什么、不能接受什么。 591-592, 标注, 2025 年 1 月 16 日星期四 上午 8:20:10 弗洛伊德说，我们的显意识扼制住了无意识的冲动或本能，比如性欲或攻击性，而我们置身的文明社会也不希望我们意识到其存在。 591-593, 标注, 2025 年 1 月 16 日星期四 上午 8:20:28 弗洛伊德说，我们的显意识扼制住了无意识的冲动或本能，比如性欲或攻击性，而我们置身的文明社会也不希望我们意识到其存在。因此，这些欲望受到压抑、否认与升华之类的防御机制的层层防护。无意识欲望渗入我们意识的一种途径就是梦境。 591-594, 标注, 2025 年 1 月 16 日星期四 上午 8:20:43 弗洛伊德说，我们的显意识扼制住了无意识的冲动或本能，比如性欲或攻击性，而我们置身的文明社会也不希望我们意识到其存在。因此，这些欲望受到压抑、否认与升华之类的防御机制的层层防护。无意识欲望渗入我们意识的一种途径就是梦境。在梦中，无意识中的内容伪装成了各种符号。不过弗洛伊德也认为，如果我们对这些符号进行解释与自由联想，就有可能弄清楚其试图透露的是什么。 591-596, 标注, 2025 年 1 月 16 日星期四 上午 8:21:08 弗洛伊德说，我们的显意识扼制住了无意识的冲动或本能，比如性欲或攻击性，而我们置身的文明社会也不希望我们意识到其存在。因此，这些欲望受到压抑、否认与升华之类的防御机制的层层防护。无意识欲望渗入我们意识的一种途径就是梦境。在梦中，无意识中的内容伪装成了各种符号。不过弗洛伊德也认为，如果我们对这些符号进行解释与自由联想，就有可能弄清楚其试图透露的是什么。如果梦境伪装得太好，就难以诠释；如果伪装得不够好，就成了噩梦。弗洛伊德有句话说得很对：“梦是通往无意识的捷径。”所以说，梦在心理治疗中至关重要。 722-724, 标注, 2025 年 1 月 16 日星期四 下午 6:38:55 每一个案例都需要反复评估，如果来访者心理上未表现出改善，就有必要采取别的方法。据说爱因斯坦就说过这样的话：“疯狂的定义就是反复做同一件事并期待不同的结果。” 787-788, 标注, 2025 年 1 月 16 日星期四 下午 6:43:07 拉曾经受到伤害，但她从未扮演过受害者的角色。这也正是她的英勇之处。多年来一直在奋斗的她，每天起床时依然会下决心要成为更好的自己。 848-849, 标注, 2025 年 1 月 16 日星期四 下午 6:46:58 翠西和她的伴侣犹如两颗迷失的心灵，就亲密程度而言，他们是彻头彻尾的陌生人。 1046-1047, 标注, 2025 年 1 月 17 日星期五 上午 8:13:25 经过三年的心理治疗，劳拉已经学会如何挖掘自己的无意识。我希望她此刻能够这么做，即便这是一道新的伤口。我提示说，伤口包扎如果没有足够的透气性会溃烂。 1094-1095, 标注, 2025 年 1 月 17 日星期五 上午 8:16:19 劳拉慢慢学会了如何适应中产阶级的生活。她开始理解可靠、长远目标与积蓄不断增长的好处。 1122-1123, 标注, 2025 年 1 月 17 日星期五 上午 8:18:58 我提醒劳拉，由于她来自一个不健全的家庭，因此正常的行为会让她感到尴尬与不自然。但要是她坚持下去，慢慢就会感到越来越自然。 1123-1124, 标注, 2025 年 1 月 17 日星期五 上午 8:19:10 每当她愤怒时都要记住，愤怒是一种防御而非感受，她需要分析愤怒所掩盖的是什么感受。 1207-1208, 标注, 2025 年 1 月 17 日星期五 上午 8:24:59 我从小就知道没有人会替我们做自己该做的事。 1214-1215, 标注, 2025 年 1 月 17 日星期五 上午 8:25:39 你也知道，生活就像是丛林，他是坐着教皇专车一路穿越过去的。而我则手拿斧头生生开辟出一条路，步行穿过最黑暗的区域，还深入充满水蛭和鳄鱼的沼泽。” 1214-1217, 标注, 2025 年 1 月 17 日星期五 上午 8:25:58 你也知道，生活就像是丛林，他是坐着教皇专车一路穿越过去的。而我则手拿斧头生生开辟出一条路，步行穿过最黑暗的区域，还深入充满水蛭和鳄鱼的沼泽。”她说，“关于这片丛林，我知道的可比他多得多。我还不得不独自穿行，不断走错方向，直到我对其了如指掌，并最终活着走了出来。我倒要看看他会怎么办。这也许算不上英雄事迹，但也是种成就。 1244-1246, 标注, 2025 年 1 月 17 日星期五 下午 6:33:19 心理学与考古学在很多方面都十分相似。我们一层层不断向下挖掘，然后小心翼翼地掸去出土文物上的灰尘，最终发现一整个比小说还要离奇的被掩埋的世界。 1335-1337, 标注, 2025 年 1 月 17 日星期五 下午 6:42:39 “最糟糕的就是孤独感。”他回忆那些岁月时说道，“虽然我偶尔会挨打和挨冻，但最令我痛苦的其实是挥之不去的孤独。”他记得自己看见树上的松鼠时会乞求它们到窗前来。“ 1621-1623, 标注, 2025 年 1 月 17 日星期五 下午 9:41:37 对来访者过度解释是心理治疗师缺乏经验或信心的标志。治疗师可以将来访者领到理解的大门前，但不应该强迫他们进去。来访者会在自己做好准备后踏入门内。 1951-1952, 标注, 2025 年 1 月 18 日星期六 下午 12:07:32 他一根接一根地将自己王冠上的荆棘拔去，在接受心理治疗后获得了重生： 1959-1960, 标注, 2025 年 1 月 18 日星期六 下午 12:09:27 彼得曾经说过，如果必须一桶桶地清走大西洋岸边的所有沙子，他只要坚持不懈就能做到。他正是这样慢慢地、有条不紊地为心理平衡抗争的：并非给予一次猛击，而是通过许多次轻轻的击打实现的。 1989-1990, 标注, 2025 年 1 月 18 日星期六 下午 12:12:09 我现在喜欢这样的我，并且觉得我经历的一切都自有其目的。我想这就是上天的安排：让我成为现在的我。” 2021-2022, 标注, 2025 年 1 月 18 日星期六 下午 12:14:07 智慧就是知道自己有所不知。” 2122-2122, 标注, 2025 年 1 月 18 日星期六 下午 12:42:02 感觉不到痛苦的人也无法感受到快乐。” 2153-2155, 标注, 2025 年 1 月 18 日星期六 下午 12:45:02 丹尼的父亲在孩子们没有听从警告后并未执意阻止或进行干预，这一点十分值得玩味。这是白人和原住民育儿方式有别的一个例证。按照布兰特博士的说法，原住民以身作则但不干预，而白人则主张积极主动的教导与塑造。 2189-2193, 标注, 2025 年 1 月 18 日星期六 下午 12:50:22 1988 年时，我对寄宿学校尚一无所知。我原本以为那是为住在森林深处无法上学的原住民设立的寄宿学校。其实不然。这属于蓄意抹杀原住民文化的一部分政策。加拿大第一任总理约翰·A. 麦克唐纳将第一民族称为“野蛮人”。此后，联邦官员在 1920 年明确目标：文化灭绝。当年，负责印第安人事务的副主管在下议院宣布，他的目标是继续开办寄宿学校，直到“加拿大所有印第安人都成为国民的一部分，再也没有印第安人的问题，也没有印第安人的部门”。 2248-2253, 标注, 2025 年 1 月 18 日星期六 下午 1:08:01 发现，《蒙特利尔每日星报》上刊登过一篇 1907 年的报告，其中提到全国就读于寄宿学校的原住民儿童死亡率为 24%（如果算上那些因病被送回家后不久死亡的儿童，死亡率为 42%）。这些孩子死于肺结核、饥饿或是单纯","date":"2025-01-22","objectID":"/%E7%AC%94%E8%AE%B0%E6%97%A9%E5%AE%89%E6%80%AA%E7%89%A9-%E5%8A%A0-%E5%87%AF%E7%91%9F%E7%90%B3%E5%90%89%E5%B0%94%E8%BF%AA%E7%BA%B3%E6%9C%A8%E8%8D%89%E8%8D%89/:0:0","tags":null,"title":"[笔记]早安，怪物-[加] 凯瑟琳·吉尔迪纳;木草草","uri":"/%E7%AC%94%E8%AE%B0%E6%97%A9%E5%AE%89%E6%80%AA%E7%89%A9-%E5%8A%A0-%E5%87%AF%E7%91%9F%E7%90%B3%E5%90%89%E5%B0%94%E8%BF%AA%E7%BA%B3%E6%9C%A8%E8%8D%89%E8%8D%89/"},{"categories":null,"content":" Table of Contents 1 什么是 STRIDE 威胁建模 2 STRIDE 威胁建模整体流程 3 威胁建模 3.1 High Level 威胁建模 3.2 Low Level 威胁建模 3.2.1 应用图（Application Diagram） 3.2.2 服务图（Service Component diagram） 4 威胁识别 4.1 STRIDE-per-Element 模型 4.2 威胁发现 4.3 威胁评估 5 威胁缓解 5.1 确立缓解顺序 5.2 常用缓解方法 6 威胁验证 7 扩展阅读 本文为摘录(或转载)，侵删，原文为： https://tonydeng.github.io/2022/04/20/threat-modeling-was-conducted-based-on-STRIDE/ ","date":"2025-01-22","objectID":"/tonydeng_github_io_threat-modeling-was-conducted-based-on-stride/:0:0","tags":null,"title":"基于STRIDE进行威胁建模","uri":"/tonydeng_github_io_threat-modeling-was-conducted-based-on-stride/"},{"categories":null,"content":"1 什么是 STRIDE 威胁建模 计算机发明后不久，人们就发现需要为这些信息系统处理威胁。早在 1994 年，NSA 和 DARPA 就提出攻击树、威胁树等概念。 1999 年微软内部发表了《The threats to out products》的文章，为定义 Windows 全系列产品面临的安全威胁正式提出了 STRIDE。随着 2002 年比尔.盖茨著名的《可信任计算备忘》发布，微软承诺改善软件产品的安全性，随即正式在 SDL（安全开发生命周期）中采用了威胁建模。 Table 1: My table caption Columna 1 Columna 2 Columna 3 Fila 1 Valor 1 Valor 2 Fila 2 Valor 3 Valor 4 This is a reference to Table 1 . 研发团队的安全例行活动中，对于一些拥有重要数据资产、安全事件影响力大的系统除了要进行常规的渗透测试、黑白盒代码扫描以外，更应该系统定期开展威胁建模活动并对业务赋能。所以对于研发团队来说，引入先进的安全技术设计能力，构建全方位、多维度防御体系，是不懈追求的目标。 通过威胁建模，我们能够实现以下这些价值： 识别体系化的结构缺陷：大多数安全问题是设计缺陷问题，而不是安全性错误。威胁建模能帮助识别这些设计缺陷，从而减少风险敞口，指导安全测试，并降低因安全漏洞而造成的品牌损害或财务损失等可能性。 节约组织安全成本：通过对威胁进行建模，并在设计阶段建立安全性需求，降低安全设计缺陷导致的修复成本。在需求管理和威胁分析阶段，与业务开发团队高效互动，释放安全团队的专业能力，专注于高性价比的安全建设。 落地 DevSecOps 文化：通过威胁建模跑通开发和安全工具的流程集成，把风险管理嵌入产品的完整生命周期，从而推动形成完整的 DevSecOps 工具链。 满足合规要求：威胁建模是国际安全行业通用的方法论，通过向管理层和监管机构提供产品的风险管理活动的完整记录，帮助团队遵守全球法律法规要求，包括 PCI DSS、GDPR、HIPAA、CSA STAR 等。 STRIDE 作为当前最流行的威胁建模方法，是值得研发团队引入的威胁建模的方法。STRIDE 是以下英文的首字母缩写，把威胁分为 6 类，基本上涵盖了所有的威胁类型，帮助建模者对威胁进行建模。 S：Spoofing（假冒） T：Tampering（篡改） R：Repudiation（抵赖） I：Information Disclosure（信息泄露） D：Denial of Service（拒绝服务） E：Elevation of Privilege（权限提升） ","date":"2025-01-22","objectID":"/tonydeng_github_io_threat-modeling-was-conducted-based-on-stride/:1:0","tags":null,"title":"基于STRIDE进行威胁建模","uri":"/tonydeng_github_io_threat-modeling-was-conducted-based-on-stride/"},{"categories":null,"content":"2 STRIDE 威胁建模整体流程 STRIDE 威胁建模方法贯穿于整体风险分析流程，将安全需求分析和安全设计相互融合。STRIDE 威胁建模不仅仅可以用于安全需求分析和设计，也可用于后续安全开发环节，整体流程如图 1 所示。 Figure 1: Stride 活动图 在威胁建模过程中起主导作用的是软件设计者、开发人员和测试人员。威胁建模的对象并不一定是一个完整的软件。根据需求的不同，建模对象可以是整个应用、安全和隐私相关的功能、跨信任边界的功能等等。 Figure 2: 主活动图 威胁建模的整体过程，本质上就是通过分析系统中的各个组件本身的安全弱点和影响，形成安全风险评估，同时基于安全风险提出相应的安全要求和采用相关的安全措施，缓解安全威胁，降低安全风险。 ","date":"2025-01-22","objectID":"/tonydeng_github_io_threat-modeling-was-conducted-based-on-stride/:2:0","tags":null,"title":"基于STRIDE进行威胁建模","uri":"/tonydeng_github_io_threat-modeling-was-conducted-based-on-stride/"},{"categories":null,"content":"3 威胁建模 建模是对软件进行抽象，数据流图、统一 UML 图表、泳道图和状态图等都可用于软件建模。接下来主要介绍数据流图建模过程。 数据流图建模过程的主要步骤包括： 定义应用场景：为了明确应用或系统的关键威胁场景，包括部署方式、配置信息、用户使用方式。 收集外部依赖：收集应用或系统所依赖的外部产品、功能或服务信息。典型外部依赖包括操作系统、数据库、Web 服务器、应用服务器。 定义安全假设：采用来自其他功能组件所提供的安全服务假设，定义安全假设是为了对应用所依赖的系统环境做出准确的安全假设。 创建外部安全备注：为了让与产品相关的用户或其他应用的设计者都可以利用外部安全备注，辅助理解应用的安全边界，以及在使用应用时应如何保障安全不受侵害。 绘制数据流图：描述系统的一种方法，是威胁建模的重要产物，它使用易于理解的一种图形表示工具分析系统或应用可能面临的攻击。 其中绘制数据流图是建模过程的重点，其余步骤都是为绘制正确的数据流图做准备。 建模首先确定要分析的应用程序边界或作用范围，确定可信任部分与不可信任部分的界限。 在数据流图中创建和命名实体应遵循以下规则： 一个过程必须至少有一个数据流流入和一个数据流流出 所有的数据流都从某个过程开始，到某个过程结束 数据存储通过数据流与过程相连 数据存储不能直接连接，必须通过过程相连 ","date":"2025-01-22","objectID":"/tonydeng_github_io_threat-modeling-was-conducted-based-on-stride/:3:0","tags":null,"title":"基于STRIDE进行威胁建模","uri":"/tonydeng_github_io_threat-modeling-was-conducted-based-on-stride/"},{"categories":null,"content":"3.1 High Level 威胁建模 High Level 你可以理解为系统上下文图（System Context Diagram），这一层级中细节并不重要，只显示系统概况。 重点应该放在人员（角色）和软件系统上，而不是技术，协议和其他低层级细节上，从而使非技术人员也能够看得懂。这个图也是明确需求的重要图示。这表示一个应用和其他系统的下辖有调用关系。不需要完整表示数据的流向，只要大致描述清楚系统的周边关系，不遗漏关键步骤。 ","date":"2025-01-22","objectID":"/tonydeng_github_io_threat-modeling-was-conducted-based-on-stride/:3:1","tags":null,"title":"基于STRIDE进行威胁建模","uri":"/tonydeng_github_io_threat-modeling-was-conducted-based-on-stride/"},{"categories":null,"content":"3.2 Low Level 威胁建模 Low Level 可以采用两种建模方式。 3.2.1 应用图（Application Diagram） 应用是可单独运行/可部署的单元（例如，单独的进程空间）执行代码或存储数据。应用图显示了软件体系结构的高层结构以及如何分配职责。它还显示了主要的技术选择以及容器之间的通信方式。 一个应用包含多个服务，如果一个系统有多个子系统，应该对每个子系统都进行分析。通过威胁建模应该尝试了解整体情况，包含应用本身、数据库、交互、部署场景、云服务、接入的基础服务。 3.2.2 服务图（Service Component diagram） 服务图显示了服务如何由多个“组件”组成，每个组件是什么，它们的职责以及技术/实现接口（API）或者细节。这个细粒度的分解是建模最大的工作量，为分解的各个通用组件创建的威胁模型结果可以复用在其他应用上。比如 Kubernetes 被分为 Kube-Proxy、ETCD、Kubelet、 Kube-APIServer、Scheduler、Container、Pods 等。 ","date":"2025-01-22","objectID":"/tonydeng_github_io_threat-modeling-was-conducted-based-on-stride/:3:2","tags":null,"title":"基于STRIDE进行威胁建模","uri":"/tonydeng_github_io_threat-modeling-was-conducted-based-on-stride/"},{"categories":null,"content":"4 威胁识别 建模完成后，进入威胁识别过程。 威胁识别方法包括 STRIDE 方法、攻击树、攻击库等。主要关注 STRIDE 威胁识别方法。 该方法分析各个数据流及其关联的资产是否受到 S、T、R、I、D、E 威胁的影响，识别并记录这些威胁，然后使用 DREAD 方法对威胁进行量化分析，评估可能造成的危害程度。 ","date":"2025-01-22","objectID":"/tonydeng_github_io_threat-modeling-was-conducted-based-on-stride/:4:0","tags":null,"title":"基于STRIDE进行威胁建模","uri":"/tonydeng_github_io_threat-modeling-was-conducted-based-on-stride/"},{"categories":null,"content":"4.1 STRIDE-per-Element 模型 STRIDE-per-Element 使得 STRIDE 更加规范，通过关注每一个元素的一系列威胁，可以更容易地找到威胁。 | 元素 || 交互 || S（假冒） || T（篡改） || R（抵赖） || I（信息泄露） || D（拒绝服务） || E（权限提升） | |———|—————–|——-|——-|——-|———|———|———| | 外部实体(浏览器) || 外部交互实体将输入传入到过程 || * || || * || * || || | | || 外部交互实体从进程得到输入 || * || || || || || | | 进程 || 进程有外来数据攒送至数据存储 || * || || * || || || | | || 进程向另一个进程输出数据 || * || || * || * || * || * | | || 进程向外部交互实体（代码）发送输出 || * || || * || * || * || | | || 进程向外部交互实体（人类）发送输出 || || || * || || || | | || 进程有来自数据存储的输入数据流 || * || * || || || * || * | | || 进程有来自另一个进程的输入数据流 || * || || * || || * || * | | || 进程有来自外部交互实体的输入数据流 || * || || || || * || * | | 数据流（命令/响应 || 跨越机器边界 || || * || || * || * || | | 数据存储（数据库） || 进程有输出数据流至数据存储 || || * || * || * || * || | | || 进程有来自数据存储的输入数据流 || * || || * || * || || | 如何进行威胁识别，可以参考下面这个的例子，场景是租户通过第三方开放平台登录后通过微服务处理业务。 对于 API 网关，存在的威胁包括： 认证和授权 未强制 HTTPS 缺失二次认证措施 日志和监控 缺失日志记录和审计模块 日志本地留存 对于 IAM 服务服务器，存在的威胁包括： 信息泄露：用户身份信息泄露 认证 暴力破解对外发送的管理平台 Token 授权策略绕过 可用性 单机实例，误操作可导致宕机风险 对于 MySQL 服务，部分存在的威胁包括： 认证：攻击者获取凭据后可以直接访问、修改、删除业务数据 权限提升：攻击者可以从普通用户提升至 Root，获取数据库完全控制权限 信息泄露：SQL 注入导致所保存的业务数据泄露 ","date":"2025-01-22","objectID":"/tonydeng_github_io_threat-modeling-was-conducted-based-on-stride/:4:1","tags":null,"title":"基于STRIDE进行威胁建模","uri":"/tonydeng_github_io_threat-modeling-was-conducted-based-on-stride/"},{"categories":null,"content":"4.2 威胁发现 使用 STRIDE 对威胁分类后，可以使用威胁树分析程序中的威胁和漏洞。 硬件领域常用“故障树”识别可能存在的故障模式，同样的方法也适用于描述软件安全问题。 威胁树起源于故障树，采用树形结构描述系统面临的威胁。 用根节点表示系统所面临威胁的抽象描述，逐层细化威胁的细节信息，直到用叶节点表示具体攻击方式。 威胁树描述了攻击者破坏各组件所经历的决策过程。 ","date":"2025-01-22","objectID":"/tonydeng_github_io_threat-modeling-was-conducted-based-on-stride/:4:2","tags":null,"title":"基于STRIDE进行威胁建模","uri":"/tonydeng_github_io_threat-modeling-was-conducted-based-on-stride/"},{"categories":null,"content":"4.3 威胁评估 建立威胁树后，就可以对威胁进行量化评估，评定其严重程度，可以使用 DREAD 方法来完成。 DREAD 方法是以下单词的首字母缩写，分别从五个方面描述威胁的危害程度，每个方面危害程度的评分范围是 1～10,10 表示威胁造成的危害程度最大。 Damage potential（潜在破坏性）: 用于衡量威胁可能造成的实际破坏程度，如 10 可以表示攻击者可能绕开所有安全限制，实际上能做任何事情；7～8 表示攻击者能读取机密数据；6表示攻击者能使服务器暂时不可用。 Reproducibility（再现性）：即衡量威胁可能造成的实际破坏程度，如 10 可以表示攻击者可能绕开所有安全限制，实际上能做任何事情； 7～8 表示攻击者能读取机密数据；6表示攻击者能使服务器暂时不可用。 Exploitability（可利用性）：指的是进行一次攻击需要的努力和专业知识。如果一个普通用户使用一台家庭计算机就能实施攻击，可以评定为 10。如果需要动用大量人力物力才能进行一次攻击，那么可利用性评为 1。 Affected users（受影响用户）：指如果威胁被利用并成功攻击，有多少用户会受到影响，10 指所有用户都会受到影响，1～9 表示受影响用户的百分比。 Discoverability（可发现性）：指如果威胁被利用并成功攻击，有多少用户会受到影响，10 指所有用户都会受到影响，1～9 表示受影响用户的百分比。 依据公式 “风险=受攻击概率危害程度”* ，可以计算出五个风险值，然后对五个风险值求平均数，平均数越大，则威胁对系统造成的风险就越大。假设受攻击概率为 100%，最高风险值是 10。 ","date":"2025-01-22","objectID":"/tonydeng_github_io_threat-modeling-was-conducted-based-on-stride/:4:3","tags":null,"title":"基于STRIDE进行威胁建模","uri":"/tonydeng_github_io_threat-modeling-was-conducted-based-on-stride/"},{"categories":null,"content":"5 威胁缓解 识别威胁后，就可以对已经暴露的威胁进行缓解。 不同风险等级的威胁可以采取不同处理策略： 低风险安全威胁，可以保持现状 潜在的用户危险操作，要及时提醒 可以缓解的威胁，要采取加密、认证等技术缓解措施 风险过高并且难以实施缓解措施的威胁，可以考虑删除/关闭相应功能 ","date":"2025-01-22","objectID":"/tonydeng_github_io_threat-modeling-was-conducted-based-on-stride/:5:0","tags":null,"title":"基于STRIDE进行威胁建模","uri":"/tonydeng_github_io_threat-modeling-was-conducted-based-on-stride/"},{"categories":null,"content":"5.1 确立缓解顺序 威胁的缓解顺序在整体设计上要有条理性和层次性。 例如，对闯入家里进行威胁建模。考虑窗户是受攻击面，那么威胁包括打破窗户进入和打开窗户进入的人。 打破窗户可以通过使用强化玻璃来阻止，这就是一阶缓解措施； 打破玻璃威胁也可以通过警报来解决，这就是二阶防御措施。 如果切掉电源，警报失效，为了解决这个三阶威胁，系统设计人员可以添加更多的防御措施，例如，警报包含剪断电源警报，防御者可以添加电池、手机或者其他无线设备。 虽然具体威胁所采用的缓解措施截然不同，但是一定要有全面的缓解措施，因为一旦底层的措施出现纰漏，无论高层措施多么完善，攻击者依然可以以很低成本进行攻击。 ","date":"2025-01-22","objectID":"/tonydeng_github_io_threat-modeling-was-conducted-based-on-stride/:5:1","tags":null,"title":"基于STRIDE进行威胁建模","uri":"/tonydeng_github_io_threat-modeling-was-conducted-based-on-stride/"},{"categories":null,"content":"5.2 常用缓解方法 不同安全威胁需要采用不同的技术缓解方法。 上面是几种常用的缓解方法，包括认证、授权、防篡改和增强保密性的技术。 在建模、识别及缓解威胁的过程中，必须记录每一个操作的详细信息，以便于理解和管理。 ","date":"2025-01-22","objectID":"/tonydeng_github_io_threat-modeling-was-conducted-based-on-stride/:5:2","tags":null,"title":"基于STRIDE进行威胁建模","uri":"/tonydeng_github_io_threat-modeling-was-conducted-based-on-stride/"},{"categories":null,"content":"6 威胁验证 验证是为了确保威胁模型准确反映应用程序的潜在安全问题，验证的内容包括: 威胁模型 列举的威胁 缓解措施和假设 验证威胁是说明列举出的威胁如何进行攻击，攻击的内容及影响。 如果验证威胁出现问题，说明威胁没有被正确识别，可能需要重新建模。 此外，还要分析威胁列举是否全面，如与可信边界接触的元素都可能被污染，这些元素都应该考虑 STRIDE 威胁。 如果建模时得到的威胁不够全面，需要进一步补充。 验证缓解措施是指检验缓解措施能否有效降低威胁影响，是否正确实施，每个威胁是否都有相应缓解措施。一旦措施无效，或者低效，必须重新选择缓解方法。如果没有正确实施，应该发出警告，确保缓解措施的有效性。 危害较为严重的威胁都要有缓解措施，以减少危害程度。 验证假设是为了判断假设是否正确，只有假设合理，才能保证在假设条件下进行的操作是合理的。 ","date":"2025-01-22","objectID":"/tonydeng_github_io_threat-modeling-was-conducted-based-on-stride/:6:0","tags":null,"title":"基于STRIDE进行威胁建模","uri":"/tonydeng_github_io_threat-modeling-was-conducted-based-on-stride/"},{"categories":null,"content":"7 扩展阅读 Trustworthy Computing - Bill Gates 可信计算-维基百科 Threat Model- Google ","date":"2025-01-22","objectID":"/tonydeng_github_io_threat-modeling-was-conducted-based-on-stride/:7:0","tags":null,"title":"基于STRIDE进行威胁建模","uri":"/tonydeng_github_io_threat-modeling-was-conducted-based-on-stride/"},{"categories":null,"content":" Table of Contents 1 什么是 SDL 2 为什么要做 SDL 3 微软 SDL 4 安全设计核心原则 5 SDL 困难 6 总结 7 reference： 本文为摘录(或转载)，侵删，原文为： https://xz.aliyun.com/t/11922?time__1311=Cq0xuD2DgAexlxGghKIxGKj2ewfxG8AeD ","date":"2025-01-21","objectID":"/sdl_note/:0:0","tags":["sdl","安全","模型","sec","model"],"title":"sdl_note","uri":"/sdl_note/"},{"categories":null,"content":"1 什么是 SDL SDL 其实是由微软提出并应用一个帮助开发人员构建更安全的软件和解决安全合规要求的同时降低开发成本的软件开发过程，侧重于软件开发的安全保证过程，旨在开发出安全的软件应用。 SDL 的核心理念就是将安全考虑集成在软件开发的每一个阶段：需求分析、设计、编码、测试和维护。从需求、设计到发布产品的每一个阶段每都增加了相应的安全活动，以减少软件中漏洞的数量并将安全缺陷降低到最小程度。 ","date":"2025-01-21","objectID":"/sdl_note/:1:0","tags":["sdl","安全","模型","sec","model"],"title":"sdl_note","uri":"/sdl_note/"},{"categories":null,"content":"2 为什么要做 SDL 举个例子： 在大部分企业中，传统的做法是在产品快要上线前经过安全测试或者安全扫描，这种做法比较局限。在发现安全问题和解决问题都是在整个流程的后期，这样就会导致项目交付时间紧迫，安全活动往往被牺牲在紧张的交付时间期限内，导致大量安全活动被压缩。 而且在大型企业中，有众多的产品线，而这些产品线只能靠投入人力资源去跟踪测试，随着开发需求的不断增多，投入的安全人力资源也需要增多，给企业增加大量的成本负担。 那 SDL 可以为企业带来什么？ 首先 SDL 是将安全活动嵌入到整个流程中去，从立项需求评审、开发代码扫描、测试漏洞扫描、发布基础环境检查、上线实时安全监控与检查这些环节逐步保证研发流程的安全，做到尽可能将安全问题往前移，建立流水线的日常安全任务保证安全横向(全面覆盖所有的研发项目)、纵向(对一个研发项目各个环节加入安全检查)的覆盖率。 SDL 好处之一是在全流程中介入安全，越早发现漏洞问题，修复成本越低；产品的安全状态可以在整个开发过程得到更精准的反馈，有助于产品的安全进度管理。 这是一张在各个时期修复漏洞所产生的成本 可以看到在软件发布运行一段时间后，才发现的漏洞，需要运维，发布的介入，修复成本成几何级数上升，给企业带来相当大的风险和成本压力，若漏洞已被黑客发现或利用，造成的损失和影响将更大。 而在研发阶段，发现的漏洞可以由开发直接修复，成本低，效率高。 所以越早发现漏洞问题，修复成本越低。 ","date":"2025-01-21","objectID":"/sdl_note/:2:0","tags":["sdl","安全","模型","sec","model"],"title":"sdl_note","uri":"/sdl_note/"},{"categories":null,"content":"3 微软 SDL 微软官网上的 SDL 实施流程图 下面来解释下这些安全步骤 培训： 管理制度，提供安全培训， 增强安全意识，确保人员了解安全基础知识。 需求： 安全要求，定义安全隐私要求与安全门限要求，包括法律和行业要求，内部标准和编码惯例，对先前事件的审查以及已知威胁等，安全门限要求指安全质量 的最低可接受级别，明确定义安全漏洞的严重性阈值； 设计： 安全隐私 需求分析与设计，具体措施包括执行威胁建模，建立设计要求，明确加密标准； 实施： 管理使用第三方组件的安全风险，拥有准确的第三方组件清单，并了解其安全漏洞可能对集成它们的系统的安全性产生影响； 验证： 安全研发与验证，具体举措包括使用经过安全性检查，认可 的工具，执行静态应用程序与动态应用程序安全性测试，进行渗透测试； 发布： 发布部署阶段，建立标准的事件响应流程； 响应： 针对运营安全， 通过人员权限认证，数据加密存储、传输，安全监控，定期更新安全策略，抵御常见网络攻击，执行渗透测试等手段保证上线运营阶段的安全。 ○ 培训 Training 核心安全培训 提高团队安全意识，对齐安全需求。 开发团队的所有成员都需要接受适当的安全培训，了解相关的安全知识，培训对象包括开发人员，测试人员、项目经理、产品经理等。项目的中期可开展针对性的培训，例如代码中经常出现的问题，测试过程中多次出现的漏洞等等。 ○ 需求 Requirements 1.确认安全需求 安全研发与验证，具体举措包括使用经过安全性检查，认可 的工具，执行静态应用程序与动态应用程序安全性测试，进行渗透测试； 2.创建质量标准及 Bug 栏 用于确定安全和隐私质量的最低可接受级别，在项目开始时定义这些标准可加强对安全问题相关风险的理解，并有助于团队在开发过程中发现和修复安全 bug。 项目团队必须协商确定每个开发阶段的质量门，随后将质量门交由给安全顾问审批，安全顾问可以根据需要添加特定于项目的说明，以及更加严格的安全要求。 3.安全\u0026隐私风险评估 项目的哪些部分在发布前需要威胁模型； 项目的哪些部分在发布前需要进行安全设计评析； 项目的哪些部分需要不属于项目团队且双方认可的小组进行渗透测试； 是否存在安全顾问认为有必要增加的测试或分析要求以缓解安全风险； 模糊测试的具体范围； 隐私对评级的影响。 ○ 设计 Design 1.确认设计要求 在设计阶段应该仔细考虑安全和隐私问题，在项目初期确定好安全需求，尽可能避免安全引起的需求变更。 2.分析攻击面 减小攻击面与威胁建模紧密相关，不过它解决安全问题的角度稍有不同。减小攻击面通过减小攻击者利用潜在弱点或漏洞的机会来降低风险。 3.威胁建模 为项目或产品面临的威胁建立模型，明确分析攻击可能来自哪里。 ○ 实施 Implementation 1.使用批准工具 开发团队使用的编辑器、链接器等相关工具，可能会涉及一些安全相关的环节，因此在使用工具的版本上，需要提前与安全团队进行沟通； 2.弃用不安全的函数 许多常用函数可能存在安全隐患，应当禁用不安全的函数 API，使用安全团队推荐的函数。 3.对代码进行静态安全检查（静态分析） 代码静态分析可以由相关工具辅助完成，其结果与人工分析相结合。 ○ 验证 Verification 1.动态安全测试（动态分析） 动态分析是静态分析的补充，用于测试环节验证程序的安全性。 2.模糊测试 模糊测试策略的制定，以应用程序的预期用途，以及应用程序的功能和设计规范为基础。 3.攻击面评审 项目经常会因为需求等因素导致最终的产出偏离原本设定的目标，因此在项目后期对威胁模型和攻击面进行评析是有必要的，能够及时发现问题并修正。 ○ 发布 Release 1.制定安全应急响应计划 每个软件在发布时都必须包含事件响应计划。即使在发布时不包含任何已知漏洞的产品，也可能在日后面临新出现的威胁。如果产品中包含第三方的代码，也需要留下第三方的联系方式并加入事件响应计划，以便在发生问题时能够找到对应的人。 2.最终安全评审（FSR） 是在发布之前仔细检查对软件执行的所有安全活动。 3.发布归档 在通过 FSR 或者虽有问题但达成一致后，可以完成产品的发布。但发布的同时仍需对各种问题和文档进行存档，为紧急响应和产品升级提供帮助。 ○ 响应 Response 执行安全应急响应计划 ","date":"2025-01-21","objectID":"/sdl_note/:3:0","tags":["sdl","安全","模型","sec","model"],"title":"sdl_note","uri":"/sdl_note/"},{"categories":null,"content":"4 安全设计核心原则 微软多年的实践和经验，软件的安全问题很大一部分是由于不安全的设计而引入的。 在设计阶段造成的安全缺陷在后期修复的成本和时间都相对较高。 相应的微软 SDL 也提出了若干核心的安全设计原则，并提出了如攻击面最小化、STRIDE 威胁建模等多种方法辅助安全人员对软件进行安全设计。 ○ 威胁模型 在 SDL 模型里，还有个很重要的执行要点，那就是威胁建模，威胁建模是在需求设计阶段的一项识别和消减威胁的重要手段。关于威胁建模，微软提出的一个方法叫做“STRIDE”。 STRIDE 威胁建模基于数据流图去识别不同环节是否存在仿冒、篡改、抵赖、信息泄露、拒绝服务、权限提升几个维度的安全威胁，并制定对应的消减措施，落实并验证的一个过程。 ","date":"2025-01-21","objectID":"/sdl_note/:4:0","tags":["sdl","安全","模型","sec","model"],"title":"sdl_note","uri":"/sdl_note/"},{"categories":null,"content":"5 SDL 困难 实施 SDL 导致整个流程线延长，安全开发软件所需的时间也随之延长，但碍于项目交付时间有限，最终会导致安全在活动中流于形式。 由于开发人员安全意识以及能力欠缺，仅靠人工实现效果差强人意，所以还需要配合自动化平台工具使用。 部分企业由于没有符合自身的一套安全开发流程，按照 SDL 模型照猫画虎去实现安全活动往往也没办法使得安全活动很好的落地，这样导致的结果就是整个安全研发流程流于形式。 ","date":"2025-01-21","objectID":"/sdl_note/:5:0","tags":["sdl","安全","模型","sec","model"],"title":"sdl_note","uri":"/sdl_note/"},{"categories":null,"content":"6 总结 实施 SDL 不能照搬照的实际情况。 SDL 只是一个方法指导，具体如何实施还是需要依赖于自己公司的业务，还是得结合公司务情况。 应该做到以人为本，尽可能的为研发团队着想，为研发团队安全赋能，降低其安全实施门槛，能够轻轻松松的应付各种安全问题。 SDL 实施是一个从上到下的过程，不仅需要对开发以及安全等人员进行培训，还需要让高层领导了解到实施 SDL 的重要性。 ","date":"2025-01-21","objectID":"/sdl_note/:6:0","tags":["sdl","安全","模型","sec","model"],"title":"sdl_note","uri":"/sdl_note/"},{"categories":null,"content":"7 reference： 微软 SDL 流程终极整理总结 https://blog.csdn.net/weixin_43965597/article/details/122882914 从 SDL 到 DevSecOps：始终贯穿开发生命周期的安全 https://zhuanlan.zhihu.com/p/146149814 ","date":"2025-01-21","objectID":"/sdl_note/:7:0","tags":["sdl","安全","模型","sec","model"],"title":"sdl_note","uri":"/sdl_note/"},{"categories":null,"content":" Table of Contents 1 Microsoft 安全开发生命周期(SDL) 1.1 培训 1.2 要求 1.3 Design 1.4 实现 1.5 验证 1.6 发布 1.7 响应 2 微软 SDL 流程终极整理总结 2.1 一、微软 SDL(Security Development Lifecycle)流程框架 2.2 二、主要步骤 2.3 三、SDL 实战经验准则 2.4 四、与 SAMM 对比 2.5 五、常用 SDL 实施方法和工具 2.6 六、敏捷 SDL 2.7 七、软件安全开发流程新增的安全活动 2.8 八、附件《安全选项表》 本文为摘录(或转载)，侵删，原文为： https://blog.csdn.net/weixin_43965597/article/details/122882914 ","date":"2025-01-21","objectID":"/blog_csdn_net_details_122882914/:0:0","tags":["sdl","security"],"title":"微软软件安全开发流程（SDL） security-development-lifecycle","uri":"/blog_csdn_net_details_122882914/"},{"categories":null,"content":"1 Microsoft 安全开发生命周期(SDL) https://learn.microsoft.com/zh-cn/compliance/assurance/assurance-microsoft-security-development-lifecycle 在开发安全软件时，安全和隐私绝不能事后考虑，必须制定正式流程，以确保在产品生命周期的所有阶段都考虑它们。 Microsoft 的安全开发生命周期 (SDL) 将所有软件产品的开发和操作中嵌入了全面的安全要求、技术特定工具和强制性流程。 Microsoft 的所有开发团队都必须遵守 SDL 流程和要求，从而生成更安全的软件，减少和减少严重的漏洞，同时降低开发成本。 Microsoft SDL 由七个组件组成，包括五个核心阶段和两个支持安全活动。 五个核心阶段是要求、设计、实现、验证和发布。 其中每个阶段都包含强制性检查和批准，以确保正确满足所有安全和隐私要求以及最佳做法。 两个支持的安全活动（培训和响应）分别在核心阶段之前和之后进行，以确保它们得到正确实施，并且软件在部署后保持安全。 ","date":"2025-01-21","objectID":"/blog_csdn_net_details_122882914/:1:0","tags":["sdl","security"],"title":"微软软件安全开发流程（SDL） security-development-lifecycle","uri":"/blog_csdn_net_details_122882914/"},{"categories":null,"content":"1.1 培训 所有 Microsoft 员工都必须完成一般安全和隐私意识培训，以及与其角色相关的特定培训。 新员工在受聘时会提供初始培训，在 Microsoft 的整个就业过程中，需要每年进行一次进修培训。 开发人员和工程师还必须参加角色特定培训，以便随时了解安全基础知识和安全开发的最新趋势。 还鼓励所有全职员工、实习生、临时员工、分包商和第三方寻求高级安全和隐私培训。 ","date":"2025-01-21","objectID":"/blog_csdn_net_details_122882914/:1:1","tags":["sdl","security"],"title":"微软软件安全开发流程（SDL） security-development-lifecycle","uri":"/blog_csdn_net_details_122882914/"},{"categories":null,"content":"1.2 要求 Microsoft 开发的每个产品、服务和功能都从明确定义的安全和隐私要求开始;它们是安全应用程序的基础，并告知其设计。 开发团队根据产品将处理的数据类型、已知威胁、最佳做法、法规和行业要求以及从以前事件中吸取的经验教训等因素来定义这些要求。 定义后，将明确记录和跟踪要求。 软件开发是一个持续的过程，这意味着相关的安全和隐私要求在产品的整个生命周期中都会发生变化，以反映功能和威胁环境的变化。 ","date":"2025-01-21","objectID":"/blog_csdn_net_details_122882914/:1:2","tags":["sdl","security"],"title":"微软软件安全开发流程（SDL） security-development-lifecycle","uri":"/blog_csdn_net_details_122882914/"},{"categories":null,"content":"1.3 Design 定义安全、隐私和功能要求后，可以开始设计软件。 作为设计过程的一部分，会创建威胁模型，以帮助根据风险识别、分类潜在威胁并对其进行评分。 在对软件进行更改时，必须在每个产品的整个生命周期内维护和更新威胁模型。 威胁建模过程首先定义产品的不同组件，以及它们在关键功能方案中（如身份验证）中彼此交互的方式。 数据流创建 (DFD) 的关系图，以直观地表示使用的关键数据流交互、数据类型、端口和协议。 DFD 用于识别威胁并确定威胁的优先级，以便针对添加到产品安全要求的缓解措施。 服务团队使用 Microsoft Threat Modeling Tool 创建威胁模型，使团队能够： 就其系统的安全设计进行沟通 使用经过验证的方法分析安全设计中的潜在安全问题 建议和管理安全问题的缓解措施 在任何产品发布之前，都会检查所有威胁模型的准确性和完整性，包括缓解不可接受的风险。 ","date":"2025-01-21","objectID":"/blog_csdn_net_details_122882914/:1:3","tags":["sdl","security"],"title":"微软软件安全开发流程（SDL） security-development-lifecycle","uri":"/blog_csdn_net_details_122882914/"},{"categories":null,"content":"1.4 实现 实现从开发人员根据他们在前两个阶段创建的计划编写代码开始。 Microsoft 为开发人员提供了一套安全开发工具，可有效实现他们设计的软件的所有安全性、隐私和功能要求。 这些工具包括编译器、安全开发环境和内置安全检查。 ","date":"2025-01-21","objectID":"/blog_csdn_net_details_122882914/:1:4","tags":["sdl","security"],"title":"微软软件安全开发流程（SDL） security-development-lifecycle","uri":"/blog_csdn_net_details_122882914/"},{"categories":null,"content":"1.5 验证 在发布任何书面代码之前，需要进行多次检查和批准，以验证代码是否符合 SDL、满足设计要求以及是否没有编码错误。 手动评审由审阅者与开发代码的工程师分开进行。 职责分离是此步骤中的一项重要控制措施，可最大程度地降低代码被编写和释放导致意外或恶意伤害的风险。 还需要各种自动检查，并内置在管道中，以在检查期间和编译生成时分析代码。 Microsoft 使用的安全检查分为以下类别： 静态代码分析：分析源代码是否存在潜在的安全漏洞，包括代码中是否存在凭据。 二进制分析：在二进制代码级别评估漏洞，以确认代码已准备好生产。 凭据和机密扫描程序：识别源代码和配置文件中凭据和机密公开的可能实例。 加密扫描：验证源代码和代码执行中的加密最佳做法。 模糊测试：使用格式不正确和意外的数据来练习 API 和分析程序，以检查漏洞并验证错误处理。 配置验证：根据安全标准和最佳做法分析生产系统的配置。 组件治理 (CG) ：开源软件检测和版本、漏洞和法律义务检查。 如果手动审阅者或自动化工具发现代码存在任何问题，则系统会通知提交者，要求他们进行必要的更改，然后再提交代码以供审阅。 此外，内部和外部提供商定期在 Microsoft 联机服务上进行渗透测试。 渗透测试提供了另一种方法来发现其他方法未检测到的安全漏洞。 若要详细了解 Microsoft 的渗透测试，请参阅 Microsoft 365 中的攻击模拟。 ","date":"2025-01-21","objectID":"/blog_csdn_net_details_122882914/:1:5","tags":["sdl","security"],"title":"微软软件安全开发流程（SDL） security-development-lifecycle","uri":"/blog_csdn_net_details_122882914/"},{"categories":null,"content":"1.6 发布 通过所有必需的安全测试和评审后，不会立即向所有客户发布版本。 在 SDP () 的安全部署流程中，生成将系统地逐步发布到越来越大的组（称为环）。 SDP 环通常可定义为： 圈 0：负责服务或功能的开发团队 圈 1：所有 Microsoft 员工 圈 2：Microsoft 外部的用户，他们已将其组织或特定用户配置为使用目标发布通道 环 3：子阶段的全球标准发布 除了环 3，生成在每个环中保留适当天数，但高负载周期除外，因为版本已在早期环中进行了适当的稳定性测试。 ","date":"2025-01-21","objectID":"/blog_csdn_net_details_122882914/:1:6","tags":["sdl","security"],"title":"微软软件安全开发流程（SDL） security-development-lifecycle","uri":"/blog_csdn_net_details_122882914/"},{"categories":null,"content":"1.7 响应 所有 Microsoft 服务在发布后都会进行广泛记录和监视，使用集中式专有近实时监视系统识别潜在的安全事件。 若要详细了解 Microsoft 的安全监视和安全事件管理，请参阅 安全监视概述 和 Microsoft 安全事件管理。 ","date":"2025-01-21","objectID":"/blog_csdn_net_details_122882914/:1:7","tags":["sdl","security"],"title":"微软软件安全开发流程（SDL） security-development-lifecycle","uri":"/blog_csdn_net_details_122882914/"},{"categories":null,"content":"2 微软 SDL 流程终极整理总结 https://blog.csdn.net/weixin_43965597/article/details/122882914 ","date":"2025-01-21","objectID":"/blog_csdn_net_details_122882914/:2:0","tags":["sdl","security"],"title":"微软软件安全开发流程（SDL） security-development-lifecycle","uri":"/blog_csdn_net_details_122882914/"},{"categories":null,"content":"2.1 一、微软 SDL(Security Development Lifecycle)流程框架 安全保证的过程，重点是软件开发，但每个阶段都引入了安全和隐私的原则。 ","date":"2025-01-21","objectID":"/blog_csdn_net_details_122882914/:2:1","tags":["sdl","security"],"title":"微软软件安全开发流程（SDL） security-development-lifecycle","uri":"/blog_csdn_net_details_122882914/"},{"categories":null,"content":"2.2 二、主要步骤 2.2.1 1.安全培训 Training 2.2.1.1 1.1 Core Security Training 核心安全培训 提高团队安全意识，对齐安全需求。 开发团队的所有成员都需要接受适当的安全培训，了解相关的安全知识，培训对象包括开发人员，测试人员、项目经理、产品经理等。项目的中期可开展针对性的培训，例如代码中经常出现的问题，测试过程中多次出现的漏洞等等。 2.2.2 2.需求分析 Requirements 针对系统业务要求实施风险评估工作，根据需求文档与项目经理确定安全需求，制定安全需求表，供后期检测时使用。 2.2.2.1 2.1 建立安全需求分析 Establish Security Requirements 2.2.2.2 在项目确立之前，需要提前与项目经理或者产品 owner 进行沟通，确定安全的要求和需要做的事情。确认项目计划和里程碑，尽量避免因为安全问题而导致项目延期发布。 2.2.2.3 2.2 创建质量标准及 Bug 栏 Create Quality Gates/ Bug Bars 用于确定安全和隐私质量的最低可接受级别，在项目开始时定义这些标准可加强对安全问题相关风险的理解，并有助于团队在开发过程中发现和修复安全 bug。项目团队必须协商确定每个开发阶段的质量门，随后将质量门交由给安全顾问审批，安全顾问可以根据需要添加特定于项目的说明，以及更加严格的安全要求。另外，项目团队需阐明其对安全门的遵从性，以便完成最终安全评析（FSR）。 Bug 栏是应用于整个开发项目的质量门，用于定义安全漏洞的严重性阈值。例如，应用程序在发布时不得包含具有“关键”或“重要”评级的已知漏洞。Bug 栏一经设定，便决不能放松。 2.2.2.4 2.3 安全\u0026隐私风险评估（SRA\u0026PRA） Security \u0026 Privacy Risk Assessment 项目的哪些部分在发布前需要威胁模型 项目的哪些部分在发布前需要进行安全设计评析 项目的哪些部分需要不属于项目团队且双方认可的小组进行渗透测试 是否存在安全顾问认为有必要增加的测试或分析要求以缓解安全风险 模糊测试的具体范围 隐私对评级的影响 2.2.3 3.系统设计 Design 2.2.3.1 3.1 制定设计规范 Establish Design Requirements 在设计阶段应该仔细考虑安全和隐私问题，在项目初期确定好安全需求，尽可能避免安全引起的需求变更。 2.2.3.2 3.2 分析攻击面 Analyze Attack Surface 减小攻击面与威胁建模紧密相关，不过它解决安全问题的角度稍有不同。减小攻击面通过减小攻击者利用潜在弱点或漏洞的机会来降低风险。方法包括：关闭或限制对系统服务的访问，应用“最小权限原则”，以及尽可能进行分层防御。 2.2.3.3 3.3 威胁建模 Threat Modeling 为项目或产品面临的威胁建立模型，明确分析攻击可能来自哪里。微软提出的 STRIDE 模型以帮助建立危险模型，是非常好的做法，从 6 个维度展开： Spoofing（假冒） Tampering（篡改） Repudiation（否认） Information Disclosure（信息泄漏） Denial of Service（拒绝服务） Elevation of Privilege（权限提升）。 其他主流威胁建模框架见文章《威胁建模主流框架》 2.2.4 4.实现 Implementation 2.2.4.1 4.1 使用优选工具 Use Approved Tools 开发团队使用的编辑器、链接器等相关工具，可能会涉及一些安全相关的环节，因此在使用工具的版本上，需要提前与安全团队进行沟通。 2.2.4.2 4.2 消减危险函数 Deprecate Unsafe Functions 许多常用函数可能存在安全隐患，应当禁用不安全的函数 API，使用安全团队推荐的函数。 2.2.4.3 4.3 对代码进行静态安全检查（静态分析）Static Analysis 代码静态分析可以由相关工具辅助完成，其结果与人工分析相结合。 2.2.5 5.验证 Verification 2.2.5.1 5.1 动态安全测试 Dynamix Analysis 动态分析是静态分析的补充，用于测试环节验证程序的安全性。 2.2.5.2 5.2 模糊测试 Fuzz Testing 专门形态的动态分析，通过故意向应用程序引入不良格式或随机数据诱发程序故障。模糊测试策略的制定，以应用程序的预期用途，以及应用程序的功能和设计规范为基础。安全顾问可能要求进行额外的模糊测试，或者扩大模糊测试的范围，增加持续的时间。 2.2.5.3 5.3 供给面评审 Attack Surface Review 项目经常会因为需求等因素导致最终的产出偏离原本设定的目标，因此在项目后期对威胁模型和攻击面进行评析是有必要的，能够及时发现问题并修正。 所有新项目上线前要经过三步检查——代码审计、Web 应用扫描、人工渗透扫描。 代码审计：使用 Jekens 拉 Github 代码放入 Fortify 中扫描。开发过程中，开发人员每次更新代码都要进行扫描，并有权限查看 Fortify 相关项目漏洞情况，进行整改（不允许有中高危以上漏洞）。开发有权对漏洞进行忽略处理，但需要承担相应后果。若不知道如何处理，可以请安全组提供解决方案。 Web 应用扫描：Web 应用扫描不需要安全基础即可操作。安全人员比测试人员少，一般交予测试人员协助处理。扫描器可选择项很多，包括开源或者商用。 人工渗透扫描：针对不同应用的发布情况，若是应用为新应用则需要对总体项目进行渗透测试。 2.2.6 6.发布 Release 2.2.6.1 6.1 制定安全应急响应计划 Incident Response Plan 受 SDL 要求约束的每个软件在发布时都必须包含事件响应计划。即使在发布时不包含任何已知漏洞的产品，也可能在日后面临新出现的威胁。如果产品中包含第三方的代码，也需要留下第三方的联系方式并加入事件响应计划，以便在发生问题时能够找到对应的人。 2.2.6.2 6.2 最终安全评审（FSR）Final Security Review FSR 是在发布之前仔细检查对软件执行的所有安全活动。通过 FSR 将得出以下三种不同结果： 通过 FSR。在 FSR 过程中确定所有安全和隐私问题都以得到修复或缓解。 通过 FSR 但有异常。在 FSR 过程中确定的所有安全和隐私问题都以得到修复或缓解，并且/或者所有异常都已得到圆满解决，无法解决的问题将记录下来，在下次发布时更正。 需上报问题的 FSR。如果团队未满足所有 SDL 要求，并且安全顾问和产品团队无法达成可接受的折中，则安全顾问不能批准项目，项目不能发布。团队必须在发布之前解决所有可解决的问题，或者上报高级管理层进行抉择。 2.2.6.3 6.3 发布归档 Release Archive 在通过 FSR 或者虽有问题但达成一致后，可以完成产品的发布。但发布的同时仍需对各种问题和文档进行存档，为紧急响应和产品升级提供帮助。 2.2.7 7.响应 Response Execute Incident Response Plan 执行安全应急响应计划。 ","date":"2025-01-21","objectID":"/blog_csdn_net_details_122882914/:2:2","tags":["sdl","security"],"title":"微软软件安全开发流程（SDL） security-development-lifecycle","uri":"/blog_csdn_net_details_122882914/"},{"categories":null,"content":"2.3 三、SDL 实战经验准则 2.3.1 1.与项目经理进行充分沟通，排除足够的时间 项目的安全评估，在开发的不同环节有着不同的安全要求，而这些安全要求都需要占用开发团队的时间，因此在立项阶段与项目经理进行充分沟通十分重要。 明确在什么阶段安全工程师需要介入，需要多长时间完成安全工作，同时预留多少时间给开发团队用以开发安全功能或者修复安全漏洞。 预留出必要时间对项目的时间管理也具有积极意义，否则很容易出现项目快发布，安全团队突然说还没有实施安全检查的情况。这种情况只能导致两种结果：项目因为安全检查而延期发布，开发团队、测试团队全员一起重新做安全检查；项目顶着风险发布，专门建立小项目专门修复安全问题。 两种结果都十分糟糕，为避免发生此类情况，在立项初期就应该与项目经理进行充分沟通，留出足够多的时间给安全检查。 2.3.2 2.规范公司的立项流程，确保所有项目都能通知到安全团队，避免遗漏 安全事件产生的原因并不复杂，往往发生在大家忽略的地方。在实施 SDL 的过程中，技术方案的好坏不是最关键的，最关键的是要覆盖到全部项目，防止边边角角的小项目没有被覆盖到导致安全事件的发生。 公司规模较小时，员工沟通成本低，很容易保证所有项目都能及时通知到安全团队。但公司大到一定规模时，出现多个部门和多个项目组，沟通成本大大增加，这种情况下就很有必要从公司层面建立完善的“立项制度”。 SDL 依托于软件工程，立项也属于软件工程的一部分。如果能集中管理立项过程，SDL 就有可能在这一阶段覆盖到公司所有项目。相对于测试阶段和发布阶段来说，在立项阶段就有安全团队介入，留给开发团队的反应事件也更加富足。 2.3.3 3.树立安全部门的权威，项目必须由安全部门审核完成后才能发布 实施 SDL 的过程中，除了教育项目组成员（项目经理、产品经理、开发人员、测试人员等）实施安全的好处外，安全部门还需要树立一定的权威。 必须通过规范和制度，明确要求所有项目必须在安全审核完成后才能发布。如果没有这样的权威，对于项目组来说，安全就变成了一项可有可无的东西。如果产品急着发布，很可能因此砍掉或裁减部分安全需求，也可能延期修补漏洞，从而导致风险升高。 权威的树立在公司里需要从上往下推动，由技术总负责人或者产品总负责人确认安全部门实施。在具体实施时可以依据公司的不同情况在相应的流程中明确。负责产品的质量保障部门，负责产品发布的运维部门，都可以称为制度的执行者。 “项目必须由安全部门审核完成之后才能发布”这句话并非绝对，背后含义实为树立安全部门的权威。因此在实际实施 SDL 的过程中，安全也可能对业务妥协。因此在业务时间压力非常大，问题不是很严重的情况下，可以考虑事后再进行修补，或使用临时方案应对紧急情况。安全最终是为业务服务的。 2.3.4 4.将技术方案写入开发、测试的工作手册中 对于开发、测试团队，对工作最有效的约束方式即工作手册。对于开发来说手册即为开发规范。开发规范涉及的方面比较广，如函数名的大小写方式、注释的写法等。（腾讯开源开发安全指南链接如下：腾讯代码安全指南开源，涉及 CC++、Go 等六门编程语言 - FreeBuf 网络安全行业门户） 但开发团队的规范内容鲜有涉及到安全规范，因此与其事后通过代码审核的方式告知开发者代码中存在漏洞，需要修补，不如直接将安全技术方案写入开发者的代码规范当中。比如规定好哪些函数禁用，只能使用哪些函数；或封装好安全功能，在代码规范中注明什么情况下使用什么样的安全 API。 对于程序员来说，记住代码规范中的要求远比记住复杂的安全原理要容易得多。一般程序员只需要记住如何使用安全功能即可，无需深究原理。 对于测试人员的要求是相似的。在测试的工作手册中加入安全测试的方法，清楚列出每一个测试用例，每一步实现什么功能，这样一些基础的安全测试就可以交由测试人员完成，最后生成一份安全测试报告即可。 2.3.5 5.给工程师培训安全方案 微软 SDL 框架中，第一项就是培训。培训的作用不可小视，它是技术方案与执行者之间的调和剂。在准则四中提到，要将安全技术方案最大程度地写入代码规范等工作手册中，但同时要让开发者有机会了解到安全方案地背景，这也是很有意义的，可以通过培训达到这个目的。 培训最重要的目的是在项目开发之前，能够让开发者之傲如何写出安全的代码，从而节约开发成本。如果开发者未经培训，可能在代码审核阶段会被找出非常多的安全 bug，修复每一个安全 bug 都将消耗额外的开发时间；同时开发者若不理解这些开发问题，由安全工程师对每一个问题进行解释和说明也是一份额外的时间支出。 因此在培训阶段贯彻代码规范中的安全需求，可以极大地节约开发时间，对整个项目组都有着积极的意义。 2.3.6 6.记录所有的安全 bug，激励程序员编写安全的代码 为了更好地推动项目组写出安全的代码，可以尝试给每个开发团队设立绩效。被发现漏洞最少的团队可以得到奖励，并将结果公布出来。如此，项目组之间将产生竞争氛围，开发者更努力于遵守安全规范，写出安全的代码，还能帮助不断提高开发者的代码质量，形成良性循环。 ","date":"2025-01-21","objectID":"/blog_csdn_net_details_122882914/:2:3","tags":["sdl","security"],"title":"微软软件安全开发流程（SDL） security-development-lifecycle","uri":"/blog_csdn_net_details_122882914/"},{"categories":null,"content":"2.4 四、与 SAMM 对比 相对于微软的 SDL，OWASP 推出了 SAMM（Software Assurance Maturity Model），帮助开发者在软件工程的过程中实施安全。 SAMM 与 SDL 的主要区别在于，SDL 适用于软件开发商，他们以贩售软件为主要业务；而 SAMM 更适用于自主开发软件的使用者，如银行或在线服务提供商。软件开发商的软件工程往往较为成熟，有着严格的质量控制；而自主开发软件的企业组织，则更强调高效，因此在软件工程的做法上也存在差异。 OWASP SAMM | OWASP Foundation ","date":"2025-01-21","objectID":"/blog_csdn_net_details_122882914/:2:4","tags":["sdl","security"],"title":"微软软件安全开发流程（SDL） security-development-lifecycle","uri":"/blog_csdn_net_details_122882914/"},{"categories":null,"content":"2.5 五、常用 SDL 实施方法和工具 2.5.1 1、需求分析与设计阶段 项目初始阶段，将论证项目的目标、可行性、实现方向等。在需求阶段，安全工程师需要关心产品主要功能上的安全强度和安全体验是否足够，主要需要思考安全功能。在此阶段可以对项目经理、产品经理或者架构师进行访谈，以了解产品背景和技术架构，并给出相应的建议，以下是安全专家 Lenny Zeltser 给出的一份 cheklist 2.5.1.1 #1:BUSINESS REQUIREMENTS 2.5.1.2 #1:业务需求 Business Model 商业模型 1.What is the application’s primary business purpose? 这款应用的主要业务目的是什么？ 2.How will the application make money? 这款应用如何盈利？ 3.What are the planned business mlestones for developing or imporving the application? 开发或者改进这款应用的业务计划是什么样的？ 4.How is the application marketed? 该应用是如何进行营销的？ 5.What key benefits does the application offer users? 这款应用给用户提供的核心功能是什么？ 6.What business continuity provisions have been defined for the application? 已经为该应用制定了哪些业务连续性规定？ 7.What geographic areas does the application service? 这款应用提供服务的主要地区？ Data Essentials 必要数据 1.What data does the application receive, produce and process? 这款应用接收、产生、处理了什么数据？ 2.How can the data be classified into categories according to sensitivity? 哪些属于敏感数据？ 3.How might an attacker benefit from capturing or modifying the data? 捕获并修改数据将如何有利于攻击者？ 4.What data backup and retention requirements have been defined for application? 已经为应用制定了哪些数据备份和保留要求？ End - Users 终端用户 1.Who are the application’s end - users? 哪些人是应用的最终用户？ 2.How do the end - user interact with the application? 最终用户如何与应用交互？ 3.What security expectations do the end - users have? 最终用户有哪些安全期望？ Partners 搭档 1.Which third - parties supply data to the application? 哪些第三方组织为应用提供数持？ 2.Which third - parties receive data from the applications? 哪些第三方组织从应用中收集数据？ 3.Which third - parites process the application’s data? 哪些第三方组织处理应用数据？ 4.What mechanisms are used to share data with third - parties besides the application itself? 除了应用本身，还有那些机制被用来和第三方共享数据？ 5.What security requirements do the partners impose? 合作伙伴实施了哪些安全要求？ Administrators 管理层 1.Who has administrative capabilities in the application? 谁对应用有着管理员权限？ 2.What administrative capabilities does the application offer? 应用提供哪些管理员权限功能？ Regulations 规章制度 1.In what industries does the application operate? 该应用在哪些行业中使用？ 2.What security - related regulations apply? 适用哪些与安全相关的法规？ 3.What auditing and compliance regulations apply? 适用于哪些审计和法规？ 2.5.1.3 #2：INRASTRUCTURE REQUIREMENTS 2.5.1.4 内部结构要求 Network 网络 1.What details regarding routing, switching, firewalling, and load- balancing have been defined? 定义了哪些有关路由、交换、防火墙和负载平衡的细节？ 2.What network design supports the application? 进行了怎样的网络设计来支持该应用程序？ 3.What core network devices support the application? 哪些核心网络设备用来支持应用程序？ 4.What network performance requirements exist? 存在哪些网络性能要求？ 5.What private and public network links support the application? 有哪些私有和公共网络链接支持应用程序？ Systems 系统 1.What operating systems support the application? 应用基于哪款操作系统？ 2.What hardware reqirements have been defined? 定义了哪些硬件需求？ 3.What details regarding required OS components and lock - down needs have been defined? 定义了哪些所需操作系统组件和锁定需求的细节？ Infrastructure Monitoring 基础设施监控 1.What network and system performance monitoring requirements have been defined？ 定义了哪些网络和系统性能监控要求？ 2.What mechanisms exist to detect malicious code or compromised applicaton components? 有哪些机制用于检测恶意代码或损坏的应用程序组件？ 3.What network and system security monitoring requirements have been defined? 定义了哪些网络和系统的安全监控要求？ Virtualization and Externalization 虚拟化和外部化 1.What aspects of the application lend themselves to virtualization? 该应用哪些方面适合虚拟化？ 2.What virtualization requirements have been defined for the applications? 该程序已经定义了哪些虚拟化需求？ 3.What aspects of the product may or may not be hosted via the cloud coompting model? 该产品哪些方面可以或者不可以被云聚合模型托管？ 2.5.1.5 #3：APPLICATION REQUIREMENTS 2.5.1.6 应用程序要求 Environment 环境 1.What frameworks and programming languages have been used to create the application? 应用使用了什么样的框架和编程语言？ 2.What process, code, or infrastructure dependencies have been defined for the application? 应用定义了哪些流程、代码和基础设施依赖关系？ 3.What databases and application servers support the application? 应用由哪些数据库和应用程序服务器支持？ Data Processing 数据处理 1.What data entry paths does the application support? 该应用支持哪些数据输入方式？ 2","date":"2025-01-21","objectID":"/blog_csdn_net_details_122882914/:2:5","tags":["sdl","security"],"title":"微软软件安全开发流程（SDL） security-development-lifecycle","uri":"/blog_csdn_net_details_122882914/"},{"categories":null,"content":"2.6 六、敏捷 SDL 微软 SDL 过程仍然较为厚重，适用于采用瀑布法进行开发的软件开发团队，对于使用敏捷开发的团队难以适应。 敏捷开发采用“小步快跑”方式，不断完善产品，没有非常规范的流程，文档尽可能简单，有利于产品的快速发布，但不利于安全，需求无法在一开始非常明确，导致安全设计发生变化，故微软设计了敏捷 SDL。 敏捷 SDL 即以变化的观点实施安全工作。需求和功能可能一直变化，代码也可能在变化，于是要求了实施 SDL 时需要在每个阶段更新威胁模型和隐私政策，在必要的环节迭代模糊测试、代码安全分析等工作。 ","date":"2025-01-21","objectID":"/blog_csdn_net_details_122882914/:2:6","tags":["sdl","security"],"title":"微软软件安全开发流程（SDL） security-development-lifecycle","uri":"/blog_csdn_net_details_122882914/"},{"categories":null,"content":"2.7 七、软件安全开发流程新增的安全活动 传统软件开发流程 软件安全开发流程新增项客户需求收集 客户安全需求收集需求分析与澄清 分析客户安全需求，制定安全标准和要求，建立安全需求管理，安全与隐私风险评估软件设计 在特性设计中结合安全设计规范进行安全设计，对模块进行威胁建模和攻击面分析软件编码 1. 安全编码：新代码使用安全函数，老代码替换危险函数，对代码进行安全检视 使用第三方开源工具或者库 版本构建 1. 满足安全编译选项的要求 选择安全的构建工具 软件测试 1. 对安全设计进行分析和评审，输出安全测试用例 对软件暴露的接口进行 Fuzz 测试 对软件暴露的攻击面进行攻防渗透测试 对软件进行安全扫描和漏洞挖掘 客户质量验收 1. 提供验收的安全交付件，如安全设计说明书、安检测报告 提供测试环境给用户，让用户进行安全评估 发布和运维 1. 制定安全应急响应计划，并在实际运维中落地 日常运维中做好安全巡检，遇到黑客攻击，即使告警，并快速修复安全漏洞 ","date":"2025-01-21","objectID":"/blog_csdn_net_details_122882914/:2:7","tags":["sdl","security"],"title":"微软软件安全开发流程（SDL） security-development-lifecycle","uri":"/blog_csdn_net_details_122882914/"},{"categories":null,"content":"2.8 八、附件《安全选项表》 其中的内容是等级保护和网站备案中必须存在的一些安全功能项，属于法律合规内容，不是产品必须符合其中的内容，而是尽量符合，自行选择保留项。 开发和测试根据产品填写好的《安全选项表》内容进行测试。部分安全专业的测试工作由安全人员进行测试。检测完成并允许上线后，三份测试报告和安全选项表格要进行归档。 Reference： https://blog.csdn.net/a167220278/article/details/80454756?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164428096416780269873953%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D\u0026request_id=164428096416780269873953\u0026biz_id=0\u0026utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-80454756.pc_search_result_cache\u0026utm_term=%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F\u0026spm=1018.2226.3001.4187 ","date":"2025-01-21","objectID":"/blog_csdn_net_details_122882914/:2:8","tags":["sdl","security"],"title":"微软软件安全开发流程（SDL） security-development-lifecycle","uri":"/blog_csdn_net_details_122882914/"},{"categories":null,"content":"三观包括：世界观、人生观、价值观。 世界观是人们对世界和宇宙的理解和认知， 人生观是指对人生的看法，解决“我为什么活着”这一问题， 价值观是指判断事情对错的标准，解决了“如何判断善恶”这一问题。 我的世界观是： 科学主义 ，我的价值观是： 效益论和义务论 ，我的人生观是： 人本主义 。我的宗教信仰是： 不可知论 。 ","date":"2025-01-20","objectID":"/www_williamlong_info_archives_7483/:0:0","tags":null,"title":"我的三观（世界观、价值观、人生观）","uri":"/www_williamlong_info_archives_7483/"},{"categories":null,"content":"1 我的世界观 我信仰科学主义的世界观和方法论，例如宇宙大爆炸理论、达尔文进化论、广义相对论与量子场论等等。 科学的核心属性是可证伪性，也就是说，每一个真正科学的理论是有可能被证明是错误的。 科学假说必须“可被证伪”，科学的理论一般都是“可证伪、且未被证伪”的。 科学的基本精神是怀疑精神，科学精神包括探索、怀疑、实证和理性四个方面。科学方法包括经由归纳推理创建假说，由实验和统计分析进行检验，并根据结果调整假说。 我觉得， 科学在世界观范畴解决了哲学的形而上学问题 。 例如： 宇宙的起源使用宇宙大爆炸理论来解释，137 亿年前，一个体积无限小，密度无限大，温度无限高，时空曲率无限大的点，发生非常快速的膨胀和冷却，空间和时间诞生， 大爆炸后 10 秒后，氢、氦类稳定原子核形成， 3 分钟后，氦、氘、铍和锂出现， 7 亿年，银河系最老的恒星形成， 45.8 亿年前，太阳系形成， 45.4 亿年前，地球诞生， 约 45.1 亿年前，月球问世。 再如： 人类起源使用达尔文的进化论来解释，所有生命形式都有共同的祖先，并且物种是通过长期的演化过程逐步改变的: 大约在 700 万至 1000 万年前，具有直立行走的能力的南方古猿出现在非洲， 大约在 25 万年到 40 万年前，能用兽皮做衣服，能人工取火的智人出现在非洲， 大约 5 万年到 10 万年前，智人走出非洲，并迁移到世界各地，之后在世界各地迅速进化，最终形成了现在的人类。 ","date":"2025-01-20","objectID":"/www_williamlong_info_archives_7483/:1:0","tags":null,"title":"我的三观（世界观、价值观、人生观）","uri":"/www_williamlong_info_archives_7483/"},{"categories":null,"content":"2 我的价值观 我的价值观是 效益论 和 义务论 ，两者都非常有道理，但在某些情况下又会有些问题，将两者结合起来使用更好。 ","date":"2025-01-20","objectID":"/www_williamlong_info_archives_7483/:2:0","tags":null,"title":"我的三观（世界观、价值观、人生观）","uri":"/www_williamlong_info_archives_7483/"},{"categories":null,"content":"2.1 义务论 康德的义务论的核心观点是：“ 人是目的，而不是手段 ”。人不是为实现其他目的（如经济利益、政治利益等）而存在的附属品，而是具有自主性和独立性的主体。 义务论判断行为的道德与否，主要依据行为本身是否符合道德规则，而非仅仅看行为的结果。义务论的核心观点是，某些行为是天经地义的，应该遵循，无论其结果如何。 在做道德判断的时候，如果一个行为符合显见义务，那么它就有可能符合道德，根据罗斯的理论，七种显见义务包括： 诚信：诚实、遵守承诺，履行契约。 友善：尽可能帮助他人，做有利于他人的行为。 公正：公正地对待他人。 补偿：补偿那些被我们伤害的人。 感恩：对他人的好意或帮助表示感谢并回报。 自我发展：追求自我成长和发展，使自己成为更好的人。 不作恶：不要伤害他人。 ","date":"2025-01-20","objectID":"/www_williamlong_info_archives_7483/:2:1","tags":null,"title":"我的三观（世界观、价值观、人生观）","uri":"/www_williamlong_info_archives_7483/"},{"categories":null,"content":"2.2 效益论 边沁的效益论的核心观点是：“ 最大幸福原则 ”。最具道德价值的行为，是那些“追求最大多数人的最大幸福”的行为。 效益论判断行为是否道德，主要依据行为所带来的结果，而不考虑行为者的动机或意图，如果一个行为产生了更多的幸福或减少了更多的痛苦，那么这个行为就是道德的。 效益论使用量化公式来判断一个行为的道德性，包括： 受影响的人数: 一个行为影响的人越多，其影响就越大； 幸福的程度: 一个行为带来的幸福程度越高，其价值就越高； 幸福的持续时间: 一个行为带来的幸福持续时间越长，其价值就越高。 评判一个行为是否道德需要考虑几个步骤： 评估所有可能的后果：所有相关的行为结果，包括它们对不同个体或群体的影响。 量化幸福与痛苦：尽可能量化这些结果中的幸福和痛苦，计算出每个选项的净效益。 选择最大化总幸福的行为：选择能够最大化整体幸福或最小化整体痛苦的行为。 ","date":"2025-01-20","objectID":"/www_williamlong_info_archives_7483/:2:2","tags":null,"title":"我的三观（世界观、价值观、人生观）","uri":"/www_williamlong_info_archives_7483/"},{"categories":null,"content":"3 我的人生观 我的人生观是人本主义，人本主义强调人的尊严、价值、创造力和自我实现。 马斯洛认为，人具有一种天生的“自我实现”（即一个人实现其潜力和能力的过程）的动机，每个人都有追求最大潜力的内在需求。人类有七个“需求层次”，好像一座金字塔，由下而上依次是生理需求、安全需求，归属与爱的需求，尊重需求，认知需求，审美需求、自我实现需求。人在满足高一层次的需求之前，至少必须先部分满足低一层次的需求。 生理需求：人们最原始、最基本的需要，如衣食住行； 安全需求：劳动安全、生活稳定、希望免于灾难、希望未来有保障等； 社交需求：归属与爱的需要； 尊重需求：自尊、他尊和权力欲； 认知需求：对自身和周围世界的探索、理解及解决问题的需要； 审美需求：对美好事物的追求，以及欣赏； 自我实现：竭尽所能，使自己趋于完美，实现理想和目标，获得成就感。 这七个需求分为两类，第一类需求属于缺失性需求，可产生匮乏性动机，一旦这些需求得到满足，动机就会减弱，甚至不再有追求的动力，而是向更高层次的需求转移。第二类需求属于成长性需求，可产生成长性动机，是一种超越了生存满足之后，发自内心的渴求发展和实现自身潜能的需求。满足了这种需求的人，能进入心理的自由状态，产生深刻的幸福感，马斯洛称之为“高峰体验”。 ","date":"2025-01-20","objectID":"/www_williamlong_info_archives_7483/:3:0","tags":null,"title":"我的三观（世界观、价值观、人生观）","uri":"/www_williamlong_info_archives_7483/"},{"categories":null,"content":"4 我的宗教信仰 对于宗教信仰，我信仰 不可知论 ，即 人不知道或无法知道神是否存在，反对有神论和无神论 。 我觉得，无神论跟有神论 本质上都是一回事 ，都试图为超验对象进行断定其存在或不存在。 无神论并不是一种“科学的世界观”，而是一种信仰立场，这种信仰与科学主义相冲突。 科学的世界观是基于经验、观察、实验和逻辑推理，强调通过可证伪的假设和实证方法来理解自然现象。科学的世界观都是可证伪的，例如宇宙大爆炸理论，达尔文进化论，相对论与量子力学等等。而无神论主张不存在任何超自然的神灵，这是一个关于信仰的主张，而不是一个可以直接通过实验或观察验证的科学假设。 不可知论强调知识的局限性，和科学主义也是有交集的，科学主义者可能也会承认，科学的当前理论和方法有局限性，尚未解答所有问题，即承认目前科学无法完全解释所有的宇宙现象。 ","date":"2025-01-20","objectID":"/www_williamlong_info_archives_7483/:4:0","tags":null,"title":"我的三观（世界观、价值观、人生观）","uri":"/www_williamlong_info_archives_7483/"},{"categories":null,"content":" 212-212, 标注, 2025 年 1 月 6 日星期一 下午 10:20:16 下。主奴关系是满人八旗世界中最基本的阶层关系之一。 212-216, 标注, 2025 年 1 月 6 日星期一 下午 10:21:07 下。主奴关系是满人八旗世界中最基本的阶层关系之一。在满人的理念中，主子给奴才提供生活所需，而奴才对主子尽忠。14 满人统治者也深知奴隶是重要的经济资源。因而他们推崇主奴之间以家为单位，和睦相处。用努尔哈赤的话说，就是要形成一种“奴才爱主子，主子爱奴才”的社会。15 由于主奴关系中蕴含着家庭关系，因而外人在对待一个奴才的时候得看主人是谁；同样，要是主人升官了，自家奴才也跟着高兴，感觉脸上有光。 252-255, 标注, 2025 年 1 月 6 日星期一 下午 10:31:12 包衣奴才？“包衣”是满语的音译。据清史前辈孟森解释：“包”是满语“家”的意思，而“衣”相当于汉语中的虚字，类似于“之”字。包衣奴才就是指跟主子关系最近的、家周围的奴才。26 满人人关以后，包衣奴才专指满人权贵家里面的奴才，是整个奴才群体中地位最高的一群。后来许多清朝名人都是包衣奴才出身。比如曹雪芹的祖父曹寅，他就是康熙的包衣。 487-489, 标注, 2025 年 1 月 7 日星期二 下午 7:13:23 鞑靼”这个词本身在欧洲就有来自蛮荒之地的意思。现在一些欧洲餐馆的菜谱上还能看到一道菜叫“鞑靼牛肉”（Tartar Steak）。这道菜的主体是一个生鸡蛋打开后淋在一块切成肉末的生牛肉上。整盘菜完全生吃，不做任何烹调。“ 1321-1323, 标注, 2025 年 1 月 10 日星期五 上午 8:13:00 清朝和俄罗斯在 1689 年签订的《尼布楚条约》就是这一时期双边关系发展的结果。而这个条约从开始谋划，到最后签订，康熙都是站在近代国家平等观念下在思考。思考的过程也接近现代国家谈判思维，考虑的是利益取舍，没有在一些虚无的礼仪称谓问题上费心思。 1321-1324, 标注, 2025 年 1 月 10 日星期五 上午 8:13:07 清朝和俄罗斯在 1689 年签订的《尼布楚条约》就是这一时期双边关系发展的结果。而这个条约从开始谋划，到最后签订，康熙都是站在近代国家平等观念下在思考。思考的过程也接近现代国家谈判思维，考虑的是利益取舍，没有在一些虚无的礼仪称谓问题上费心思。康熙在思维方式和战略眼光上都远超其朝廷里的大臣 2233-2233, 标注, 2025 年 1 月 12 日星期日 下午 10:28:55 纸上的文字竟然是用希伯来文书写的波斯语。 2233-2233, 笔记, 2025 年 1 月 12 日星期日 下午 10:29:19 太奇怪了！ 2235-2235, 标注, 2025 年 1 月 12 日星期日 下午 10:30:28 纸上内容记录的就是他们在做羊的买卖）。42 2235-2235, 笔记, 2025 年 1 月 12 日星期日 下午 10:30:43 我勒个去 2781-2781, 标注, 2025 年 1 月 13 日星期一 上午 8:51:28 真实的康熙是一位现实的、没有文化偏执的皇帝。 3514-3514, 标注, 2025 年 1 月 13 日星期一 下午 9:47:43 宗教到最后都是殊途同归” 3543-3545, 标注, 2025 年 1 月 13 日星期一 下午 9:58:08 雍正和康熙不一样，他对传教士讲的数学、天文等欧洲学术都没有兴趣，因而在他眼里，传教士并没有什么特别之处。这一点是他和康熙在看待传教士问题上的根本区别。 3647-3649, 标注, 2025 年 1 月 14 日星期二 上午 2:39:43 基督教和伊斯兰教文明冲突了上千年，互相都不能接受对方。文明冲突理论是在这个历史背景下发展出来的。后来的学者，非要把信奉“君子和而不同”的儒家文明也加入到这个理论中，就出现了各种削足适履的事例。 3757-3758, 标注, 2025 年 1 月 14 日星期二 上午 7:56:45 康熙一朝就是六十一年。六十一年放在历史长河中很短暂，但这也是传教士在中国，和中国百姓一天天、一年年过出来的六十一年。 3761-3763, 标注, 2025 年 1 月 14 日星期二 上午 7:57:29 历史应该最少有两次评判。一是当时的人-历史参与者流露出的主观感觉，这可以算作一种评判。二是后来人综合历史上下文的评判。这两种评判可以不同，但是后来的历史评判不能无视当时人自身的感受。 3827-3829, 标注, 2025 年 1 月 14 日星期二 上午 8:12:16 寻找历史规律主导了现当代历史研究，同时也支配了现当代的历史书写。这一影响最具体的表现就是史家热衷于讲抽象的“大”历史，而忽视了历史中的个人和那些有血有肉的细节，以及个体生命轨迹中展现出的偶然性和不确定性。 3849-3851, 标注, 2025 年 1 月 14 日星期二 上午 8:16:56 康熙在病床上匆匆开始了传位，皇四子也在完全没有预兆的情况下，突然登基了。几个月后，皇三子被发配去给康熙守陵墓，他负责的西学事业也随之停止。又过了几个月，传教士的教也被禁了，这在影响天主教入华的同时也影响了西方科学的传播。 3849-3852, 标注, 2025 年 1 月 14 日星期二 上午 8:17:29 康熙在病床上匆匆开始了传位，皇四子也在完全没有预兆的情况下，突然登基了。几个月后，皇三子被发配去给康熙守陵墓，他负责的西学事业也随之停止。又过了几个月，传教士的教也被禁了，这在影响天主教入华的同时也影响了西方科学的传播。当时所有的西方知识都是靠这些来华的传教士亲自带到中国的。他们人不再来，西学传播的渠道也随之减少。对于中国来说，这就使得中国错过了西方科学革命中最重要的 18 世纪。 3853-3856, 标注, 2025 年 1 月 14 日星期二 上午 8:18:04 欧洲科学革命中最关键的反而是从阿拉伯传到欧洲的代数，以及在代数上发展出的微积分这两个实用的数学工具。牛顿就是使用这两个工具来解释现实世界的第一人，开启了 18 世纪欧洲科学的井喷式发展。可惜在代数就快要进入中国时，持续了大约一百年的西学东传，随着康熙的驾崩和雍正的登台而逐渐停止了。 4023-4024, 标注, 2025 年1月14日星期二 上午8:44:00 从2004年出国留学，到2019年拿到博士学位，历时十五年之久。 ","date":"2025-01-14","objectID":"/%E7%AC%94%E8%AE%B0%E5%BA%B7%E7%86%99%E7%9A%84%E7%BA%A2%E7%A5%A8%E5%85%A8%E7%90%83%E5%8C%96%E4%B8%AD%E7%9A%84%E6%B8%85%E6%9C%9D-%E5%AD%99%E7%AB%8B%E5%A4%A9/:0:0","tags":["kangxidehong","note","ireader"],"title":"[笔记]康熙的红票:全球化中的清朝-孙立天","uri":"/%E7%AC%94%E8%AE%B0%E5%BA%B7%E7%86%99%E7%9A%84%E7%BA%A2%E7%A5%A8%E5%85%A8%E7%90%83%E5%8C%96%E4%B8%AD%E7%9A%84%E6%B8%85%E6%9C%9D-%E5%AD%99%E7%AB%8B%E5%A4%A9/"},{"categories":null,"content":" 108-109, 标注, 2024 年 12 月 31 日星期二 下午 11:01:17 追寻真相不等于一切都“反着看”“倒着看”，最后的判断只能是依据事实。 111-113, 标注, 2024 年 12 月 31 日星期二 下午 11:02:54 本书的考察自然要涉及领袖人物的意志和党内分歧，但更注重于分析在个人意志和党内分歧背后起作用的历史的、制度的和观念的因素。通过这种梳理，为人们思考中国未来走向提供某种历史经验的支持。 140-142, 标注, 2024 年 12 月 31 日星期二 下午 11:07:29 按照最初的设想，新民主主义社会将持续 10 年、20 年，甚至更长时间。新民主主义社会的任务是，在多种所有制基础上发展生产力，实现农业国向工业国的转变，为向社会主义转变准备条件。 139-142, 标注, 2024 年 12 月 31 日星期二 下午 11:09:34 所谓新民主主义社会论，是指在新民主主义革命完成后，要经历一个新民主主义社会阶段。按照最初的设想，新民主主义社会将持续 10 年、20 年，甚至更长时间。新民主主义社会的任务是，在多种所有制基础上发展生产力，实现农业国向工业国的转变，为向社会主义转变准备条件。 285-285, 标注, 2025 年 1 月 1 日星期三 上午 12:00:09 人民有思想、言论、出版、集会、结社、通讯、人身、居住、迁徙、宗教信仰及示威游行的自由权”。 879-881, 标注, 2025 年 1 月 1 日星期三 下午 10:06:47 [ 1067-1067, 笔记, 2025 年 1 月 1 日星期三 下午 10:47:00 他看到的 是他想看的,是别人按其心意安排的吧 1098-1100, 标注, 2025 年 1 月 2 日星期四 上午 7:50:00 在他看来，过去几年合作社的发展都超过计划，而且大都巩固下来了。各地给他报告的情况是，现有 65 万个合作社 80%以上是增产的，这给了毛泽东底气。 1100-1100, 笔记, 2025 年 1 月 2 日星期四 上午 7:50:51 虚假报告导致错误决论? 1117-1117, 标注, 2025 年 1 月 2 日星期四 上午 7:53:17 所谓社会主义高潮，是一个自我实现的预言。 1127-1128, 标注, 2025 年 1 月 2 日星期四 上午 7:54:41 中共七届六中全会精神贯彻下去，全国掀起对“右倾机会主义”的批判，各级领导人争先恐后，总是超指标完成任务。高潮就这样出现了。 1127-1129, 标注, 2025 年 1 月 2 日星期四 上午 8:00:14 中共七届六中全会精神贯彻下去，全国掀起对“右倾机会主义”的批判，各级领导人争先恐后，总是超指标完成任务。高潮就这样出现了。各级领导人把推动合作化运动视为表明政治坚定性和展示政绩的机会。 1177-1178, 标注, 2025 年 1 月 2 日星期四 上午 8:04:33 农业四十条甚至让知识分子也为之振奋，一千多位科学家和民主人士应邀参加了讨论，这当中肯定融入了热衷于中国乡村建设的知识分子的理想。 1324-1326, 标注, 2025 年 1 月 2 日星期四 下午 1:08:56 季羡林回忆说：“解放初期，政治清明，一团朝气，许多措施深得人心。旧社会留下的许多污泥浊水，荡涤一清……觉得从此换了人间”。[ 1349-1350, 标注, 2025 年 1 月 2 日星期四 下午 1:11:05 家族宗法组织、神祖祀会等传统社会网络基本瓦解；千百年来政权止于县和乡绅自治的传统结构被彻底打破； 1390-1391, 标注, 2025 年 1 月 2 日星期四 下午 1:14:01 户籍制度把中国社会从此分割为城市与农村两大部分，市民与农民是两种不同的身份，而且带有世袭性质。这种城乡分割二元体制对中国社会影响深远。 1774-1778, 标注, 2025 年 1 月 2 日星期四 下午 1:25:53 毛泽东在八大期间讲：斯大林在消灭了阶级以后还要继续进行阶级斗争，这就是他的错误的根源。“我们的政权专政的职能，只剩下十分之一了……现在我们的任务是解放生产力，保护生产力……要党内不恐慌，要民主党派不恐慌，要全国人民不恐慌。”[28]看了这几段话，几乎难以相信此后 20 年毛泽东会反道而行，把阶级斗争推向极致。 1958-1960, 标注, 2025 年 1 月 2 日星期四 下午 6:30:31 反右的直接后果，不只是中国的知识精英受到整体伤害，更深远的后果在于，由此在相当一段时间阻塞了中国走向民主和法治轨道的可能性。知识分子和民主党派集体失声，共产党再也听不到党外批评。 1981-1984, 标注, 2025 年 1 月 2 日星期四 下午 6:32:23 毛泽东的雄心建立在一种特殊的自信之上。这种自信，来源于社会主义将大大解放生产力的普遍信念，[73]更来自对中华民族之伟力和中共强大动员能力的强烈的自信心。[ 1993-1994, 标注, 2025 年 1 月 2 日星期四 下午 6:33:37 指导思想悄然从“反右倾”转向“反冒进”，而年初提出的农业四十条和“多、快、好、省”口号，实际上被搁置。毛泽东的意见被中央集体否决，这在建国后是极少见的。 2033-2036, 标注, 2025 年 1 月 2 日星期四 下午 6:39:13 [84]我不认为，毛泽东真的相信报纸上亩产多少万斤的连篇累牍的报道，[85]但他不愿“泼冷水”，群众运动靠的是一股气，“气可鼓不可泄”。 2423-2425, 标注, 2025 年 1 月 4 日星期六 上午 7:02:48 以政治斗争压制各种不同意见，结果是个人意志左右全局，最高权威无法约束，无论进退，都倚仗于一人决断。真正的危险不在因缺乏经验而犯错，而在于因阻塞批评而丧失纠错的能力。 2430-2431, 标注, 2025 年 1 月 4 日星期六 上午 7:03:55 每个人都成了高速旋转战车上的一个部件，每个人的行为似乎都能找到理由，又都无法对其后果负完全责任。“ 2451-2452, 标注, 2025 年 1 月 4 日星期六 上午 7:06:32 这次大饥荒至少可以得出两条教训：一是应当藏粮于民，决不可竭泽而渔；二是应当有必要的粮食市场，不仅可以调剂余缺，更可以及时传递灾情信号。 2455-2456, 标注, 2025 年 1 月 4 日星期六 上午 7:07:25 1958 年，年景并不坏，农业丰收在望。可是几千万人正在山上大炼钢铁，粮食烂在地里无人收割，留在农村的劳力也不关心收成多少，浪费和干部多吃多占消耗了过多粮食。 2464-2467, 标注, 2025 年 1 月 4 日星期六 上午 7:09:17 由此，我们应当得到启示，任何时候都应对人类理性的局限保持一份警惕，谨慎对待按照理想设计出来的社会方案。理想是提升社会的明灯，现实则是一个试错改良的过程，把理想直接拿来进行社会试验，必然带来灾难。理想越崇高、目标越远大、权威越强大，带来的灾难可能就越大。 3050-3051, 标注, 2025 年 1 月 4 日星期六 上午 11:53:32 所有上述公开争辩的或隐藏在背后的因素，也都披上了意识形态的外衣。中共指斥苏共为“修正主义”，苏共指斥中共为“教条主义”，双方为马克思主义和社会主义的正统性而斗争。 3115-3119, 标注, 2025 年 1 月 4 日星期六 下午 12:01:41 [66]毛泽东的解决之道不是改革体制，而是每隔几年进行一次整风，办法是发动群众整干部。[67]用不断“翻烧饼”的办法，防止官僚化和利益集团板结化，不能说没有震慑之效，却以巨大社会创痛为代价。 3181-3190, 标注, 2025 年 1 月 4 日星期六 下午 2:29:56 [82]三则要改造人性，在“灵魂深处爆发革命”。毛泽东历来相信，人性是可以改造的，也必须改造；只有改造才能培养出“新人”，只有“新人”才能建设新社会。而人性改造一要经受体力劳动的净化，二要经受阶级斗争的炼狱。 3206-3206, 标注, 2025 年 1 月 4 日星期六 下午 2:33:01 人类历史上的许多人为灾难，往往都宣称为了某种崇高的理想和目标。 4524-4524, 标注, 2025 年 1 月 4 日星期六 下午 9:48:16 最有希望的时期也许是充满危险的时期。 4536-4538, 标注, 2025 年 1 月 4 日星期六 下午 9:58:01 如果说世界上有两个坏东西，那么，一个是贪婪的资本，一个是腐败的权力。还有比这更坏的，就是权力与资本的合谋与分账，即所谓权贵资本主义。 4562-4568, 标注, 2025 年 1 月 4 日星期六 下午 10:52:46 市场化改革必须深化，但市场化必须与社会公正同行，不能以目标的正当性为过程的非公正性做辩护，不能将改革变成权贵和强势集团掠夺财富的饕餮盛宴，导致贫富状况进一步恶化。中国必须逐步实现以宪法为中心的民主政治，但通向现代民主政治的道路仍然只能是渐进的中国式的，应当根据中国的现实国情和文化背景寻找适合自己的民主化模式和路线图。中国不能丢弃自己的优势，但中国特色社会主义的最大优势，正在于它吸纳优秀文明成果的包容性，有不断改革的能力和自我调适的空间。中国未来之路应当警惕任何一种理性自负的陷阱，如果能避免拉美一些国家总是在“两个鸡蛋上跳舞”，避免中东一些国家出现的转型乱局，那是中国之幸，百姓之幸。 4798-4800, 标注, 2025 年 1 月 4 日星期六 下午10:55:0","date":"2025-01-06","objectID":"/%E7%AC%94%E8%AE%B0%E7%AD%9A%E8%B7%AF%E7%BB%B4%E8%89%B0%E4%B8%AD%E5%9B%BD%E7%A4%BE%E4%BC%9A%E4%B8%BB%E4%B9%89%E8%B7%AF%E5%BE%84%E7%9A%84%E4%BA%94%E6%AC%A1%E9%80%89%E6%8B%A9-%E8%90%A7%E5%86%AC%E8%BF%9E/:0:0","tags":["biluweijian","","note","ireader"],"title":"[笔记]筚路维艰:中国社会主义路径的五次选择-萧冬连","uri":"/%E7%AC%94%E8%AE%B0%E7%AD%9A%E8%B7%AF%E7%BB%B4%E8%89%B0%E4%B8%AD%E5%9B%BD%E7%A4%BE%E4%BC%9A%E4%B8%BB%E4%B9%89%E8%B7%AF%E5%BE%84%E7%9A%84%E4%BA%94%E6%AC%A1%E9%80%89%E6%8B%A9-%E8%90%A7%E5%86%AC%E8%BF%9E/"},{"categories":null,"content":" 198-199, 标注, 2025 年 1 月 4 日星期六 下午 9:45:57 最重要的是，要不断问自己，在复杂的情况面前，坚持严谨意味着什么，并把诚实的怀疑作为你学习的核心。 242-243, 标注, 2025 年 1 月 5 日星期日 下午 9:25:45 人类的理解总是既暂时又迟缓。许多现在看来很明显的事情，在当时却并不明显，因为我们在回顾过去时所体验到的清晰，完全不同于围绕着当下生活的不确定性的阴霾。 246-248, 标注, 2025 年 1 月 5 日星期日 下午 9:29:35 如果我们希望提高理解的有效性和准确性，就需要进行终身实践和审视。换句话说，为了提升思考能力，我们必须花时间来对思考本身进行思考：这个过程被称为元认知。 311-311, 标注, 2025 年 1 月 5 日星期日 下午 10:54:39 认知失调现象，即面对 311-312, 标注, 2025 年 1 月 5 日星期日 下午 10:54:43 认知失调现象，即面对相互矛盾的证据时，人们会基于个人认知做出决定。 312-316, 标注, 2025 年 1 月 5 日星期日 下午 10:55:30 同理心和专注能帮助我们领会到这些差异的本质。然而，尤其是在面临压力和不确定性的时候，几乎所有人都倾向于看重自己的观点，而不是观点本身的价值。心理学家称之为可得性偏差，它所描述的东西非常浅显，以至于其重要性很容易被忽视。除非我们多留心我们的知识和经验的局限性，否则我们的思维往往会被最容易和最清晰地出现在脑海中的东西所支配，不管它多么不具代表性。 338-340, 标注, 2025 年 1 月 5 日星期日 下午 10:57:06 讲一个有意义的故事意味着激励你的听众……让他们得出与你相同的结论，并自己决定相信你所说的，做你希望他们做的事情。比起你的结论，人们更看重自己的结论。他们只会相信对他们个人来说已经成为事实的故事。”（ 412-413, 标注, 2025 年 1 月 6 日星期一 上午 7:54:34 尽可能坦诚地面对自己的局限性。不要养成不懂装懂的坏习惯。 709-709, 标注, 2025 年 1 月 6 日星期一 下午 1:19:29 就像说“汽车因为能量而移动”一样，引入一个表面上精确的术语，掩盖了没有解释的事实， ","date":"2025-01-06","objectID":"/%E7%AC%94%E8%AE%B0%E6%B8%85%E6%99%B0%E6%80%9D%E8%80%83-%E8%8B%B1-%E6%B1%A4%E5%A7%86%E6%9F%A5%E7%89%B9%E8%8F%B2%E5%B0%94%E5%BE%B7%E8%B5%B5%E5%86%9B/:0:0","tags":["qingxisikao","note","ireader"],"title":"[笔记]清晰思考-(英) 汤姆·查特菲尔德;赵军","uri":"/%E7%AC%94%E8%AE%B0%E6%B8%85%E6%99%B0%E6%80%9D%E8%80%83-%E8%8B%B1-%E6%B1%A4%E5%A7%86%E6%9F%A5%E7%89%B9%E8%8F%B2%E5%B0%94%E5%BE%B7%E8%B5%B5%E5%86%9B/"},{"categories":null,"content":" Table of Contents 1 LowCardinality(T) 1.1 Syntax​ 1.2 Description​ 1.3 Example​ 2 Use LowCardinality 3 string optimization 3.1 String storage in ClickHouse 3.2 Dictionary encoded strings 3.3 Summary 本文为摘录(或转载)，侵删，原文为： https://clickhouse.com/docs/en/sql-reference/data-types/lowcardinality ","date":"2025-01-03","objectID":"/clickhouse_com_data-types_lowcardinality/:0:0","tags":null,"title":"LowCardinality(T) | ClickHouse Docs","uri":"/clickhouse_com_data-types_lowcardinality/"},{"categories":null,"content":"1 LowCardinality(T) https://clickhouse.com/docs/en/sql-reference/data-types/lowcardinality Changes the internal representation of other data types to be dictionary-encoded. ","date":"2025-01-03","objectID":"/clickhouse_com_data-types_lowcardinality/:1:0","tags":null,"title":"LowCardinality(T) | ClickHouse Docs","uri":"/clickhouse_com_data-types_lowcardinality/"},{"categories":null,"content":"1.1 Syntax​ LowCardinality(data_type) Parameters: data_type String, FixedString, Date, DateTime, and numbers excepting Decimal. LowCardinality is not efficient for some data types, see the allow_suspicious_low_cardinality_types setting description. ","date":"2025-01-03","objectID":"/clickhouse_com_data-types_lowcardinality/:1:1","tags":null,"title":"LowCardinality(T) | ClickHouse Docs","uri":"/clickhouse_com_data-types_lowcardinality/"},{"categories":null,"content":"1.2 Description​ LowCardinality is a superstructure that changes a data storage method and rules of data processing. ClickHouse applies dictionary coding to LowCardinality-columns. Operating with dictionary encoded data significantly increases performance of SELECT queries for many applications. LowCardinality 是一种改变数据存储方法和数据处理规则的超级结构。ClickHouse 对 LowCardinality 列应用字典编码。使用字典编码的数据操作显著提高了许多应用程序的 SELECT 查询性能。 The efficiency of using LowCardinality data type depends on data diversity. If a dictionary contains less than 10,000 distinct values, then ClickHouse mostly shows higher efficiency of data reading and storing. If a dictionary contains more than 100,000 distinct values, then ClickHouse can perform worse in comparison with using ordinary data types. 使用 LowCardinality 数据类型的效率取决于数据的多样性。如果字典包含少于 10,000 个不同的值，那么 ClickHouse 在数据读取和存储方面通常显示出更高的效率。如果字典包含超过 100,000 个不同的值，那么 ClickHouse 的性能可能会比使用普通数据类型差。 Consider using LowCardinality instead of Enum when working with strings. LowCardinality provides more flexibility in use and often reveals the same or higher efficiency. 在处理字符串时，可以考虑使用 LowCardinality 代替 Enum 。 LowCardinality 在使用上提供了更多的灵活性，并且通常展现出相同或更高的效率。 ","date":"2025-01-03","objectID":"/clickhouse_com_data-types_lowcardinality/:1:2","tags":null,"title":"LowCardinality(T) | ClickHouse Docs","uri":"/clickhouse_com_data-types_lowcardinality/"},{"categories":null,"content":"1.3 Example​ Create a table with a LowCardinality-column: CREATE TABLE lc_t ( `id` UInt16, `strings` LowCardinality(String) ) ENGINE = MergeTree() ORDER BY id ","date":"2025-01-03","objectID":"/clickhouse_com_data-types_lowcardinality/:1:3","tags":null,"title":"LowCardinality(T) | ClickHouse Docs","uri":"/clickhouse_com_data-types_lowcardinality/"},{"categories":null,"content":"2 Use LowCardinality https://www.tinybird.co/clickhouse/knowledge-base/low-cardinality The fewer bytes you read from disk, the faster your query. If your column contains a limited set of repeated values (otherwise known as low cardinality, or low unique-ness) you can optimize the storage of the value of this column by using the LowCardinality type. The LowCardinality type encapsulates other data types, creating a dictionary of possible column values. Rather than storing the raw value many, many times, instead, the column value is a key that points to the raw value in a dictionary. For example, if you had ColumnA with 5 possible unique values: 'Possible String Value 1' 'Possible String Value 2' 'Possible String Value 3' 'Possible String Value 4' 'Possible String Value 5' Your table may contain 1 million rows, and 300,000 rows have the value ‘Possible String Value 1’ for ColumnA. If you use a standard STRING type, you will store the entire value ‘Possible String Value 1’ 300,000 times, which uses 25 bytes each time, for a total of 7.5 megabytes. To optimize, you can set the column type to LowCardinality. Every unique value will be stored once, in a dictionary table, for example: 1: 'Possible String Value 1' 2: 'Possible String Value 2' 3: 'Possible String Value 3' 4: 'Possible String Value 4' 5: 'Possible String Value 5' Now, rather than each of the 300,000 rows storing ‘Possible String Value 1’ for ColumnA, instead, each of these rows stores the key 1. When selecting ColumnA, you would retrieve the value for key 1 from the dictionary of values. Storing 1 as a 4 byte integer, 300,000 times, would result in a total of 1.2 megabytes, or a 6.25x reduction in bytes. Here’s an example: DROP DATABASE IF EXISTS lc; CREATE DATABASE lc; CREATE TABLE lc.base ENGINE = MergeTree ORDER BY (n1, s1) AS SELECT number n1, [ 'The tattered work gloves speak of the many hours of hard labor he endured throughout his life.', 'The glacier came alive as the climbers hiked closer.', 'Nancy was proud that she ran a tight shipwreck.', 'The ants enjoyed the barbecue more than the family.', 'The bug was having an excellent day until he hit the windshield.' ][(rand() % 5) + 1] s1 FROM numbers(2000000); CREATE TABLE lc.lowcard ENGINE = MergeTree ORDER BY (n1, s1) AS SELECT n1, toLowCardinality(s1) s1 FROM lc.base; select formatReadableSize(sum(bytes_on_disk)), count() from system.parts WHERE table = 'base' and active FORMAT PrettyCompact; select formatReadableSize(sum(bytes_on_disk)), count() from system.parts WHERE table = 'lowcard' and active FORMAT PrettyCompact; You can already see that the table using the LowCardinality column requires less disk space. You can confirm this by doing a query and checking the statistics returned by ClickHouse. localhost :) SELECT * FROM lc.base WHERE n1 = 10 ; ┌─n1─┬─s1───────────────────────────────────────────────────┐ │ 10 │ The glacier came alive as the climbers hiked closer. │ └────┴──────────────────────────────────────────────────────┘ 1 rows in set. Elapsed: 0.006 sec. Processed 8.19 thousand rows, 646.57 KB (1.39 million rows/s., 110.00 MB/s.) localhost :) SELECT * FROM lc.lowcard WHERE n1 = 10 ; ┌─n1─┬─s1───────────────────────────────────────────────────┐ │ 10 │ The glacier came alive as the climbers hiked closer. │ └────┴──────────────────────────────────────────────────────┘ 1 rows in set. Elapsed: 0.004 sec. Processed 8.19 thousand rows, 74.09 KB (1.83 million rows/s., 16.51 MB/s.) As expected, both queries are reading the same number of rows but the one not using LowCardinality is reading almost 9 times more data! ","date":"2025-01-03","objectID":"/clickhouse_com_data-types_lowcardinality/:2:0","tags":null,"title":"LowCardinality(T) | ClickHouse Docs","uri":"/clickhouse_com_data-types_lowcardinality/"},{"categories":null,"content":"3 string optimization ","date":"2025-01-03","objectID":"/clickhouse_com_data-types_lowcardinality/:3:0","tags":null,"title":"LowCardinality(T) | ClickHouse Docs","uri":"/clickhouse_com_data-types_lowcardinality/"},{"categories":null,"content":"3.1 String storage in ClickHouse Downloadable from: https://raw.githubusercontent.com/ClickHouse/clickhouse-presentations/master/meetup19/string_optimization.pdf 3.1.1 External dictionaries Store strings in a dictionary, indices in a table Advantages Dynamically changeable set of strings No alterations (no problems) A variety of dictionary sources Disadvantages Bulky (explicit) syntax Difficult to optimize Delayed updates from external source 3.1.2 Local dictionaries Getting rid of global dictionaries No synchronization — no problem Store dictionaries locally Per block (in memory) Per part (on file system) In caches (during query processing) ","date":"2025-01-03","objectID":"/clickhouse_com_data-types_lowcardinality/:3:1","tags":null,"title":"LowCardinality(T) | ClickHouse Docs","uri":"/clickhouse_com_data-types_lowcardinality/"},{"categories":null,"content":"3.2 Dictionary encoded strings 3.2.1 StringWithDictionary Datatype for dictionary encoded strings Serialization Representation in memory Data processing Content: Dictionary Column with positions Reversed index 3.2.2 LowCardinality(Type) Is a general datatype with dictionary encoding Is implemented for strings, numbers, Date, DateTime, Nullable. StringWithDictionary is an alias for LowCardinality(String). Remains for some functions 3.2.3 Queries optimizations Implemented Functions executed on dictionaries if it’s possible Calculations are cached for same dictionaries GROUP BY optimization To be done Specializations for aggregate functions ","date":"2025-01-03","objectID":"/clickhouse_com_data-types_lowcardinality/:3:2","tags":null,"title":"LowCardinality(T) | ClickHouse Docs","uri":"/clickhouse_com_data-types_lowcardinality/"},{"categories":null,"content":"3.3 Summary LowCardinality type is available in last release Experimental ( set allow_experimental_low_cardinality_type = 1 to enable) Test performance on your dataset Just replace String with StringWithDictionary Goals Make datatype with dictionary better than String in all cases Implicitly replace String with StringWithDictionary ","date":"2025-01-03","objectID":"/clickhouse_com_data-types_lowcardinality/:3:3","tags":null,"title":"LowCardinality(T) | ClickHouse Docs","uri":"/clickhouse_com_data-types_lowcardinality/"},{"categories":null,"content":" Table of Contents 1 为什么要引入低基数字典优化 2 为什么需要全局字典 3 如何高效构建全局字典 3.1 通常的分布式字典构建方式 3.2 StarRocks 全局字典的构建 4 如何高效使用全局字典 4.1 CBO 优化器的紧密配合 4.2 全局字典的字符串函数优化 5 优化效果 6 总结 本文为摘录(或转载)，侵删，原文为： https://segmentfault.com/a/1190000042326071 作者：冯浩桉，StarRocks 核心研发工程师，StarRocks Committer 在数据库和存储系统中，String 类型数据广泛存在。为了提升 String 的处理效率和节省存储资源，出现了很多针对 String 类型进行优化的技术手段，例如提升处理效率的各类字典应用，提升存储效率的字典编码压缩技术。 本文主要针对 StarRocks 基于全局字典做的低基数 String 查询优化，揭秘其技术内幕。 ","date":"2025-01-03","objectID":"/my_oschina_net_blog_5566031/:0:0","tags":["starrocks","string","global","low","cardinality"],"title":"StarRocks 技术内幕 | 基于全局字典的极速字符串查询","uri":"/my_oschina_net_blog_5566031/"},{"categories":null,"content":"1 为什么要引入低基数字典优化 我们先看下两个 SQL 的对比，表 Lineorder 是 SSB100G 数据集， lo_shippriority 为低基数 int 列， l_shipmode 为低基数 String 列 mysql\u003e select count(cnt) from ( select count(*) cnt from lineorder group by lo_shippriority) tb; +------------+ | count(cnt) | +------------+ | 1 | +------------+ 1 row in set (3.51 sec) mysql\u003e select count(cnt) from ( select count(*) cnt from lineorder group by lo_shipmode) tb; +------------+ | count(cnt) | +------------+ | 7 | +------------+ 1 row in set (9.33 sec) 可以看到，处理相同数据量的情况下，String 类型的处理时间差不多是 int 类型的 3 倍。 如果能使用整数类型来替代 String 类型进行数据处理，能够显著提升系统的性能！ 对于利用整型替代字符串进行处理，通常是使用字典编码进行优化。一个 SQL 从输入到输出结果，往往会经过这几个步骤，几乎每一个阶段都可以使用字典优化：Scan，Filter，Agg，Join，Shuffle，Sort。 以 Filter 和 Agg 为例： Filter (过滤操作) ​ 对于 Filter 阶段来说，如果某一个列是用字典编码的，我们就可以直接使用编码之后的整数进行比较，而不是直接用 String 进行比较操作。大多数情况下，整数之间的 Compare 性能会高于字符串之间的性能。 Agg (聚合操作) 对于 Agg 操作，如果使用了字典编码，我们在聚合中可以使用编码之后的值作为聚合的 Key。如此一来，在聚合操作的 Hash 表构建和查找过程中，可以减少 Hash 表中 Key 的比较代价，同时也能够加快 Hash 值计算，节省内存空间，可以提升聚合操作的速度。 因此如果我们使用字典的编码方式把字符串转变成整型，在 SQL 执行的很多阶段，都可以起到正向加速的效果。 使用整型来替代 String 类型进行加速计算，业界通常使用的手段是使用字典优化。但是对于一个复杂系统来说，想要充分利用字典优化，并不是一件容易的事情。 ","date":"2025-01-03","objectID":"/my_oschina_net_blog_5566031/:1:0","tags":["starrocks","string","global","low","cardinality"],"title":"StarRocks 技术内幕 | 基于全局字典的极速字符串查询","uri":"/my_oschina_net_blog_5566031/"},{"categories":null,"content":"2 为什么需要全局字典 在一个分布式执行引擎中，一个 SQL 的执行过程是复杂的。一个查询会存在多个执行阶段，可能会涉及到多个机器多个任务之间的数据交换。如果想充分利用字典优化，那么需要考虑很多的情况: 在执行过程中，字典要保证全局性 也就是说在不同的节点之间同样需要维护一个字典。字典数据始终贯穿 SQL 执行的整个生命周期，如果不是全局字典，那么加速只能在局部进行。例如如果两个执行节点的字典编码不一致，那么在网络传输过程中需要同时把字典传给对端机器，或者是需要提前把字典码转为字符串再通过网络发送。如果能保证一个字典的全局性，在网络传输中就可以直接使用字典码而不再需要传输字典。 查询规划器规划出使用全局字典最高效的方式 如果一个 SQL 在执行过程中没有网络 Shuffle，也不存在潜在应用字典优化的操作，那么不再采用字典优化。例如 insert into t1 select * from t2 这样的 SQL，中间既不存在数据网络 Shuffle，也不存在可能会应用到低基数优化的算子。那么这样的 SQL 就不适合使用低基数优化。 对于一个复杂的、支持实时数据更新的分布式数据库，做到以上两点，并不容易。所以很多的分布式系统，只是用了字典来做局部加速，并没有做全局加速。 ","date":"2025-01-03","objectID":"/my_oschina_net_blog_5566031/:2:0","tags":["starrocks","string","global","low","cardinality"],"title":"StarRocks 技术内幕 | 基于全局字典的极速字符串查询","uri":"/my_oschina_net_blog_5566031/"},{"categories":null,"content":"3 如何高效构建全局字典 为了充分利用字典加速，首先需要解决的问题就是全局字典构建和维护问题。 ","date":"2025-01-03","objectID":"/my_oschina_net_blog_5566031/:3:0","tags":["starrocks","string","global","low","cardinality"],"title":"StarRocks 技术内幕 | 基于全局字典的极速字符串查询","uri":"/my_oschina_net_blog_5566031/"},{"categories":null,"content":"3.1 通常的分布式字典构建方式 对于很多系统来说，通常构建全局字典的方式有两种： 3.1.1 用户指定 Schema，用户在建表的时候，指定对应的列为低基数列 因为用户指定了低基数，那么可以在数据导入的时候，构建全局字典，因为知道了基数范围，全局字典很好维护，按着特定的规则去生成就好了，存储的代价也不高。 但是这么做，主要存在的问题在于： 对用户不友好，需要用户指定 Schema，当基数存在变化，比如基数变高后，不方便维护 无法提升已经运行的系统的性能，必须得重建表并且重新导入数据后才能使用。 3.1.2 导入时候构建全局字典 导入数据时，通过中心节点维护全局字典。每次遇到新的的字符都要通过中心节点创建一个新的字典码。但是这么做的主要问题是中心节点很容易会成为瓶颈。另外中心节点因为需要同时处理维护并发控制。 因为维护和构建字典对于很多系统来说都是一个比较困难的事情，因此很多系统，只是在局部使用了局部字典来进行加速，并不支持字典的全局加速。 ","date":"2025-01-03","objectID":"/my_oschina_net_blog_5566031/:3:1","tags":["starrocks","string","global","low","cardinality"],"title":"StarRocks 技术内幕 | 基于全局字典的极速字符串查询","uri":"/my_oschina_net_blog_5566031/"},{"categories":null,"content":"3.2 StarRocks 全局字典的构建 对于 StarRocks 的全局字典的构建，主要有以下考虑： 自适应，不需要用户通过 Schema 指定特定低基数列，而是根据数据特性，自动选择优化策略。 尽可能避免单点问题，比如数据导入的时候遇到新的字符串，先通过中心节点更新全局字典。 3.2.1 数据存储上的字典优化 首先先来看下 StarRocks 的数据存储的结构。 StarRocks 的基本存储单元为 Segment，每个 Segment 的存储结构如下图所示： StarRocks 的存储结构天然为低基数字符串做了字典编码。对于 Segment 上的低基数字符串列会有以下特点： Footer 上会存储有这个 Column 特有的字典信息，包括字典码跟原始字符串之间的映射关系； Data page 上存储的不是原始字符串，而是整数类型的字典码(整型)。 简单的示意图如下： 当处理低基数 String column 的时候，直接使用编码后的字典码，而不是直接处理原始的 String 值。当需要原始的 String 值时，使用字典码就可以很方便地在这个列的字典信息里面拿到原始 String 值。这么做带来的明显好处是： 减少了磁盘 IO。 可以提前做一些过滤操作，提升处理速度。 3.2.2 全局字典的构建 StarRocks 支持 CBO 优化器，并且存在一套统计信息机制，那么就可以通过统计信息来收集全局字典。我们通过统计信息，筛选出潜在的低基数列，再从潜在的低基数列的元数据中读取字典信息，然后做去重/编码操作，就可以收集到全量的字典了。 3.2.3 全局字典的正确性保证 对于低基数列来说，那么肯定会出现一种情况，在某次导入中导入了新的 String (这个 String 不在全局字典的集合内)，那么这个时候，原先已经构建的全局字典就没有办法包含所有的字符串的值。因此 StarRocks 需要维护全局字典的有效性。 全局字典可能失效只会出现在导入， StarRocks 支持了很多类型的数据导入方式，而所有的导入都有两个共同点 导入产生新的 Segment。 通过 Master FE 提交事务。 对于低基数列，所有 Segment 中都必定存在局部字典信息，那么对于一个新的导入，在产生新的 Segment 时，会有几种情况。 如果新生成的 Segment 没有了局部字典，那么说明这个列很可能是一个高基数列，此时不再适合全局字典优化； 新生成的 Segment 有局部字典，而且局部字典中的所有 String 是全局字典的子集，这种情况下可以直接使用旧的字典； 新生成的 Segment 有局部字典，而且局部字典所有的 String 值，部分不在全局字典里，此时全局字典失效已经生效，需要重新生成全局字典。 无论出现了上面的哪种情况，在向 FE 中心节点提交的时候，带上这个对应的信息，我们就都能保证全局字典的正确性。 因为每次导入都是产生新的版本，而查询是支持 MVCC 的，每次查询都会带有一个固定的查询版本号。在某一时刻中，如果出现一个新的版本数据，那么对这个版本出现之前的所有查询都是不可见的。因此我们查询中如果有新的导入，那么已发起的查询也是不受影响的。 ","date":"2025-01-03","objectID":"/my_oschina_net_blog_5566031/:3:2","tags":["starrocks","string","global","low","cardinality"],"title":"StarRocks 技术内幕 | 基于全局字典的极速字符串查询","uri":"/my_oschina_net_blog_5566031/"},{"categories":null,"content":"4 如何高效使用全局字典 ","date":"2025-01-03","objectID":"/my_oschina_net_blog_5566031/:4:0","tags":["starrocks","string","global","low","cardinality"],"title":"StarRocks 技术内幕 | 基于全局字典的极速字符串查询","uri":"/my_oschina_net_blog_5566031/"},{"categories":null,"content":"4.1 CBO 优化器的紧密配合 对于一个简单的聚合 SQL 来说，其执行过程如下： 因为 StarRocks 是个分布式系统，其数据分散在多个后端 BE 实例上，且存在多个副本。Segment 内的字典是一个局部的字典，不能作为全局字典码使用。 对于一个没有使用全局字典优化的 SQL，在 SCAN NODE 扫描 Segment 数据的过程中就需要将对应把局部的字典码(int)解码成原始的 String 返回给上层节点。 如果使用了全局字典优化，我们就不需要 SCAN NODE 节点就进行 Decoded，而是可以将原先的局部字典码(int)，直接映射到全局字典中的字典码(int)，并在之后的计算处理过程中，均使用全局字典码进行处理。当遇到某些特殊的算子，或者是需要具体的依赖字符串内部信息的时候，再按着全局字典的信息，Decoded 出原始的 String 值，这样可以充分利用到全局字典的加速。 下图展示了 SCAN NODE 使用全局字典后，向上传递的数据使用了 int 编码： 既然我们已经有了全局字典，那么接下来的问题就是更高效地使用好全局字典。 当存在全局字典的时候，所需要做的比较关键的就是： 将对 String 的操作转化为对 int 的操作时，从而提升处理的速度，节省对应的资源。 当遇到无法使用 int 替代 String 的操作时，需要提前将字典码 Decoded 成 String。 举个例子： lineitem 表中的 l_shipmode 是低基数 String 列 4.1.1 case 1 select count(*) from lineitem group by l_shipmode; 对于这个 SQL 来说，我们需要的只是聚合之后的行数，因此在整个 SQL 的执行过程中，都可以使用 int 来替代 String 进行处理，并不需要进行 Decoded。 4.1.2 case 2 select count(*), l_shipmode from lineitem group by l_shipmode; 而对于这个 SQL，需要的不仅仅是聚合后的结果数，还有对应的字符串值。在这里我们需要在结果输出之前，进行 Decoded，将 int 值翻译成 String。 对于第二条 SQL 来说，其执行过程如下所示： 可以看到第二条 SQL 多了个 Decode 节点。 对于低基数 String 列来说，聚合后的行数并不多，这个 Decode 的成本基本可以忽略不计，反而在之前的处理，使用 int 替代 String 所带来的提升是巨大的。 那么，对于查询规划器来说，要做的就是选择最合适的 Decode 时期，最大限度地提升性能。 4.1.3 case 3 select * from lineitem； 对于上面的 SQL 来说，使用全局字典，反而会带来额外的解码的开销。对于这样的 SQL，我们的 CBO 优化器需要正确规划，并且不会使用字典。 ","date":"2025-01-03","objectID":"/my_oschina_net_blog_5566031/:4:1","tags":["starrocks","string","global","low","cardinality"],"title":"StarRocks 技术内幕 | 基于全局字典的极速字符串查询","uri":"/my_oschina_net_blog_5566031/"},{"categories":null,"content":"4.2 全局字典的字符串函数优化 上面的 SQL 都是简单的例子。如果稍微对 SQL 进行一些改动，比如： select count(*), l_shipmode from lineitem group by substr(l_shipmode, 1, 3); 在这个 SQL 中，需要对 String 列进行 substr 运算，并且按着运算后的值进行聚合，这么一看，那肯定是需要在聚合前，插入一个 Decode 节点来把字典码转为具体的字符串值了，甚至在扫描数据的时候，就需要原始的 String 列了。 对于这条 SQL 来说，使用 int 值替代 String 来进行聚合，所带来的提升是巨大的，我们应该发挥全局字典的最大价值。 对于大多数的字符串函数来说，他们的计算往往有下面的一些特点: 对于固定的输入，输出也是固定，最简单的比如 substring 函数, substring(\"abc\", 1, 2) 的结果一定是 “AB”； 大部分 String 操作，都符合上面的定义。 既然对于单个 String 的运算，输出是固定的，那么对于固定集合的 String 的运算，其结果集合也一定是固定的，比如对 {\"s1\", \"s2\", \"s11\" } 进行 substring (str, 1, 2) 运算，其结果也一定是 {\"s1\", \"s2\", \"s11\" } 。 很明显，当有了低基数全局字典，全局字典里面的 String 取值，就是固定的集合。因此，我们将对单个 String 的操作，转化为对 String 集合的操作，而这个操作，在 SQL 执行的过程中，只需要执行一次。 以上面的 substr SQL 为例子，当低基数列 l_shipmode 存在全局字典时，我们运用 substr 对全局字典进行计算，计算的示意图如下： 对于上图所示的全局字典来说，substring(“hello”, 1, 2) 和 substring(“world”, 1, 3)产生的结果集是 {“he”, “wo”}。我们会把所有的输出都加入到一个新的字典中，与此同时，我们还得到了两个字典之间的转换关系。 例如字典码 1 的输入在经过这个函数之后会变成新字典的字典码 1。 有了这个映射关系，对输入的数据，进行 substring 操作，那就很简单了，因为我们输入的数据是全局字典码，并不是原始的 String，我们只需要按着 substring 中两个字典之间的转换关系，将对应的字典码通过映射输出成对应的新字典码，就完成了相关函数的计算。 对于这类的字符串函数，并不需要进行 Decode 获取原始 String 来调用函数处理，而且这种映射的方法，对于直接使用字符串进行计算也有一定的性能提升，尤其是对复杂的表达式。 ","date":"2025-01-03","objectID":"/my_oschina_net_blog_5566031/:4:2","tags":["starrocks","string","global","low","cardinality"],"title":"StarRocks 技术内幕 | 基于全局字典的极速字符串查询","uri":"/my_oschina_net_blog_5566031/"},{"categories":null,"content":"5 优化效果 我们选取了几组典型的 SQL，对比了开启低基数下的性能。 StarRocks 2.0+ 后的版本默认会开启低基数字典优化： set cbo_enable_low_cardinality_optimize = true; 对比 SQL： select count(*),lo_shipmode from lineorder group by lo_shipmode; select count(distinct lo_shipmode) from lineorder; select count(*),lo_shipmode,lo_orderpriority from lineorder group by lo_shipmode,lo_orderpriority; select count(*),lo_shipmode,lo_orderpriority from lineorder group by lo_shipmode,lo_orderpriority,lo_shippriority; select count(*) from (select count(*) from lineorder_flat group by lo_shipmode,lo_orderpriority,p_category,s_nation,c_nation) t; select count(*) from (select count(*) from lineorder_flat group by lo_shipmode,lo_orderpriority,p_category,s_nation,c_nation,p_mfgr) t; select count(*) from (select count(*) from lineorder_flat group by substr(lo_shipmode,2),lower(lo_orderpriority),p_category,s_nation,c_nation,s_region,p_mfgr) t; select count(*),lo_shipmode,s_city from lineorder_flat group by lo_shipmode,s_city; select count(*) from lineorder_flat group by c_city,s_city; select count(*) from lineorder_flat group by c_city,s_city,c_nation,s_nation; select count(*) from lineorder_flat group by lo_shipmode,lo_orderdate; select count(*) from lineorder_flat group by lo_orderdate,s_nation,s_region; 对比结果： 从效果上来看，开启低基数优化的 SQL 比没开启低基数优化的 SQL 平均快了 3 倍。 ","date":"2025-01-03","objectID":"/my_oschina_net_blog_5566031/:5:0","tags":["starrocks","string","global","low","cardinality"],"title":"StarRocks 技术内幕 | 基于全局字典的极速字符串查询","uri":"/my_oschina_net_blog_5566031/"},{"categories":null,"content":"6 总结 StarRocks 的低基数 String 优化，主要的特点有: 全局的字典加速，作用于 SQL 执行的各个阶段。 基于 CBO 优化器的，自适应选择全局字典的加速策略。 无 Schema，自适应，用户不需要指定特定的低基数列。 对用户透明，不需要重新导数据。 高性能，业界领先水平。 支持场景丰富，兼容大部分 String 处理逻辑。 ","date":"2025-01-03","objectID":"/my_oschina_net_blog_5566031/:6:0","tags":["starrocks","string","global","low","cardinality"],"title":"StarRocks 技术内幕 | 基于全局字典的极速字符串查询","uri":"/my_oschina_net_blog_5566031/"},{"categories":null,"content":" Table of Contents 1 Join 背景 2 Join 逻辑优化 3 Join Reorder 4 分布式 Join 规划 5 总结 本文为摘录(或转载)，侵删，原文为： https://segmentfault.com/a/1190000042739883 作者：贺凯，StarRocks Committer 导读：欢迎来到 StarRocks 技术内幕系列文章，我们将为你全方位揭晓 StarRocks 背后的技术原理和实践细节，助你逐步上手这款明星开源数据库产品。 本文整理自作者在 StarRocks 线下 MeetUp 的分享，主要介绍 StarRocks 在 Join 查询规划上的经验和探索。文章主要分为四个部分： Join 背景，Join 逻辑优化，Join Reorder，分布式 Join 规划。 ","date":"2025-01-03","objectID":"/segmentfault_com_a_1190000042739883/:0:0","tags":["starrocks","join"],"title":"数据库 - StarRocks 技术内幕 | Join 查询优化","uri":"/segmentfault_com_a_1190000042739883/"},{"categories":null,"content":"1 Join 背景 1、Join 类型 上图列举了常见的 Join 类型： Cross Join：左表和右表的一个笛卡尔积。 Full / Left / Right Outer Join：Outer Join 需要根据语义，对两表/左表/右表上没有匹配上的行进行补 Null。 Anti Join：输出连接关系上没有匹配上的数据行，通常 Anti Join 出现在 not in 或者 not exists 子查询的规划中。 Semi Join：与 Anti Join 相反，只输出在连接关系上匹配的数据行即可。 Inner Join：输出左表和右表的交集，根据连接条件产生一对多的结果行。 2、Join 优化的难点 Join 的执行效率通常分成两部分来优化，一是提高单机上 Join 算子的效率，二是规划一个合理的 Join 计划，尽可能地减少 Join 的输入/执行成本。本文主要集中在后者的介绍上，那么接下来就从 Join 优化的难点开始讲起。 难点一，Join 的实现方式多。 如上图所示，不同 Join 的实现方式在不同场景下效率不同，如 Sort-Merge Join 在 Join 有序数据时，效率可能远高于 Hash Join，但是在数据 Hash 分布的分布式数据库里，Hash Join 的效率可能远比 Sort-Merge 高。而数据库则需要针对不同的场景，选择合适的 Join 方式。 难点二，多表 Join 的执行顺序。 在多表 Join 的场景下，选择度高的 Join 先执行，会提高整个 SQL 的效率，但是怎么判断出 Join 的执行顺序呢？这却是十分困难的。 如上图所示，在 Left-Deep 模型下，N 个表 Join 可能的排列个数有 2^n-1 个，但是在 Bushy 模型下，排列个数高达 2^(n-1) * C(n-1)个，对于数据库而言，查找一个最佳 Join 顺序的耗时和成本是指数级的增长。 难点三，Join 的效果难以评估。 在执行 SQL 之前，数据库难以准确评估一个 Join 实际的执行效果，通常我们都认为小表 Join 大表的选择度高于大表 Join 大表。但是实际情况下呢？显然并不是这样的，还有很多一对多的场景，甚至在更复杂的 SQL 中，存在各种聚合、过滤的算子，在数据经过一系列运算后，数据库系统对于 Join 的输入都会难以评估准确。 难点四，单机最优的计划不等于分布式最优。 在分布式系统中，会通过 Re-Shuffle 或者广播数据的方式，将需要的数据发送到目的端参与计算，分布式数据库中 Join 也是如此。但这也带来了另外一个问题，一个单机数据库上最优的执行计划，因为没有考虑数据的分布 \u0026 网络传输的开销，放在分布式数据库上未必是最优的执行计划。分布式数据库在规划 Join 的执行计划和执行方式时，需要考虑数据的分布和网络成本。 3、SQL 的优化流程 StarRocks 对于 SQL 的优化主要通过优化器完成，主要集中在 Rewrite 和 Optimize 阶段。关于优化器的详细介绍可以参考 StarRocks 优化器代码导读（https://zhuanlan.zhihu.com/p/…）。 4、Join 优化的原则 StarRocks 目前 Join 的算法主要是一个 Hash Join，默认使用右表去构建 Hash 表，在这个前提下，我们总结了五个优化方向： 不同 Join 类型的算子，性能是不同的，尽可能使用性能高的 Join 类型，避免使用性能差的 Join 类型。根据 Join 输出的数据量，大致上的性能排序：Semi-Join/Anti-Join \u003e Inner Join \u003e Outer Join \u003e Full Outer Join \u003e Cross Join。 Hash Join 实现时，使用小表做 Hash 表，远比用一个大表做 Hash 表高效。 多表 Join 时，优先执行选择度高的 Join，能大幅减少后续 Join 的开销。 尽可能减少参与 Join 的数据量。 尽可能减少分布式 Join 产生的网络成本。 ","date":"2025-01-03","objectID":"/segmentfault_com_a_1190000042739883/:1:0","tags":["starrocks","join"],"title":"数据库 - StarRocks 技术内幕 | Join 查询优化","uri":"/segmentfault_com_a_1190000042739883/"},{"categories":null,"content":"2 Join 逻辑优化 ◎ — 这部分主要给大家介绍一些 Join 上的启发式规则。 1、类型转换 第一个优化规则紧贴着前面所说的第一个优化原则，也就是把低效率的 Join 类型转为高效的 Join 类型，主要包括以下三个转换规则。 转换规则一：Cross Join 转换为 Inner Join 当 Cross Join 满足某个约束时，可以将 Cross Join 转为 Inner Join。该约束为：Join 上至少存在一个表示连接关系的谓词。例如： – 转换前 Select * From t1, t2 Where t1.v1 = t2.v1; – 转换后, Where t1.v1 = t2.v1 是连接关系谓词 Select * From t1 Inner Join t2 On t1.v1 = t2.v1; 转换规则二：Outer Join 转换为 Inner Join 当满足以下约束时，可以将 Outer Join 转为 Inner Join： Left / Right Outer Join 上存在一个 Right / Left 表的相关谓词； 该相关谓词是一个严格（Restrick Null）谓词。 例如： – 转换前 Select * From t1 Left Outer Join t2 On t1.v1 = t2.v1 Where t2.v1 \u003e 0; – 转换后， t2.v1 \u003e 0 是一个 t2 表上的严格谓词 Select * From t1 Inner Join t2 On t1.v1 = t2.v1 Where t2.v1 \u003e 0; 需要注意的是，在 Outer Join 中，需要根据 On 子句的连接谓词进行补 Null 操作，而不是过滤，所以该转换规则不适用 On 子句中的连接谓词。例如： Select * From t1 Left Outer Join t2 On t1.v1 = t2.v1 And t2.v1 \u003e 1; – 显然，上面的 SQL 和下面 SQL 的语义并不等价 Select * From t1 Inner Join t2 On t1.v1 = t2.v1 And t2.v1 \u003e 1; 这里需要提到一个概念，即严格（Restrick Null）谓词。StarRocks 把一个可以过滤掉 Null 值的谓词叫做严格谓词，例如 a \u003e 0；而不能过滤 Null 的谓词，叫做非严格谓词，例如：a IS Null。大部分谓词都是严格谓词，非严格谓词主要是 IS Null、IF、CASE WHEN 或函数构成的谓词。 StarRocks 对于严格谓词的判断，用了一个简单的方法：将需要检测的列全部替换成 Null，然后进行表达式化简。如果结果是 True，意味着输入为 Null 时，Where 子句无法过滤数据，那么该谓词是一个非严格谓词；反之，如果结果是 False 或 Null，那么是一个严格谓词。 转换规则三：Full Outer Join 转为 Left / Right Outer Join 同样，当满足该约束时，Full Outer Join 可以转为 Left / Right Outer Join：存在一个可以 bind 到 Left / Right 表的严格谓词。例如： – 转换前 Select * From t1 Full Outer Join t2 On t1.v1 = t2.v1 Where t1.v1 \u003e 0; – 转换后， t1.v1 \u003e 0 是一个左表上的谓词，且是一个严格谓词 Select * From t1 Left Outer Join t2 On t1.v1 = t2.v1 Where t1.v1 \u003e 2、谓词下推 谓词下推是一个 Join 上非常重要，也是很常用的一个优化规则，其主要目的是提前过滤 Join 的输入，从而提升 Join 的性能。 对于 Where 子句，当满足以下约束时，我们可以进行谓词下推，并且伴随着谓词下推，我们可以做 Join 类型转换： 任意 Join 类型； Where 谓词可以 bind 到其中一个输入上。 例如： Select * From t1 Left Outer Join t2 On t1.v1 = t2.v1 Left Outer Join t3 On t2.v2 = t3.v2 Where t1.v1 = 1 And t2.v1 = 2 And t3.v2 = 3; 其谓词下推的流程如下。 第一步，分别下推 (t1.v1 = 1 And t2.v1 = 2) 和 (t3.v2 = 3)，由于满足类型转换规则(t1 Left Outer Join t2) Left Outer Join t3 转换为 (t1 Left Outer Join t2) Inner Join t3。 第二步，继续下推 (t1.v1 = 1) 和 (t2.v1 = 2)，且 t1 Left Outer Join t2 转换为 t1 Inner Join t2。 需要注意的是，对于 On 子句上的连接谓词，其下推的规则和 Where 子句有所不同，这里我们分为 Inner Join 和其他 Join 类型两种情况。 第一种情况是，对于 Inner Join，On 子句上的连接谓词下推，和 Where 子句相同，上面已经叙述过，这里不再重复。 第二种情况是，对于 Outer / Semi / Anti Join 的连接谓词下推，需要满足以下约束，且下推过程中无法进行类型转换： 必须为 [Left/Right] Outer/Semi/Anti Join； 连接谓词只能 bind 到 [Right/Left] 输入上。 例如： Select * From t1 Left Outer Join t2 On t1.v1 = t2.v1 And t1.v1 = 1 And t2.v1 = 2 Left Outer Join t3 On t2.v2 = t3.v2 And t3.v2 = 3; 其 On 连接谓词下推的流程如下。 第一步，下推 t1 Left Join t2 Left Join t3 上可以 bind 到右表的连接谓词 (t3.v2 = 3)，此时无法将 Left Outer Join 转换为 Inner Join。 第二步，下推 t1 Left Join t2 上可以 bind 到右表的连接谓词 (t2.v1 = 2)。由于 t1.v1 = 1 是 bind 到左表的，下推以后会过滤 t1 的数据，所以该行为与 Left Outer Join 语义不符，无法下推该谓词。 3、谓词提取 在之前的谓词下推的规则中，只能下推满足合取语义的谓词，例如 t1.v1 = 1 And t2.v1 = 2 And t3.v2 = 3 中，三个子谓词都是通过合取谓词连接，而无法下推析取语义的谓词，例如 t1.v1 = 1 Or t2.v1 = 2 Or t3.v2 = 3。 但是在实际场景中，析取谓词也十分常见，对此 StarRocks 做了一个提取谓词（列值推导）的优化。通过一系列的交并集操作，将析取谓词中的列值范围提取出合取谓词，继而下推合取谓词。例如： – 谓词提取前 Select * From t1 Join t2 On t1.v1 = t2.v1 Where (t2.v1 = 2 AND t1.v2 = 3) OR (t2.v1 \u003e 5 AND t1.v2 = 4) – 利用(t2.v1 = 2 AND t1.v2 = 3) OR (t2.v1 \u003e 5 AND t1.v2 = 4)进行列值推导，推导出（t2.v1 \u003e= 2），（t1.v2 IN (3, 4)）两个谓词 Select * From t1 Join t2 On t1.v1 = t2.v1 Where (t2.v1 = 2 AND t1.v2 = 3) OR (t2.v1 \u003e 5 AND t1.v2 = 4) AND t2.v1 \u003e= 2 AND t1.v2 IN (3, 4); 这里需要注意的是，提取出来的谓词范围可能是原始谓词范围的超集，所以不一定能直接替换原始谓词。 4、等价推导 在谓词上，除了上述的谓词提取，还有另一个重要的优化，叫等价推导。等价推导主要利用了 Join 的连接关系，从左表/右表列的取值范围，推导出右表/左表对应列的取值范围。例如： – 原始 SQL Select * From t1 Join t2 On t1.v1 = t2.v1 Where (t2.v1 = 2 AND t1.v2 = 3) OR (t2.v1 \u003e 5 AND t1.v2 = 4) – 利用(t2.v1 = 2 AND t1.v2 = 3) OR (t2.v1 \u003e 5 AND t1.v2 = 4)进行列值推导，推导出（t2.v1 \u003e= 2），（t1.v2 IN (3, 4)）两个谓词 Select * From t1 Join t2 On t1.v1 = t2.v1 Where (t2.v1 = 2 AND t1.v2 = 3) OR (t2.v1 \u003e 5 AND t1.v2 = 4) AND t2.v1 \u003e= 2 AND t1.v2 IN (3, 4); – 利用连接谓词(t1.v1 = t2.v1)和(t2.v1 \u003e= 2)进行等价推导，推导出（t1.v1 \u003e= 2）谓词 Select * From t1 Join t2 On t1.v1 = t2.v1 Where (t2.v1 = 2 AND t1.v2 = 3","date":"2025-01-03","objectID":"/segmentfault_com_a_1190000042739883/:2:0","tags":["starrocks","join"],"title":"数据库 - StarRocks 技术内幕 | Join 查询优化","uri":"/segmentfault_com_a_1190000042739883/"},{"categories":null,"content":"3 Join Reorder ◎ — Join Reorder 用于推断多表 Join 的执行顺序，数据库需要尽可能地先执行一个高选择度的 Join，这样就能减少后续 Join 的输入数据，从而提升性能。 StarRocks 的 Join Reorder，主要是在一个连续的 Inner Join 或者 Cross Join 上工作。以下图为例，StarRocks 会将一组连续的 Inner / Cross Join 叫做一个 Multi Join Node，而 Multi Join Node 就是一个 Join Reorder 的单位，即下推存在两个 Multi Join Node，StarRocks 将分别对着两个 Multi Join Node 进行 Join Reorder 推导。 目前业界实现 JoinReorder 的算法有很多种，或者基于不同模型的，例如： Heuristic：基于启发式规则的，类似 MemSQL，通过定义维度表中心表排 Join 顺序。 Left-Deep：左深树模型，搜索空间小，但是不一定最优。 Bushy：稠密树模型，搜索空间大，包含最优解。其常见的一些 reorder 算法有： Exhaustive(Commutativity + Associativity) Greedy Simulated annealing DP（DPsize, DPsub，DPccp…） Genetic：GreenPlum …… 其中 StarRocks 实现了 Left-Deep、Exhaustive、Greedy、DPsub，接下来会着重介绍一下 StarRocks 中 Exhaustive、Greedy 的实现。 1、Exhaustive 穷举算法通常包括两个规则，通过这两个规则基本上覆盖 Join 的全排列组合。 规则一：Join 的交换律。 A Join B 转为 B Join A，转换过程中需要注意 Join 类型的变化，比如 Left Outer Join 交换后变为 Right Outer Join。 规则二：Join 的结合律。 (A Join B) Join C 转为 A Join（B Join C)。结合律上 StarRocks 又分为两种，一种是 Inner / Cross Join 的结合律，另一种是 Semi Join 的结合律。 2、Greedy StarRocks 在贪心算法上主要参考多序列贪心算法，其次做了一个小改进，就是对于贪心算法每层产生的结果，StarRocks 都会保留 10 个最优解（可能不是全局最优），以此往后迭代，最终计算出 10 个贪心最优的 Plan。 当然，由于贪心算法的局限性，这样的优化只是提高了计算出全局最优解的概率，并不能保证一定得到全局最优的 Plan。 3、Cost Model StarRocks 使用这些 Join Reorder 的算法推导出 N 个 Plan，最终会根据 Cost Model 的算法，估算出每个 Join 的 Cost，整个 Cost 的计算公式如下： Join Cost: CPU * (Row(L) + Row(R)) + Memory * Row(R) 其中 Row(L）、Row(R) 分别表示 Join 左右孩子的输出行数，公式主要是考虑 CPU 开销，以及 Hash Join 右表做 Hash 表内存的开销，下图详细展示了 StarRocks 中 Join 的输出行数的计算方式。 此外，由于不同算法探索 Join Reorder 的空间不同，StarRocks 按照算法的空间复杂度和耗时做了基本的测试，具体如下。 基于上述耗时的结论，StarRocks 对各个算法的执行做了简单的限制。当在 4 表以内的 Join Reorder 使用穷举算法；4~10 表时会分别使用左深、贪心、动态规划算法产生 1 个、10 个、1 个计划，并且在此基础上会使用 Join 交换律探索更多的 Plan；当 10 表以上时， StarRocks 就只使用贪心和左深产生的 11 个 Plan 为基础进行 Reorder；另外，在 StarRocks 没有统计信息时，基于 Cost 的贪心和动规都无法很好地工作，所以只会使用左深产生的 1 个 Plan 为基础 Reorder。 ","date":"2025-01-03","objectID":"/segmentfault_com_a_1190000042739883/:3:0","tags":["starrocks","join"],"title":"数据库 - StarRocks 技术内幕 | Join 查询优化","uri":"/segmentfault_com_a_1190000042739883/"},{"categories":null,"content":"4 分布式 Join 规划 ◎ — 在前面介绍完一个 Join 查询的一些逻辑上的优化点后，后面会结合 StarRocks 作为一个分布式数据库，在分布式 Join 执行上的优化。 1、MPP 并行执行 首先，StarRocks 的执行框架是一个 MPP 的并行执行架构，整体架构如图所示，以一个简单的 Join SQL 为例，StarRocks 执行 A Join B 的流程如下： 按照 A 表和 B 表的分布信息分别从不同的机器上读取数据； 按照 Join 的连接谓词，将 A 表和 B 表的数据 Re-Shuffle 到同一批机器上； 单机 Join 执行，输出结果。 可以看到，实际执行过程中，不只是一台机器参与计算，A 表的机器、B 表的机器、Join 的机器可能都不是同一批机器，中间会涉及到网络传输、数据交换等操作。而在这个过程中，很自然地就带来了网络操作的开销。所以对于 StarRocks，优化分布式 Join 效率中比较重要的一个措施，就是尽可能地减少网络开销，更合理地拆分/分发整个查询计划，尽可能将并行执行的优势发挥出来。 2、分布式 Join 优化 这里先介绍一些 StarRocks 可以生成的分布式执行计划，以一个最简单的 Join 为例： Select * From A Join B on A.a = B.b 可以看到，StarRocks 实际执行中会产生 5 种最基本的分布式 Plan： Shuffle Join：分别将 A、B 两表的数据按照连接关系都 Shuffle 到同一批机器上，再进行 Join 操作。 Broadcast Join：通过将 B 表的数据全量的广播到 A 表的机器上，在 A 表的机器上进行 Join 操作，相比较于 Shuffle Join，节省了 A 表的数据 Shuffle，但是 B 表的数据是全量广播，适合 B 表是个小表的场景。 Bucket Shuffle Join：在 Broadcast 的基础上进一步优化，将 B 表按照 A 表的分布方式 Shuffle 到 A 表的机器上进行 Join 操作， B 表 Shuffle 的数据量全局只有一份，比 Broadcast 少传输了很多倍数据量。当然，有约束条件限制，Join 的连接关系必须和 A 表的分布一致。 Colocate Join：通过建表时指定 A 表和 B 表是同一个 Colocate Group，意味着 A、B 表的分布完全一致，那么当 Join 的连接关系和 A、B 表分布一致时，StarRocks 可以直接在 A、B 表的机器上直接 Join，不需要进行数据 Shuffle。 Replicate Join：StarRocks 的实验性功能，当每一台 A 表的机器上都存在一份完整的 B 表数据时，直接在本地进行 Join 操作，该 Join 的约束条件比较严格，基本上意味着 B 表的副本数需要和整个集群的机器数保持一致，所以实践意义并不理想。 StarRocks 会对每个 Join 都尝试生成上述 5 种分布式 Join 计划，但是由于不同 Join 类型的语义限制，实际上一些特殊的 Join 类型只能生成特定的分布式 Join 计划。例如，Cross Join 只能生成 Broadcast Join。 3、探索分布式 Join StarRocks 的分布式 Join 计划，是通过一系列的 Distribution Property 推导产生的。以下述的 Join SQL 的 Shuffle Join Plan 为例，Join 会自顶向下地向 A、B 表分别要求 Shuffle Property。 当 Scan 节点无法满足该要求时，会通过 Enforce 操作，加入一个 Shuffle 的操作节点，用于满足 Join 的要求。最后在生成执行计划时，StarRocks 会将 Shuffle 节点“翻译”成一个 Exchange 节点，通过该节点完成网络数据的传输和交换。 其他的分布式 Join 生成方式和 Shuffle Join 类似，都是由 Join 向下要求不同的属性推导出。 Select * From A Join B on A.a = B.b 4、复杂的分布式 Join 在用户场景中，用户的 SQL 远比前面的一个 A Join B 复杂得多，可能是 3 表 Join，也可能是 4 表 Join。实际上，StarRocks 对于更复杂的 Join，同样也会生成更复杂多样的分布式 Plan，但都是基于上述最基础的几种 Join 方式推导出来的。例如： Select * From A Join B on A.a = B.b Join C on A.a = C.c 这里简单举几个 StarRocks 基于 Shuffle Join 和 Broadcast Join 生成的分布式 Plan： 当然，如果继续引入 Colocate Join 和 Bucket Shuffle Join，StarRocks 还可以推导出下面这样一些 Plan： 对于上面这些复杂的分布式 Join Plan，其推导原理和前面的原理几乎一致。Distribution Property 在节点间会一直向下传递，进而推导出各种 Join 组合的分布式 Plan。具体的推导实现也可以参考 StarRocks 优化器代码导读（https://zhuanlan.zhihu.com/p/…）。 5、Global Runtime Filter 除了分布式 Plan 的这样一些探索外，StarRocks 在规划 Plan 时，还会结合 Join 算子的执行特点，来构造全局性的 Global Runtime Filter 这样一个优化。StarRocks 的 Hash Join 执行过程如下： StarRocks 先查询得到全量的右表数据； 将右表的数据构造为一个 Hash 表； 再去拉取左表的数据； 基于 Hash 表来构建 Join 的连接关系； 输出 Join 结果。 那么，Global Runtime Filter 的工作时机就在 Step 2 和 Step 3 之间，StarRocks 在得到右表的数据后，通过这些运行时数据构造出来一个过滤谓词，在拉取左表数据前先将这样一个 Runime 的过滤谓词下发到左表的 Scan 节点，从而帮助左表的 Scan 节点提前过滤数据，最终达到减少 Join 输入的目的。 目前 Global Runtime Filter 支持的过滤方式为：Min / Max、In predicate 和 Bloom Filter。示意图如下： ","date":"2025-01-03","objectID":"/segmentfault_com_a_1190000042739883/:4:0","tags":["starrocks","join"],"title":"数据库 - StarRocks 技术内幕 | Join 查询优化","uri":"/segmentfault_com_a_1190000042739883/"},{"categories":null,"content":"5 总结 本文讲述了 StarRocks 对 Join 查询优化的实践和探索，所有的优化都是紧贴提到的优化原则。当然，用户在自行优化 SQL 时，也完全可以参考如下 5 点，以及 StarRocks 提供的功能进行优化。 不同 Join 类型的算子，性能是不同的，尽可能使用性能高的 Join 类型，避免使用性能差的 Join 类型。根据 Join 输出的数据量，大致的性能排序为：Semi-Join/Anti-Join \u003e Inner Join \u003e Outer Join \u003e Full Outer Join \u003e Cross Join。 Hash Join 的实现时，使用小表做 Hash 表，远比用一个大表做 Hash 表高效。 多表 Join 时，优先执行选择度高的 Join，能大幅减少后续 Join 的开销。 尽可能减少参与 Join 的数据量。 尽可能减少分布式 Join 产生的网络成本。 StarRocks 在支持了那么多优化后，也有了更多的心得和更多的规划，比如： 支持更多的 Join 实现方式，更智能地结合上下文选择更合适的 Join 实现算子； 结合 StarRocks 的特性，支持更多特定的 Join Reorder 算法； 尽可能地解决 Cost 估算的问题，引入更多的算法或者数据结构来确保估算结果； 支持更多调度方式，可能优化网络成本开销。 ","date":"2025-01-03","objectID":"/segmentfault_com_a_1190000042739883/:5:0","tags":["starrocks","join"],"title":"数据库 - StarRocks 技术内幕 | Join 查询优化","uri":"/segmentfault_com_a_1190000042739883/"},{"categories":null,"content":" Table of Contents 1 从 SQL 文本到执行计划 1.1 SQL Parse 1.2 SQL Analyze 1.3 SQL Logical Plan 1.4 SQL Optimize 1.5 Logical Plan Rewrite 1.6 CBO Transform 1.7 统计信息和 Cost 估计 1.8 生成 Plan fragment 2 执行计划的调度 3 执行计划的执行 3.1 MPP 多机并行执行 3.2 Pipeline 单机并行执行 3.3 向量化执行 4 总结 本文为摘录(或转载)，侵删，原文为： https://my.oschina.net/u/5658056/blog/5519656 一条查询 SQL 在关系型分布式数据库中的处理，通常需要经过 3 大步骤： 将 SQL 文本转换成一个 “最佳的” 分布式物理执行计划 将执行计划调度到计算节点 计算节点执行具体的物理执行计划 本文将详细解释在 StarRocks 中如何完成一条查询 SQL 的处理。 首先来了解 StarRocks 中的基本概念： FE： 负责查询解析，查询优化，查询调度和元数据管理 BE： 负责查询执行和数据存储 ","date":"2025-01-02","objectID":"/my_oschina_net_blog_5519656/:0:0","tags":["starrocks","tag2"],"title":"StarRocks 技术内幕：查询原理浅析","uri":"/my_oschina_net_blog_5519656/"},{"categories":null,"content":"1 从 SQL 文本到执行计划 从 SQL 文本到分布式物理执行计划, 在 StarRocks 中，需要经过以下 5 个步骤: SQL Parse： 将 SQL 文本转换成一个 AST（抽象语法树） SQL Analyze： 基于 AST 进行语法和语义分析 SQL Logical Plan： 将 AST 转换成逻辑计划 SQL Optimize：基于关系代数、统计信息、Cost 模型，对逻辑计划进行重写、转换，选择出 Cost “最低” 的物理执行计划 生成 Plan Fragment：将 Optimizer 选择的物理执行计划转换为 BE 可以直接执行的 Plan Fragment SQL Parse ","date":"2025-01-02","objectID":"/my_oschina_net_blog_5519656/:1:0","tags":["starrocks","tag2"],"title":"StarRocks 技术内幕：查询原理浅析","uri":"/my_oschina_net_blog_5519656/"},{"categories":null,"content":"1.1 SQL Parse Query Parse 的输入是 SQL 的 String 字符串，Query Parse 的输出是 Abstract Syntax Tree，每个节点都是一个 ParseNode 。 一个查询 SQL Parse 后生成一个 QueryStmt，由 SelectList, FromClause, wherePredicate, GroupByClause, havingPredicate, OrderByElement, LimitElement 等组成，基本和 SQL 文本一一对应。 StarRocks 目前使用的 Parser 是 ANTLR4，语法规则定义的文件可在 GitHub 搜索 StarRocks g4 获取。 ","date":"2025-01-02","objectID":"/my_oschina_net_blog_5519656/:1:1","tags":["starrocks","tag2"],"title":"StarRocks 技术内幕：查询原理浅析","uri":"/my_oschina_net_blog_5519656/"},{"categories":null,"content":"1.2 SQL Analyze StarRocks 获取到 AST 后，接着会进行语法分析和语义分析，完成下面的工作： 检查并绑定 Database, Table, Column 等元信息 SQL 的合法性检查：Where 中不能有 Grouping 操作， HLL 和 Bitmap 列不能 Sum 等 Table 和 Column 的别名处理 函数参数的合法性检测: Sum 的参数类型必须是数值类型，Lead 和 Lag 窗口函数第 2 和第 3 个参数必须常量等 类型检查和类型转换：BIGINT 和 DECIMAL 比较，BIGINT 类型需要 Cast 成 DECIMAL SQL Analyze 的结果是一个有层级结构的 Relation，如图 2 所示，比如一个 From 子句对应一个 TableRelation，一个子查询对应一个 SubqueryRelation。 ","date":"2025-01-02","objectID":"/my_oschina_net_blog_5519656/:1:2","tags":["starrocks","tag2"],"title":"StarRocks 技术内幕：查询原理浅析","uri":"/my_oschina_net_blog_5519656/"},{"categories":null,"content":"1.3 SQL Logical Plan 接下来，StarRocks 会将 Relations 转化成一颗 Logical Plan Tree，如图 2 所示，可以简单理解为每个集合操作都会对应一个 Logical Node。 ","date":"2025-01-02","objectID":"/my_oschina_net_blog_5519656/:1:3","tags":["starrocks","tag2"],"title":"StarRocks 技术内幕：查询原理浅析","uri":"/my_oschina_net_blog_5519656/"},{"categories":null,"content":"1.4 SQL Optimize StarRocks Optimizer 的输入是一棵逻辑计划树，输出是一棵 Cost “最低” 的分布式物理计划树。 一般 SQL 越复杂，Join 的表越多，数据量越大，Optimizer 的意义就越大，因为不同执行方式的性能差别可能有成百上千倍。StarRocks 优化器完全自研，主要基于 Cascades 和 ORCA 论文实现，并结合 StarRocks 执行器和调度器进行了深度定制，优化和创新。 它完整支持了 TPC-DS 99 条 SQL，实现了公共表达式复用，相关子查询重写，Lateral Join， CTE 复用，Join Rorder， Join 分布式执行策略选择，Global Runtime Filter 下推，低基数字典优化等重要功能和优化。 ","date":"2025-01-02","objectID":"/my_oschina_net_blog_5519656/:1:4","tags":["starrocks","tag2"],"title":"StarRocks 技术内幕：查询原理浅析","uri":"/my_oschina_net_blog_5519656/"},{"categories":null,"content":"1.5 Logical Plan Rewrite 在正式进入 CBO 之前，StarRocks 会首先进行一系列 Logical Plan 的 Rewrite，Rewrite 阶段的 Rule 我们认为都会生成更优的 Logical Plan，主要的 Rewrite Rule 有下面这些： 各种表达式的重写和化简 列裁剪 谓词下推 Limit Merge, Limit 下推 聚合 Merge 等价谓词推导（常量传播） Outer Join 转 Inner Join 常量折叠 公共表达式复用 子查询重写 Lateral Join 化简 分区分桶裁剪 Empty Node 优化 Empty Union, Intersect, Except 裁剪 Intersect Reorder Count Distinct 相关聚合函数重写 ","date":"2025-01-02","objectID":"/my_oschina_net_blog_5519656/:1:5","tags":["starrocks","tag2"],"title":"StarRocks 技术内幕：查询原理浅析","uri":"/my_oschina_net_blog_5519656/"},{"categories":null,"content":"1.6 CBO Transform 我们在 Logical Plan Rewrite 完成后，正式基于 Columbia 论文进行 CBO 优化，主要包括下面的优化： 多阶段聚合优化：普通聚合（count, sum, max, min 等）会拆分成两阶段，单个 Count Distinct 查询会拆分成三阶段或是四阶段。 Join 左右表调整：StarRocks 始终用右表构建 Hash 表，所以右表应该是小表，StarRocks 可以基于 cost 自动调整左右表顺序，也会自动把 Left Join 转 Right Join。 Join 多表 Reorder：多表 Join 如何选择出正确的 Join 顺序，是 CBO 优化器的核心。当 Join 表的数量小于等于 5 时， StarRocks 会基于 Join 交换律和结合律进行 Join Reorder，大于 5 时，StarRocks 会基于贪心算法和动态规划进行 Join Reorder。 Join 分布式执行选择：StarRocks 支持的分布式 Join 方式有 Broadcast、Shuffle、单边 Shuffle、Colocate、Replicated。 StarRocks 会基于 Cost 估算和 Property Enforce 机制选择出 “最佳” 的 Join 分布式执行方式。 Push Down Aggregate to Join 物化视图选择与重写 如图 5 所示，在 CBO 优化中，Logical Plan 会先转成 Memo 的数据结构。Memo 的中文含义是备忘录，所有的逻辑计划和物理计划都会记录在 Memo 中， Memo 就构成了整个搜索空间。 然后如图 6 所示，StarRocks 应用各种 Rule 扩展搜索空间，并生成对应的物理执行计划，再基于统计信息和 Cost 估计从 Memo 中选择一组 Cost 最低的物理执行计划。 ","date":"2025-01-02","objectID":"/my_oschina_net_blog_5519656/:1:6","tags":["starrocks","tag2"],"title":"StarRocks 技术内幕：查询原理浅析","uri":"/my_oschina_net_blog_5519656/"},{"categories":null,"content":"1.7 统计信息和 Cost 估计 CBO 优化器好坏的关键之一是 Cost 估计是否准确，而 Cost 估计是否准确的关键点之一是统计信息是否收集及时准确。 StarRocks 目前支持表级别和列级别的统计信息，支持自动收集和手动收集两种方式。无论自动还是手动，都支持全量和抽样收集两种方式。 有了统计信息之后， StarRocks 就会基于统计信息进行 Cost 估算。StarRocks 估算 Cost 时会考虑 CPU、内存、网络、IO 等资源因子，每个资源因子会有不同的权重，每个执行算子的 Cost 计算公式都不太一样。 当你使用 StarRocks 发现 Join 左右表不合理、Join 分布式执行策略不合理时，可以参考 StarRocks CBO 使用文档收集统计信息。 ","date":"2025-01-02","objectID":"/my_oschina_net_blog_5519656/:1:7","tags":["starrocks","tag2"],"title":"StarRocks 技术内幕：查询原理浅析","uri":"/my_oschina_net_blog_5519656/"},{"categories":null,"content":"1.8 生成 Plan fragment StarRocks Optimizer 的输出是一棵分布式物理执行计划树，但并不能直接被 BE 节点执行，所以需要转换成 BE 可以直接执行的 PlanFragment。转换过程基本是个一一映射的过程。 ","date":"2025-01-02","objectID":"/my_oschina_net_blog_5519656/:1:8","tags":["starrocks","tag2"],"title":"StarRocks 技术内幕：查询原理浅析","uri":"/my_oschina_net_blog_5519656/"},{"categories":null,"content":"2 执行计划的调度 在生成查询的分布式 Plan 之后，FE 调度模块会负责 PlanFragment 的执行实例生成、PlanFragment 的调度、每个 BE 执行状态的管理、查询结果的接收。 有了分布式执行计划之后，我们需要解决下面的问题： 哪个 BE 执行哪个 PlanFragment 每个 Tablet 选择哪个副本去查询 多个 PlanFragment 如何调度 StarRocks 会首先确认 Scan Operator 所在的 Fragment 在哪些 BE 节点执行，每个 Scan Operator 有需要访问的 Tablet 列表。然后对于每个 Tablet，StarRocks 会先选择版本匹配的、健康的、所在的 BE 状态正常的副本进行查询。在最终决定每个 Tablet 选择哪个副本查询时，采用的是随机方式，不过 StarRocks 会尽可能保证每个 BE 的请求均衡。假如我们有 10 个 BE、10 个 Tablet，最终调度的结果理论上就是每个 BE 负责 1 个 Tablet 的 Scan。 当确定包含 Scan 的 PlanFragment 由哪些 BE 节点执行后，其他的 PlanFragment 实例也会在 Scan 的 BE 节点上执行（也可以通过参数选择其他 BE 节点），不过具体选择哪个 BE 是随机选取的。 当 FE 确定每个 PlanFragment 由哪个 BE 执行，每个 Tablet 查询哪个副本后，FE 就会将 PlanFragment 执行相关的参数通过 Thrift 的方式发送给 BE。 目前 FE 对多个 PlanFragment 调度的方式是 All At Once 的方式，是按照自顶向下的方式遍历 PlanFragment 树，将每个 PlanFragment 的执行信息发送给对应的 BE。 ","date":"2025-01-02","objectID":"/my_oschina_net_blog_5519656/:2:0","tags":["starrocks","tag2"],"title":"StarRocks 技术内幕：查询原理浅析","uri":"/my_oschina_net_blog_5519656/"},{"categories":null,"content":"3 执行计划的执行 StarRocks 是通过 MPP 多机并行机制来充分利用多机的资源，通过 Pipeline 并行机制来充分利用单机上多核的资源，通过向量化执行来充分利用单核的资源，进而达到极致的查询性能。 ","date":"2025-01-02","objectID":"/my_oschina_net_blog_5519656/:3:0","tags":["starrocks","tag2"],"title":"StarRocks 技术内幕：查询原理浅析","uri":"/my_oschina_net_blog_5519656/"},{"categories":null,"content":"3.1 MPP 多机并行执行 MPP 是大规模并行计算的简称，核心做法是将查询 Plan 拆分成很多可在单个节点上执行的计算实例，然后多个节点并行执行。每个节点不共享 CPU、内存、磁盘资源。MPP 数据库的查询性能可以随着集群的水平扩展而不断提升。 如图 9 所示，StarRocks 会将一个查询在逻辑上切分为多个 Query Fragment（查询片段），每个 Query Fragment 可以有一个或者多个 Fragment 执行实例，每个 Fragment 执行实例会被调度到集群某个 BE 上执行。一个 Fragment 可以包括一个或者多个 Operator（执行算子），图中的 Fragment 包括了 Scan、Filter、Aggregate。每个 Fragment 可以有不同的并行度。 如图 10 所示，多个 Fragment 之间会以 Pipeline 的方式在内存中并行执行，而不是像批处理引擎那样 Stage By Stage 执行。Shuffle （数据重分布）操作是 MPP 数据库查询性能可以随着集群的水平扩展而不断提升的关键，也是实现高基数聚合和大表 Join 的关键。 ","date":"2025-01-02","objectID":"/my_oschina_net_blog_5519656/:3:1","tags":["starrocks","tag2"],"title":"StarRocks 技术内幕：查询原理浅析","uri":"/my_oschina_net_blog_5519656/"},{"categories":null,"content":"3.2 Pipeline 单机并行执行 StarRocks 在 Fragment 和 Operator 之间引入了 Pipeline 的概念，一个 Pipeline 内的数据没有到达终点前不需要 Materialize，遇到需要 Materialize 的算子（Agg, Sort, Join)，则需要拆分出一个新的 Pipeline，所以 1 个 Fragment 会对应多个 Pipeline。 如图 11 所示，一个 Pipeline 由多个 Operator 组成。第一个 Operator 是 Source Operator，负责产生数据，一般是 Scan 节点和 Exchange 节点。最后一个 Operator 是 Sink Operator，负责物化或者消费数据。中间的 Operator 负责对数据进行 Transform。 那么 Pipeline 如何并行呢？答案是 Pipeline 和 Fragment 一样，可以生成多个实例，每个实例称为一个 Pipeline Driver。当一个 Pipeline 需要 N 个并行度去执行时，一个 Pipeline 就会生成 N 个 Pipeline Driver，如图 12 所示，并行度是 3，一个 Pipeline 就产生了 3 个 Pipeline Driver。 如图 13 所示，一个 Pipeline 执行中，当前一个 Operator 可以产生数据，且后一个 Operator 可以消费数据时， Pipeline 的执行线程就会从前一个 Operator Pull 出数据，然后 Push 到后一个 Operator。每个 Pipeline 的执行状态是很清晰的，简单可以理解为有 Ready、Running、Blocked 等 3 种状态。当前面的 Operator 无法产生数据，或者后面的 Operator 不需要消费数据时，Pipeline 就会处于 Blocked 的状态。 如图 14 所示， Pipeline 并行执行框架的核心是实现一个用户态的协程调度，不再依赖操作系统的内核态线程调度，减少线程创建、线程销毁、线程上下文切换的成本。 在 Pipeline 并行执行框架中，StarRocks 会启动机器 CPU 核数个执行线程，每个执行线程会从一个多级反馈就绪队列中获取 Ready 状态的 Pipeline 去执行，同时会有一个全局 Poller 线程不断检查 Blocked 队列中的 Pipeline 是否解除了阻塞，可以变为 Ready 状态。如果可以变为了 Ready 状态，就可以把 Pipeline 从阻塞队列移到多级反馈就绪队列中。 ","date":"2025-01-02","objectID":"/my_oschina_net_blog_5519656/:3:2","tags":["starrocks","tag2"],"title":"StarRocks 技术内幕：查询原理浅析","uri":"/my_oschina_net_blog_5519656/"},{"categories":null,"content":"3.3 向量化执行 随着数据库执行的瓶颈逐渐从 IO 转移到 CPU，为了充分发挥 CPU 的执行性能，StarRocks 基于向量化技术重新实现了整个执行引擎，向量化执行引擎是为了充分利用单核 CPU 的能力。 向量化在实现上主要是算子和表达式的向量化，图 15 是算子向量化的示例，图 16 是表达式向量化的示例，算子和表达式向量化执行的核心是批量按列执行。相比于单行执行，批量执行可以有更少的虚函数调用，更少的分支判断；相比于按行执行，按列执行对 CPU Cache 更友好，更易于 SIMD 优化。 向量化执行不仅仅是数据库所有算子的向量化和表达式的向量化，而是一项巨大和复杂的性能优化工程，包括数据在磁盘、内存、网络中的按列组织，数据结构和算法的重新设计，内存管理的重新设计，SIMD 指令优化，CPU Cache 优化，C++ Level 优化等。经过努力，StarRocks 向量化执行引擎相比之前的按行执行，取得了整体 5 到 10 倍的性能提升。 每个算子和表达式具体如何实现、如何进行向量化，之后的文章会详细解释，本文不再赘述。 ","date":"2025-01-02","objectID":"/my_oschina_net_blog_5519656/:3:3","tags":["starrocks","tag2"],"title":"StarRocks 技术内幕：查询原理浅析","uri":"/my_oschina_net_blog_5519656/"},{"categories":null,"content":"4 总结 本文主要介绍了 StarRocks 如何完成一条查询 SQL 的处理： 通过高效强大的 CBO 优化器生成最佳的分布式物理执行计划； 通过查询调度器选择合适的数据副本，并将分布式物理执行计划调度到合适的计算节点进行计算； 通过 MPP 分布式执行框架充分利用多机的资源，做到查询性能可以随着机器数量近似线性扩展； 通过 Pipeline 并行执行框架充分利用多核资源，做到查询性能可以随着机器核数近似线性扩展； 通过向量化执行引擎充分利用 CPU 单核资源，将单核执行性能做到极致。 作者 康凯森 | StarRocks 核心研发、StarRocks 查询团队负责人 ","date":"2025-01-02","objectID":"/my_oschina_net_blog_5519656/:4:0","tags":["starrocks","tag2"],"title":"StarRocks 技术内幕：查询原理浅析","uri":"/my_oschina_net_blog_5519656/"},{"categories":null,"content":" Table of Contents 1 MPP 分布式执行框架 2 全面向量化执行引擎 3 存储计算分离 4 CBO 优化器 5 可实时更新的列式存储引擎 6 智能的物化视图 7 数据湖分析 本文为摘录(或转载)，侵删，原文为： https://docs.starrocks.io/zh/docs/introduction/Features/ ","date":"2025-01-02","objectID":"/docs_starrocks_io_features/:0:0","tags":["starrocks","database"],"title":"产品特性 | StarRocks","uri":"/docs_starrocks_io_features/"},{"categories":null,"content":"1 MPP 分布式执行框架 StarRocks 采用 MPP (Massively Parallel Processing) 分布式执行框架。在 MPP 执行框架中，一条查询请求会被拆分成多个物理计算单元，在多机并行执行。每个执行节点拥有独享的资源（CPU、内存）。 MPP 执行框架能够使得单个查询请求可以充分利用所有执行节点的资源，所以单个查询的性能可以随着集群的水平扩展而不断提升。 如上图所示，StarRocks 会将一个查询在逻辑上切分为多个逻辑执行单元（Query Fragment）。按照每个逻辑执行单元需要处理的计算量，每个逻辑执行单元会由一个或者多个物理执行单元来具体实现。物理执行单元是最小的调度单位。一个物理执行单元会被调度到集群某个 BE 上执行。一个逻辑执行单元可以包括一个或者多个执行算子，如图中的 Fragment 包括了 Scan，Project，Aggregate。每个物理执行单元只处理部分数据。由于每个逻辑执行单元处理的复杂度不一样，所以每个逻辑执行单元的并行度是不一样的，即，不同逻辑执行单元可以由不同数目的物理执行单元来具体执行，以提高资源使用率，提升查询速度。 与很多数据分析系统采用的 Scatter-Gather 分布式执行框架不同，MPP 分布式执行框架可以利用更多的资源处理查询请求。在 Scatter-Gather 框架中，只有 Gather 节点能处理最后一级的汇总计算。而在 MPP 框架中，数据会被 Shuffle 到多个节点，并且由多个节点来完成最后的汇总计算。在复杂计算时（比如高基数 Group By，大表 Join 等操作），StarRocks 的 MPP 框架相对于 Scatter-Gather 模式的产品有明显的性能优势。 ","date":"2025-01-02","objectID":"/docs_starrocks_io_features/:1:0","tags":["starrocks","database"],"title":"产品特性 | StarRocks","uri":"/docs_starrocks_io_features/"},{"categories":null,"content":"2 全面向量化执行引擎 StarRocks 通过实现全面向量化引擎，充分发挥了 CPU 的处理能力。全面向量化引擎按照列式的方式组织和处理数据。StarRocks 的数据存储、内存中数据的组织方式，以及 SQL 算子的计算方式，都是列式实现的。按列的数据组织也会更加充分的利用 CPU 的 Cache，按列计算会有更少的虚函数调用以及更少的分支判断从而获得更加充分的 CPU 指令流水。 另一方面，StarRocks 的全面向量化引擎通过向量化算法充分的利用 CPU 提供的 SIMD（Single Instruction Multiple Data）指令。这样 StarRocks 可以用更少的指令数目，完成更多的数据操作。经过标准测试集的验证，StarRocks 的全面向量化引擎可以将执行算子的性能，整体提升 3~10 倍。 除了使用向量化技术实现所有算子外，StarRocks 还在执行引擎中实现了其他的优化。比如 StarRocks 实现了 Operation on Encoded Data 的技术。对于字符串字段的操作，StarRocks 在无需解码情况下就可以直接基于编码字段完成算子执行，比如实现关联算子、聚合算子、表达式算子计算等。这可以极大的降低 SQL 在执行过程中的计算复杂度。通过这个优化手段，相关查询速度可以提升 2 倍以上。 ","date":"2025-01-02","objectID":"/docs_starrocks_io_features/:2:0","tags":["starrocks","database"],"title":"产品特性 | StarRocks","uri":"/docs_starrocks_io_features/"},{"categories":null,"content":"3 存储计算分离 StarRocks 3.0 版本支持了全新的存算分离模式，实现了计算与存储的完全解耦、计算节点弹性扩缩容、高性能热数据缓存。存算分离模式下 StarRocks 具备灵活弹性、高性能、高可靠、低成本等特点。 存算分离模式下，存储与计算解耦，各自独立服务，独立扩缩容，解决了在存算一体模式下的计算与存储等比例扩缩容所带来的资源浪费问题。计算节点可以实现秒级的动态扩缩容，提升计算资源的利用率。 存储层利用对象存储近乎无限的容量，以及数据高可用的特性实现数据的海量存储和持久化。支持包括 AWS S3，Azure Blob Storage，Google Cloud Storage，阿里云 OSS，腾讯云 COS，火山引擎 TOS，华为云 OBS，以及各类兼容 S3 协议的对象存储，同时也支持 HDFS 存储。 部署模式上用户可以选择基于公有云、私有云、本地机房部署。StarRocks 存算分离也支持基于 Kubernetes 部署，并提供了相应的 Operator 方便用户自动化部署。 StarRocks 存算分离模式与存算一体模式功能保持一致，写入及热数据查询性能也与存算一体基本持平。用户在存储分离模式下也可以实现数据更新、数据湖分析、物化视图加速等多种场景。 ","date":"2025-01-02","objectID":"/docs_starrocks_io_features/:3:0","tags":["starrocks","database"],"title":"产品特性 | StarRocks","uri":"/docs_starrocks_io_features/"},{"categories":null,"content":"4 CBO 优化器 在多表关联查询场景下，仅靠优秀的执行引擎没有办法获得最极致的执行性能。因为这类场景下，不同执行计划的复杂度可能会相差几个数量级。查询中关联表的数目越大，可能的执行计划就越多，在众多的可能中选择一个最优的计划，这是一个 NP-Hard 的问题。只有优秀的查询优化器，才能选择出相对最优的查询计划，从而实现极致的多表分析性能。 StarRocks 从零设计并实现了一款全新的，基于代价的优化器 CBO（Cost Based Optimizer）。该优化器是 Cascades Like 的，在设计时，针对 StarRocks 的全面向量化执行引擎进行了深度定制，并进行了多项优化和创新。该优化器内部实现了公共表达式复用，相关子查询重写，Lateral Join，Join Reorder， Join 分布式执行策略选择，低基数字典优化等重要功能和优化。目前，该优化器已可以完整支持 TPC-DS 99 条 SQL 语句。 由于全新 CBO 的支持，StarRocks 能比同类产品更好地支持多表关联查询，特别是复杂的多表关联查询，让全面向量化引擎能够发挥极致的性能。 ","date":"2025-01-02","objectID":"/docs_starrocks_io_features/:4:0","tags":["starrocks","database"],"title":"产品特性 | StarRocks","uri":"/docs_starrocks_io_features/"},{"categories":null,"content":"5 可实时更新的列式存储引擎 StarRocks 实现了列式存储引擎，数据以按列的方式进行存储。通过这样的方式，相同类型的数据连续存放。一方面，数据可以使用更加高效的编码方式，获得更高的压缩比，降低存储成本。另一方面，也降低了系统读取数据的 I/O 总量，提升了查询性能。此外，在大部分 OLAP 场景中，查询只会涉及部分列。相对于行存，列存只需要读取部分列的数据，能够极大地降低磁盘 I/O 吞吐。 StarRocks 能够支持秒级的导入延迟，提供准实时的服务能力。StarRocks 的存储引擎在数据导入时能够保证每一次操作的 ACID。一个批次的导入数据生效是原子性的，要么全部导入成功，要么全部失败。并发进行的各个事务相互之间互不影响，对外提供 Snapshot Isolation 的事务隔离级别。 StarRocks 存储引擎不仅能够提供高效的 Partial Update 操作，也能高效处理 Upsert 类操作。使用 Delete-and-insert 的实现方式，通过主键索引快速过滤数据，避免读取时的 Sort 和 Merge 操作，同时还可以充分利用其他二级索引，在大量更新的场景下，仍然可以保证查询的极速性能。 ","date":"2025-01-02","objectID":"/docs_starrocks_io_features/:5:0","tags":["starrocks","database"],"title":"产品特性 | StarRocks","uri":"/docs_starrocks_io_features/"},{"categories":null,"content":"6 智能的物化视图 StarRocks 支持用户使用物化视图（materialized view）进行查询加速和数仓分层。不同于一些同类产品的物化视图需要手动和原表做数据同步，StarRocks 的物化视图可以自动根据原始表更新数据。只要原始表数据发生变更，物化视图的更新也同步完成，不需要额外的维护操作就可以保证物化视图能够维持与原表一致。不仅如此，物化视图的选择也是自动进行的。StarRocks 在进行查询规划时，如果有合适的物化视图能够加速查询，StarRocks 自动进行查询改写(query rewrite)，将查询自动定位到最适合的物化视图上进行查询加速。 StarRocks 的物化视图可以按需灵活创建和删除。用户可以在使用过程中视实际使用情况来判断是否需要创建或删除物化视图。StarRocks 会在后台自动完成物化视图的相关调整。 StarRocks 的物化视图可以替代传统的 ETL 建模流程，用户无需在上游应用处做数据转换，可以在使用物化视图时完成数据转换，简化了数据处理流程。 例如图中，最底层 ODS 的湖上数据可以通过 External Catalog MV 来构建 DWD 层的 normalized table；并且可以通过多表关联的物化视图来构建 DWS 层的宽表 (denormalized table)；最上层可以进一步构建实时的物化视图来支撑高并发的查询，提供更加优异的查询性能。 ","date":"2025-01-02","objectID":"/docs_starrocks_io_features/:6:0","tags":["starrocks","database"],"title":"产品特性 | StarRocks","uri":"/docs_starrocks_io_features/"},{"categories":null,"content":"7 数据湖分析 StarRocks 不仅能高效的分析本地存储的数据，也可以作为计算引擎直接分析数据湖中的数据。用户可以通过 StarRocks 提供的 External Catalog，轻松查询存储在 Apache Hive、Apache Iceberg、Apache Hudi、Delta Lake 等数据湖上的数据，无需进行数据迁移。支持的存储系统包括 HDFS、S3、OSS，支持的文件格式包括 Parquet、ORC、CSV。 如上图所示，在数据湖分析场景中，StarRocks 主要负责数据的计算分析，而数据湖则主要负责数据的存储、组织和维护。使用数据湖的优势在于可以使用开放的存储格式和灵活多变的 schema 定义方式，可以让 BI/AI/Adhoc/报表等业务有统一的 single source of truth。而 StarRocks 作为数据湖的计算引擎，可以充分发挥向量化引擎和 CBO 的优势，大大提升了数据湖分析的性能。 ","date":"2025-01-02","objectID":"/docs_starrocks_io_features/:7:0","tags":["starrocks","database"],"title":"产品特性 | StarRocks","uri":"/docs_starrocks_io_features/"},{"categories":null,"content":" 218-218, 标注, 2024 年 12 月 14 日星期六 上午 9:23:03 荒时暴月，向亲友乞哀告怜，借得几斗几升，敷衍三日五日，债务丛集，如牛负重。 424-425, 标注, 2024 年 12 月 14 日星期六 下午 2:26:12 革命不是请客吃饭，不是做文章，不是绘画绣花，不能那样雅致，那样从容不迫，文质彬彬，那样温良恭俭让。 424-426, 标注, 2024 年 12 月 14 日星期六 下午 2:26:20 革命不是请客吃饭，不是做文章，不是绘画绣花，不能那样雅致，那样从容不迫，文质彬彬，那样温良恭俭让。革命是暴动，是一个阶级推翻一个阶级的暴烈的行动。 ","date":"2024-12-31","objectID":"/%E7%AC%94%E8%AE%B0%E6%AF%9B%E6%B3%BD%E4%B8%9C%E9%80%89%E9%9B%86-%E6%AF%9B%E6%B3%BD%E4%B8%9C/:0:0","tags":["maozedongxua","note","ireader"],"title":"[笔记]毛泽东选集-毛泽东","uri":"/%E7%AC%94%E8%AE%B0%E6%AF%9B%E6%B3%BD%E4%B8%9C%E9%80%89%E9%9B%86-%E6%AF%9B%E6%B3%BD%E4%B8%9C/"},{"categories":null,"content":" 92-93, 标注, 2024 年 12 月 13 日星期五 下午 4:28:51 我反对愚蠢，不是反对天生就笨的人，这种人只是极少数，而且这种人还盼着变聪明。在这个世界上，大多数愚蠢里含有假装和弄假成真的成分。 105-106, 标注, 2024 年 12 月 13 日星期五 下午 4:30:25 我对自己的要求很低：我活在世上，无非想要明白些道理，遇见些有趣的事。倘能如我所愿，我的一生就算成功。 122-124, 标注, 2024 年 12 月 13 日星期五 下午 6:19:52 我相信这不是我一个人的经历：傍晚时分，你坐在屋檐下，看着天慢慢地黑下去，心里寂寞而凄凉，感到自己的生命被剥夺了。当时我是个年轻人，但我害怕这样生活下去，衰老下去。在我看来，这是比死亡更可怕的事。 157-158, 标注, 2024 年 12 月 13 日星期五 下午 6:26:29 我最赞成罗素先生的一句话：“须知参差多态，乃是幸福的本源。”大多数的参差多态都是敏于思索的人创造出来的。 161-162, 标注, 2024 年 12 月 13 日星期五 下午 6:27:31 在生活的其他方面，某种程度的单调、机械是必须忍受的，但是思想绝不能包括在内。 173-175, 标注, 2024 年 12 月 13 日星期五 下午 6:29:05 知识虽然可以带来幸福，但假如把它压缩成药丸子灌下去，就丧失了乐趣。当然，如果有人乐意这样来对待自己的孩子，那不是我能管的事，我只是对孩子表示同情而已。 185-186, 标注, 2024 年 12 月 13 日星期五 下午 6:30:36 更何况那些高尚和低下完全是以他们自己的立场来度量的，假如我全盘接受，无异于请那些善良的思想母鸡到我脑子里下蛋，而我总不肯相信，自己的脖子上方，原来是长了一座鸡窝。 205-207, 标注, 2024 年 12 月 13 日星期五 下午 6:33:29 假设善恶是可以判断的，那么明辨是非的前提就是发展智力，增广知识。然而，你劝一位自以为已经明辨是非的人发展智力，增广见识，他总会觉得你让他舍近求远，不仅不肯，还会心生怨恨。我不愿为这样的小事去得罪人。 210-211, 标注, 2024 年 12 月 13 日星期五 下午 6:34:37 信念，我认为我们国家在“废黜百家，独尊儒术”之后，就丧失了很多机会。 211-212, 标注, 2024 年 12 月 13 日星期五 下午 6:34:55 我们这个民族总是有很多的理由封锁知识、钳制思想、灌输善良，因此有很多才智之士在其一生中丧失了学习、交流、建树的机会，没有得到思想的乐趣就死掉了。 219-220, 标注, 2024 年 12 月 13 日星期五 下午 6:36:43 据此我认为，我们国家自汉代以后，一直在进行思想上的大屠杀；而我能够这样想，只说明我是幸存者之一。除了对此表示悲伤之外，我想不到别的了。 222-224, 标注, 2024 年 12 月 13 日星期五 下午 6:37:11 古人曾说：天不生仲尼，万古长如夜。但我有相反的想法。假设历史上曾有一位大智者，一下发现了一切新奇、一切有趣，发现了终极真理，根绝了一切发现的可能性，我就情愿到该智者以前的年代去生活。这是因为，假如这种终极真理已经被发现，人类所能做的事就只剩下了依据这种真理来做价值判断。 222-225, 标注, 2024 年 12 月 13 日星期五 下午 6:37:16 古人曾说：天不生仲尼，万古长如夜。但我有相反的想法。假设历史上曾有一位大智者，一下发现了一切新奇、一切有趣，发现了终极真理，根绝了一切发现的可能性，我就情愿到该智者以前的年代去生活。这是因为，假如这种终极真理已经被发现，人类所能做的事就只剩下了依据这种真理来做价值判断。从汉代以后到近代，中国人就是这么生活的。我对这样的生活一点都不喜欢。 253-255, 标注, 2024 年 12 月 13 日星期五 下午 6:41:12 君特·格拉斯在《铁皮鼓》里，写了一个不肯长大的人。小奥斯卡发现周围的世界太过荒诞，就暗下决心要永远做小孩子。在冥冥之中，有一种力量成全了他的决心，所以他就成了个侏儒。这个 285-290, 标注, 2024 年 12 月 13 日星期五 下午 6:45:24 从这些话里我知道了土平炉可以炼钢，这种东西和做饭的灶相仿，装了一台小鼓风机，嗡嗡地响着，好像一窝飞行的屎壳郎。炼出的东西是一团团火红的粘在一起的锅片子，看起来是牛屎的样子。有一位手持钢钎的叔叔说，这就是钢。那一年我只有六岁，以后有好长一段时间，一听到钢铁这个词，我就会想到牛屎。从那些话里我还知道了一亩地可以产三十万斤粮，然后我们就饿得要死。总而言之，从小我对讲出来的话就不大相信，越是声色俱厉，嗓门高亢，我越是不信，这种怀疑态度起源于我饥饿的肚肠。和任何话语相比，饥饿都是更大的真理。 394-397, 标注, 2024 年 12 月 14 日星期六 上午 9:36:37 还有一个终生爱好，就是写小说。但是写好了不拿去发表，同样也保持了沉默。至于沉默的理由，很是简单，那就是信不过话语圈。从我短短的人生经历来看，它是一座声名狼藉的疯人院。当时我怀疑的不仅是说过亩产三十万斤粮、炸过精神原子弹的那个话语圈，而是一切话语圈子。假如在今天能证明我当时犯了一个以偏概全的错误，我会感到无限的幸福。 394-397, 标注, 2024 年 12 月 14 日星期六 上午 9:36:47 我还有一个终生爱好，就是写小说。但是写好了不拿去发表，同样也保持了沉默。至于沉默的理由，很是简单，那就是信不过话语圈。从我短短的人生经历来看，它是一座声名狼藉的疯人院。当时我怀疑的不仅是说过亩产三十万斤粮、炸过精神原子弹的那个话语圈，而是一切话语圈子。假如在今天能证明我当时犯了一个以偏概全的错误，我会感到无限的幸福。 400-401, 标注, 2024 年 12 月 14 日星期六 上午 9:37:47 但是照我的标准，那不叫说话，而是上着一种话语的捐税。我们听说，在过去的年代里，连一些伟大的人物都“讲过一些违心的话”，这说明征税面非常的宽。 420-423, 标注, 2024 年 12 月 14 日星期六 上午 9:40:16 猛省到自己也属于古往今来最大的一个弱势群体，就是沉默的大多数。这些人保持沉默的原因多种多样，有些人没能力，或者没有机会说话；还有人有些隐情不便说话；还有一些人，因为种种原因，对于话语的世界有某种厌恶之情。我就属于这最后一种。 481-482, 标注, 2024 年 12 月 14 日星期六 上午 11:31:25 我上大学时，老师教诲我们说，搞现代史要牢记两个原则，一是治史的原则，二是党性的原则。 481-483, 标注, 2024 年 12 月 14 日星期六 上午 11:31:31 我上大学时，老师教诲我们说，搞现代史要牢记两个原则，一是治史的原则，二是党性的原则。这就是说，让历史事实按党性的原则来发生。 ","date":"2024-12-31","objectID":"/%E7%AC%94%E8%AE%B0%E7%8E%8B%E5%B0%8F%E6%B3%A2%E6%B2%89%E9%BB%98%E7%9A%84%E5%A4%A7%E5%A4%9A%E6%95%B0%E6%9D%8E%E9%93%B6%E6%B2%B3%E7%8B%AC%E5%AE%B6%E6%8E%88%E6%9D%83%E5%B9%B6%E4%BA%B2%E8%87%AA%E6%A0%A1%E8%AE%A2%E5%85%A8%E7%A8%BF%E7%8E%8B%E5%B0%8F%E6%B3%A2%E9%80%9D%E4%B8%96%E4%BA%8C%E5%8D%81%E5%91%A8%E5%B9%B4%E7%BA%AA%E5%BF%B5%E7%89%88%E7%89%B9%E5%88%AB%E6%94%B6%E5%85%A5%E4%BB%8E%E6%9C%AA%E9%9D%A2%E5%B8%82%E7%9A%84%E6%89%8B%E7%A8%BF-%E7%8E%8B%E5%B0%8F%E6%B3%A2/:0:0","tags":null,"title":"[笔记]王小波：沉默的大多数","uri":"/%E7%AC%94%E8%AE%B0%E7%8E%8B%E5%B0%8F%E6%B3%A2%E6%B2%89%E9%BB%98%E7%9A%84%E5%A4%A7%E5%A4%9A%E6%95%B0%E6%9D%8E%E9%93%B6%E6%B2%B3%E7%8B%AC%E5%AE%B6%E6%8E%88%E6%9D%83%E5%B9%B6%E4%BA%B2%E8%87%AA%E6%A0%A1%E8%AE%A2%E5%85%A8%E7%A8%BF%E7%8E%8B%E5%B0%8F%E6%B3%A2%E9%80%9D%E4%B8%96%E4%BA%8C%E5%8D%81%E5%91%A8%E5%B9%B4%E7%BA%AA%E5%BF%B5%E7%89%88%E7%89%B9%E5%88%AB%E6%94%B6%E5%85%A5%E4%BB%8E%E6%9C%AA%E9%9D%A2%E5%B8%82%E7%9A%84%E6%89%8B%E7%A8%BF-%E7%8E%8B%E5%B0%8F%E6%B3%A2/"},{"categories":null,"content":" 10-12, 标注, 2024 年 12 月 1 日星期日 下午 10:27:24 整个美国都沉睡在这荒野之路的尽头，我们的过去没有完全消逝，依然活在我们心中。我们的祖辈外表野蛮，内心文明。我们生活在他们建设的文明中，内心却仍有荒蛮。他们曾梦想的世界，我们正在经历；他们曾经历的世界，我们在梦想。 369-369, 标注, 2024 年 12 月 2 日星期一 下午 6:38:38 科曼切人再来光顾的话，理所当然地还会利用这个老渡口， 949-951, 标注, 2024 年 12 月 14 日星期六 下午 10:42:04 东方的天空红得像锻炉里的火，照亮了沿河的一派平川。露水浸湿了查帕拉尔树丛的千万簇针叶，阳光从地平线平射过来，树丛立刻闪闪发光，像是用无数颗宝石镶嵌而成的。阳光洒在后院一片灌木丛的露珠上，小树丛马上被无数道彩虹包围了。 2224-2225, 标注, 2024 年 12 月 16 日星期一 上午 8:02:11 他被河边的一块石头绊了一下，便吐了起来。这阵子正趴在河床上吐个不停。纽特听他那声音，就像一头牛从泥窝里往外拔腿的声音一样。 3762-3763, 标注, 2024 年 12 月 18 日星期三 上午 7:54:03 而是突然的空虚——是一种肚子上被踢了一脚的感觉。一个敌人的死和一个朋友的死带来的影响几乎一模一样，虽说很奇怪，但千真万确。 4146-4146, 标注, 2024 年 12 月 18 日星期三 下午 6:32:27 查帕拉尔树丛、 4238-4239, 标注, 2024 年 12 月 18 日星期三 下午 6:45:15 有时纽特提那么多问题，不能不令狄兹发笑——他简直像个蓄水池，不过流出的不是水，而是问题。 4241-4242, 标注, 2024 年 12 月 18 日星期三 下午 6:45:41 他知道几个精神崩溃的人，他反复思考，觉得他们可能不会通过对天空和月亮的观察得到快乐，以克服每个人必将经受的低落情绪的打击。 4926-4927, 标注, 2024 年 12 月 19 日星期四 下午 10:18:56 听人们谈话通常使他感到更加孤独——比他只身一人坐在两公里外的树下更孤独。 5368-5370, 标注, 2024 年 12 月 20 日星期五 下午 6:30:37 在阿比林，她认识一个叫作詹妮的姑娘，试图终止妊娠，结果因流血过多而死去了。在一个刺骨的寒夜，她死在爱尔迈拉屋外的台阶上。血顺着台阶往下流，冻成了红色的冰。死去的姑娘詹妮牢牢地冻在台阶上，人们不得不浇些热水才能将尸体移开。 5895-5896, 标注, 2024 年 12 月 21 日星期六 上午 11:35:53 随着闪电越来越近，滚雷也跟了过来。隆隆的雷声如同巨石从头顶滚过。 5893-5897, 标注, 2024 年 12 月 21 日星期六 上午 11:36:03 西边天空突然出现了一道闪光，吓了他一跳。闪光消失得那么快，一开始他竟没有认出那是闪电。很快那亮光又闪了一次，接着便间断地闪了起来。闪电离得还很远。开始纽特还挺喜欢它，因为它不仅能使他看见自己仍与数百头牛同在，还能使他避开荆棘丛。然而，随着闪电越来越近，滚雷也跟了过来。隆隆的雷声如同巨石从头顶滚过。耗子很害怕，纽特也开始胆怯。不久，闪电已不像蛇的芯子一样在地平线上吞吐，而是像利剑一样从天上直直插入地下，同时发出骇人的霹雳声。 6414-6415, 标注, 2024 年 12 月 21 日星期六 下午 6:02:36 考尔想，他说得对。人死了，他们能做的最好的事便是继续前进。牛仔们一一上马，随牛群而去。很多人都迅速地回头，朝树下那座泥土堆起的新坟看上最后一眼。 6837-6839, 标注, 2024 年 12 月 21 日星期六 下午 8:04:50 他骑着马离开时，心情十分复杂，时而为能离开这里而高兴，时而又变得沉重不堪。有一两次，他突然感到惆怅，不禁流下了眼泪。他的忧伤究竟是因不得不与路易莎离别而引起的，还是由前途渺茫、心中无底所致，谁也说不清楚。 6962-6964, 标注, 2024 年 12 月 21 日星期六 下午 8:41:27 牛群仍不习惯赶路，所以十分不好管理。荆棘丛总坏事儿，天气也与人过不去。大雨连降三天，蚊蚋叮得人们 6991-6994, 标注, 2024 年 12 月 21 日星期六 下午 8:43:21 “我希望你别再谈那个孩子的死。”考尔说，“你要是不说，他们也许就会忘掉。” “荒谬的理论。”奥古斯塔斯说，“只有常说，才能让人不怕它，不论什么头痛的事都一样，连死也是如此。” 7263-7265, 标注, 2024 年 12 月 22 日星期日 上午 10:36:15 考尔有的时候忧郁、沮丧，每逢这样的时刻，他会被从未说出口的疑虑折磨得一筹莫展。但他从来不在真正的危机时刻愁眉苦脸，危机出现时，考尔反倒精神振奋。他只会为小的事故发愁，比如这辆篷车摔散了。 9272-9273, 标注, 2024 年 12 月 22 日星期日 下午 9:19:57 可能还会见面。我必须去雷德河，看看水是不是清凉， 10853-10854, 标注, 2024 年 12 月 23 日星期一 下午 6:30:01 “不要想着以眼还眼，以牙还牙。”他说，“干这种事，你可别想打平手。 10977-10979, 标注, 2024 年 12 月 23 日星期一 下午 6:37:14 每当他放眼散布在草原上的牛群，便感到这一切实在没有意义，甚至还有些荒唐。有几天，他甚至想，还不如把牛群驱散，把工钱分发给牛仔们，就此散伙算了。 11059-11059, 标注, 2024 年 12 月 23 日星期一 下午 6:41:29 俄克拉何马领地 11668-11669, 标注, 2024 年 12 月 24 日星期二 上午 7:49:28 “我喜欢他们又脏又臭。”莎莉说，“我不是好人，这也不是个好地方，生活也不是好生活。要是能找到用两条腿走路的猪，我也要。” 11693-11693, 标注, 2024 年 12 月 24 日星期二 上午 7:51:28 莎莉有一双绿眼睛，她一吸白面儿它们便凸出来。她瞧他时的样子就像一只要跳起来抓蜥蜴的恶猫。 11804-11805, 标注, 2024 年 12 月 24 日星期二 上午 7:58:48 他正做的事情，乃至他一生所做的一切，现在看起来都毫无意义。他骑马走在这空荡荡的土地上，并不是因为他有任何希望，只是因为他总得做点儿什么。 12081-12081, 标注, 2024 年 12 月 24 日星期二 下午 1:21:45 他给了咱们一些野牛肉，”考尔说，“给点儿牛肉报答 12106-12108, 标注, 2024 年 12 月 24 日星期二 下午 1:23:39 在阿肯色的一局牌中响起一枪，导致了这一切的发生——他尚未看到事情的结局。那一枪并没有终止在一个牙医的死亡上，到目前为止，肖恩·奥布赖恩、比尔·斯佩特尔，还有与七月约翰逊同行的三个人都已死去，而蒙大拿则连个影儿都没有见到。 14298-14301, 标注, 2024 年 12 月 26 日星期四 上午 7:52:13 她最喜欢干的活儿是种花，花会在曙光中盛开。她种了些花，还从东部订购了球茎与花籽。那曙光抚养了它们，风却把它们从她身边夺去。她讨厌尘土，更恨狂风。尘土是可以对付的，她可以每天早上清扫，风却无穷无尽，而且凛冽刺骨。它一次又一次地从北方刮来，将花一瓣一瓣地从她身边掠走，最后只留下可怜巴巴的花茎。 14298-14303, 标注, 2024 年 12 月 26 日星期四 上午 7:53:06 她最喜欢干的活儿是种花，花会在曙光中盛开。她种了些花，还从东部订购了球茎与花籽。那曙光抚养了它们，风却把它们从她身边夺去。她讨厌尘土，更恨狂风。尘土是可以对付的，她可以每天早上清扫，风却无穷无尽，而且凛冽刺骨。它一次又一次地从北方刮来，将花一瓣一瓣地从她身边掠走，最后只留下可怜巴巴的花茎。然而克拉拉还是坚持要种。她把花种在防风条件最好的地方，风虽然还是能吹到它们，但花朵毕竟能开上几天才被风带走。这是一场她绝不肯放弃的搏斗。 14399-14401, 标注, 2024 年 12 月 26 日星期四 上午 7:58:59 当黄昏到来，夕阳西下时，她发现自己的脾气很坏——一会儿因为女儿们吵闹而说些难听话，一会儿又自己抱着孩子到阳台去，几乎要哭出来。 15557-15558, 标注, 2024 年 12 月 27 日星期五 上午 8:02:07 也许会永远不知道她的死活，他不能让自己的妻子像一根草一样，被风从生活中吹卷而去。 15636-15638, 标注, 2024 年 12 月 27 日星期五 上午 8:05:35 看到狄兹恍惚的眼神，考尔很纳闷儿。在比这艰苦得多的岁月里，他总是高高兴兴的，而现在考尔经常见他坐在马背上，遥望南方，遥望他们走过的茫茫路途。有时候吃着早饭，考尔见他呆呆地注视着火堆，如同一只老兽临死前那样，好像在凝望另一个世界。 15867-15870, 标注, 2024 年 12 月 27 日星期五 下午 6:29:57 对往事的回忆如此甜蜜，他竟然不敢去看克拉拉变成了什么样子，生怕会破坏他那美好的回忆。她或许已经成为一个暴君，她在少女时代就具有那种潜在的能量。她也可能仅仅成了一个被劳苦折磨得疲惫不堪的拓荒者，美貌已不复存在，精力业已耗尽。见到她以后，他也许什么也感觉不到，如果真是这样，他就将失去他珍惜的东西。 17008-17010, 标注, 2024 年 12 月 28 日星期六 下午 1","date":"2024-12-13","objectID":"/%E7%AC%94%E8%AE%B0%E5%AD%A4%E7%8B%AC%E9%B8%BD%E5%85%A8%E4%B8%89%E5%86%8C-%E6%8B%89%E9%87%8C%E9%BA%A6%E5%85%8B%E9%BB%98%E7%89%B9%E9%87%8C/:0:0","tags":null,"title":"[笔记]孤独鸽：全三册-拉里•麦克默特里","uri":"/%E7%AC%94%E8%AE%B0%E5%AD%A4%E7%8B%AC%E9%B8%BD%E5%85%A8%E4%B8%89%E5%86%8C-%E6%8B%89%E9%87%8C%E9%BA%A6%E5%85%8B%E9%BB%98%E7%89%B9%E9%87%8C/"},{"categories":null,"content":" 47-48, 标注, 2024 年 12 月 3 日星期二 上午 7:44:17 人的气质就像是古董的包浆，说不清道不明，但一眼看过去就能感觉得到。 1537-1538, 标注, 2024 年 12 月 4 日星期三 下午 10:41:00 世外人，法非常法，然后知非法法也；天下事，了犹未了，何妨以不了了之。” 3493-3493, 标注, 2024 年 12 月 5 日星期四 下午 9:15:03 福尔摩斯在里面说过一句话：当你排除掉一切不可能以后，剩下的即使再离奇，也是事实。” 4932-4934, 标注, 2024 年 12 月 6 日星期五 上午 7:55:05 车窗外的黑暗中，赫然浮现出一张惨白的人脸，脸上的双眼特别怪异，一边特别大，圆如牛眼，黑的少，白的多；一边特别小，跟王八对瞪不一定能赢。这一大一小两只眼睛，好像随时在瞄准开枪似的。 9635-9638, 标注, 2024 年 12 月 8 日星期日 上午 10:02:01 一个家族的传承，就像是一件上好的古董。它历经许多代人的呵护与打磨，在漫长时光中悄无声息地积淀。慢慢地，这传承也如同古玩一样，会裹着一层幽邃圆熟的包浆，沉静温润，散发着古老的气息。古董有形，传承无质，它看不见，摸不到，却渗到家族每一个后代的骨血中去，成为家族成员之间的精神纽带，甚至成为他们的性格乃至命运的一部分。 9918-9919, 标注, 2024 年 12 月 8 日星期日 下午 12:08:16 鉴宝要究其本源；鉴人要究其本心。想要拿捏住人的心思，得往根儿上倒，弄清楚他到底想要什么、最怕什么、最在乎的又是什么，那便可以如臂使指，随意驱驰—— 11476-11476, 标注, 2024 年 12 月 9 日星期一 上午 7:58:50 作事奸邪任尔焚香无益，居心正直见吾不拜何妨”， 13443-13443, 标注, 2024 年 12 月 10 日星期二 上午 7:50:00 他们在恐惧，非常恐惧，只能不停指责别人，来换取一些安全感。 13665-13668, 标注, 2024 年 12 月 10 日星期二 上午 8:02:09 许一城发现，他检查的手法和对工具的运用，见都没见过。看来不愧是欧阳家的独传之秘，五脉对海底针的运用，根本未能发挥其全部功能。 中国许多技艺都是如此，匠人单传，秘不开放，结果一旦碰到不肖子孙，就此失传。后世所见，不过只鳞片爪而已。 14657-14658, 标注, 2024 年 12 月 10 日星期二 下午 6:41:07 这个计策说来简单，用四个字来形容就是——欲擒故纵。人的心理总是如此，你越给他推销什么，他越不相信；你越藏着掖着不给他知道，他越是笃信不疑。 14657-14660, 标注, 2024 年 12 月 10 日星期二 下午 6:41:14 这个计策说来简单，用四个字来形容就是——欲擒故纵。人的心理总是如此，你越给他推销什么，他越不相信；你越藏着掖着不给他知道，他越是笃信不疑。在古董行里，这是个非常实用的技巧，想出手什么物件，切不可主动劝说，非得一脸心疼舍不得放，买主才会毫不犹豫地买下来。俗话说，上赶着不如冷脸子，就是这个道理。 15313-15314, 标注, 2024 年 12 月 11 日星期三 上午 7:46:53 这骗局当真了得，不靠高明的造假技术，只靠洞悉人心。 15409-15411, 标注, 2024 年 12 月 11 日星期三 上午 7:54:52 这些故事里，或是贪婪，或是痴缠，或是无情，或是无奈，明里讲的是四件器物，其实已跟掌眼鉴定关系不大，甚至和真假也都无关，说的全是人心。正所谓鉴古易，鉴人难。比起那些器物，这人心才是最耐琢磨的。 15988-15989, 标注, 2024 年 12 月 11 日星期三 下午 12:44:14 “这些事不是一次两次，而是无数次，周而复始。不是毁于政治，就是毁于贪婪；不是毁于无知，就是毁于自大。 16141-16142, 标注, 2024 年 12 月 11 日星期三 下午 6:26:55 门口一副对联：读书随处净土，闭门即入深山。居然读出几分大隐隐于市的味道。 16322-16324, 标注, 2024 年 12 月 11 日星期三 下午 6:38:09 其中钻孔这一道工序，最考验功力。瓷器薄而脆，要在上面钻出一个孔来，还得保证不碎不裂，需要极精细的手法。焗匠用的开孔工具，是一根铁笔，在笔头镶嵌一颗金刚石，在要开孔的部位轻轻研磨，磨出一个孔来。 中国有句俗话，叫“不是金刚钻，别揽瓷器活”，就是打这里来。 17413-17414, 标注, 2024 年 12 月 12 日星期四 上午 8:07:50 刚才那一番胡搅蛮缠，不过是刻意表演，把事往绝了做，好攫取更大利益。 人的心理就是这样。你说开窗户，人家未必愿意，你闹着说把屋子给拆了，人家三劝两劝说开个窗户就得了。 19593-19595, 标注, 2024 年 12 月 13 日星期五 上午 8:01:57 此时天色也开始慢慢阴郁起来，大块大块的云彩把阳光挡住，只留下一道金边，很快连金边也看不到了。湛蓝色的海水颜色逐渐变成灰蓝，浑浊不堪，远方一层层的浪墙推锋而进。在遥远的天边，令人不安的黑色如洇入宣纸的墨滴，正朝这边扩散而来。 19801-19803, 标注, 2024 年 12 月 13 日星期五 上午 8:24:07 入水的感觉非常奇妙，仿佛有一圈厚厚的幕布在四周霎时垂落，把世界与自己隔绝开来。无论光线还是声音，都没有了，只能看到眼前的海水，只能听见自己有节奏的喘息。四肢移动缓慢，但没有拘束，如同飞翔在一片黏滞的天空中。到了这个时候，心中也会变得一片澄清，似乎那些纷扰烦恼也被一并隔离开。 ","date":"2024-12-13","objectID":"/%E7%AC%94%E8%AE%B0%E5%8F%A4%E8%91%A3%E5%B1%80%E4%B8%AD%E5%B1%80-%E5%A4%A7%E5%85%A8%E9%9B%86-%E9%A9%AC%E4%BC%AF%E5%BA%B8/:0:0","tags":["gudongjuzhon","note","ireader"],"title":"[笔记]古董局中局 大全集-马伯庸","uri":"/%E7%AC%94%E8%AE%B0%E5%8F%A4%E8%91%A3%E5%B1%80%E4%B8%AD%E5%B1%80-%E5%A4%A7%E5%85%A8%E9%9B%86-%E9%A9%AC%E4%BC%AF%E5%BA%B8/"},{"categories":null,"content":" 91-91, 标注, 2024 年 11 月 16 日星期六 上午 9:17:49 心在朝廷，原无论先主后主；名高天下，何必辨襄阳南阳。” 92-93, 标注, 2024 年 11 月 16 日星期六 上午 9:17:55 心在人民，原无论大事小事；利归天下，何必争多得少得。” 115-116, 标注, 2024 年 11 月 16 日星期六 上午 9:24:45 任何一切社会或经济模式的演进，都是多种因素——包括必然和偶然——综合作用的产物。 172-174, 标注, 2024 年 11 月 16 日星期六 上午 9:33:41 一位温州小官吏曾慨然地对我说，“很多时候，改革是从违规开始的。”谁都听得出他这句话中所挥散着的清醒、无奈和决然，你可以反驳他，打击他，蔑视他，但你却无法让他停止，因为，他几乎是在代替历史一字一句地讲出上述这句话。 193-196, 标注, 2024 年 11 月 16 日星期六 上午 9:46:10 阅读。在 1978 年到 2008 年的中国商业圈出没着这样的一个族群：他们出身草莽，不无野蛮，性情漂移，坚忍而勇于博取。他们的浅薄使得他们处理任何商业问题都能够用最简捷的办法直指核心，他们的冷酷使得他们能够拨去一切道德的含情脉脉而回到利益关系的基本面，他们的不畏天命使得他们能够百无禁忌地去冲破一切的规则与准绳，他们的贪婪使得他们敢于采用一切的手法和编造最美丽的谎言。 227-229, 标注, 2024 年 11 月 16 日星期六 上午 9:50:35 任何被视为奇迹的事物，往往都很难延续，因为它来自一个超越了常规的历程，身处其中的人们，因此而获得巨大利益的人们，每每不可能摆脱那些让他们终生难忘的际遇，他们相信那就是命运，他们总希望每次都能红运高照，每次都能侥幸胜出，最后，所有的光荣往往枯萎在自己的光环中。 229-232, 标注, 2024 年 11 月 16 日星期六 上午 9:50:59 任何貌似理所当然的神话，往往都是不可信的，越是无懈可击，往往越值得怀疑。我们从来相信，事物的发展是粗劣的，是有锋芒和缺陷的。当一个商业故事以无比圆滑和生动的姿态出现在你面前的时候，你首先必须怀疑，而所有的怀疑，最终都会被证明是正确的，或者至少是值得的。 284-286, 标注, 2024 年 11 月 16 日星期六 上午 9:58:43 凡是有超越于实践并自奉为绝对的‘禁区’的地方，就没有科学，就没有真正的马列主义、毛泽东思想，而只有蒙昧主义、唯心主义、文化专制主义。” 1201-1202, 标注, 2024 年 11 月 16 日星期六 下午 12:08:40 黑夜给了我黑色的眼睛/我却用它寻找光明。” 2074-2075, 标注, 2024 年 11 月 17 日星期日 下午 10:45:47 沧海横流，历史从来浩荡向前。“八大王”身份渺小，命运如蚁，举重若轻的“符合中央精神”六字似乎已算是还了他们一个公道。 2203-2207, 标注, 2024 年 11 月 18 日星期一 上午 7:48:11 广东学者何博传在《山坳上的中国》58 一书中曾经描写过一个“倒卖”的实例：一些上海人跑到深圳买了一把折叠伞，发现竟是从上海运去香港，又转回深圳的。上海人很高兴，说是比在上海买少花了几块钱，深圳人也高兴，说赚了几块钱；香港百货公司也高兴，同样说赚了几块钱，真不知谁见鬼了！ 2841-2843, 标注, 2024 年 11 月 18 日星期一 下午 6:24:30 戴尔和思科的出现，基本上代表了日后新技术公司的两种成长路径：独一无二的商业渠道模式，或高度垄断的核心技术优势。由此我们可以看到，中国公司与美国公司之间的距离，并不在于创始资本的大小，而在于各自对产业成长的视野和理解的差距。 2845-2849, 标注, 2024 年 11 月 18 日星期一 下午 6:26:02 新中国成立后共有三次下海经商浪潮，这是第一次，其后两次发生在 1987 年和 1993 年。经过将近六年的酝酿和鼓动，“全民经商”热终于降临，当时在北方便流传着这样的顺口溜——“十亿人民九亿倒，还有一亿在寻找”。根据《中国青年报》做的一份调查，当年最受欢迎的职业排序前三名依次是：出租车司机、个体户、厨师，而最后的三个选项分别是科学家、医生、教师。“修大脑的不如剃头的”、“搞导弹的不如卖茶叶蛋的”，是当时社会的流传语。 2985-2985, 标注, 2024 年 11 月 18 日星期一 下午 6:36:13 泥石俱下的 3733-3734, 标注, 2024 年 11 月 18 日星期一 下午 11:02:22 很多年来我天天思考的都是失败，对成功视而不见，也没有什么荣誉感、自豪感，而是危机感，也许是这样才存活了下来。” 3942-3944, 标注, 2024 年 11 月 19 日星期二 上午 8:01:40 跟其他改革典型不同的是，面对鲜花、荣誉，这个修车匠出身的中年人从来没有头脑发热过。他拒绝把工厂的总部搬进杭州城，也没对汽车配件以外的行业发生太大的兴趣。在工作之余，他把很多时间花在读书和学习上，在大学教授的辅导下，他提出了“企业利益共同体”的新概念， 4319-4320, 标注, 2024 年 11 月 19 日星期二 下午 6:50:40 我有一所房子， 面朝大海，春暖花开 ——海子：《面朝大海，春暖花开》，1989 4319-4320, 标注, 2024 年 11 月 19 日星期二 下午 6:50:45 我有一所房子， 面朝大海，春暖花开 ——海子：《面朝大海，春暖花开》，1989 年 4867-4869, 标注, 2024 年 11 月 19 日星期二 下午 9:47:31 正如运动员赛跑，最容易在拐弯处比出高下，中国众多公司的此起彼伏，也每每是在周期性的宏观调控中变幻着各自的命运。开始于 1989 年初的治理整顿，让无数企业备感压力，也让那些有远见和能力的企业获得了快速成长、超越同类的机会。 在经历 5019-5020, 标注, 2024 年 11 月 20 日星期三 上午 7:49:32 成都的无缝钢管厂就兼并了六家亏损的工厂，厂长对记者说，“兼并是企业行为，但绝不是企业的自发行为。” 5022-5023, 标注, 2024 年 11 月 20 日星期三 上午 7:49:40 在这过程中，像钢管厂那么“强势”的企业似乎不多，绝大多数的兼并都是政府意志的体现，“归大堆”带来的后遗症又将引发新一轮的企业兴衰。 5039-5041, 标注, 2024 年 11 月 20 日星期三 上午 7:51:39 上海牌轿车的消失，是一个象征性事件。在跨国公司和新兴民间企业的双重冲击下，曾经红极一时的老牌国营企业品牌都相继凋零，一个时代终于在恋恋不舍中褪去了它最后的一道余晖。 5080-5082, 标注, 2024 年 11 月 20 日星期三 上午 7:55:58 仰融是一个思想上天马行空的人，你跟他坐在一起，总是被他牵着走，很难把握自己的节奏。跟其他企业家相比，他显得更桀骜一些。如果说仰融自己身上只有 20 万了，而且明天就要全部还掉，但是他今天能请你吃 10 万元的饭，并且面色如常。” 5083-5084, 标注, 2024 年 11 月 20 日星期三 上午 7:56:20 莎士比亚的一段名言：“世事的起伏本来就是波浪式的，人们要是能够趁着高潮一往直前，一定可以功成名就，要是不能把握时机，就要终身蹭蹬，一事无成”， 5101-5103, 标注, 2024 年 11 月 20 日星期三 上午 7:58:30 仰融在 1991 年前后的这一系列资本操作，已经表现得非常娴熟——以少量资金控股资本质量良好却暂时陷入困境的国有企业、在免税天堂设立“壳公司”、以“中国股”概念在海外上市套现。跟 5211-5212, 标注, 2024 年 11 月 20 日星期三 上午 8:08:31 中国的其他地方也将慢慢改变。它不得不变，因为每个人都想过上高水平的生活。美国（或者随便什么人）可以加速，也可以减缓这个过程，但是，阻止不了。” 5214-5215, 标注, 2024 年 11 月 20 日星期三 上午 8:08:44 自从达成“罐头换飞机”的传奇贸易后，牟其中再没有认认真真地做过一笔生意。 5253-5258, 标注, 2024 年 11 月 20 日星期三 上午 8:21:27 从本质上来讲，牟是一个企图在政治资源与经济领域的灰色地带攫取利益的寻租者，他确实也与当时一些很有政府背景的国有金融机构，如中国农业信托投资公司等有密切的往来，他所有的项目其实都是为了从各地的金融机构融到资金，以空手套狼的方式在企业转型中获取利益，在其后的十多年里，无数“商业天才”用这样的方式一夜暴富。牟其中的错误在于，在这种“见不得阳光”的寻租过程中，他又渴望表达自己的思想和理论，同时还显示出一份十分醒目的异端姿态。他连续不断的、让人瞠目结舌的、恶作剧式的承诺最终让他在政界、经济界、传媒界和社会公众层面多重失信。 5406-5409, 标注, 2024 年 11 月 20 日星期三 下午 6:45:47 那个时候很好玩，很快活，像是大姑娘初婚，很幸福，幸福又糊涂。”冯仑后来说，“几乎是游侠般的生活，江湖日子。江湖和游侠在中国实际上就是脱离体制边缘的一种自由状态。都是生人，谁也不欠谁，不管你过去是怎么样的，海南不相信眼泪，不承认过去，大家都这样，然后该求人的就求人，没钱了就去蒙，这吃一口，那吃一口，人都没有身份感了。” 5717-5718, 标注, 2024 年 11 月 20 日星期三 下","date":"2024-12-13","objectID":"/%E7%AC%94%E8%AE%B0%E6%BF%80%E8%8D%A1%E4%B8%89%E5%8D%81%E5%B9%B4%E4%B8%AD%E5%9B%BD%E4%BC%81%E4%B8%9A1978-2008-%E5%90%B4%E6%99%93%E6%B3%A2/:0:0","tags":null,"title":"[笔记]激荡三十年：中国企业1978-2008-吴晓波","uri":"/%E7%AC%94%E8%AE%B0%E6%BF%80%E8%8D%A1%E4%B8%89%E5%8D%81%E5%B9%B4%E4%B8%AD%E5%9B%BD%E4%BC%81%E4%B8%9A1978-2008-%E5%90%B4%E6%99%93%E6%B3%A2/"},{"categories":null,"content":" 32-32, 标注, 2024 年 11 月 30 日星期六 下午 2:02:42 紧张状态，仿佛患了多疑症。他常常冥思苦想，离群索居， 452-453, 标注, 2024 年 12 月 1 日星期日 下午 10:25:43 马尔梅拉多夫被揪着头发拖着走，大声喊叫。这在他们是一种快乐的时候，他们笑得异常开心。 ","date":"2024-12-13","objectID":"/%E7%AC%94%E8%AE%B0%E7%BD%AA%E4%B8%8E%E7%BD%9A-%E4%BF%84-%E9%99%80%E6%80%9D%E5%A6%A5%E8%80%B6%E5%A4%AB%E6%96%AF%E5%9F%BA%E6%9B%BE%E6%80%9D%E8%89%BA/:0:0","tags":["zuiyufa","note","ireader"],"title":"[笔记]罪与罚-[俄] 陀思妥耶夫斯基;曾思艺","uri":"/%E7%AC%94%E8%AE%B0%E7%BD%AA%E4%B8%8E%E7%BD%9A-%E4%BF%84-%E9%99%80%E6%80%9D%E5%A6%A5%E8%80%B6%E5%A4%AB%E6%96%AF%E5%9F%BA%E6%9B%BE%E6%80%9D%E8%89%BA/"},{"categories":null,"content":"本文为摘录(或转载)，侵删，原文为： https://postgr.es/p/6J3 ","date":"2024-12-11","objectID":"/postgr_es_p_6j3/:0:0","tags":["pg","time","travel"],"title":"Implementing Time Travel In PostgreSQL","uri":"/postgr_es_p_6j3/"},{"categories":null,"content":" 558-559, 标注, 2024 年 11 月 11 日星期一 上午 8:07:12 他太理想主义了，所以感到痛苦。向生活索取太多。永远向前，焦虑不安，怨天尤人。 762-764, 标注, 2024 年 11 月 11 日星期一 下午 6:25:52 或许将来某一天，他们会怀疑……然后便是泡沫破灭，市场随之崩溃，那些真品也不能幸免。按照格雷欣定律，赝品会让真品的价值大打折扣。这就是没有人愿意调查真假的背后动机。不调查的结果就是人人皆大欢喜。 1656-1659, 标注, 2024 年 11 月 12 日星期二 下午 12:30:40 呢？所谓“道”，就是先有光明，后 有黑暗 。这两种原始力量相互作用，不断产生新生命。只有这样，生命才会生生不息，宇宙才不会毁灭。当黑暗似乎就要窒息一切、主宰一切的时候，光明的种子在最黑暗的地方萌芽。这就是“道”。当种子落下的时候，它是落进地里，落在泥土里的。在下面，眼睛看不到的地方，种子得以萌芽生长。 1969-1972, 标注, 2024 年 11 月 12 日星期二 下午 6:35:37 元首的魔力对他产生了深远的影响，可怕的深远影响。元首难以置信的人生记录已经画上了最后的句号。他从奥地利一个偏僻的乡村走出来，在维也纳的穷困潦倒中崛起，饱尝战场的艰苦磨难，经历了政治上的钩心斗角，终于建立了纳粹党，成为政府总理，最后差一点征服了整个世界。他的这种魔力究竟是什么呢？ 1969-1973, 标注, 2024 年 11 月 12 日星期二 下午 6:35:45 元首的魔力对他产生了深远的影响，可怕的深远影响。元首难以置信的人生记录已经画上了最后的句号。他从奥地利一个偏僻的乡村走出来，在维也纳的穷困潦倒中崛起，饱尝战场的艰苦磨难，经历了政治上的钩心斗角，终于建立了纳粹党，成为政府总理，最后差一点征服了整个世界。他的这种魔力究竟是什么呢？ 卡尔心里明白，这种魔力就是虚张声势。阿道夫·希特勒对他们说的全是谎话。他一直用谎言领导他们。 2289-2291, 标注, 2024 年 11 月 12 日星期二 下午 7:44:02 天时变了，人一定要作好与时俱变的准备。要不然就会落伍。要顺应 。 这是生存的法则，他想。要留意周围的环境，了解环境的需要。并且——满足环境的需要。在适当的 时候做适当的 事情。 2750-2751, 标注, 2024 年 11 月 13 日星期三 上午 8:00:40 怎么评价这种责任心呢？这是日本的民族特色。一个民族，你让它复制一艘英国的驱逐舰，它连驱逐舰上锅炉的修修补补也复制下来。 2785-2787, 标注, 2024 年 11 月 13 日星期三 上午 8:02:30 你和我——我们对那些愚昧的大众一无所知。他们可以从模具里生产出来的千篇一律的挂饰获得乐趣，而我们却不可以。我们认为，值得我们拥有的东西必须是独一无二的，至少是稀有的，只配少数人拥有。当然，还要是真品，不能是仿制品或者复制品。” 2785-2788, 标注, 2024 年 11 月 13 日星期三 上午 8:02:49 你和我——我们对那些愚昧的大众一无所知。他们可以从模具里生产出来的千篇一律的挂饰获得乐趣，而我们却不可以。我们认为，值得我们拥有的东西必须是独一无二的，至少是稀有的，只配少数人拥有。当然，还要是真品，不能是仿制品或者复制品。”保罗的目光越过齐尔丹，凝神地看着远处，“不是那种成千上万大批量生产的东西。” 3203-3204, 标注, 2024 年 11 月 13 日星期三 下午 6:57:02 泪水在她的眼眶里打转，她不由自主地将大拇指放在手心握紧，就像她小时候受委屈时那样。她感到自己的下巴在颤抖。 3802-3804, 标注, 2024 年 11 月 13 日星期三 下午 9:26:37 即便我们地球上的所有生命都被毁灭了，在其他某个地方，一定还存在我们未知的生命形式。人类世界不可能是唯一的世界。在这个世界之外，一定还有我们看不到的世界，存在于某个区域，某个维度，只是我们看不到而已。 4039-4039, 标注, 2024 年 11 月 13 日星期三 下午 9:49:49 她想，真相和死亡一样可怕，但是比死亡更难发现。 4082-4085, 标注, 2024 年 11 月 13 日星期三 下午 9:55:04 我读了迪克的书，有这么一种印象：他的文字黑暗、混乱、恐惧、战栗、怪诞、荒谬、疯狂、压抑，常常是梦呓般的对话，主角也像是活在别人的梦里，世界随时会发生翻转，还弥漫着神秘和错位，叙事常常不连贯，有宗教或邪教般的本体论情结，是东西方文化碎片的混杂，贯穿了哲学或准哲学的沉思或抽搐。 4086-4087, 标注, 2024 年 11 月 13 日星期三 下午 9:55:33 他的书中，有着各种文明、文化以及政治、商业的交替穿插，甚为丰富、复杂而混乱，像一个装满垃圾和珍宝的大型地下室，然而其中又显现出一种至简至纯感，直指人心。 7335-7336, 标注, 2024 年 11 月 15 日星期五 下午 7:24:04 她看上去真像一只孤独无助的小动物，被整个世界逼进了死角 8066-8067, 标注, 2024 年 11 月 23 日星期六 下午 10:40:33 他的梦境、夜里的渴望，以及那些乱七八糟的思绪，全都浓缩起来，伪装成了理智。 9780-9781, 标注, 2024 年 11 月 25 日星期一 上午 8:15:49 自己嘴里吐出的蠢话把自己给勒死了。蠢话结成一张蜘蛛网，自己就在老蜘蛛的口器正下方挣扎，紧紧缠在蛛网的正中间。 9840-9841, 标注, 2024 年 11 月 25 日星期一 上午 8:24:59 他心想，什么恶有恶报，狗屁，他早八百年前就学到这一点：从来就没有什么恶有恶报，更不要提什么善有善报。到头来没有一件事是公平的。 9905-9906, 标注, 2024 年 11 月 25 日星期一 上午 8:33:25 我们每个人都会出卖别人，他心想，当我是个名人时，我只不过是被暂时豁免了而已。现在，我只是一个普通人，我必须面对每个普通人都要面对的事实。 11401-11402, 标注, 2024 年 11 月 25 日星期一 下午 10:58:25 恐惧会比憎恨和嫉妒带给你更多错误决定。如果你恐惧，你就不能全然地接纳生命。恐惧会成为你永远退缩的理由。” 11474-11475, 标注, 2024 年 11 月 25 日星期一 下午 11:06:12 “说什么的人都有。有人说你不值一文，也有人认为你是无价之宝。有人说你太差，也有人会觉得你非常棒。你总能取悦一批人——”他敲敲盐瓶——“同时也会得不到另一批人的认同。” 11898-11899, 标注, 2024 年 11 月 26 日星期二 上午 7:52:08 在过去两天里，他充分认识到警察是如何统治这个社会的。第二次内战的遗产，他心想，从猪到警察，一步之遥。 12102-12103, 标注, 2024 年 11 月 26 日星期二 下午 1:29:49 我们身居不同的位置，有的微不足道，有的只手遮天。 12371-12374, 标注, 2024 年 11 月 26 日星期二 下午 6:37:16 随着时代发展，迪克的作品正日益受到重视，然而这于作家本人却没有丝毫意义。迪克的许多小说在他身后才告出版，而他生前却屡遭退稿，可谓贫困交加。最穷的时候他甚至付不起图书馆的逾期罚款，还不得不到宠物店花三十五美分买一磅给狗吃的马肉杂碎充当肉食。 12392-12397, 标注, 2024 年 11 月 26 日星期二 下午 6:39:48 1982 年 3 月 2 日，迪克因反复中风伴随心衰而辞世。据说五天前他已脑死亡，只不过这一天才正式拔管。迪克年迈的父亲把儿子带回女儿的墓地。半个多世纪前，来到这个世界没几天的珍被安葬后，墓碑上刻下了她与兄长的名字，以及他们的出生日期和珍的死亡日期。现在，迪克的死亡日期也终于被刻上，他安静地躺在孪生妹妹的身边。 自此，菲利普·K.迪克告别了他的写作生涯，告别了他的科幻故事，告别了他的毒品和幻觉，告别了那些离开他的妻子和孩子，同时也告别了这个令他流泪不止、亦真亦幻的冷漠世界。 13372-13374, 标注, 2024 年 11 月 27 日星期三 上午 8:08:19 他感到有一股邪恶的力量在恣意玩弄他们，让他们像无脑鼠一般飞跑乱窜，叽喳乱语。我们一直被当作消遣。逃生的企图权作可笑的欢娱。当我们就要逃脱，迎头就会砸来一顿饱拳，把我们揍成肉饼之后，扔到缓慢移动的传送带上，就像朗西特那样。 13519-13519, 标注, 2024 年 11 月 27 日星期三 下午 12:28:10 刹那间，厌恶化成丝丝惶恐，不可名状。 15698-15704, 标注, 2024 年 11 月 29 日星期五 上午 8:10:11 寂静，从木家具和墙壁中突然闪现出来，对他一记猛击，像凝聚了一座大风车的所有力量一样沉重。它从地板上升起，从破烂死灰的连壁地毯下升起。它从残破的厨房用具中，从这些日子里从未正常运转过的机器中一跃而出。它从客厅里当摆设的立式台灯里缓缓渗出，从布满死苍蝇的天花板上悄悄落下。它设法从他视野中的所有物件里冒了出来，就好像它—寂静—已经打定主意，要取代所有看得见摸得着的东西。它不但攻击他的耳朵，还进犯他的眼睛。他站在关掉的电视旁边，感觉到寂静不仅是看得见的，而且是活生生的。活生生的！他已经习惯了它直来直去的风格，呼啸而来，毫不掩饰，迫不及待。这个世界的寂静再也抑制不住贪婪，尤其是在它已经几乎赢得整个世界的时候。 17565-17","date":"2024-11-11","objectID":"/%E7%AC%94%E8%AE%B0%E8%8F%B2%E5%88%A9%E6%99%AE%E8%BF%AA%E5%85%8B%E4%BD%9C%E5%93%81%E9%9B%86-%E8%8F%B2%E5%88%A9%E6%99%AE%E8%BF%AA%E5%85%8B/:0:0","tags":["feilipu-dike","note","ireader"],"title":"[笔记]菲利普·迪克作品集-菲利普•迪克","uri":"/%E7%AC%94%E8%AE%B0%E8%8F%B2%E5%88%A9%E6%99%AE%E8%BF%AA%E5%85%8B%E4%BD%9C%E5%93%81%E9%9B%86-%E8%8F%B2%E5%88%A9%E6%99%AE%E8%BF%AA%E5%85%8B/"},{"categories":null,"content":" 12-13, 标注, 2024 年 11 月 2 日星期六 上午 10:38:24 那时她的儿子还太年轻，还来不及为母亲想，他被命运击昏了头，一心以为自己是世上最不幸的一个，不知道儿子的不幸在母亲那儿总是要加倍的。 19-20, 标注, 2024 年 11 月 2 日星期六 上午 10:39:01 寂寞不一定要到深山大泽里去寻求，只要内心清净，随便在市廛里、陋巷里，都可以感觉到一种空灵悠逸的境界，所谓“心远地自偏”是也。 21-23, 标注, 2024 年 11 月 2 日星期六 上午 10:39:21 过去的日子如轻烟，被微风吹散了，如薄雾，被初阳蒸融了；我留着些什么痕迹呢？我何曾留着像游丝样的痕迹呢？我赤裸裸来到这世界，转眼间也将赤裸裸地回去罢？但不能平的，为什么偏要白白走这一遭啊？ 80-82, 标注, 2024 年 11 月 2 日星期六 上午 10:45:45 外公外婆是什么样子，我就不知道了，因为他们早已去世。至于更远的族系与家史，就更不晓得了；穷人只能顾眼前的衣食，没有功夫谈论什么过去的光荣；“家谱”这字眼，我在幼年就根本没有听说过。 135-137, 标注, 2024 年 11 月 2 日星期六 上午 10:51:58 年。除夕，我请了两小时的假。由拥挤不堪的街市回到清炉冷灶的家中。母亲笑了。及至听说我还须回校，她愣住了。半天，她才叹出一口气来。到我该走的时候，她递给我一些花生，“去吧，小子！”街上是那么热闹，我却什么也没看 145-146, 标注, 2024 年 11 月 2 日星期六 上午 10:53:01 人，即使活到八九十岁，有母亲便可以多少还有点孩子气。失了慈母便像花插在瓶子里，虽然还有色有香，却失去了根。有母亲的人，心里是安定的。 373-374, 标注, 2024 年 11 月 2 日星期六 下午 2:30:38 他那唱的音调就像是在厅的顶梁上绕着，又像是暖天细雨似的在你身上匀匀的洒，反正听着心里就觉得舒服， 488-489, 标注, 2024 年 11 月 3 日星期日 下午 8:33:08 他知道一点便去作一点，能作一点便作一点。他的学问也许不高，但是他所知道的都能见诸实行。 510-513, 标注, 2024 年 11 月 3 日星期日 下午 8:49:22 人是为明天活着的，因为记忆中有朝阳晓露；假若过去的早晨都似地狱那么黑暗丑恶，盼明天干吗呢？是的，记忆中也有痛苦危险，可是希望会把过去的恐怖裹上一层糖衣，像看着一出悲剧似的，苦中有些甜美。无论怎说吧，过去的一切都不可移动；实在，所以可靠；明天的渺茫全仗昨天的实在撑持着，新梦是旧事的拆洗缝补。 536-539, 标注, 2024 年 11 月 3 日星期日 下午 8:52:22 春在燕的翅上，把春光颤得更明了一些，同样，我的青春在她的眼里，永远使我的血温暖，像土中的一颗籽粒，永远想发出一颗小小的绿芽。一粒小豆那么小的一点爱情，眼珠一移，嘴唇一动，日月都没有了作用，到无论什么时候，我们总是一对刚开的春花。 1142-1149, 标注, 2024 年 11 月 7 日星期四 下午 1:35:27 在我的后园，可以看见墙外有两株树，一株是枣树，还有一株也是枣树。 这上面的夜的天空，奇怪而高，我生平没有见过这样的奇怪而高的天空。他仿佛要离开人间而去，使人们仰面不再看见。然而现在却非常之蓝，闪闪地着几十个星星的眼，冷眼。他的口角上现出微笑，似乎自以为大有深意，而将繁霜洒在我的园里的野花草上。 我不知道那些花草真叫什么名字，人们叫他们什么名字。我记得有一种开过极细小的粉红花，现在还开着，但是更极细小了，她在冷的夜气中，瑟缩地做梦，梦见春的到来，梦见秋的到来，梦见瘦的诗人将眼泪擦在她最末的花瓣上，告诉她秋虽然来，冬虽然来，而此后接着还是春，蝴蝶乱飞，蜜蜂都唱起春词来了。她于是一笑，虽然颜色冻得红惨惨地，仍然瑟缩着。 1142-1142, 标注, 2024 年 11 月 7 日星期四 下午 10:47:49 在我的后园，可以看见墙外有两株树，一株是枣树，还有一株也是枣树。 1201-1203, 标注, 2024 年 11 月 7 日星期四 下午 10:54:38 我也曾经有过两天这样的情形，但原因不同，他是做乏，我是病乏的。我的确什么欲望也没有，似乎一切都和我不相干，所有举动都是多事，我没有想到死，但也没有觉得生；这就是所谓“无欲望状态”，是死亡的第一步。 1229-1229, 标注, 2024 年 11 月 7 日星期四 下午 10:57:34 删夷枝叶的人，决定得不到花果。 1274-1275, 标注, 2024 年 11 月 7 日星期四 下午 11:03:14 “渐”的作用，就是用每步相差极微极缓的方法来隐蔽时间的过去与事物的变迁的痕迹，使人误认其为恒久不变。 1251-1256, 标注, 2024 年 11 月 7 日星期四 下午 11:03:30 使人生圆滑进行的微妙的要素，莫如“渐”；造物主骗人的手段，也莫如“渐”。在不知不觉之中，天真烂漫的孩子“渐渐”变成野心勃勃的青年；慷慨豪侠的青年“渐渐”变成冷酷的成人；血气旺盛的成人“渐渐”变成顽固的老头子。因为其变更是渐进的，一年一年地、一月一月地、一日一日地、一时一时地、一分一分地、一秒一秒地渐进，犹如从斜度极缓的长远的山坡上走下来，使人不察其递降的痕迹，不见其各阶段的境界，而似乎觉得常在同样的地位，恒久不变，又无时不有生的意趣与价值，于是人生就被确实肯定，而圆滑进行了。 1295-1295, 标注, 2024 年 11 月 7 日星期四 下午 11:06:35 一粒沙里见世界，一朵花里见天国；手掌里盛住无限，一刹那便是永劫。” 1342-1343, 标注, 2024 年 11 月 7 日星期四 下午 11:18:50 人间的事，只要生机不灭，即使重遭天灾人祸，暂被阻抑，终有抬头的日子。个人的事如此，家庭的事如此，国家、民族的事也如此。 1622-1624, 标注, 2024 年 11 月 7 日星期四 下午 11:30:45 批评是有益处的。我爱批评，它多少给我点益处；即使完全不对，不是还让我笑一笑吗？自己写的时候仿佛是蒸馒头呢，热气腾腾，莫名其妙。及至冷眼人一看，一定看出许多错儿来。我感谢这种指摘。说的不对呢，那是他的错儿，不干我的事。 ","date":"2024-11-11","objectID":"/%E7%AC%94%E8%AE%B0%E5%90%AC%E9%A3%8E%E5%85%AB%E7%99%BE%E9%81%8D%E6%89%8D%E7%9F%A5%E6%98%AF%E4%BA%BA%E9%97%B4-%E5%8F%B2%E9%93%81%E7%94%9F%E7%AD%89/:0:0","tags":["tingfengbaba","note","ireader"],"title":"[笔记]听风八百遍，才知是人间-史铁生等","uri":"/%E7%AC%94%E8%AE%B0%E5%90%AC%E9%A3%8E%E5%85%AB%E7%99%BE%E9%81%8D%E6%89%8D%E7%9F%A5%E6%98%AF%E4%BA%BA%E9%97%B4-%E5%8F%B2%E9%93%81%E7%94%9F%E7%AD%89/"},{"categories":null,"content":" 28-28, 标注, 2024 年 11 月 2 日星期六 上午 10:43:00 人间的事，只要生机不灭，即使重遭天灾人祸，暂被阻抑，终有抬头的日子。 ","date":"2024-11-11","objectID":"/%E7%AC%94%E8%AE%B0%E6%88%91%E4%BB%8E%E6%9C%AA%E5%A6%82%E6%AD%A4%E7%9C%B7%E6%81%8B%E4%BA%BA%E9%97%B4-%E5%8F%B2%E9%93%81%E7%94%9F-%E6%B1%AA%E6%9B%BE%E7%A5%BA-%E7%AD%89-%E8%91%97/:0:0","tags":["wocongweiruc","note","ireader"],"title":"[笔记]我从未如此眷恋人间-史铁生 汪曾祺 等 著","uri":"/%E7%AC%94%E8%AE%B0%E6%88%91%E4%BB%8E%E6%9C%AA%E5%A6%82%E6%AD%A4%E7%9C%B7%E6%81%8B%E4%BA%BA%E9%97%B4-%E5%8F%B2%E9%93%81%E7%94%9F-%E6%B1%AA%E6%9B%BE%E7%A5%BA-%E7%AD%89-%E8%91%97/"},{"categories":null,"content":" 45-47, 标注, 2024 年 11 月 10 日星期日 下午 8:07:39 小说家所说的大纲指的是内容梗概，也就是由若干主要情节构成的故事概要。 她得知一个严谨、讲究的作者往往要写上五遍甚至十遍大纲，不断打磨，不断推敲，直至打造出无懈可击的最终版。 152-153, 标注, 2024 年 11 月 10 日星期日 下午 8:15:25 对一个小说家而言，‘情绪化’可是个好东西，因为你要出售的唯一一件商品就是你自己的情绪体验。” 174-176, 标注, 2024 年 11 月 10 日星期日 下午 8:17:47 “现代化商业需要的是规模经济，”小猪先生娓娓道来，“为了获取尽可能高的利润，你需要用尽可能低的成本运送最大数量的商品。这就意味着你必须打造针对最小公倍数的产品。 193-195, 标注, 2024 年 11 月 10 日星期日 下午 8:19:13 所以当你写小说的时候，你并不是要写给全世界人看，你得选择你的目标读者群，把目标群限定在一个尽可能小的范围内。你就是要写一个取悦你目标读者群的故事，不必考虑其他人爱不爱看。” 480-482, 标注, 2024 年 11 月 10 日星期日 下午 8:44:28 你的读者需要这三样东西：刺激、决定、新方向，而且他们希望这些都能呈现在一张时间表上，也就是说你得安排好灾难的出场时间。如果你把整个故事想象成一场橄榄球赛，那么在比赛第一小节结束、中场以及第三节结束时都需要插入一次灾难性事件。” 519-519, 标注, 2024 年 11 月 10 日星期日 下午 8:46:30 雪花写作法的第二步——故事结构的作用。 571-572, 标注, 2024 年 11 月 10 日星期日 下午 8:49:23 我们刚才学的叫做三幕式结构。雪花写作法的第二步就是给你的小说设计三幕式结构， 800-801, 标注, 2024 年 11 月 10 日星期日 下午 10:23:56 现在只要把段落里的每句话扩写成一个独立的段落就行了。换言之，你们已经有了五句现成的句子，接下来的任务就是把它们扩展成一页纸上的五个段落。 889-890, 标注, 2024 年 11 月 13 日星期三 下午 1:14:45 “在雪花写作法中我们研究的对象将交替上场，先是情节，然后是人物，再回到情节，接着又是人物，随着次数递增，研究的深度也会不断增加。 1070-1071, 标注, 2024 年 11 月 13 日星期三 下午 1:25:39 即便是世上最十恶不赦的人，在他们自己的故事里依然会把自己视为英雄。 1147-1149, 标注, 2024 年 11 月 13 日星期三 下午 1:29:27 可是每一部优秀的小说都有一个道德前提。在斯坦·威廉姆斯所著的《道德前提》一书中有非常详细的阐述。它的核心思想就是在故事的前半段中，主人公活在一个错误的道德前提中，由此产生了一系列后果。” 1218-1219, 标注, 2024 年 12 月 14 日星期六 上午 9:46:36 “回溯本身没有问题，”熊贝比说，“事实上，回溯非常必要，所有的作家都是一边往前写一边往回看，问题是需要回溯到何种程度。” 1242-1244, 标注, 2024 年 12 月 14 日星期六 上午 9:48:27 每个作者都得做这件事，你不可能第一稿就写得天衣无缝，完美无缺。在雪花写作法的十个步骤中，我一直建议如果有必要，每走一步都要往回看一遍自己写了什么，写得怎么样。” 1263-1265, 标注, 2024 年 12 月 14 日星期六 上午 9:50:09 回顾雪花写作法的前五步，凡是觉得有问题的地方一律做好修改。完成一页纸概括，然后将每个主要人物的描述扩写至半页到一页纸的篇幅。我希望你们都能变成小说里的人物，与他们融为一体，挖掘他们背后的故事，找到他们变成现在这个样子的根源。 1279-1280, 标注, 2024 年 12 月 14 日星期六 上午 9:51:03 预感，前期工作做得越细致，后面就会事半功倍。 1302-1303, 标注, 2024 年 12 月 14 日星期六 上午 9:55:49 今天我们就要把大家昨天写好的一页纸概括进行扩写，每一段扩写成一页，这样你们就会有一份长达四五页的内容梗概，我称之为完整大纲。” 1373-1373, 标注, 2024 年 12 月 14 日星期六 上午 10:01:24 雪花写作法的第七步是为你的每个角色撰写一份人物宝典。 1383-1385, 标注, 2024 年 12 月 14 日星期六 上午 10:08:15 许多小说在第一页明明写着女主人公长着一双蓝眼睛，到了第九十九页却莫名其妙地变成了绿眼睛。所以，人物宝典众多作用中的一个就是把跟每一个角色相关的所有信息全部归拢在一个地方，这样你就不会犯类似眼睛变色的低级错误了。” 1583-1584, 标注, 2024 年 12 月 14 日星期六 上午 10:19:43 “这就是写小说的意义，”大灰狼说，“故事教会你如何做正确的事，融入那些作出正确选择的人物的内心，成为他们，当你感同身受之后，你也会作出正确的选择。” 1676-1678, 标注, 2024 年 12 月 14 日星期六 上午 10:24:58 “你说的这些我们叫做背景故事，”熊贝比说，“你之所以需要掌握这些重要信息是因为你必须了解小说里的人物，可是你的读者并不需要知道。你首先要做的是让你的目标读者群喜欢上故事的主要内容，接下来他们就会对背后的故事产生强烈的好奇，而故事的主要部分就是从德克遇见伊莉斯开始的。” 1900-1901, 标注, 2024 年 12 月 14 日星期六 上午 10:37:29 每一个场景都有两种标准模式。一种叫主动型场景，它以目标开始，整个场景中充满矛盾冲突，最后以挫折结束。” 1903-1904, 标注, 2024 年 12 月 14 日星期六 上午 10:37:35 另一种模式叫被动型场景。它先是对之前一幕结束时的挫折作出情感反应，接下来的主干部分是分析面临的困境，找到走出困局的方法，最后以决定作结。” 1933-1935, 标注, 2024 年 12 月 14 日星期六 上午 10:39:17 大多数人在面对一场突如其来的恶战时都会这样的。人们总说‘要么战斗，要么逃跑’，就好像非此即彼只有两种选择似的。其实还有第三种——吓傻了。所以应该是‘要么战斗，要么逃跑，要么吓傻’， 1957-1957, 标注, 2024 年 12 月 14 日星期六 上午 10:40:45 矛盾冲突，” 1927-1927, 标注, 2024 年 12 月 14 日星期六 上午 10:41:06 “目标——冲突——挫折，” 2045-2046, 标注, 2024 年 12 月 14 日星期六 上午 11:01:46 以下就是雪花写作法的十个步骤。 这十个步骤的主要目的就是帮助你完成小说的第一稿。（ 2051-2053, 标注, 2024 年 12 月 14 日星期六 上午 11:02:24 每往前走一步，也许你会想回头看看来时路，并且重新修正一下之前完成的工作。越早越好。雪花写作法的作用就在于帮助你尽早修改，不断完善。 2053-2055, 标注, 2024 年 12 月 14 日星期六 上午 11:02:42 你先要确定自己准备撰写哪个类型的小说，并且明确你的目标读者群。作为一个小说家，你的职责就是要取悦你的目标读者 2058-2060, 标注, 2024 年 12 月 14 日星期六 上午 11:03:09 第一步：一句话概括 用一小时时间思考，然后写下一句话概括小说内容。尽可能不要超过二十五个词。集中于一到两个主人公，说清他们在故事中需要完成的任务，但注意不要泄露故事的结局。 2066-2067, 标注, 2024 年 12 月 14 日星期六 上午 11:03:40 第二步：一段式概括 用一小时将一句话概括扩写成由五句话组成的段落，所含信息如下： 2072-2073, 标注, 2024 年 12 月 14 日星期六 上午 11:04:27 一段式概括能确保小说有一个完整的三幕式结构，其中包含了三次灾难性事件以及一个清晰的道德前提。 2075-2076, 标注, 2024 年 12 月 14 日星期六 上午 11:05:07 第三步：一页纸人物介绍 用一小时时间、一页纸的篇幅为书里的每一个主要人物写下人物介绍。 2077-2081, 标注, 2024 年 12 月 14 日星期六 上午 11:06:06 角色：（男主人公、女主人公、反派、导师、副手、朋友，等等） 姓名：人物的姓名 目标：该人物在这个故事里所要实现的目标。 抱负：该人物所怀揣的抽象的野心。 价值观：以“没有什么比……更重要”为模板写下几句话。 矛盾：是什么阻碍了该人物实现他的目标？ 顿悟：该人物在故事的结尾处有何顿悟？ 2085-2087, 标注, 2024 年 12 月 14 日星期六 上午 11:06:13 第四步：一页纸大纲 用一小时时间将段落式概括扩写成一页，也就是把五句话段落中的每句话扩写成一个完整的段落。 2092-2094, 标注, 2024 年 12 月 14 日星期六 上午 11:07:21 第五步：人物大纲 用一小时时间给小说里的每个人物撰写背景故事，半页至一页即可。解释说明人物在小说里所呈现的性格及行为的成因，他们想获得什么，以及其他你认为有意思的信息。解释说明他们是如何与故事融为一体、息息相关的。 2100-2101, 标注, 2024 年 12 月 14 日星期六 上午 11:07:4","date":"2024-11-11","objectID":"/%E7%AC%94%E8%AE%B0%E9%9B%AA%E8%8A%B1%E5%86%99%E4%BD%9C%E6%B3%9510%E6%AD%A5%E5%86%99%E5%87%BA%E4%B8%80%E7%AF%87%E5%A5%BD%E5%B0%8F%E8%AF%B4-%E7%BE%8E%E5%85%B0%E8%BF%AA%E8%8B%B1%E6%A0%BC%E6%9B%BC%E6%A3%AE%E7%8E%8B%E6%B5%B7%E9%A2%96/:0:0","tags":["xuehuaxiezuo","note","ireader"],"title":"[笔记]雪花写作法:10步写出一篇好小说-[美]兰迪·英格曼森;王海颖","uri":"/%E7%AC%94%E8%AE%B0%E9%9B%AA%E8%8A%B1%E5%86%99%E4%BD%9C%E6%B3%9510%E6%AD%A5%E5%86%99%E5%87%BA%E4%B8%80%E7%AF%87%E5%A5%BD%E5%B0%8F%E8%AF%B4-%E7%BE%8E%E5%85%B0%E8%BF%AA%E8%8B%B1%E6%A0%BC%E6%9B%BC%E6%A3%AE%E7%8E%8B%E6%B5%B7%E9%A2%96/"},{"categories":null,"content":" Table of Contents 1 Improving the print 2 Getting time in my current time zone 获取我当前时区的时间 3 Daylight saving time 夏令时 4 Summary 本文为摘录(或转载)，侵删，原文为： https://www.cppstories.com/2024/chrono_dates_zones/ 在这篇博客文章中，我们将探讨如何使用 std::chrono 处理日期，包括时区。我们将利用该库的最新特性来检索各个时区的当前时间，同时考虑夏令时的变化。此外，我们还将结合 C++23 中引入的新功能，例如增强的打印函数等。 让我们从以下代码开始，它将打印当前的日期和时间： #include \u003cchrono\u003e #include \u003cprint\u003e int main() { auto now = std::chrono::system_clock::now(); std::print(\"now is {}\", now); } 在我的会话中，我得到以下结果： Now is 2024-11-01 11:44:06.374573703 这很简单，但我们处于哪个时区？我们可以以更短的形式打印出来吗？我们如何检查世界各地的时间？夏令时呢？ 第一件事：时间输出。 ","date":"2024-11-04","objectID":"/www_cppstories_com_chrono_dates_zones/:0:0","tags":null,"title":"What is the current time around the world? Utilizing std::chrono with time zones in C++23","uri":"/www_cppstories_com_chrono_dates_zones/"},{"categories":null,"content":"1 Improving the print 如您所见，我使用了 C++23 中的 std::print ，这在 GCC 14 中可用！默认情况下，使用 std::chrono::system_clock::now() 获得的时间点会打印完整信息，但我们可以更改并调整它。例如： 基本日期和时间格式设置 Basic Date and Time Formatting 仅显示日期： {0:%F} 将日期格式化为 YYYY-MM-DD 。 使用 hh:mm:ss 格式显示时间： {0:%T} 将时间格式化为 HH:MM:SS 。 显示月份和/或星期几的名称： {0:%A, %B} 将格式化为星期几，月份。 Advanced Formatting Options Year and Month: {0:%Y}: Full year (e.g., 2024). {0:%y}: Last two digits of the year (e.g., 24). {0:%B}: Full month name (e.g., November). {0:%b}: Abbreviated month name (e.g., Nov). Day and Week: {0:%d}: Day of the month, zero-padded (e.g., 01). {0:%A}: Full weekday name (e.g., Friday). {0:%a}: Abbreviated weekday name (e.g., Fri). Time of Day: {0:%H}: Hour (24-hour clock), zero-padded (e.g., 14). {0:%I}: Hour (12-hour clock), zero-padded (e.g., 02). {0:%M}: Minute, zero-padded (e.g., 05). {0:%S}: Second, zero-padded (e.g., 09). {0:%p}: AM/PM designation. Time Zone: {0:%Z}: Time zone abbreviation (e.g., UTC). {0:%z}: Offset from UTC (e.g., +0000). Here is an example demonstrating some of these formatting options: #include \u003cchrono\u003e #include \u003cprint\u003e int main() { auto now = std::chrono::system_clock::now(); std::print(\"Full date and time: {0:%Y-%m-%d %H:%M:%S}\\n\", now); std::print(\"Date only: {0:%F}\\n\", now); std::print(\"Time only: {0:%T}\\n\", now); std::print(\"Day of the week: {0:%A}\\n\", now); std::print(\"Month name: {0:%B}\\n\", now); std::print(\"12-hour clock with AM/PM: {0:%I:%M:%S %p}\\n\", now); std::print(\"ISO 8601 format: {0:%FT%T%z}\\n\", now); } Run @Compiler Explorer Example output: Full date and time: 2024-11-02 19:35:16.296643881 Date only: 2024-11-02 Time only: 19:35:16.296643881 Day of the week: Saturday Month name: November 12-hour clock with AM/PM: 07:35:16.296643881 PM ISO 8601 format: 2024-11-02T19:35:16.296643881+0000 ","date":"2024-11-04","objectID":"/www_cppstories_com_chrono_dates_zones/:1:0","tags":null,"title":"What is the current time around the world? Utilizing std::chrono with time zones in C++23","uri":"/www_cppstories_com_chrono_dates_zones/"},{"categories":null,"content":"2 Getting time in my current time zone 获取我当前时区的时间 #include \u003cchrono\u003e #include \u003cprint\u003e int main() { const auto now = std::chrono::system_clock::now(); auto zt_local = std::chrono::zoned_time{ std::chrono::current_zone(), now }; std::print(\"now is {} UTC and local is: {}\\n\", now, zt_local); constexpr std::string_view Warsaw{ \"Europe/Warsaw\" }; constexpr std::string_view NewYork{ \"America/New_York\" }; constexpr std::string_view Tokyo{ \"Asia/Tokyo\" }; try { const std::chrono::zoned_time zt_w{Warsaw, now}; std::print(\"Warsaw: {0:%F} {0:%R}\\n\", zt_w); const std::chrono::zoned_time zt_ny{NewYork, now}; std::print(\"New York: {0:%F} {0:%R}\\n\", zt_ny); const std::chrono::zoned_time zt_t{Tokyo, now}; std::print(\"Tokyo: {0:%F} {0:%R}\\n\", zt_t); } catch (std::runtime_error\u0026 ex) { std::print(\"Error: {}\", ex.what()); } } Example output: now is 2024-11-01 19:24:51.319170338 UTC and local is: 2024-11-01 19:24:51.319170338 Warsaw: 2024-11-01 20:24 New York: 2024-11-01 15:24 Tokyo: 2024-11-02 04:24 让我们现在深入细节： 获取当前时间： 我们通过使用 std::chrono::system_clock::now() 来获取当前时间。这将给我们 UTC 的当前时间。 本地时区： 我们使用 std::chrono::current_zone() 创建一个 std::chrono::zoned_time 对象，该对象会自动检测代码运行所在系统的本地时区。这使我们能够将 UTC 时间转换为本地时区。 时区转换： 我们使用 std=::string_view= 定义三个时区：华沙、纽约和东京。这些时区是使用各自的 IANA 时区标识符进行指定的。 对于每个时区，我们创建一个 std::chrono::zoned_time 对象，将当前的 UTC 时间转换为指定的时区。 打印结果： 我们使用 std::print 来显示 UTC 和本地时区的当前时间。 对于每个指定的时区（华沙、纽约、东京），我们使用格式说明符 {0:%F} 打印日期（ YYYY-MM-DD ）和 {0:%R} 打印时间（ HH:MM ）。 错误处理：– 代码被包裹在一个 try-catch 块中，以处理任何潜在的运行时错误，例如无效的时区标识符。 ","date":"2024-11-04","objectID":"/www_cppstories_com_chrono_dates_zones/:2:0","tags":null,"title":"What is the current time around the world? Utilizing std::chrono with time zones in C++23","uri":"/www_cppstories_com_chrono_dates_zones/"},{"categories":null,"content":"3 Daylight saving time 夏令时 我们甚至可以检查与我们当前时区相关的一些额外信息。我们可以从 zoned_time 中获取信息并打印出开始/结束、偏移量等信息： #include \u003cchrono\u003e #include \u003cprint\u003e #include \u003ciostream\u003e int main() { try { const auto now = std::chrono::floor\u003cstd::chrono::minutes\u003e(std::chrono::system_clock::now()); auto zt_local = std::chrono::zoned_time{ \"Europe/Warsaw\", now }; std::print(\"现在是 {} UTC，华沙是: {}\\n\", now, zt_local); auto info = zt_local.get_info(); std::print(\"本地时间信息: \\n缩写: {},\\n 开始 {}, 结束 {}, \\n偏移 {}, 夏令时 {}\\n\", info.abbrev, info.begin, info.end, info.offset, info.save); } catch (std::runtime_error\u0026 ex) { std::print(\"错误: {}\", ex.what()); } } 和夏令时信息： #include \u003cchrono\u003e #include \u003cprint\u003e void printInfo(std::chrono::sys_days sd, std::string_view zone) { auto zt_local = std::chrono::zoned_time{ \"Europe/Warsaw\", std::chrono::sys_days{sd} }; auto info = zt_local.get_info(); std::print(\"在 {:%F} 的 {} 的时间信息:\\n缩写: {},\\n开始 {}, 结束 {}, \\n偏移 {}, 夏令时 {}\\n\", sd, zone, info.abbrev, info.begin, info.end, info.offset, info.save); } int main() { try { printInfo(std::chrono::year{ 2024 } / 9 / 14, \"Europe/Warsaw\"); printInfo(std::chrono::year{ 2024 } / 11 / 14, \"Europe/Warsaw\"); } catch (std::runtime_error\u0026 ex) { std::print(\"错误: {}\", ex.what()); } } 我得到了： 在 Europe/Warsaw 的时间信息 2024-09-14: 缩写: CEST, 开始 2024-03-31 01:00:00, 结束 2024-10-27 01:00:00, 偏移 7200s, 夏令时 60min 在 Europe/Warsaw 的时间信息 2024-11-14: 缩写: CET, 开始 2024-10-27 01:00:00, 结束 2025-03-30 01:00:00, 偏移 3600s, 夏令时 0min 如您所见，我们获得了以下信息： – info.abbrev - 时区缩写名，例如 CET、PT 等– info.begin, info.end - 给定时区的开始和结束日期（以 sys_seconds 为单位），通常在夏令时转换时会发生变化– info.offset - 相对于 UTC 时间的偏移量– info.save - 如果不为零，则表示时区处于夏令时 ","date":"2024-11-04","objectID":"/www_cppstories_com_chrono_dates_zones/:3:0","tags":null,"title":"What is the current time around the world? Utilizing std::chrono with time zones in C++23","uri":"/www_cppstories_com_chrono_dates_zones/"},{"categories":null,"content":"4 Summary 这真是一趟旅程！我们从简单的当前时间显示开始，逐渐过渡到更复杂的场景，包括 C++20 和 C++23 中提供的各种格式选项，以及时区。最后，我们探讨了如何检查特定时间点的细节，并检查与其时区相关的信息。 ","date":"2024-11-04","objectID":"/www_cppstories_com_chrono_dates_zones/:4:0","tags":null,"title":"What is the current time around the world? Utilizing std::chrono with time zones in C++23","uri":"/www_cppstories_com_chrono_dates_zones/"},{"categories":null,"content":" 58-59, 标注, 2024 年 10 月 26 日星期六 下午 8:48:23 大人聚会总是吃一些难得而无聊的食物。海参躺在白瓷大盘里就像一条屎在阿娜擦得发光的马桶底。 159-160, 标注, 2024 年 10 月 26 日星期六 下午 10:27:11 出学校大门的时候看到瘦高的身影，逆着黑头车的车头灯，大伞在风中癫痫，车灯在雨中伸出两道光之触手，触手里有雨之蚊蚋狂欢。 172-172, 标注, 2024 年 10 月 26 日星期六 下午 10:33:57 杜斯妥也夫斯基。 192-194, 标注, 2024 年 10 月 26 日星期六 下午 10:38:25 怡婷很悲愤，她知道的比世界上任何一个小孩都来得多，但是她永远不能得知一个自知貌美的女子走在路上低眉敛首的心情。 413-413, 标注, 2024 年 10 月 27 日星期日 上午 8:02:06 方求白时嫌雪 503-504, 标注, 2024 年 10 月 27 日星期日 上午 8:20:24 眼泪流下来，就像是伊纹脸上拉开了拉链，让她们看见金玉里的败絮。 ","date":"2024-10-31","objectID":"/%E7%AC%94%E8%AE%B0%E6%88%BF%E6%80%9D%E7%90%AA%E7%9A%84%E5%88%9D%E6%88%80%E6%A8%82%E5%9C%92-%E6%9E%97%E5%A5%95%E5%90%AB/:0:0","tags":["fangsiqidech","note","ireader"],"title":"[笔记]房思琪的初戀樂園-林奕含","uri":"/%E7%AC%94%E8%AE%B0%E6%88%BF%E6%80%9D%E7%90%AA%E7%9A%84%E5%88%9D%E6%88%80%E6%A8%82%E5%9C%92-%E6%9E%97%E5%A5%95%E5%90%AB/"},{"categories":null,"content":" 1524-1526, 标注, 2024 年 10 月 28 日星期一 上午 7:57:33 风吹日晒、疲惫不堪的土地散发着尘埃和太阳的气味。风沙沙地响着，翻动着向日葵的绿叶子。一堆棉絮似的白云遮住了太阳，天突然昏暗了，于是烟雾般的云影落到了草原上，村落上，落到了阿克西妮亚的低垂着的脑袋上，落到了菟丝的粉红色花萼上，然后又盘旋、翻滚飘逝。 1543-1544, 标注, 2024 年 10 月 28 日星期一 上午 7:59:18 粘土地上和山坡上一片金黄，小麦叶子被太阳晒得都卷起来了，生命已经告终的麦茎也干枯了。 1817-1820, 标注, 2024 年 10 月 28 日星期一 下午 1:29:42 小麦长出了尖尖的绿芽儿，天天见长；一个半月以后，连乌鸦的脑袋都能藏进去了，麦子吮吸着土壤里的养料，抽了穗；然后开花，麦穗罩上了一层金黄的花粉；麦粒灌满了香喷喷、甜丝丝的乳浆。当家人来到麦地里一看，真是心花怒放，可是突然不知道从什么地方闯来一群牲口，在麦地里乱踩一阵：可怜那沉甸甸的麦穗全被踩烂在田垄上。凡是牲口践踏过的地方，到处是一片片踩坏了的麦子…… 1826-1828, 标注, 2024 年 10 月 28 日星期一 下午 1:30:20 被牲口踩倒的麦子又立起来了。雨露阳光，使踩倒在地上的麦茎又挺立起来；起初，就像一个被不能胜任的重负压得弯着身子的人一样，后来就挺直身子，抬起头来，白昼又照样照耀着它，风又照样吹得它摇曳多姿了…… 1898-1898, 标注, 2024 年 10 月 28 日星期一 下午 6:32:56 在头发上擦着油手。 1898-1898, 笔记, 2024 年 10 月 28 日星期一 下午 6:33:16 想起我奶奶了, 2681-2684, 标注, 2024 年 10 月 28 日星期一 下午 10:23:29 严寒袭来，下了一场大雪；一天比一天冷得厉害，接着又下了两俄寸半厚的雪，顿河边上的菜园子里，野兔越过顶上被大雪覆盖着的篱笆，留下一圈圈梅花形的趾印，宛如姑娘衣服上的花边。烧牛粪的烟雾笼罩在村庄的上空，飞集到有人烟的地方来的乌鸦，在路旁的灰堆里徘徊觅食。爬犁压出来的冬季道路，像一条褪了色的灰带子，蜿蜒在村中。 2971-2973, 标注, 2024 年 10 月 29 日星期二 下午 12:35:43 在维申斯克对面，顿河像鞑靼人的弓囊似的弯成弧形，仿佛要向右转去，可是到巴兹基村附近，却又雄伟浩荡地笔直流去，闪着蓝光的淡绿色河水，流过右岸的白垩山崖、接连不断的村庄和左岸的稀疏的集镇，奔向大海，奔向蓝色的亚速海。 3090-3092, 标注, 2024 年 10 月 29 日星期二 下午 12:43:14 傍晚，葛利高里坐在风磨的旁边，在袖口里抽着烟。寒风在风车后面枯干的玉米秸中间冲撞，呼号。系在风车轮翼上的一块破布片在啪啦啪啦地响。葛利高里觉得好像是一只飞不动的大鸟拍打着翅膀，在他头顶盘旋。 3090-3095, 标注, 2024 年 10 月 29 日星期二 下午 12:43:40 傍晚，葛利高里坐在风磨的旁边，在袖口里抽着烟。寒风在风车后面枯干的玉米秸中间冲撞，呼号。系在风车轮翼上的一块破布片在啪啦啪啦地响。葛利高里觉得好像是一只飞不动的大鸟拍打着翅膀，在他头顶盘旋。阿克西妮亚还没有来。西面的半边天，是一片淡紫色的晚霞和金黄的夕照。从东方吹来越来越紧的刺骨寒风，黑夜追逐着挂在柳树梢上的月亮，铺天盖地袭来。风车顶上，红黄色的、有蓝色斑纹的夜空，像僵尸一样的阴沉；村庄上空还回荡着白昼忙碌生活喧嚣的余音。 3092-3095, 标注, 2024 年 10 月 29 日星期二 下午 12:43:42 地响。葛利高里觉得好像是一只飞不动的大鸟拍打着翅膀，在他头顶盘旋。阿克西妮亚还没有来。西面的半边天，是一片淡紫色的晚霞和金黄的夕照。从东方吹来越来越紧的刺骨寒风，黑夜追逐着挂在柳树梢上的月亮，铺天盖地袭来。风车顶上，红黄色的、有蓝色斑纹的夜空，像僵尸一样的阴沉；村庄上空还回荡着白昼忙碌生活喧嚣的余音。 3414-3414, 标注, 2024 年 10 月 29 日星期二 下午 6:33:30 Крепыш） 4262-4266, 标注, 2024 年 10 月 30 日星期三 上午 7:42:12 一个干旱的夏天。村边顿河的水变浅了，那片从前是急流奔腾的地方，现在变成了浅滩，牛走到对岸去，连脊背都湿不了。夜里，沉闷的暑热从山岗上吹到村子里来，风把晒焦的草香味吹散到空中。牧场上的干蓬蒿在燃烧，甜藜像一层看不见的薄幕挂在顿河岸上。一到夜间，顿河对岸的天上就布满了黑云，雷声单调地、隆隆地响着，但是连一个雨点也没有落到炎热煎烤的大地上，电光在空中闪个不停，夜空被划成一些带尖角的蓝色块块。 5048-5052, 标注, 2024 年 10 月 30 日星期三 下午 6:44:26 整齐的队列前一片窸窣声，宛如飘忽吹过成熟了的大麦田的风声。一阵阵刺耳的马嘶声。一双双睁圆的眼睛和张着的、黑洞洞的嘴都转向一连那边；那里的左翼上有一匹马在长嘶。 上校又讲了些话。他在斟酌字句，想激起人们的民族自豪感。可惜此时此刻呈现在成千的哥萨克眼前的，并不是沙沙响着倒在脚下的敌人的旗帜，而是他们日常的、熟悉的生活；大声呼叫哀号的老婆、孩子、情人；没有收完的庄稼，荒凉的村庄、市镇…… 5707-5708, 标注, 2024 年 10 月 31 日星期四 上午 7:46:18 离他们有十步远的地方，一片没有收割、麦粒已经脱落的黑麦在随风翻滚。被风吹空的麦穗弯下头，在悲伤地沙沙哭泣。 5783-5787, 标注, 2024 年 10 月 31 日星期四 上午 7:52:53 哥萨克们默默地走到连队宿营的地方。暮色已深。微风从西方吹来卷层的黑云。从什么地方的沼泽地里吹来一阵阵淡淡的污泥和烂草的潮湿气味。鹭鸶咕咕叫着。马具的叮当声、马刀偶尔撞碰马镫的响声和马蹄踏着地上的松针发出的沙沙声划破了睡梦般的寂静。林中小路的上空，松树枝干上的夕阳余晖渐渐黯淡下来。“锅圈儿”不住地在吸烟。忽明忽暗的火光照亮了他那紧紧夹着卷烟、长着鼓起的黑指甲的大粗指头。 黑云在树林上空飘动，使大地无比忧郁的苍茫暮色更加幽暗、浓重。 5896-5897, 标注, 2024 年 10 月 31 日星期四 下午 1:33:17 我们总是在加倍重犯过去的错误， 5900-5904, 标注, 2024 年 10 月 31 日星期四 下午 1:34:36 风吹拂着焦黄的、硬毛似的麦茬。黑云在西方的天边涌起。这片黑云顶上镶了一带紫色的霞光，再往下一点儿，这绮丽的色彩却正在消失，色调瞬息万变，在忧郁的天空涂上一抹轻柔如烟的、淡紫色的夕照余晖；这一片像河流解冻时壅塞的冰块垒起来的云堆从中间陷裂，云隙间透出一道橙黄色的落日霞光。红彤彤的光芒令人目眩，直泻大地，扇面似地迸散开，又折射回天空。云隙的下面，神奇地绣出一条美丽的，杂乱无章的色谱。 6093-6096, 标注, 2024 年 10 月 31 日星期四 下午 6:41:09 一个晴朗的九月的日子，鞑靼村的上空飘着一层薄薄的像蜘蛛网似的彩色艳丽烟云。没有血色的太阳像寡妇一样苦笑着。万里晴空，碧蓝洁净，犹如拒人于千里之外的骄矜的处女。顿河对岸的树林染上一片忧郁的黄色，白杨树闪着黯淡的光辉，橡树飘落着稀疏的、有花纹的叶子，只有赤杨依然碧绿喜人。它那顽强的生命力感染了目光锐利的喜鹊。 6125-6128, 标注, 2024 年 10 月 31 日星期四 下午 6:43:43 潘苔莱·普罗珂菲耶维奇自从收到葛利高里阵亡的通知以后，好像一下子就变得憔悴不堪了。亲人们眼看着他一天一天地衰老下去。痛苦的结局不可避免地降临到他头上：记忆衰退，头脑也糊涂了。驼着背，脸色像生铁一样黑，在宅院里打转转儿；眼睛里患热病似的油晃晃的光芒道出了他心灵上的混乱不安。 6233-6238, 标注, 2024 年 10 月 31 日星期四 下午 6:52:37 白昼将尽。无限肃穆，宜人的晚秋的寂寞黄昏催人欲睡。天空已经失去了夏日灿烂的光辉，只是黯淡地闪着蓝光。不知道从什么地方飘来的苹果树叶，在沟渠上洒下了一层瑰丽火红的秋色。蜿蜒起伏的群山遮断了通向四方的大道，——它正在枉费心机地招引人们往那里去，往那朦胧如梦的、碧绿的地平线那边的神秘广原中去，——而人们却被关在日常生活的牢笼里，被家务、收割的繁重劳动折磨得痛苦、疲惫不堪；而这条旷无人迹的大道——一线引人愁思的踪迹——却穿过地平线，伸向看不见的远方。 6257-6259, 标注, 2024 年 10 月 31 日星期四 下午 6:54:10 生活奔腾泛滥，溢出河床，分成无数的支流。简直难以预料它那叛逆和狡狯的洪峰将泻向哪条支流。今天那里的生活还像流过浅滩的潺潺溪水，浅到使你可以看到肮脏的沙底，——明天却忽然变成浊浪滚滚的洪流…… 6718-6719, 标注, 2024 年 11 月 1 日星期五 上午 7:46:04 咱们俩是在这儿悄悄说说，就像两只野雁在芦苇丛里偷偷咕咕几声，只要你大声一叫，——立刻就有一颗子弹飞过来。 6730-6732, 标注, 2024 年 11 月 1 日星期五 上午 7:47:12 不管是德国人，还是法国人，——所有的国家都要变成工人和农民的政权。到那时候，咱们谁还要打仗呢？那时候国界没有啦！凶恶的仇恨也没有啦！全世界都过着美好的生活。 6820-6822, 标注, 2024 年 11 月 1 日星期五 上午 7:56:47 “很久以前我还是小伙子的时候，唱过这支歌，可是现在我的嗓子已经干枯，生活吞没了歌声。现在我是","date":"2024-10-31","objectID":"/%E7%AC%94%E8%AE%B0%E9%9D%99%E9%9D%99%E7%9A%84%E9%A1%BF%E6%B2%B3-%E8%8B%8F-%E8%82%96%E6%B4%9B%E9%9C%8D%E5%A4%AB%E9%87%91%E4%BA%BA/:0:0","tags":["jingjingdedu","note","ireader"],"title":"[笔记]静静的顿河-[苏] 肖洛霍夫;金人","uri":"/%E7%AC%94%E8%AE%B0%E9%9D%99%E9%9D%99%E7%9A%84%E9%A1%BF%E6%B2%B3-%E8%8B%8F-%E8%82%96%E6%B4%9B%E9%9C%8D%E5%A4%AB%E9%87%91%E4%BA%BA/"},{"categories":null,"content":" 458-461, 标注, 2024 年 10 月 26 日星期六 下午 2:52:10 阳明思想中最出彩的“体认”，其实是一种情感。西方哲学重理性，东方哲学重情感。如果我们把哲学思想比喻成一棵大树，那么阳明的东方哲学就可以被看作是对根的培养，而西方哲学则是对枝枝叶叶的探求。学问有本末之分，阳明哲学乃“培根之学”，西方哲学乃“枝叶探求之学”，何为本，何为末，各位读者要切记。 669-671, 标注, 2024 年 10 月 26 日星期六 下午 3:04:00 宋代，严格来说，中国真正的文艺复兴始于王阳明。王阳明创立“良知”说，认为自我和圣人一样，生而伟大，存而无异，这种强调自我的主张正是文艺复兴开始的标志。 855-856, 标注, 2024 年 10 月 26 日星期六 下午 5:31:32 经过来，乃知功夫只在自己，不去责人，所以致得‘克谐’，此是舜‘动心忍性、增益不能’处。”（《 855-856, 标注, 2024 年 10 月 26 日星期六 下午 5:31:39 经过来，乃知功夫只在自己，不去责人，所以致得‘克谐’，此是舜‘动心忍性、增益不能’处。”（《传习录》下卷） ","date":"2024-10-26","objectID":"/%E7%AC%94%E8%AE%B0%E7%8E%8B%E9%98%B3%E6%98%8E%E5%A4%A7%E4%BC%A0%E7%9F%A5%E8%A1%8C%E5%90%88%E4%B8%80%E7%9A%84%E5%BF%83%E5%AD%A6%E6%99%BA%E6%85%A7%E5%85%A8%E6%96%B0%E4%BF%AE%E8%AE%A2%E7%89%88-%E6%97%A5%E5%86%88%E7%94%B0%E6%AD%A6%E5%BD%A6%E6%9D%A8%E7%94%B0%E5%86%AF%E8%8E%B9%E8%8E%B9%E8%A2%81%E6%96%8C%E5%AD%99%E9%80%A2%E6%98%8E/:0:0","tags":null,"title":"[笔记]王阳明大传：知行合一的心学智慧","uri":"/%E7%AC%94%E8%AE%B0%E7%8E%8B%E9%98%B3%E6%98%8E%E5%A4%A7%E4%BC%A0%E7%9F%A5%E8%A1%8C%E5%90%88%E4%B8%80%E7%9A%84%E5%BF%83%E5%AD%A6%E6%99%BA%E6%85%A7%E5%85%A8%E6%96%B0%E4%BF%AE%E8%AE%A2%E7%89%88-%E6%97%A5%E5%86%88%E7%94%B0%E6%AD%A6%E5%BD%A6%E6%9D%A8%E7%94%B0%E5%86%AF%E8%8E%B9%E8%8E%B9%E8%A2%81%E6%96%8C%E5%AD%99%E9%80%A2%E6%98%8E/"},{"categories":null,"content":" 139-140, 标注, 2024 年 10 月 17 日星期四 下午 6:16:57 这一年，已经是 1967 年，一冰五十六岁。最后共监禁四年，四年后假释出狱。一冰先生晚年常对子女说：“我这辈子最大的错误，就是相信这个时代还有公道！” 153-156, 标注, 2024 年 10 月 17 日星期四 下午 6:18:42 一冰先生写《苏传》，不像林语堂看到的东坡，是横空出世、天才洋溢，他看到的东坡是狱中狼狈至极的东坡、虎口余生出狱后的东坡，是从苦闷中走向旷达自在、从现实接二连三的无情打击走向一而再、再而三的意志坚强与生命韧性的东坡，他更从东坡一生看到文人的真性情、率直和乐观，看到一肚子不合时宜，更看到了围绕其间的政治漩涡与小人诬陷—— 130-164, 标注, 2024 年 10 月 17 日星期四 下午 6:20:00 1979 年，《苏传》全书写成，共计七十余万字。一冰先生当时并不想出版，因不想出名，也不求闻达了，甚至像东坡一样“自喜渐不为人识”，《苏传》是他前半生忧患、孤愤之书。 180-181, 标注, 2024 年 10 月 17 日星期四 下午 6:22:26 人生得失，难以短暂时光看待，其屈辱悲痛，当时哭之、恨之、衔之，放诸长远，祸福得失之间，亦难遽 180-181, 标注, 2024 年 10 月 17 日星期四 下午 6:22:30 人生得失，难以短暂时光看待，其屈辱悲痛，当时哭之、恨之、衔之，放诸长远，祸福得失之间，亦难遽断 571-577, 标注, 2024 年 10 月 17 日星期四 下午 10:21:51 宋真宗御笔亲作《劝学篇》，传布天下，这短短的篇章，迷醉天下士子者，几近千年，何况当时。诗曰： 富家不用买良田，书中自有千钟粟。 安居不用架高堂，书中自有黄金屋。 娶妻莫恨无良媒，书中自有颜如玉。 出门莫恨无人随，书中车马多如簇。 男儿欲遂平生志，五经勤向窗前读。 737-740, 标注, 2024 年 10 月 18 日星期五 上午 4:19:15 苏轼少年读《范滂传》时，认为这个世界需要正直而勇敢的天才，立志要做一个为真理而不惜以死相争的巨人；到了历尽坎坷，才发现生命里仍是空无一物。当初，他用一片如火的热情来拥抱人生，不料四十年漫长的历程，却尽是错落的噩梦。 945-948, 标注, 2024 年 10 月 18 日星期五 上午 8:05:30 七月，大雨虽止，而京城内繁华的九陌通衢，竟已完全看不到车马的影子，路上到处都是小艇，在浊水里划来划去。有天晚上，苏轼独自一人走上大内正对面的龙津桥上观看夜市，虽然仍是满街辉煌的灯火，却照耀在黑黝黝的脏水面上，像无数蠢动的金蛇，抬头上看，则星寒月皎，一片凄清，这岂是繁华的京城？宛然为江湖水乡的风貌。“独立市桥人不识，万人如海一身藏”，苏轼心里有无限的寂寞、无限的乡愁。 1132-1133, 标注, 2024 年 10 月 18 日星期五 下午 7:28:18 三苏回到家门，只见屋庐倒坏，篱落破漏，正如一栋逃亡无人的家屋，如今新丧在堂，更增一重凄凉空洞的光景。 1186-1190, 标注, 2024 年 10 月 18 日星期五 下午 7:35:52 京师，苏轼作诗赠行，认为扩大生活天地，是人生第一件大事。他打了一个譬喻，生长在山上石溪里的鲤鱼，倘然碰上赤日沸水的天气，而溪岸石密，无缝可钻时，定将窘迫得有如涸辙之鲋。所以，必须超越小溪，奋然跃往大江大海，而与浮沉浅水的群蛙道别。苏轼鼓励他道：“赖尔溪中物，虽困有远谋。不似沼沚间，四合狱万鲰。纵知有江湖，绵绵隔山丘。人生岂异此，穷达皆有由。” 1572-1572, 标注, 2024 年 10 月 18 日星期五 下午 10:37:01 不饮胡为醉兀兀，此心已逐归鞍发。 18640-18642, 标注, 2024 年 10 月 19 日星期六 上午 10:04:31 清刘鹗在《老残游记》序文中说天下至性至情的文章都是一种“哭泣”：《离骚》是屈大夫的哭泣，《史记》则太史公之哭泣，《红楼梦》是曹雪芹的哭泣。如是，《苏传》便是父亲的哭泣。或许这是命运的定数，天降大任的道路必须如此酷烈。 1931-1933, 标注, 2024 年 10 月 19 日星期六 下午 12:14:16 十年生死两茫茫。不思量，自难忘。千里孤坟，无处话凄凉。纵使相逢应不识，尘满面，鬓如霜。 夜来幽梦忽还乡。小轩窗，正梳妆。相顾无言，惟有泪千行。料得年年肠断处，明月夜，短松冈。 2379-2379, 标注, 2024 年 10 月 19 日星期六 下午 10:53:58 文章本天成，妙手偶得之”。 3101-3102, 标注, 2024 年 10 月 20 日星期日 下午 6:59:25 水光潋滟晴方好，山色空濛雨亦奇。 欲把西湖比西子，淡妆浓抹总相宜。 3034-3036, 标注, 2024 年 10 月 20 日星期日 下午 7:12:49 这年深秋，雨水丰足，苏轼白天听人说今年农家的收成都很好，夜雨敲窗，辗转不能成眠，深悔当年无端放弃家乡的田园生活，实在大错特错，秋怀难遣，竟至通宵不寐，坐以待旦，《秋怀二首》诗， 3197-3199, 标注, 2024 年 10 月 20 日星期日 下午 7:16:39 人生中，能抗拒霜雪欺凌的，固是勇者，但有更高一层的生命本质，不经风霜锻炼，就开不出瑰伟的奇葩来，是谓“宜霜”。苏轼 3314-3315, 标注, 2024 年 10 月 21 日星期一 上午 7:47:38 新月照水水欲冰，夜霜穿屋衣生棱。野庐半与牛羊共，晓鼓却随鸦鹊兴。夜来履破裘穿缝，红颊曲眉应入梦。……” 3708-3708, 标注, 2024 年 10 月 21 日星期一 下午 1:04:46 多事始知田舍好，凶年偏觉野蔬香。 5807-5809, 标注, 2024 年 10 月 21 日星期一 下午 1:13:22 缺月挂疏桐，漏断人初静。谁见幽人独往来，缥缈孤鸿影。 惊起却回头，有恨无人省。拣尽寒枝不肯栖，寂寞沙洲冷。 4014-4018, 标注, 2024 年 10 月 21 日星期一 下午 1:25:20 江城子》词，词曰： 老夫聊发少年狂，左牵黄，右擎苍。锦帽貂裘，千骑卷平冈。为报倾城随太守，亲射虎，看孙郎。 酒酣胸胆尚开张，鬓微霜，又何妨！持节云中，何日遣冯唐？会挽雕弓如满月，西北望，射天狼。 4161-4166, 标注, 2024 年 10 月 21 日星期一 下午 1:28:51 明月几时有，把酒问青天。不知天上宫阙，今夕是何年？我欲乘风归去，惟恐琼楼玉宇，高处不胜寒。起舞弄清影，何似在人间？ 转朱阁，低绮户，照无眠。不应有恨，何事长向别时圆？人有悲欢离合，月有阴晴圆缺，此事古难全。但愿人长久，千里共婵娟。 此词从自然的流变说及人事的无常，从一种孤高的气氛中，透露出作者旷远的胸襟，历来被认为是中秋词中的绝唱。 4409-4410, 标注, 2024 年 10 月 21 日星期一 下午 7:03:03 臣闻好兵犹好色也。伤生之事非一，而好色者必死。贼民之事非一，而好兵者必亡，此理之必然者也。 ","date":"2024-10-19","objectID":"/%E7%AC%94%E8%AE%B0%E8%8B%8F%E4%B8%9C%E5%9D%A1%E6%96%B0%E4%BC%A0-%E6%9D%8E%E4%B8%80%E5%86%B0/:0:0","tags":["sudongpoxinc","note","ireader"],"title":"[笔记]苏东坡新传-李一冰","uri":"/%E7%AC%94%E8%AE%B0%E8%8B%8F%E4%B8%9C%E5%9D%A1%E6%96%B0%E4%BC%A0-%E6%9D%8E%E4%B8%80%E5%86%B0/"},{"categories":null,"content":" 354-357, 标注, 2024 年 10 月 17 日星期四 上午 8:01:10 早上下了霜，潮湿得厉害。早起就看见我那小窗户外边蒙着一层水汽，仿佛有个妖魔整夜在那里哭个没停，把我的窗户当作了擦眼泪的手绢。走出门，只见光秃秃的篱笆上和稀疏的小草上也全是一片水汽，看上去真像粗丝络的蜘蛛网，网丝儿从这根树枝挂到那根树枝，从这棵小草挂到那棵小草。家家篱栅上，大门上，都罩着一团黏糊糊的湿气。 1344-1346, 标注, 2024 年 10 月 22 日星期二 上午 7:38:28 靠里边的一个小院子里，遍地都是杂乱无章的空酒桶，发出一股酸溜溜的气味，大概是为昔日美好的年华留下的一点纪念吧；可是这气味毕竟酸得太厉害，不能算作当年的啤酒的一份货样——说到这里，我倒是想起了，大凡世外隐士都是如此，留下的残迹遗事往往未必尽如其为人。 1536-1538, 标注, 2024 年 10 月 22 日星期二 上午 7:52:21 读者诸君，请你们暂时放下书来想一想吧，人生的长链不论是金铸的也好，铁打的也好，荆棘编成的也好，花朵串起来的也好，要不是你自己在终生难忘的某一天动手去制作那第一环，你也就根本不会过上这样的一生了。 1790-1791, 标注, 2024 年 10 月 22 日星期二 下午 1:17:45 高高的壁炉架上点着几支阴森森的蜡烛，把屋里映照得影影绰绰。如果用词再贴切一些，应当说是几支蜡烛影影绰绰地搅动了满屋子的黑暗。 2264-2267, 标注, 2024 年 10 月 22 日星期二 下午 6:47:31 以前我还以为有朝一日我卷起袖管走进打铁间去做了乔的学徒，我就算出头了，就很幸福了。如今希望成为事实之后，却只觉得遍身都是煤屑煤灰；每天思及往事，觉得心头无限沉重，相比之下，铁砧真是轻如鸿毛。我后来也曾不止一次地尝到过一种滋味（我看大多数人都尝到过这种滋味），觉得一时间仿佛天上落下一块厚厚的帷幕，盖没了人生的一切乐趣和美妙的幻想，使我百无聊赖，只有浑浑噩噩耐着性子度日。 2269-2271, 标注, 2024 年 10 月 22 日星期二 下午 6:48:03 后来有一段时期，我常常在星期天黄昏站在教堂公墓里，看夜幕降落，拿我自己的前程跟那一片寒风萧瑟的沼地景色相比较，觉得二者倒颇有些类似之处：一样单调，一样低下，一样看不见出路，一样是浓雾弥漫，大海茫茫。 3410-3412, 标注, 2024 年 10 月 22 日星期二 下午 9:52:42 这一夜时睡时醒，老是梦见马车跑错地方，哪儿都跑到了，就是跑不到伦敦；驾车的一会儿是狗，一会儿是猫，一会儿是猪，一会儿是人——就是没有马。整夜乱梦颠倒，迷途失向，醒来已是天光拂晓、百鸟欢歌的时分。 3430-3430, 标注, 2024 年 10 月 22 日星期二 下午 9:54:20 其实，人大可不必为流泪而感到羞耻，因为眼泪好比甘霖，会涤净那蒙蔽我们心灵的凡尘俗垢。 3868-3869, 标注, 2024 年 10 月 23 日星期三 上午 8:04:40 木料尽管抹上漆，却掩盖不了纹理；漆抹得愈多，纹理反而愈显著。 3963-3964, 标注, 2024 年 10 月 23 日星期三 下午 12:34:27 在阒无人声的深夜里，巴那尔德旅馆里那个不会看门的家伙，借值夜为名在四下闲荡，脚步声一阵阵落在我心上，显得那么空洞。 4315-4315, 标注, 2024 年 10 月 23 日星期三 下午 6:40:56 划碎了一河夕照或月光 4789-4789, 标注, 2024 年 10 月 23 日星期三 下午 9:12:24 世界上形形色色的骗子，比起自骗自的人来，实在算不上一回事， 5514-5518, 标注, 2024 年 10 月 24 日星期四 上午 7:37:00 活下去呢还是死？——这就是问题的症结； 要做到胸怀磊落，究竟是应该 承当那暴戾命运的明枪暗箭， 还是应该持戈举矛， 去堵截那无边的苦海，以牙还牙，歼灭了这苦恼？ 死亡不过是长眠——一了百了； 既然步入了长眠就再也不会肝肠断碎，那血肉之躯挣不脱的百千种疾痛从此也同归于尽， 那岂不是我们求之不得的圆满功德？ 死亡不过是长眠 —— 可是长眠了也许还会做梦，这倒是个难题！ 5851-5854, 标注, 2024 年 10 月 24 日星期四 下午 1:16:43 半夜醒来（也像卡密拉一样了），我只觉得心情腻烦，老是想着，若是这一辈子没见过郝薇香小姐的面，安心伴着乔，守住那间正大光明的古老打铁间长大成人，那我的日子一定要比现在过得幸福，过得快活。也不知有多少个傍晚，孤单单一个人望着壁炉，就不禁觉得，世间的炉火再好，也比不上打铁间的那一炉火，比不上老家厨房里的那一炉火。 5994-5996, 标注, 2024 年 10 月 24 日星期四 下午 1:29:14 又到了骄阳当空的夏季，一路走去，小时候孤苦凄凉、备受姐姐虐待的情景，又历历浮现目前。不过这些前尘往事，今天重新勾上心头，却别有一种柔和滋味，连那根抓痒棍打在身上，回想起来似乎也不是那么痛了。 6048-6048, 标注, 2024 年 10 月 24 日星期四 下午 6:31:00 “人生在世，生不带来，死不带去，韶光易逝兮如影旋灭，浮生苦短兮孰能久羁” 7183-7184, 标注, 2024 年 10 月 24 日星期四 下午 10:37:25 凡事不能只看表面，要有凭有据才能作准。为人处世，这是头一条金科玉律。 7846-7848, 标注, 2024 年 10 月 25 日星期五 下午 1:22:09 一张用四根木柱撑起来的床架简直像个专制魔王，叉开四条腿，占据了整个地盘：它一只蛮不讲理的脚踏住壁炉，另外一只脚一直迈到门洞子里，俨然摆出一副神圣不可侵犯的架势，把个可怜巴巴的小脸盆架挤得不能动弹。 7886-7887, 标注, 2024 年 10 月 25 日星期五 下午 1:24:36 为人处世，记住一条原则大有好处：能够不落笔据在人家手里，那就千万不要落，因为，谁说得准多早晚会让人家利用呢？ 8162-8163, 标注, 2024 年 10 月 25 日星期五 下午 6:31:20 我整个的希望好比一件撕得七零八碎的袍子，一块块都被风儿吹散了，为什么偏偏要留着这最后一块可怜巴巴的小小的碎片呢？ 8260-8262, 标注, 2024 年 10 月 25 日星期五 下午 6:37:06 我尽管用尽心机，处处留神，偏偏这一回竟是这样糊涂，这样疏忽，正好比关严了远远近近前前后后的百十扇门窗，堵塞了他的一切来路，回头一看，他居然就在我的跟前。 9343-9346, 标注, 2024 年 10 月 26 日星期六 上午 9:36:54 好孩子。我们现在已经够安静、够自在的了，还要怎么安静、怎么自在呀？可是我想——大概因为在河上淌呀淌的，实在太舒坦、太愉快了，所以才会这样想吧——我刚才一边抽烟，一边就在心里想，我们谁说得上过几个小时会是怎么个光景呢，正像我撩得起这把河水，却看不到河底一样。可是，河水我抓不住，时光我们也留不得。喏，水都从手指缝里漏掉了，你瞧！”说着举起了那只水淋淋的手。 9524-9525, 标注, 2024 年 10 月 26 日星期六 上午 10:13:37 昨天我们背着一轮落日而来，今天我们又迎着一轮落日而归。我们的希望也如河水，都滚滚地往回倒流。 9751-9754, 标注, 2024 年 10 月 26 日星期六 上午 10:32:59 太阳通过法庭大玻璃窗上的亮闪闪的雨点照了进来，在三十二个男女犯人和大法官之间洒下一大片阳光，阳光把双方连为一片，也许旁听席上有人见了这个景象就会想到，这双方也即将以绝对平等的地位，去听候那位洞察一切、绝无舛错的更高的审判者的审判了。 9790-9791, 标注, 2024 年 10 月 26 日星期六 上午 10:35:24 最难得的是，自从乌云罩在我头上以来，你守着我，反而比从前我红日高照的时候更加尽心了。这是最难得的。 9787-9791, 标注, 2024 年 10 月 26 日星期六 上午 10:35:40 “你没有抛弃我，好孩子。” 我没有作声，只是按了按他的手，因为我忘不了我一度有过想抛弃他的意思。他说：“最难得的是，自从乌云罩在我头上以来，你守着我，反而比从前我红日高照的时候更加尽心了。这是最难得的。” 9854-9858, 标注, 2024 年 10 月 26 日星期六 上午 10:39:24 我发了一场高烧，结果把人们都吓跑了；我病得厉害，常常神志迷糊；我挨呀挨呀，却总挨不到头；我糊里糊涂，分辨不出哪是虚无缥缈的幻景，哪是我本人；我忽而成了砌在墙壁高处的一块砖头，只求赶快脱离这个高得我头昏眼花的地方，我忽而又变成大机器上的一根钢轴，给架在深渊上嘎嘎打转，心里恨不得这台机器能马上关住，我这根钢轴也能马上拆下来——病中的这种种光景，都是今天回忆起来的，不过当时多少也知道一些。 9898-9902, 标注, 2024 年 10 月 26 日星期六 上午 10:44:19 我的书桌已经被推到墙角里，桌上累累赘赘地放了许多小药瓶，乔现在就在这张桌子前坐下，着手干他的伟大事业：先从笔盘里挑了一支笔，好像从工具箱里挑个榔头斧头似的，然后卷起衣袖，仿佛要抓起撬棍、抡起大锤一般。乔在动笔之前，先得用左臂使劲抵住桌子，把右腿老远伸在身后；既经动笔以后，只见凡是朝下的笔画，他每一笔都要划上好半天，我看这一笔大概总有五六尺长；要是朝上的笔画，那简直连墨水四溅的声音都听得见。 9948-9949, 标注, 2024 年 10 月 2","date":"2024-10-19","objectID":"/%E7%AC%94%E8%AE%B0%E8%BF%9C%E5%A4%A7%E5%89%8D%E7%A8%8B%E6%8F%92%E5%9B%BE%E7%8F%8D%E8%97%8F%E7%89%88-%E8%8B%B1-%E6%9F%A5%E5%B0%94%E6%96%AF%E7%8B%84%E6%9B%B4%E6%96%AF/:0:0","tags":["yuandaqianch","note","ireader"],"title":"[笔记]远大前程:插图珍藏版-[英] 查尔斯·狄更斯","uri":"/%E7%AC%94%E8%AE%B0%E8%BF%9C%E5%A4%A7%E5%89%8D%E7%A8%8B%E6%8F%92%E5%9B%BE%E7%8F%8D%E8%97%8F%E7%89%88-%E8%8B%B1-%E6%9F%A5%E5%B0%94%E6%96%AF%E7%8B%84%E6%9B%B4%E6%96%AF/"},{"categories":null,"content":" 474-476, 标注, 2024 年 10 月 14 日星期一 下午 6:57:20 “这条铁路有几里长呀？”那个时候，奇怪的是，他感觉自己以前好像经历过这个瞬间。分明就是在那里，那个样子。自己和一个脸晒得黑红的女孩站在那里，接着传来了汽笛声，好像还有一只喜鹊往西飞走了…… 637-640, 标注, 2024 年 10 月 14 日星期一 下午 7:08:29 祖母说，以前她一直觉得曾祖母对高祖母的感情是一种负罪感。但后来她才知道，曾祖母对高祖母只有深深的思念。想撒撒娇、想要抱抱、想耍赖皮、想得到很多爱、想喊“妈妈，妈妈”，但她只能一一锁起这些心情生活。曾祖母看着祖母喊出妈妈的时候，想起了高祖母说过的话。“好吧，你走吧。下辈子我就做你的女儿。到时候我们再见。到时候再见。” 1151-1153, 标注, 2024 年 10 月 14 日星期一 下午 10:09:46 当地球的寿命结束，再过一段更长的时间，到熵值最大的那一瞬间，时间也会消失。那时，人类会成为连自己曾经在宇宙停留过的事实都不记得的种族，宇宙会变成再也没有一颗心记得他们的地方。这便是我们的最终结局。 1163-1164, 标注, 2024 年 10 月 15 日星期二 上午 7:35:48 所以我只能对它们保持沉默——在不肯倾听自己声音的父母身边长大的孤独，以及和对我没有感情的配偶一起生活的孤独。 1338-1340, 标注, 2024 年 10 月 15 日星期二 上午 7:46:10 新雨大婶把丝线套在祖母的双手上，然后往绕线板上缠线。祖母轻轻晃动着双手，同时望着新雨大婶整齐地将线缠到线板上。偶尔两人对视一下，新雨大婶的脸上就会露出灿烂的笑容。有时干完活她们就玩挑花线游戏，两个人用线可以挑出许多好看的花样，年幼的祖母觉得神奇极了。 2319-2321, 标注, 2024 年 10 月 15 日星期二 下午 6:53:54 曾祖母的话音刚落，阿春就从地上站了起来，逐个闻了一下每个人身上的味道，然后便往家的方向走去，直到走出很远才回头看了一眼。祖母担心阿春再返回来，不敢叫它的名字。看着阿春远去的背影，祖母无声地哭了，脖子上的围巾都湿透了。从那以后再也没有人提起过阿春。 2467-2467, 标注, 2024 年 10 月 15 日星期二 下午 7:31:51 吃了感冒药睡觉就会做一些彩色的梦。 2550-2552, 标注, 2024 年 10 月 15 日星期二 下午 7:40:22 她尽量不去想，但还是想起了留在开城的阿春。一路上避难看到的那些情景在眼前一一掠过，她尽量不让自己去想，但站在屋檐下看着雨的时候，深藏在内心的思绪就像一直都在等待一个出口那样，接踵而至。那些不可能变出一粒米，也不可能变出一片柴的毫无用处的思绪。 2550-2552, 标注, 2024 年 10 月 15 日星期二 下午 7:40:48 一路上避难看到的那些情景在眼前一一掠过，她尽量不让自己去想，但站在屋檐下看着雨的时候，深藏在内心的思绪就像一直都在等待一个出口那样，接踵而至。那些不可能变出一粒米，也不可能变出一片柴的毫无用处的思绪。 2866-2869, 标注, 2024 年 10 月 15 日星期二 下午 9:08:27 但是那天祖母感到了不安。一种在放松警惕的时候、缺乏紧张的时候、以为不会有什么事的时候、摆脱悲观想法的时候、享受某个瞬间的时候，就会担心不好的事情再次降临的不安。祖母总觉得，因为即将发生的事情而战战兢兢的时候，即使暂时风平浪静，可只要稍微放松一些，就会挨一记闷棍，这就是生活。 3621-3622, 标注, 2024 年 10 月 16 日星期三 上午 7:48:53 我说着自己以前从未说过的恶言恶语，却感觉自己受到了这些话的暴击，可是他并没有因为我的话而受伤或内疚。我说出的那些话从他那不接纳任何事物的光滑表面被弹回来，打到了我自己的身上。 3918-3922, 标注, 2024 年 10 月 16 日星期三 上午 8:06:03 妈妈说过，平凡的生活就是最好的生活。还说因为和爸爸结婚，自己也组建了平凡的家庭，因此她很高兴。以前我不太理解总是把这些话挂在嘴边的妈妈。我在脑海里画了一个圈，在里面写下“平凡”这个词。与其他人没什么不同的人生、不突出的人生、不显眼的人生，因此是不会成为任何话题、不会受到任何评价或审判、不会被排挤的人生。不管那个圆圈有多么狭小和令人感到痛苦，都不能从里面出来。也许这就是妈妈的信仰吧。 4248-4249, 标注, 2024 年 10 月 16 日星期三 下午 1:25:12 你的朋友三川为了活着，一辈子都在寻找生路。像野兽一样，像以泥土和尘芥为食的虫子一样，一辈子都在寻找生路。 4305-4307, 标注, 2024 年 10 月 16 日星期三 下午 1:28:33 我想，就是这种看似微不足道的心意，有时也会给人以活下去的力量。不管是对于靠在别人肩膀上的人，还是把肩膀借给别人的人。就像一缕阳光从云缝里照出来，这种心意也再次降临到了我的身上。我很欣慰。 4320-4321, 标注, 2024 年 10 月 16 日星期三 下午 1:30:12 她和喜子已经十年没见过面了，她几乎无法想象喜子的生活。喜子也一样，她们之间没有现实的公分母。 4493-4495, 标注, 2024 年 10 月 16 日星期三 下午 4:19:55 不知从什么时候起，妈妈开始对祖母说敬语。祖母看到别的孩子惹是生非、闯了祸以后，一边喊着“妈妈，妈妈”一边挂到自己妈妈身上时，总是感到很羡慕。 4510-4513, 标注, 2024 年 10 月 16 日星期三 下午 4:24:37 “反抗的话会挨两拳、三拳，而且不会赢。不反抗的话，挨一拳就可以结束。”我想起了说这话时的妈妈的脸。“输也是赢。”“如果因为别人欺负你，就跟他们一样使坏的话，你也会变成和他们一样的人。”“扼杀自己就可以活下去。”这些话充满了失败感，因为认定了就算反抗也不可能赢，于是早早地缴械投降。 4550-4551, 标注, 2024 年 10 月 16 日星期三 下午 6:33:56 她对微不足道的事情也喜欢感叹，我常常想，她以后的人生该有多丰富啊。今后的日子里每当有好事发生，她就会说‘哇’。那曾是我的希望。” 4595-4596, 标注, 2024 年 10 月 16 日星期三 下午 6:37:03 她行动比较慢，但没有问题，请不要一直催促，孩子会有压力的； 4732-4738, 标注, 2024 年 10 月 16 日星期三 下午 6:45:12 在梦中，曾祖母深夜里坐在老家的屋顶上仰望月亮。“祖母！”妈妈大声叫着，曾祖母却不看妈妈，只望着月亮。妈妈跺着脚又说：“祖母！我是美仙啊！”然后又叫了一声曾祖母。妈妈发现，自己又变成了对曾祖母说平语的小孩子。“你看看我啊，祖母！”妈妈哀求着，这时曾祖母才回过头来。曾祖母的脸在月光下面闪着光辉。“祖母讨厌我吗？”母亲问。曾祖母似乎觉得这句话很有趣，脸上露出微笑。“祖母很讨厌我吧？”妈妈哽咽着再次问道，这时曾祖母开口了。妈妈一下醒了过来。 4742-4746, 标注, 2024 年 10 月 16 日星期三 下午 6:46:11 每当妈妈想到为了不被折磨，每一刻都要拼尽全力坚持下去的时候，总觉得自己是孤身一人。心里想着“该回家了，该回家了”，脚步却总是不由自主，经常去海边。每当这时，曾祖母就会去找妈妈。妈妈还记得曾祖母在天黑的海边一边喊着“美仙啊，美仙啊”，一边走过来时的样子。妈妈记住了当时的喜悦，以及受到压抑的心情变得轻松起来的感觉。最重要的是，还有那种“我也有人牵挂”的心声。 4780-4783, 标注, 2024 年 10 月 16 日星期三 下午 6:48:21 晚秋时节妈妈带我去大邱避难，她浑身瑟瑟发抖，还一直开着玩笑。我知道妈妈不是因为冷，而是因为害怕而发抖。她一生都是这样，即便浑身颤抖着，也要牵着我的手往前走。妈妈是我一生中最爱的人，即使她怕得发抖，还是步履不停。我想变得像妈妈那样。 4823-4825, 标注, 2024 年 10 月 16 日星期三 下午 6:50:53 我经常想起新雨大婶对金喜子博士说过的话——尽可能地走远一些。这句话指的绝不仅仅是物理上的距离，大婶一定是希望自己的女儿能去另一个维度的世界。她希望在自己所感受到的现实重力无法起作用的地方，女儿能够变得更加轻松，更加自由。 4839-4845, 标注, 2024 年 10 月 16 日星期三 下午 6:52:51 我既是现在的自己，也是三岁时的自己，同时还是十七岁时的自己。我轻易便抛弃了自己，但被我抛弃的自己并没有消失，而是一直留在我的心里。她在等着我，希望得到我的而不是其他人的关心；期望得到我的而不是别人的安慰。我常常闭上眼睛，寻找年幼的姐姐和自己。有时我会牵起她们的手，有时会坐在日落的游乐场的长椅上和她们聊天。我走近在空荡荡的家里准备独自上学的十岁的我、吊在单杠上忍住眼泪的上中学时的我、和伤害自己身体的冲动做斗争的二十岁的我、原谅了随意对待我的配偶的我，以及无法原谅这样的自己而忍不住自我攻击的我，倾听着她们的声音。是我，我在听。把你长久以来想说的话都告诉我吧。 4871-4873, 标注, 2024 年 10 月 16 日星期三 下午 6:54:41 对我来说，过去的两年是我长大成人后最艰难的一段时光。那段日子里，我有一半的时间没能写作，剩下的时间则都在写《明亮的夜晚》。那个时期的我好像不是人，而是像个被打一下就会倾泻而出的水袋。写这部小说的过程，也是我重新获得自己的身体，接纳自己的内心，成为一个人的","date":"2024-10-16","objectID":"/%E7%AC%94%E8%AE%B0%E6%98%8E%E4%BA%AE%E7%9A%84%E5%A4%9C%E6%99%9A-%E5%B4%94%E6%81%A9%E8%8D%A3/:0:0","tags":["mingliangdey","note","ireader"],"title":"[笔记]明亮的夜晚-崔恩荣","uri":"/%E7%AC%94%E8%AE%B0%E6%98%8E%E4%BA%AE%E7%9A%84%E5%A4%9C%E6%99%9A-%E5%B4%94%E6%81%A9%E8%8D%A3/"},{"categories":null,"content":" Table of Contents 1 一 2 二 3 三 ","date":"2024-10-16","objectID":"/wechat-%E6%98%8E%E4%BA%AE%E7%9A%84%E5%A4%9C%E6%99%9A%E6%89%80%E6%84%9F/:0:0","tags":["wechat","tag2"],"title":"明亮的夜晚所感","uri":"/wechat-%E6%98%8E%E4%BA%AE%E7%9A%84%E5%A4%9C%E6%99%9A%E6%89%80%E6%84%9F/"},{"categories":null,"content":"1 一 刚刚读完了韩国作家崔恩荣的《明亮的夜晚》，作者以细腻的笔法，将八十年来几代人的故事娓娓道来： 和丈夫离婚后，三十一岁的我独自来到海边小城熙岭，却在那里邂逅多年未见的祖母。尴尬和沉默之后，孤独的心一点点靠近，我和祖母成为相互倾吐心声的朋友。在祖母家老屋的旧相册里，我发现一位和我长相非常相似的女子，依偎在少女时代的祖母身旁。一个个鲜活的面孔逐渐从一张张黑白相片中，从一封封感人至深的书信中，从久远的回忆里，穿过女人生如飘萍、命如草芥的时代，走到我面前。经过曾祖母、祖母和母亲，来到我身边的故事，她们的人生在我的眼前重现。现在的我能够触及她们吗? 正如过去无数的我组成了现在的我，现在的我也能见到过去的无数个我吗？ 我是在上下班时间，在地铁上陆续读完的，也许是因为最近的压力太大而变得神经兮兮、多愁善感，看的过程中，多次眼角湿润，几欲落泪。 ","date":"2024-10-16","objectID":"/wechat-%E6%98%8E%E4%BA%AE%E7%9A%84%E5%A4%9C%E6%99%9A%E6%89%80%E6%84%9F/:1:0","tags":["wechat","tag2"],"title":"明亮的夜晚所感","uri":"/wechat-%E6%98%8E%E4%BA%AE%E7%9A%84%E5%A4%9C%E6%99%9A%E6%89%80%E6%84%9F/"},{"categories":null,"content":"2 二 但是那天祖母感到了不安。一种在放松警惕的时候、缺乏紧张的时候、以为不会有什么事的时候、摆脱悲观想法的时候、享受某个瞬间的时候，就会担心不好的事情再次降临的不安。祖母总觉得，因为即将发生的事情而战战兢兢的时候，即使暂时风平浪静，可只要稍微放松一些，就会挨一记闷棍，这就是生活。 这不就是我现在的状态吗。。。 我既是现在的自己，也是三岁时的自己，同时还是十七岁时的自己。我轻易便抛弃了自己，但被我抛弃的自己并没有消失，而是一直留在我的心里。她在等着我，希望得到我的而不是其他人的关心；期望得到我的而不是别人的安慰。我常常闭上眼睛，寻找年幼的姐姐和自己。有时我会牵起她们的手，有时会坐在日落的游乐场的长椅上和她们聊天。我走近在空荡荡的家里准备独自上学的十岁的我、吊在单杠上忍住眼泪的上中学时的我、和伤害自己身体的冲动做斗争的二十岁的我、原谅了随意对待我的配偶的我，以及无法原谅这样的自己而忍不住自我攻击的我，倾听着她们的声音。 是我，我在听。把你长久以来想说的话都告诉我吧。 晚秋时节妈妈带我去大邱避难，她浑身瑟瑟发抖，还一直开着玩笑。我知道妈妈不是因为冷，而是因为害怕而发抖。她一生都是这样，即便浑身颤抖着，也要牵着我的手往前走。妈妈是我一生中最爱的人，即使她怕得发抖，还是步履不停。我想变得像妈妈那样。 ","date":"2024-10-16","objectID":"/wechat-%E6%98%8E%E4%BA%AE%E7%9A%84%E5%A4%9C%E6%99%9A%E6%89%80%E6%84%9F/:2:0","tags":["wechat","tag2"],"title":"明亮的夜晚所感","uri":"/wechat-%E6%98%8E%E4%BA%AE%E7%9A%84%E5%A4%9C%E6%99%9A%E6%89%80%E6%84%9F/"},{"categories":null,"content":"3 三 你的朋友三川为了活着，一辈子都在寻找生路。像野兽一样，像以泥土和尘芥为食的虫子一样，一辈子都在寻找生路。 也许人生本来就是充满磨难，早年的快意生活本来就是不常有的吧。不管怎样，坚持下去： 当苦到极点和难到极点的时候，最需要的不是力气，更不是放弃，而是坚忍和打脱牙和血吞的精神。 ","date":"2024-10-16","objectID":"/wechat-%E6%98%8E%E4%BA%AE%E7%9A%84%E5%A4%9C%E6%99%9A%E6%89%80%E6%84%9F/:3:0","tags":["wechat","tag2"],"title":"明亮的夜晚所感","uri":"/wechat-%E6%98%8E%E4%BA%AE%E7%9A%84%E5%A4%9C%E6%99%9A%E6%89%80%E6%84%9F/"},{"categories":null,"content":" Table of Contents 1 Before C++17 2 Converting From Characters to Numbers: from_chars 2.1 示例 3 性能 4 C++23 更新 5 C++26 更新 6 C++ 中对 std::from_chars 的编译器支持 7 总结 本文为摘录(或转载)，侵删，原文为： https://www.cppstories.com/2018/12/fromchars/ 随着引入 C++17，C++标准库通过添加 std::from_chars 来扩展了将文本转换为数字的功能。这个低级、高性能的 API 相较于以前的方法（如 atoi 和 stringstream）提供了显著的优势。在本文中，我们将探讨从 C++17 到 C++26 的字符串转换程序的演变，重点突出了诸如 constexpr 支持和改进的错误处理等关键改进。让我们深入了解细节，看看 std::from_chars 如何可以改变您对字符串转换的方法。 ","date":"2024-10-14","objectID":"/www_cppstories_com_fromchars/:0:0","tags":["cpp","string","convert"],"title":"C++ String Conversion: Exploring std::from_chars in C++17 to C++26","uri":"/www_cppstories_com_fromchars/"},{"categories":null,"content":"1 Before C++17 sprintf / snprintf sscanf atol strtol strstream stringstream to_string stoi 等函数 而在 C++17 中，新增了一种选项： std::from_chars ！为什么需要新方法？难道旧方法不够好吗？ 新的转换例程具有以下特点： 不抛出异常 不分配内存 不支持本地化 内存安全 错误报告提供有关转换结果的额外信息 虽然 API 可能不太友好，但很容易封装为外观模式。 一个简单的示例： const std::string str { \"12345678901234\" }; int value = 0; std::from_chars(str.data(), str.data() + str.size(), value); // 省略了错误检查... ","date":"2024-10-14","objectID":"/www_cppstories_com_fromchars/:1:0","tags":["cpp","string","convert"],"title":"C++ String Conversion: Exploring std::from_chars in C++17 to C++26","uri":"/www_cppstories_com_fromchars/"},{"categories":null,"content":"2 Converting From Characters to Numbers: from_chars std::from_chars ，在 \u003ccharconv\u003e 头文件中可用，是一组重载函数：用于整数类型和浮点类型。 对于整数类型，我们有以下函数： std::from_chars_result from_chars(const char/ first, const char/ last, TYPE \u0026value, int base = 10); 其中，TYPE 展开为所有可用的有符号和无符号整数类型以及 char。 base 可以是从 2 到 36 的数字。 然后是浮点数版本： std::from_chars_result from_chars(const char/ first, const char/ last, FLOAT_TYPE\u0026 value, std::chars_format fmt = std::chars_format::general); FLOAT_TYPE 展开为 float 、 double 或 long double 。 chars_format 是一个枚举，包含以下值： scientific、 fixed、 hex 和 general（是 fixed 和 scientific 的组合）。 所有这些函数（对于整数和浮点数）的返回值是 from_chars_result ： struct from_chars_result { const char/ ptr; std::errc ec; }; from_chars_result 包含有关转换过程的信息。 以下是总结： Table 1: caption | 返回条件 || from_chars_result 的状态 | |——|—————————————————————————-| | 成功 || ptr 指向第一个不匹配模式的字符，或者如果所有字符匹配则为 last 的值，并且 ec 为值初始化状态。 | | 无效转换 || ptr 等于 first，ec 等于 std::errc::invalid_argument。value 未被修改。 | | 超出范围 || 数字太大，无法装入值类型。ec 等于 std::errc::result_out_of_range，ptr 指向第一个不匹配的字符。value 未被修改。 | ","date":"2024-10-14","objectID":"/www_cppstories_com_fromchars/:2:0","tags":["cpp","string","convert"],"title":"C++ String Conversion: Exploring std::from_chars in C++17 to C++26","uri":"/www_cppstories_com_fromchars/"},{"categories":null,"content":"2.1 示例 以下是使用 from_chars 将字符串转换为数字的两个示例，一个是整数一个是浮点数。 2.1.1 整数类型 #include \u003ccharconv\u003e // from_char, to_char #include \u003cstring\u003e #include \u003ciostream\u003e int main() { const std::string str { \"12345678901234\" }; int value = 0; const auto res = std::from_chars(str.data(), str.data() + str.size(), value); if (res.ec == std::errc()) { std::cout \u003c\u003c \"value: \" \u003c\u003c value \u003c\u003c \", distance: \" \u003c\u003c res.ptr - str.data() \u003c\u003c '\\n'; } else if (res.ec == std::errc::invalid_argument) { std::cout \u003c\u003c \"invalid argument!\\n\"; } else if (res.ec == std::errc::result_out_of_range) { std::cout \u003c\u003c \"out of range! res.ptr distance: \" \u003c\u003c res.ptr - str.data() \u003c\u003c '\\n'; } } 这个示例很简单，它将一个字符串 str 传递给 from_chars，然后在可能的情况下显示结果并提供附加信息。 你的任务是在编译器资源管理器中运行这段代码。 “12345678901234” 能够装入这个数字吗？或者你是否看到一些来自转换 API 的错误？ 2.1.2 浮点数 这里是浮点数版本： #include \u003ccharconv\u003e // from_char, to_char #include \u003cstring\u003e #include \u003ciostream\u003e int main() { const std::string str { \"16.78\" }; double value = 0; const auto format = std::chars_format::general; const auto res = std::from_chars(str.data(), str.data() + str.size(), value, format); if (res.ec == std::errc()) { std::cout \u003c\u003c \"value: \" \u003c\u003c value \u003c\u003c \", distance: \" \u003c\u003c res.ptr - str.data() \u003c\u003c '\\n'; } else if (res.ec == std::errc::invalid_argument) { std::cout \u003c\u003c \"invalid argument!\\n\"; } else if (res.ec == std::errc::result_out_of_range) { std::cout \u003c\u003c \"out of range! res.ptr distance: \" \u003c\u003c res.ptr - str.data() \u003c\u003c '\\n'; } } ","date":"2024-10-14","objectID":"/www_cppstories_com_fromchars/:2:1","tags":["cpp","string","convert"],"title":"C++ String Conversion: Exploring std::from_chars in C++17 to C++26","uri":"/www_cppstories_com_fromchars/"},{"categories":null,"content":"3 性能 我做了一些基准测试，新例程速度非常快！ 一些数字： 在 GCC 上，它比 stoi 快大约 4.5 倍，比 atoi 快大约 2.2 倍，比 istringstream 快近 50 倍。 在 Clang 上，它比 stoi 快大约 3.5 倍，比 atoi 快 2.7 倍，比 istringstream 快 60 倍！ MSVC 的性能比 stoi 快约 3 倍，比 atoi 快约 2 倍，比 istringstream 快近 50 倍。 你可以在我的 C++17 书籍中找到这些结果：《C++17 详细信息》。 ","date":"2024-10-14","objectID":"/www_cppstories_com_fromchars/:3:0","tags":["cpp","string","convert"],"title":"C++ String Conversion: Exploring std::from_chars in C++17 to C++26","uri":"/www_cppstories_com_fromchars/"},{"categories":null,"content":"4 C++23 更新 在 C++23 中，我们为我们的函数得到了一个改进：P2291 std::to_chars() 和 std::from_chars() 的整数重载现在是 constexpr 。 它已经在 GCC 13、Clang 16 和 MSVC 19.34 中实现。 与 std::optional 一起，它还可以在 constexpr 上下文中工作，我们可以创建以下示例： #include \u003ccharconv\u003e #include \u003coptional\u003e #include \u003cstring_view\u003e constexpr std::optional\u003cint\u003e to_int(std::string_view sv) { int value {}; const auto ret = std::from_chars(sv.begin(), sv.end(), value); if (ret.ec == std::errc{}) return value; return {}; }; int main() { static_assert(to_int(\"hello\") == std::nullopt); static_assert(to_int(\"10\") == 10); } 在编译器资源管理器中运行 ","date":"2024-10-14","objectID":"/www_cppstories_com_fromchars/:4:0","tags":["cpp","string","convert"],"title":"C++ String Conversion: Exploring std::from_chars in C++17 to C++26","uri":"/www_cppstories_com_fromchars/"},{"categories":null,"content":"5 C++26 更新 这项工作尚未完成，在 C++26 中看起来我们将有更多的添加： 查看 P2497R0，这个提案已经被接受并包含在 C++26 的工作草案中： 对 \u003ccharconv\u003e 函数成功或失败的测试 这一功能已在 GCC 14 和 Clang 18 中实现。 简而言之，from_chars_result（以及 to_chars_result）获得了一个 bool 转换运算符： constexpr explicit operator bool() const noexcept; 它必须返回 ec = std::errc{}= 。 这意味着我们的代码可能会更简单： if (res.ec == std::errc()) { ... } 可以变成： if (res) { ... } 例如： // ... const auto res = std::from_chars(str.data(), str.data() + str.size(), value, format); if (res) { std::cout \u003c\u003c \"value: \" \u003c\u003c value \u003c\u003c \", distance: \" \u003c\u003c res.ptr - str.data() \u003c\u003c '\\n'; } // ... ","date":"2024-10-14","objectID":"/www_cppstories_com_fromchars/:5:0","tags":["cpp","string","convert"],"title":"C++ String Conversion: Exploring std::from_chars in C++17 to C++26","uri":"/www_cppstories_com_fromchars/"},{"categories":null,"content":"6 C++ 中对 std::from_chars 的编译器支持 Visual Studio： 完全支持 std::from_chars 是在 Visual Studio 2019 版本 16.4 中引入的，浮点支持从 VS 2017 版本 15.7 开始。Visual Studio 2022 包含了 C++23 功能，如对整数重载的 constexpr 支持。 GCC： 从 GCC 11.0 开始，std::from_chars 提供完整支持，包括整数和浮点转换。最新的 GCC 版本，比如 GCC 13，包含 constexpr 整数支持。 Clang： Clang 7.0 引入了对整数转换的初始支持。Clang 16 及以上支持整数重载的 constexpr。 获取最准确和最新的信息，请查看 CppReference、编译器支持。 ","date":"2024-10-14","objectID":"/www_cppstories_com_fromchars/:6:0","tags":["cpp","string","convert"],"title":"C++ String Conversion: Exploring std::from_chars in C++17 to C++26","uri":"/www_cppstories_com_fromchars/"},{"categories":null,"content":"7 总结 如果你想将文本转换为数字，并且不需要任何额外的功能，如区域设置支持，那么 std::from_chars 可能是最好的选择。它提供了很好的性能，而且更重要的是，你将获得关于转换过程的大量信息（例如扫描了多少个字符）。 这些例程在解析 JSON 文件、三维文本模型表示（如 OBJ 文件格式）等方面可能特别有用。 而且新函数甚至可以在编译时使用（截至 C++23），并且在 C++26 中具有更好的错误检查功能。 ","date":"2024-10-14","objectID":"/www_cppstories_com_fromchars/:7:0","tags":["cpp","string","convert"],"title":"C++ String Conversion: Exploring std::from_chars in C++17 to C++26","uri":"/www_cppstories_com_fromchars/"},{"categories":null,"content":" 17737-17739, 标注, 2020 年 9 月 7 日星期一 下午 10:18:09 那句什么“我变秃了、也变强了”，简直是天大的笑话，这是对所有日夜操劳的小喽啰们最大的欺骗。 事实证明，你只能变秃，很难变强。 ","date":"2024-10-09","objectID":"/%E7%AC%94%E8%AE%B0%E4%B9%9D%E6%98%9F%E6%AF%92%E5%A5%B6-unknown/:0:0","tags":null,"title":"[笔记]《九星毒奶》-Unknown","uri":"/%E7%AC%94%E8%AE%B0%E4%B9%9D%E6%98%9F%E6%AF%92%E5%A5%B6-unknown/"},{"categories":null,"content":" 383-586, 标注, unknown 中国的工人、杂工以及职员击败其他来自外地的人，他们凭着毅力、自给自足和廉价，没有什么人能与其竞争。中国人不知道什么是休息时间，什么是星期日，他们从早工作到晚，日复一日年复一年。他们从来不觉得自己需要休息，他们能够不间断地进行机械的工作， 而欧洲工人持续那么久时间工作就会发疯。总之，中国人永远快乐，总是开朗乐观，似乎他们从来没有想过能过更美好的生活。 588-688, 标注, unknown 中国人赚钱赚得很少，但是他们需要的比他们赚的更少。你会有一个印象：这些人只靠一半的工作量就可以过活，你不明白的是，他们为何努力使自己变得苦不堪言 690-769, 标注, unknown 国家的公权力，只要官员愿意，要怎么使用就怎么使用。他可以不需要一点理由，轻而易举地就把一个记者送进大牢。 771-887, 标注, unknown 一个通晓中国各大城市天文地理的上海人说，汉口是全世界他最不想去的地方。他们的家畜猪到处玩耍，黑色的大母猪领着刚刚出生还没长 出毛的小猪，自由自在地在草皮上吃着主人留给它们的厨余。 889-1266, 标注, unknown 清朝的政治人物多半要花费大量的金钱来得到官位，上任之后不仅没有合理的官饷回报，还要定期向北京缴纳一定金额的费用；由于任期只 有短短的几年，他们就必须要在很短的时间里，想尽办法谋财图利，赚回他为获得官爵的投入偏偏中国并非是有什么虔诚信仰的民族，那些 文明之人是哲学家，大多数也是物质主义者，他们贪图金钱、地位与官位。 寺庙是为中国社会中下层人士和女人等弱势人群修建的，这也是为什么中国的僧人很少受到重视，社会地位也比较低的缘故在这个所有事物 自几百年来都一直枯燥单调，却又要求人们一成不变地去适应国家要求的国度，你如何要求社会进步呢？书本教条的执着已经将人心都石化 了，这就牺牲了其他艺术的发展空间。那些习惯于书中的虚幻生活的人，早就已经没有能力感受现实的强大，特别是在建筑中所能展现出来 的那种现实 1268-1408, 标注, unknown 人在青岛，一整天下来始终是被苍蝇围绕的，等到晚上又换成了蚊子来接班，苍蝇功成身退地去休息了。等到一晚过去蚊子吸饱血犯困了， 苍蝇又接着出现在你的眼前。蚊子和苍蝇就是这样轮班的，一个在晚上负责把人搞疯，另一个负责在白天把你搞晕。 1410-1607, 标注, unknown 河岸的左边是一个非常特殊的城市——塘沽，这里的人用河水泥土建造所有的东西，就连房舍也不例外。这座棕色的泥土城就立在棕色的泥地 上，看起来就好像是泥土的一部分似的说到挣钱，没有什么比直接把行李偷走更简单的了，但是，行李失窃的情形却几乎没有发生过，这也 证明中国苦力的诚实。同时，人们最后也慢慢体认到，苦力其实是中国人中，做事最正大光明的一群人 1609-2239, 标注, unknown 中国的那些红顶商人们，大多便是通过军火贸易来积攒财富的古来有之. 比如有一位德国商人，通过某位潜伏在北京的间谍得知，清政府打 算买进枪支。而他的仓库里正好有一万支老旧的废弃的普鲁士步枪，当初是用一支一个马克的价格买来的。于是，他就要向这位衔命负责枪 支采购的官员引介自己，向官员游说。 “要卖多少？”这位官员问道。 “咱们是老朋友了，就算您一支二十马克吧。就算是亲兄弟，也得卖上三倍的价格呢。” “你来迟喽！”这位官员回应说，“我刚刚才买了一万支英国来的枪支，一支只需要十个马克，这批货两周内就会到了。” “其实我也不想卖价超过十马克的呀。”商人解释道，“多出来的十马克，那是咱们的友谊！” “您还记得吗？孔老夫子曾说，‘朋友有通财之义’，我想了想，价格上每支枪多出来的五马克归您！剩下来的五马克，您就给同僚里负责采买 的那几位好了。我的枪确实只值十马克，但是我卖给中国政府的枪支优点在于，普鲁士人用它们打赢了每场战役。” 这位中国官员是位“爱国志士”，认为有责任让中国赢得战争，于是这批普鲁士步枪被订购了，原本的英国枪支也并没有被取消交易，显然， 他也参与了获利分配。不过这批枪支最终还是留在箱子里没有被打开，因为这位官员收到的谕令是购买一万支枪，而他以政府官员虚有其表 的良知遵守了这道命令。他付了两万支枪的钱，却只买回来一万支枪。这则故事最精彩之处在于，它可绝非一般人所认为的是出于杜撰。 2241-2487, 标注, unknown 一个位居高位的领导却从不为自己牟利，这就可能会把整个行政体制带入混乱。 由此可见，荫昌先生是不会成为居更高位的官员的。人们想要一次性就把所有错失的东西赢回来。但情况总是这样的，当长久以来的保守已 经到了某个极点时，可能一下就变得极端的激进。历史上所发生的事总是从一个极端到另一个极端，很少真正出现过渡的情况。在我们这里， 追求第一的意志昭然若揭。但是，我害怕在这样的急切追求中会丧失基础。而近来所发生的事情，带来的后果其实是一场大混乱。 2489-2651, 标注, unknown 荣禄在天津接任直隶总督时，针对所属的单位下了许多人事变动命令，但这似乎不是为了把无能的官吏扫地出门，而是为了替他的朋友和党羽把职位腾空。 我表示我正在进行一次从胶州到天津的旅行，并且，刻意强调了一下胶州，希望我的话能触碰到这位中国政治人物心中敏感的神经，使其对此发表意见 2653-2765, 标注, unknown 一个不具有强烈反抗意识、情愿臣属于他者的民族，是无法办成大事的北京是一座数百年来已不再成长的城市，街道的清扫留给风来负责， 冲洗则留给雨水。这两者清除不掉的，就让它留着吧 2767-2858, 标注, unknown 古老的中国步履艰难走过的那段岁月，学过历史的中国人都不会忘记。我们无法忘记国家贫弱时候的屈辱，因而才会更加珍惜国家富强之后的自豪 2860-2980, 标注, unknown 我发现他们这些人很有趣，当然他们也一定觉得我很有趣，因为我没有长辫子的头。我是个没有眯眯眼的怪物，他们这样想着且笑着。商人 通常都不是爱国者，他们为什么要爱一个什么都不能为他做的国家呢？ 2982-3083, 标注, unknown 中国大众对于最近的事件所知甚少，并且没有很多机会对公共生活的议题形成意见。不过，大众有什么想法也是多余的，官员们有意见就够 了。官员做事，人民听从！ 3085-3262, 标注, unknown 中国人几乎在所有的事情上，面对每个命令及每个命运都没有杂音，世界上没有比中国更温顺的民族了。但是，现在他们慢慢地变强了，那 就让他变强吧！他们经历过沉重的压迫与苦难，他们从不会与命运争执。为什么？好像每个人都能够承受，他们忍受要忍受的；当不再忍受 时，他们会耸耸肩说“maski！”然后，继续忍受着。 3264-3473, 标注, unknown 在中国别的城市，如果市民对政府有所不满，原则上政府会把市民丢到监狱里面去，但如果这件事发生在上海，市民们就会把政府推翻，然 后重新选举、另立一个政府现在到处都在建设的铁路，是否能够帮助中国实现现代化？许多迹象显示，最后的胜利都会属于新势力的一方， 接着便会开始大幅度进步，以数十年时间的努力来弥补数千年的差距，接着上海就会成为百万人口的大城，就像美国的芝加哥一样。 3475-3536, 标注, unknown 宁为活狗，莫为死狮。生年不满百，常怀千岁忧；昼短苦夜长，何不秉烛游” 3538-3779, 标注, unknown 这里的人们不单单只是为了鸦片而来，如果仅仅为了吸鸦片的话，那么他们大可待在自己的家里抽就好了，其实，主要还是为了社交。就像 是喝啤酒一样，一个人在家里也可以喝，但还是会有很多人去酒馆。啤酒就是要等到大家在一起高谈阔论时，到了一个振奋人心的情绪时刻 喝起来才痛快，人们才会感觉到它有一股特殊的风味。一般的平民女子很少裹小脚，剧场演出的大部分作品，都是明朝著名的英雄事迹（十 四至十七世纪），因为与当今朝代有关的表演都是被严格禁止的 3781-3854, 标注, unknown 中国的土地似乎有一半以上就像个大墓园，农夫要和死去的人争分土地，而且坟墓总是把最好的土地拿走 3856-4383, 标注, unknown 他特别希望施坦尼斯坦先生能够解释为什么中国军队在李鸿章聘用德国军事教官的教导下，还是在甲午战争中失败。施坦尼斯坦先生回答说： “其实原因很简单，天津的军事教官只是负责训练，对部队没有直接的指挥权。甲午战争中军队是由中国军官带领的，中国军官自身指挥能力 不足，导致无法展现出军队的战斗力。如果中国军队想要在未来作战中实施正确的军事指令，就势必要把这些军事教官看成是部队的上级长 官。” 张之洞听完，对此说法表示完全可以理解，并且，爽快地答应了这个指挥权的提议。太平天国之乱是当时已经没落的清朝宗亲八旗军队，与 各地起义军之间的战争，在一八五一年至一八六四年间，死亡人数高达两千万人，是人类历史上最血腥残暴的战争之一）终于出现了一支奇 怪的队伍，十二位将旗举得老高的旗手，领着一支队伍到来了。旗上细数李将军的丰功伟业及头衔，接着就看到轿子一台接着一台，最后， 终于有一匹马出现在视野里。两个马夫小心谨慎地驾驭着它，一个苦力正忙着替这匹骏马撑伞。紧接着看到马鞍上坐了一团红色不明物体， 这个物体就是李将军本人，因为下雨的关系，他把自己包裹了起来。他躲在多得难以计数的雨伞雨衣里，最外层竟然还裹着几条红毛毯 ","date":"2024-10-09","objectID":"/%E7%AC%94%E8%AE%B01898%E5%B9%B4%E7%9A%84%E5%A4%8F%E6%97%A5-n-a/:0:0","tags":["1898niandexi","note","ireader"],"title":"[笔记]1898年的夏日-N/A","uri":"/%E7%AC%94%E8%AE%B01898%E5%B9%B4%E7%9A%84%E5%A4%8F%E6%97%A5-n-a/"},{"categories":null,"content":" 630-630, 标注, 2024 年 10 月 1 日星期二 下午 10:15:12 Never hurry and never worry! 1653-1653, 标注, 2024 年 12 月 28 日星期六 下午 11:11:17 Charlotte died 1661-1661, 标注, 2025 年 1 月 1 日星期三 下午 10:29:46 congratulations 1661-1661, 笔记, 2025 年 1 月 1 日星期三 下午 10:30:11 2025.1.1 ","date":"2024-10-09","objectID":"/%E7%AC%94%E8%AE%B0charlottes-web-trophy-newbery-e.-b/:0:0","tags":["Charlotte's-","note","ireader"],"title":"[笔记]charlotte's web (trophy newbery) e. b","uri":"/%E7%AC%94%E8%AE%B0charlottes-web-trophy-newbery-e.-b/"},{"categories":null,"content":" 416-419, 标注, 2019 年 3 月 10 日星期日 下午 8:57:40 garden, bright and airy, where tall redwoods spread dappled shadows across tinkling streams, birds sang from hidden nests, and the air was spicy with the scent of flowers. The gods of Winterfell kept a different sort of wood. It was a dark, primal place, three acres of old forest untouched for ten thousand years as the gloomy castle rose around it. It smelled of moist earth and decay 769-769, 标注, 2019 年 3 月 11 日星期一 下午 10:01:07 They had found him still holding her body, silent with grief. 791-792, 标注, 2019 年 3 月 11 日星期一 下午 10:44:22 Some old wounds never truly heal, and bleed again at the slightest word. 828-829, 标注, 2019 年 3 月 11 日星期一 下午 10:58:18 Half of them don’t dare tell me the truth, and the other half can’t find it. 997-998, 标注, 2019 年 3 月 12 日星期二 下午 1:53:12 “Never forget what you are, for surely the world will not. Make it your strength. Then it can never be your weakness. Armor yourself in it, and it will never be used to hurt you.” 1000-1000, 标注, 2019 年 3 月 12 日星期二 下午 8:27:00 “All dwarfs are bastards in their father’s eyes.” 1121-1122, 标注, 2019 年 3 月 12 日星期二 下午 9:35:22 He is a sweet boy, quick to laugh, easy to love 1350-1350, 标注, 2019 年 3 月 13 日星期三 下午 7:44:19 halls slanted up and down so that you couldn’t even 1563-1564, 标注, 2019 年 3 月 13 日星期三 下午 10:01:48 Death is so terribly final, while life is full of possibilities.” 1664-1665, 标注, 2019 年 3 月 13 日星期三 下午 10:31:08 “Different roads sometimes lead to the same castle. 1986-1987, 标注, 2019 年 3 月 14 日星期四 下午 11:22:14 A man could not always be where he belonged, though. 2029-2030, 标注, 2019 年 3 月 15 日星期五 上午 7:14:58 The Lannisters never declined, graciously or otherwise. The Lannisters took what was offered. 2077-2078, 标注, 2019 年 3 月 15 日星期五 上午 7:58:13 My brother later killed that very same king, as it turns out, but life is full of these little ironies. 2080-2082, 标注, 2019 年 3 月 15 日星期五 上午 7:59:05 My mind is my weapon. My brother has his sword, King Robert has his warhammer, and I have my mind … and a mind needs books as a sword needs a whetstone, if it is to keep its edge.” 2404-2404, 标注, 2019 年 3 月 16 日星期六 上午 7:49:24 an animal takes after its master. 2809-2809, 标注, 2019 年 3 月 16 日星期六 下午 2:51:00 He was always clever, even as a boy, but it is one thing to be clever and another to be wise. 3095-3095, 标注, 2019 年 3 月 16 日星期六 下午 7:03:48 Jon knew that if it fell, the world fell with it. 3111-3112, 标注, 2019 年 3 月 16 日星期六 下午 7:07:42 Let them see that their words can cut you, and you’ll never be free of the mockery. If they want to give you a name, take it, make it your own. 3111-3113, 标注, 2019 年 3 月 16 日星期六 下午 7:07:52 Let them see that their words can cut you, and you’ll never be free of the mockery. If they want to give you a name, take it, make it your own. Then they can’t hurt you with it anymore.” 3342-3343, 标注, 2019 年 3 月 16 日星期六 下午 9:15:49 “Do you Starks have nought but snow between your ears?” 3356-3357, 标注, 2019 年 3 月 16 日星期六 下午 9:21:45 to drop that in the river and forget that it was ever forged.” Ned regarded him coldly. “Lord Baelish, I am a Stark of 3429-3430, 标注, 2019 年 3 月 17 日星期日 上午 3:55:36 “If a man paints a target on his chest, he should expect that sooner or later someone will loose an arrow at him. 3742-3742, 标注, 2019 年 3 月 17 日星期日 下午 4:36:46 When the snows fall and the white winds blow, the lone wolf dies, but the pack survives 3742-3743, 标注, 2019 年 3 月 17 日星期日 下午 4:37:14 When the snows fall and the white winds blow, the lone wolf dies, but the pack survives. Summer is the time for squabbles. In winter, we must protect one another, keep each other warm, share our strengths. 3758-3758, 标注, 2019 年 3 月 17 日星期日 下午 4:42:09 to Septa Mordane and asked for her 3808-3809, 标注, 2019 年 3 月 17 日星期日 下午 4:55:34 He had a neck and shoulders like a bull, and coarse black hair covered his arms and chest so thickly that there was none left for his head. 3809-3809, 笔记, 2019 年 3 月 17 日星期日 下午 4:55:50 太损了，作者 4021-4023, 标注, 2019 年 3 月 17 日星期日 下","date":"2024-10-09","objectID":"/%E7%AC%94%E8%AE%B0george-r.-r.-martins-a-game-of-thrones-5-book-boxed-set-george-r.r/:0:0","tags":["George-R.-R.","note","ireader"],"title":"[笔记]George R. R. Martin's A Game of Thrones 5-Book Boxed Set-George R.R. Martin","uri":"/%E7%AC%94%E8%AE%B0george-r.-r.-martins-a-game-of-thrones-5-book-boxed-set-george-r.r/"},{"categories":null,"content":" 104-107, 标注, 2019 年 6 月 14 日星期五 上午 8:12:33 写作即思考。写作其实就代表思考，你需要言之有物，需要架构需要梳理，要有开端有结尾有结论有主题，特别神奇的是你构思了一篇文章，写完后发现文章像具备了生命一样生长出了很多奇异的果实，它们就在那些文字中间微微颤动，闪烁着独特的光泽，仿佛被岁月冲刷过的鹅卵石一样，而这一切你可能完全没有想到过，而且不可复制。 503-504, 标注, 2019 年 6 月 14 日星期五 上午 9:23:14 人长大总是伴随着痛苦，现实变得越来越现实，那些无限可能都变成了没有可能或很小可能，这东西是很残酷的。当年我进入洪恩软件的时候，大概 24 岁，洪恩的总 503-504, 标注, 2019 年 6 月 14 日星期五 上午 9:23:19 人长大总是伴随着痛苦，现实变得越来越现实，那些无限可能都变成了没有可能或很小可能，这东西是很残酷的。 507-508, 标注, 2019 年 6 月 14 日星期五 上午 9:24:53 这时候你就会慢慢认识到，想取得什么样的成就，或者想成为什么样的人，除了通过长期艰苦的练习和有意识的提升，资质、环境、勇气、运气等同样重要。 510-511, 标注, 2019 年 6 月 14 日星期五 上午 9:25:20 其实都在，它们就藏在某个角落默默的等着，一旦你准备重新上路，它们就会跳出来，指引你前行。所以最重要的是你还想做事，而不是混世。 512-513, 标注, 2019 年 6 月 14 日星期五 上午 9:25:38 是把目前正在做的事情做好，如果你把不感兴趣的事情都做好了，一旦你找到自己的方向，那你得做得多好啊。 510-513, 标注, 2019 年 6 月 14 日星期五 上午 9:25:44 其实都在，它们就藏在某个角落默默的等着，一旦你准备重新上路，它们就会跳出来，指引你前行。所以最重要的是你还想做事，而不是混世。有人说不知道自己想做什么，那么最好的办法就是把目前正在做的事情做好，如果你把不感兴趣的事情都做好了，一旦你找到自己的方向，那你得做得多好啊。 510-511, 标注, 2019 年 6 月 14 日星期五 上午 9:25:58 其实都在，它们就藏在某个角落默默的等着，一旦你准备重新上路，它们就会跳出来，指引你 510-511, 标注, 2019 年 6 月 14 日星期五 上午 9:26:07 其实都在，它们就藏在某个角落默默的等着，一旦你准备重新上路，它们就会跳出来，指引你前行。所以最重要的是你还想做事，而不是混世 511-513, 标注, 2019 年 6 月 14 日星期五 上午 9:26:48 有人说不知道自己想做什么，那么最好的办法就是把目前正在做的事情做好，如果你把不感兴趣的事情都做好了，一旦你找到自己的方向，那你得做得多好啊。 515-517, 标注, 2019 年 6 月 14 日星期五 上午 9:27:34 到了 40 岁，该明白的都明白了，不明白的估计你也不想去明白了，所以就不惑了。但现实的情况是，如果你一直在思考、读书、实践，做自己认为对的事情，到了40岁，你会发现不是不惑，而是有了更多的惑。这种未知的恐惧可能会伴随我们的一生 ","date":"2024-10-09","objectID":"/%E7%AC%94%E8%AE%B0mactalk%E4%BA%BA%E7%94%9F%E5%85%83%E7%BC%96%E7%A8%8B-%E6%B1%A0%E5%BB%BA%E5%BC%BA/:0:0","tags":["MacTalk-rens","note","ireader"],"title":"[笔记]MacTalk·人生元编程-池建强","uri":"/%E7%AC%94%E8%AE%B0mactalk%E4%BA%BA%E7%94%9F%E5%85%83%E7%BC%96%E7%A8%8B-%E6%B1%A0%E5%BB%BA%E5%BC%BA/"},{"categories":null,"content":" 85-86, 标注, 2024 年 10 月 4 日星期五 上午 8:39:25 逆境塑造了我，我的痛苦阈值变得非常高。 242-243, 标注, 2024 年 10 月 4 日星期五 下午 5:14:49 从小时候开始，如果我要思考一些困难的问题，那么我所有的感官系统都会关闭。”埃隆说，“我看不到，也听不到任何东西。我在用大脑进行计算，而不是接收外界的信息。” 370-373, 标注, 2024 年 10 月 4 日星期五 下午 5:36:09 老师说：“他能迅速掌握新的数学概念。”但是在学生评价那一栏，老师给他的评语里总是出现同样的话：“他研究问题的速度极慢，要么是因为他耽于幻想，要么是他在做一些不该做的事。”“他干得有头有尾的事情凤毛麟角。明年他必须集中精力了，不要在课上做白日梦。”“ 377-378, 标注, 2024 年 10 月 4 日星期五 下午 5:36:51 我并不打算在我觉得毫无意义的事情上投入大量的精力，”埃隆说，“我宁愿去读书或者玩电子游戏。” 417-418, 标注, 2024 年 10 月 4 日星期五 下午 5:39:54 科幻小说是那种又打游戏、智力又超群的孩子获取智慧的源泉。 622-623, 标注, 2024 年 10 月 4 日星期五 下午 6:04:08 游戏策略的一个关键就是要保障可持续的资源供给，比如来自矿山的金属和取自森林的木材。 865-866, 标注, 2024 年 10 月 4 日星期五 下午 9:55:55 “伟大的东西永远不会在风险投资人和职业经理人手里诞生，”马斯克告诉《公司》杂志，“他们没有创造力，也没有洞察力。” 1149-1151, 标注, 2024 年 10 月 4 日星期五 下午 10:21:03 埃隆所做的就是在每一手牌上全押，输个精光，再买更多的筹码，加倍下注。最后，他输了许多手牌以后，又一次全押，赢了，然后他说：‘好，就这样吧，我不玩了。’” 1227-1228, 标注, 2024 年 10 月 4 日星期五 下午 10:39:53 埃隆是以使命为先导，过后再想办法填补财务方面的空缺，让项目在财务上变得可持续。”他说，“埃隆是在使命感的驱动下顺势而为，先行好事，后问前程。” 1490-1491, 标注, 2024 年 10 月 5 日星期六 上午 9:30:27 所有要求都应该被当成建议，不可变更的金科玉律只有那些物理学定律约束下的条件。 1771-1771, 标注, 2024 年 10 月 5 日星期六 下午 1:01:45 削足适履的 1876-1878, 标注, 2024 年 10 月 5 日星期六 下午 1:43:21 作为一个“造梗”大师，他有一种天赋，知道怎么在社交媒体上营造争议性话题，从而达到免费宣传的效果。不过面对批评的声音，他脸皮又很薄，面对他人的冷落轻视，他会耿耿于怀数年之久。 2131-2132, 标注, 2024 年 10 月 5 日星期六 下午 8:26:01 他母亲在密歇根州大急流城经营一家小型内衣店，只会说西班牙语，但她想办法用 300 美元给他买了 10 股。他至今仍然持有这些股票，现在的价值大约为 49 万美元。 2144-2146, 标注, 2024 年 10 月 5 日星期六 下午 8:27:46 让一家公司成功的不是产品本身，而是高效地制造产品的能力。这个问题其实就是，你怎么制造那些制造机器的机器。换句话说，你是怎么设计工厂的。” 2463-2465, 标注, 2024 年 10 月 5 日星期六 下午 8:56:51 对我来说，这就像你有两个孩子，快没吃的了，你可以给每个孩子分一半，但这样他们可能都会饿死，或者你把所有的食物给一个孩子，增加至少一个孩子存活的概率。但由我自己来决定一生一死，这种事我干不出来，所以我决定必须付出我的全部来拯救两个孩子。” 2528-2529, 标注, 2024 年 10 月 5 日星期六 下午 9:01:15 “好事多磨，四发必成” 2723-2725, 标注, 2024 年 10 月 5 日星期六 下午 9:27:31 设计不仅是美学问题。真正的工业设计必须将产品的外观与它的工程问题联系在一起。乔布斯曾经解释说：“在大多数人看来，设计就是徒有其表，但实际上没有什么工作能比设计的意义更深入。设计是人造产品的灵魂内核，它最终体现在人造物由表及里的所有层次当中。” 2941-2943, 标注, 2024 年 10 月 5 日星期六 下午 10:00:43 甲骨文创始人拉里·埃里森只加入了苹果和特斯拉两家公司的董事会，他与乔布斯和马斯克是亲密的朋友。他说这两个人都有强迫症，但是是好的那种。埃里森说：“强迫症是他们成功的原因之一，因为他们执着于解决一个问题，不达目的不罢休。” 3108-3110, 标注, 2024 年 10 月 5 日星期六 下午 10:19:47 安东尼奥·格拉西亚斯想给大家打打气，他说人生中失败带来的经验教训都是最宝贵的。“如果有的选，”马斯克回应道，“我宁愿从成功中学习这些经验。” 3348-3351, 标注, 2024 年 10 月 6 日星期日 下午 9:49:42 他有工程师般的头脑，但对人之常情知之甚少，他无法理解每年有 130 多万人死于交通事故，为什么特斯拉自动驾驶车辆造成一两起死亡事故就会引起公众的强烈不满。没有人统计自动驾驶预防了多少事故的发生、挽救了多少人的生命，也没有人评估过使用自动驾驶系统是不是比人类司机开车更安全。 3568-3569, 标注, 2024 年 10 月 6 日星期日 下午 10:40:45 她总结出的一个观点是，马斯克性格中对戏剧性冲突的迷恋潜滋暗长，是因为他需要大量的外部刺激来保持精力充沛。 3687-3688, 标注, 2024 年 10 月 6 日星期日 下午 10:53:26 “干活的第一步就应该是质疑 3859-3860, 标注, 2024 年 10 月 7 日星期一 上午 10:45:03 无论是在特斯拉还是在 SpaceX，在所有生产会议上，马斯克都会抓住机会，像念咒一样念叨他所谓的 “五步工作法” ： 1.质疑每项要求。提出任何一项要求时，都应该附上提出这一要求的人。永远不要接受一项来自某个部门的要求，比如来自“法务部门”或者“安全部门”的要求。你必须知道提出这项要求的人的名字。接下来你应该质疑它，不管这个人有多聪明。聪明人提出的要求才是最危险的，因为人们不太可能质疑他们。这件事要一直做下去，即便这项要求来自我马斯克本人。质疑后，大家就要改进要求，让它变得不那么愚蠢。 2.删除要求当中所有你能删除的部分和流程，虽然你可能还得把它们加回来。事实上，你如果最后加回来的部分还不到删除部分的 10%，那就说明你删减得还不够。 3.简化和优化。这应该放在第 2 步之后，因为人们常犯的错误就是简化和优化一个原本不应该存在的部分或者流程。 4.加快周转时间。每个流程都可以加快，但只有遵循了前三个步骤之后才能这么做。在特斯拉工厂，我错误地把很多精力花在加快生产流程上，后来我才意识到有些流程原本就应该被拿掉。 5.自动化。在内华达工厂和弗里蒙特工厂犯下的一个大错就是我一开始试图将每个步骤进行自动化改造。我们本应该先质疑所有要求，删除不必要的部分和流程，把问题筛出来、处理掉，然后再推进自动化。 3876-3878, 标注, 2024 年 10 月 7 日星期一 上午 10:47:11 • 所有技术经理都必须有实战经验，比如说软件团队的管理人员必须至少花 20%的时间进行编程，太阳能屋顶业务的经理必须花时间在屋顶上亲自做安装工作。否则光说不练，他们就像是不会骑马的骑兵队队长、不会舞刀弄枪的将军。 3878-3880, 标注, 2024 年 10 月 7 日星期一 上午 10:47:23 • “你好，我好，大家好”是很危险的，人们会因此不再质疑同事的工作成果。人们天然有一种倾向是不想把要好的同事踢下船，而这种危险倾向一定要避免。 3880-3881, 标注, 2024 年 10 月 7 日星期一 上午 10:47:29 犯错没关系，但错了还不肯低头就不行。 3881-3886, 标注, 2024 年 10 月 7 日星期一 上午 10:47:55 永远不要要求你的团队做你自己都不愿意做的事。 每当有问题需要解决时，不要只与你直接管理的相关负责人聊。深入调研就要跨层级沟通，去跟你属下的属下直接交流吧。 招聘要招态度端正的人。技能是可以教的，但要扭转一个人的工作态度可就太费劲了，得给他“换个脑子”。 疯狂的紧迫感是我们公司运作的法则。 唯一要遵守的规则就是物理学定律能推导出来的规则，其他一切都只是建议。 4035-4035, 标注, 2024 年 10 月 7 日星期一 上午 11:04:10 马斯克先生的情绪在笑声和泪水中跌宕起伏 4255-4256, 标注, 2024 年 10 月 7 日星期一 上午 11:22:28 如果他专注于某件事，外界刺激对他就无效，他不会接收外部输入的任何信息。一个东西可能就放在他眼前，但他看不到。 4387-4387, 标注, 2024 年 10 月 7 日星期一 上午 11:34:13 将一个目标远大的任务与一个务实的商业计划相结合。 4421-4422, 标注, 2024 年 10 月 7 日星期一 上午 11:36:45 当容科萨接手星链时，他抛弃了已有的设计思路，从第一性原理层面开始思考，根据基础物理学质疑每项要求。 4482-4483, 标注, 2024 年 10 月 7 日星期一 上午 11:42:35 Space","date":"2024-10-09","objectID":"/%E7%AC%94%E8%AE%B0%E5%9F%83%E9%9A%86%E9%A9%AC%E6%96%AF%E5%85%8B%E4%BC%A0-%E7%BE%8E%E6%B2%83%E5%B0%94%E7%89%B9%E8%89%BE%E8%90%A8%E5%85%8B%E6%A3%AE/:0:0","tags":["ailong-masik","note","ireader"],"title":"[笔记]埃隆·马斯克传 [美]沃尔特·艾萨克森","uri":"/%E7%AC%94%E8%AE%B0%E5%9F%83%E9%9A%86%E9%A9%AC%E6%96%AF%E5%85%8B%E4%BC%A0-%E7%BE%8E%E6%B2%83%E5%B0%94%E7%89%B9%E8%89%BE%E8%90%A8%E5%85%8B%E6%A3%AE/"},{"categories":null,"content":" 7220-7222, 标注, 2024 年 9 月 13 日星期五 下午 10:41:32 我的天空里没有太阳，总是黑夜，但并不暗，因为有东西代替了太阳。虽然没有太阳那么明亮，但对我来说已经足够。凭借着这份光，我便能把黑夜当成白天。你明白吧？我从来就没有太阳，所以不怕失去。” 3795-3795, 标注, 2024 年 9 月 13 日星期五 下午 11:07:38 我的人生就像在白夜里走路。 ","date":"2024-10-09","objectID":"/%E7%AC%94%E8%AE%B0%E7%99%BD%E5%A4%9C%E8%A1%8C-%E4%B8%9C%E9%87%8E%E5%9C%AD%E5%90%BE/:0:0","tags":["baiyexing","note","ireader"],"title":"[笔记]白夜行-东野圭吾","uri":"/%E7%AC%94%E8%AE%B0%E7%99%BD%E5%A4%9C%E8%A1%8C-%E4%B8%9C%E9%87%8E%E5%9C%AD%E5%90%BE/"},{"categories":null,"content":" 503-607, 标注, unknown 福楼拜不是一般意义上的小说家，他自称，他也确实是艺术家，文字的艺术家。他视文字、文学创作为生命，每一部作品，每一章，每一 节，每一句，都是呕心沥血的结果。 654-785, 标注, unknown 小说的形式和风格比其内容更加重要。他写得很慢，很苦，反复修改，要求每一个细节都来自仔细的观察或亲身体验，要求文字具有音乐 的节奏。（“一句好的散文应该同一句好诗一样，是不可改动的，是同样有节奏，同样响亮的。” 832-1148, 标注, unknown 城像圆剧场，一步比一步低，雾气笼罩，直到过了桥，才乱纷纷展开。再过去又是旷野，形象单调，越远越高，最后碰上灰天的模糊的基 线。全部风景，这样从高望去，平平静静，像煞一幅画。停锚的船只，堆在一个角落；河顺着绿岭弯来弯去；长方形的岛屿，如同几条大 黑鱼，停在水面，一动不动。工厂的烟筒冒出大团棕色的烟，随风飘散。教堂的尖顶突破浓雾，清越的钟声有冶铸厂的轰隆轰隆的响声伴 奏。马路的枯树，站在房屋中间，好像成堆的紫色荆棘一样。雨洗过的屋顶，由于市区有高有低，光色参差不齐。有时候，吹来一阵劲风， 浮云漂向圣·卡特琳岭，仿佛空气凝成波涛，冲击岸边绝崖，先是气势汹汹，转瞬就又销声匿迹了。 1204-1329, 标注, unknown 他什么也不懂；上课像腾云驾雾，听了也白听。但他还是很用功，一本本笔记装订成册，一堂课也不缺席，一次出诊也不拉下。他当天的 事当天了，却好似一匹拉磨的马，蒙住双眼绕着碾磨转圈，不知道磨的是什么东西。 1385-1495, 标注, unknown 夏尔对爱玛的恩爱，在她眼里就是对她的母爱的辜负，就是对她的尊严的亵渎；她闷不作声地看着儿子日子过得挺和美，犹如破了产的人 呆在窗口，瞧着人家在自己的老屋里围坐着吃饭。 1551-1706, 标注, unknown 屋顶的茅草往下垂，犹如皮帽翻下盖住眼睛，把低矮的窗户遮去近三分之一，窗玻璃厚厚的，中间凸起，就像酒瓶底儿。石灰墙面上，沿 斜角嵌着一根根黑色明梁，不时还有细瘦的梨树攀在上面，底层房门外加了扇矮矮的木栅门，小鸡能到门口啄食苹果酒泡过的面包屑，却 进不了屋子。 1762-1985, 标注, unknown 他俩沿着河岸走回永镇。一到夏季，陡峭的河岸就变宽了，看得见花园围墙的脚跟，沿墙有石阶通到水边。河水悄没声儿地流过，乍看上 去湍急而清凉；纤长的水草顺流偃伏，宛如随手扔在河里的绿发，平摊在清澈的水面上。灯心草的尖端或睡莲的叶片上，不时有个细脚伶 仃的虫子爬过或小憩。一绺绺阳光穿过水波泛起的气泡，蓝莹莹的小气泡一路躜赶一路迸碎。修过枝的老柳树在水中映出灰蒙蒙的倒影； 放眼望去，原野显得分外空旷 2041-2136, 标注, unknown 她那么忧郁，又那么宁静，那么动人，那么矜持，在她身边会让人感到一种玉洁冰清的美，犹如置身于教堂之中，透着大理石寒意的花香 叫人嗅着打颤。 2192-2434, 标注, unknown 正是四月初的天气，报春花绽开了蓓蕾；一阵和风拂过拾掇过的花圃，各家的花园就像女眷一样，仿佛都披上了盛装来迎接夏天的节日。 透过棚架眺望四周，只见原野上的那条河，若隐若现，一路迤逦在草地上勾勒出它的身影。暮霭弥漫在没有叶片的杨树枝丫之间，给它们 的轮廓染上朦朦胧胧的紫色，即便给枝丫装点上一层薄纱，也不会比这更淡雅、更透明。远处，成群的牲畜在行走；既听不见它们的脚步 声，也听不见它们的叫声；而教堂的钟声依然在回荡，显得柔和而凄婉。 2481-2658, 标注, unknown 从钟楼垂下的粗绳，直拖到地面，随着粗绳振幅的减小，钟声也渐渐变弱了。嘤嘤而鸣的燕群，骤然划破天空，急速飞回檐瓦下棕黄的窝 巢。教堂深处，亮着一盏灯，也就是说有根细细的灯芯，在悬空的玻璃罩里发出黯淡的光。远远望去，亮光如豆，在灯油上方颤悠。一绺 长长的阳光射进整座中殿，那些侧道和墙角就显得更加昏暗了。 2705-2760, 标注, unknown 圣保罗在传道时说：“我们进入神的国，必须经历许多艰难。” 2816-2983, 标注, unknown 周围的一切仿佛都笼罩着凄迷的雾气，它隐隐绰绰地在物件的外表上浮动；悲伤涌进她的心扉，带着哀怨的呻吟，有如冬天的风吹进废弃 的城堡。那是一种对逝去的时光怅然的梦寻，是在某事无可挽回地有了结局时感到的疲惫，总之，这就是习惯的节律一旦中断、持续的震 颤一旦停止时，您所会感到的那种痛苦。 3039-3375, 标注, unknown 她手里拿着这张糙纸，冥想了几分钟。信上拼写错误比比皆是，可爱玛感受得到那份拳拳的爱心，从字里行间流露出来，犹如母鸡在棘篱 后面探出身来咕咕地叫。信纸用炉灰吸过墨水，有些灰色粉末从纸上滑到她的裙上，她眼前浮现出父亲朝炉膛弯下身去拿火钳的情景。当 年待在他身边，坐在壁炉跟前的矮凳上，炉膛里芦苇劈劈啪啪烧得正旺，她拿根细棍搁进去看它烧，这些都是那么遥远的事了！……她 回想起那些红霞满天的夏日傍晚。小马驹一见旁边有人走过，就欢快地嘶鸣，奔到东，奔到西……她的窗前有个蜂箱，蜜蜂在阳光中嗡 嗡飞舞，有时猛不丁撞到玻璃窗上，像颗金色的弹子似的弹回去。那时候多么幸福！多么自由！那是满怀希望、沉湎在幻想中的年月！ 3432-3507, 标注, unknown 他的脑子里乱纷纷地闪过种种假设，思绪在这些假设上颠簸晃荡，犹如一只空桶在海上随波逐流，翻来滚去。 3564-3781, 标注, unknown 一轮浑圆的月亮，红嫣嫣的，从草场尽头的地面上升起。它在杨树枝丫间迅速上行，不时被密枝繁叶所遮蔽，宛如在一幅剜了好些洞的黑 色幕布后穿过。随后它又现了出来，显得分外皎洁，把一片清辉洒向寥廓的天空；而后，它冉冉穿行在夜空，圆圆的光影投射在河面上， 变成无数波光粼粼的小星星，银辉宛似披满闪亮鳞片的水蛇，蜿蜒迤逦钻向河底。这又像一盏巨大的枝形烛台，千万滴熔化的钻石连绵不 断地往下流淌。 3838-3920, 标注, unknown 凄哀的歌声，在低音提琴的伴奏下拖着长腔，犹如海难幸存者在风雨交加、波涛汹涌的海面上的哀号，占据了爱玛的全部身心 3977-4122, 标注, unknown 说来奇怪，包法利虽说不停地思念着爱玛，她的形象居然却想不起来了；他绝望地感到这个形象在从他的记忆中逸出，他拼命想留也留不 住。但他每夜都梦见她；总是同样的梦：他离她愈来愈近；可就在他要抱紧她的当口，她从他的怀里跌落下去，犹如化成了齑粉。 ","date":"2024-10-09","objectID":"/%E7%AC%94%E8%AE%B0%E5%8C%85%E6%B3%95%E5%88%A9%E5%A4%AB%E4%BA%BA-n-a/:0:0","tags":["baofalifuren","note","ireader"],"title":"[笔记]包法利夫人-N/A","uri":"/%E7%AC%94%E8%AE%B0%E5%8C%85%E6%B3%95%E5%88%A9%E5%A4%AB%E4%BA%BA-n-a/"},{"categories":null,"content":" 6554-6556, 标注, 2018 年 2 月 14 日星期三 上午 7:44:59 他们的面容，对奈德来说，曾如自己的脸庞一般熟悉，但岁月仿如水蛭，渐渐吸走了人们的记忆，即使是他一度发誓绝不忘记的部分也不例外。在梦里他们只剩幻影，宛如灰色的幽灵，骑在浓雾聚成的马上。 8047-8050, 标注, 2018 年 2 月 14 日星期三 下午 10:02:48 长夜将至，我从今开始守望，至死方休。我将不娶妻，不封地，不生子。我将不戴宝冠，不争荣宠。我将尽忠职守，生死于斯。我是黑暗中的利剑，长城上的守卫，抵御寒冷的烈焰，破晓时分的光线，唤醒眠者的号角，守护王国的坚盾。我将生命与荣耀献给守夜人，今夜如此，夜夜皆然。” 14361-14362, 标注, 2018 年 2 月 18 日星期日 下午 1:13:15 房间转。“倘若每个背誓者都发配来守长城，我就不愁人手不够了。” 21468-21473, 标注, 2018 年 2 月 21 日星期三 下午 3:25:56 来此的目的，”史坦尼斯说，“我给了你两个星期时间考虑我的条件，你也派了信鸦去讨救兵，结果没人来帮你，以后也不会有。风息堡只能孤军作战，而我的耐心已到了极限。我给你最后一次机会，爵士，我命令你打开城门，把按照权利属于我的财产交还于我。” “条件?”科塔奈爵士问。 “不变，”史坦尼斯说，“我赦免了你面前这些领主老爷，我也会饶恕你的叛逆罪行。你手下的士兵可以自行选择加入我军或是回家。他们可以保留自己的武器，以及本人能带走的私人财物。不过，我要征用所有的马匹和牲口。” 56503-56504, 标注, 2018 年 3 月 24 日星期六 下午 10:54:38 他可没瞎……他自己知道不能向这帮家伙屈服。”派柏粗鲁地指指艾德温•佛雷和瓦德•河文的方向。 144-145, 标注, 2019 年 3 月 10 日星期日 下午 3:48:58 结霜的落叶在他们耳边低语飘零，罗伊斯的战马局促不安。“ 299-299, 标注, 2019 年 3 月 10 日星期日 下午 7:07:53 人在恐惧的时候还能勇敢吗？” “人惟有恐惧的时候方能勇敢。” 1564-1564, 标注, 2019 年 3 月 13 日星期三 下午 10:33:54 “殊途不见得不能同归， 1855-1855, 标注, 2019 年 3 月 14 日星期四 下午 11:24:28 但凡事毕竟不可能尽如人意。 1919-1920, 标注, 2019 年 3 月 15 日星期五 上午 7:52:38 冲锋，坦格利安军立时四散溃逃。短短几分钟内， 1935-1937, 标注, 2019 年 3 月 15 日星期五 上午 8:00:30 它就是我的武器。老哥有他的宝剑，劳勃国王有他的战锤，我则有我的脑袋瓜……不过人若要保持思路清晰锐利，就得多读书，就好像宝剑需要磨刀石一样。” 2755-2755, 标注, 2019 年 3 月 16 日星期六 下午 5:06:13 希望他们带上弓箭，因为你们只配当靶子。” 9706-9706, 标注, 2019 年 4 月 4 日星期四 下午 9:55:07 是“错误的春天”，他又回到了十八岁，陪着琼 10227-10227, 标注, 2019 年 4 月 6 日星期六 下午 1:11:03 “当一个人无所畏惧时，即便懦夫也能展现不输于人的勇气。 14968-14970, 标注, 2019 年 4 月 21 日星期日 下午 12:17:01 长夏之后，星辰泣血，冰冷的黑暗将笼罩世界，在这个恐怖的时刻，将有一位战士自烈火中拔出燃烧之剑，那把剑是‘光明使者’，英雄之红剑，持有该剑者便是亚梭尔•亚亥转世，而他将驱离黑暗。” 16106-16106, 标注, 2019 年 4 月 27 日星期六 下午 5:00:34 最好的谎言里面往往会隐藏少许事实，足以令听者生疑。 22889-22890, 标注, 2019 年 6 月 1 日星期六 下午 2:46:27 命中注定你将燃起三团火焰……一团为生，一团为死，一团为爱…… 22891-22892, 标注, 2019 年 6 月 1 日星期六 下午 2:46:38 命中注定你将骑乘三匹坐骑……一匹床笫，一匹恐怖，一匹为爱…… 22893-22893, 标注, 2019 年 6 月 1 日星期六 下午 2:46:45 命中注定你将经历三次背叛……一次为血，一次为财，一次为爱…… 22902-22903, 标注, 2019 年 6 月 1 日星期六 下午 2:47:28 冰墙的裂缝开出一朵碧蓝的玫瑰，散发出无比甜美的气息…… 24044-24045, 标注, 2019 年 6 月 6 日星期四 下午 6:39:22 “行吗?我得说，您的脸色糟透了。或许是灯光的缘故。”他戴着手铐脚镣，并互相连接，使得 25623-25625, 标注, 2019 年 6 月 11 日星期二 上午 9:21:38 今其族事迹败露，恶行滔天，神人共愤，人人得而诛之，自无须念昔日之友盟，守过往之重诺。陛下，吾以诸神之名在此宣布，您的义务已告解除，婚约无效！” 26342-26342, 标注, 2019 年 6 月 12 日星期三 下午 8:59:31 这是尸骨已寒后的安息殿堂，这是属于死者的黑暗大厅，这是仇视生人的恐怖之地。 28273-28273, 标注, 2019 年 6 月 15 日星期六 下午 6:30:54 “有的胜利靠宝剑和长矛赢取，有的胜利则要靠纸笔和乌鸦。 28808-28809, 标注, 2019 年 6 月 16 日星期日 上午 8:39:11 纪律严明，十战九胜， 39176-39177, 标注, 2019年7月6日星期六 下午5:07:18 临阵脱逃者其实最容易遭到攻击，”艾德公爵曾教诲琼恩，“好比受伤的动物，激起对方杀戮的欲望。” ","date":"2024-10-09","objectID":"/%E7%AC%94%E8%AE%B0%E5%86%B0%E4%B8%8E%E7%81%AB%E4%B9%8B%E6%AD%8C1-5%E5%8D%B7-george-r.r/:0:0","tags":["﻿bingyuhuozh","note","ireader"],"title":"[笔记]﻿冰与火之歌1 5卷 george r.r","uri":"/%E7%AC%94%E8%AE%B0%E5%86%B0%E4%B8%8E%E7%81%AB%E4%B9%8B%E6%AD%8C1-5%E5%8D%B7-george-r.r/"},{"categories":null,"content":" 3638-3640, 标注, 2023 年 6 月 29 日星期四 下午 12:51:25 有了这样一群醉心于新文学的师生，大学里就多了一份灵气，少了一份俗气；多了一份热情，少了一份冷漠；多了一份温馨，少了一份寒意；多了一份无用之用，少了一份急功近利……正是在这个意义上，可以说现代文学也养育着现代大学，也施惠于现代大学。 5624-5625, 标注, 2023 年 6 月 29 日星期四 下午 10:14:50 凡是受到压抑的东西，总要到处为自己寻找迂回曲折的出路。 4459-4461, 标注, 2023 年 7 月 2 日星期日 下午 3:20:12 很少人能想及，即使蒋氏自己也可能未曾料及，自‘九·一八事件’至卢沟桥抗战的五年九个余月的时间，也是他一生对祖国最有贡献的一段时间。其贡献的方式不是战胜取攻，而是忍辱负重。但是此中情形至今尚少为人洞悉 ","date":"2024-10-09","objectID":"/%E7%AC%94%E8%AE%B0%E5%B9%B6%E6%9C%AA%E8%BF%9C%E5%8E%BB%E7%9A%84%E8%83%8C%E5%BD%B1-%E7%8E%8B%E5%BD%AC%E5%BD%AC/:0:0","tags":["bingweiyuanq","note","ireader"],"title":"[笔记]并未远去的背影-王彬彬","uri":"/%E7%AC%94%E8%AE%B0%E5%B9%B6%E6%9C%AA%E8%BF%9C%E5%8E%BB%E7%9A%84%E8%83%8C%E5%BD%B1-%E7%8E%8B%E5%BD%AC%E5%BD%AC/"},{"categories":null,"content":" 281-282, 标注, 2021 年 11 月 7 日星期日 下午 7:54:12 你们是世上的光，城造在山上是不能隐藏的。” 281-283, 标注, 2021 年 11 月 7 日星期日 下午 7:54:22 你们是世上的光，城造在山上是不能隐藏的。”清教徒相信他们是被上帝选中的选民，是人类世界的领导者。他们此行的目的就是要建立一座闪耀上帝之光的山巅之城。 428-432, 标注, 2021 年 11 月 7 日星期日 下午 8:13:04 历史学家克罗齐有一句名言“一切历史都是当代史”，历史解释是为当代人服务的，所以无论何种解释都有其合理性，也自有其偏颇之处。历史从不是给人以答案，它只是过往的回响，为人们理解当下提供更多的选项。 第二章 革命时代（1775—1820）：独立战争与建立联邦 刚刚独立的美国是一个松散的邦联，中央政府衰弱到连债务都还不起，社会内部各阶层之间矛盾丛生。 428-430, 标注, 2021 年 11 月 7 日星期日 下午 8:13:16 历史学家克罗齐有一句名言“一切历史都是当代史”，历史解释是为当代人服务的，所以无论何种解释都有其合理性，也自有其偏颇之处。历史从不是给人以答案，它只是过往的回响，为人们理解当下提供更多的选项。 490-491, 标注, 2021 年 11 月 7 日星期日 下午 8:20:57 我们认为这些真理是不言而喻的：人人生而平等，造物者赋予他们若干不可剥夺的权利，其中包括生命权、自由权和追求幸福的权利。” 692-695, 标注, 2021 年 11 月 7 日星期日 下午 9:08:52 宪法原文由序言和 7 条正文组成，规定美国由原来的邦联制改为实行联邦制政体，建立总统制民主共和国，立法、行政、司法三权分立、相互制衡。立法权属于美国国会，行政权属于美国总统，司法权属于美国联邦最高法院。对于国会、总统、最高法院的产生与组成，宪法中都做出了明确的规定。 979-981, 标注, 2021 年 11 月 8 日星期一 上午 12:06:47 为了让这种行为合理化，美国国内渐渐出现了一种“天定命运”的理论。约翰·奥沙利文是杂志《民主评论》的编辑，他在 1845 年创造了这个词。这个特别的词汇表达了一种信念，即美国优越的制度和文化赋予美国人将其文明传播到整个北美大陆的权利乃至责任，这符合上帝的旨意。 1279-1284, 标注, 2021 年 11 月 8 日星期一 下午 1:19:29 年幼的卡内基先后曾在纺织厂、锅炉房中担任童工，艰辛劳动之余，晚上参加夜校学习。在学习中他掌握的会计知识，可能对其一生起到了重要作用。14 岁时，卡内基成为一名送电报的小报童。但他并未局限于手头的电报分发工作，而是利用这一机会牢记了匹兹堡这个工业中心城市中每家公司的名称和特点，同时也了解到了这些公司的经济和业务状况。18 岁时，他被宾夕法尼亚铁路公司的一个主管看中，成为其私人电报员和秘书。6年后，他便当上了这家公司西部管理区的主任。在这里，他进一步掌握了现代大型企业的管理方法，并开始进行投资。 1292-1295, 标注, 2021 年 11 月 8 日星期一 下午 1:20:17 卡内基大量聘用专业技术人才及管理人才，他的一句名言广为人知：“如果把我的厂房设备、材料全部烧毁，但只要保住我的全班人马，几年以后，我仍将是一个钢铁大王。”对于优秀员工，卡内基采用将公司股权分给他们的方式，既作为奖励，又能将他们的切身利益与公司发展牢牢结合在一起，使其同样成为公司的一部分。 3252-3252, 标注, 2021 年 11 月 13 日星期六 下午 4:13:59 伊甸”在苏美尔语中是荒原的意思。《 31700-31705, 标注, 2022 年 3 月 27 日星期日 下午 3:27:06 1982 年 3 月 23 日，在一篇演说中，里根总统宣布美国将建立一张“天网”，对袭击美国的导弹进行拦截，建立全方位的反弹道导弹综合主体防御系统。该计划表面上以防御为主，其实是针对苏联的一项战略，该战略既可以确立对苏联的核军事优势，又能够把与苏联的军备竞赛引向太空，达到“以压促变”分流苏联经济的目的。同时，它还有利于推动美国高科技发展的目标。为了应对美国的“星球大战计划”，苏联投入了大量的资金，经济发展因此受到严重损害。 31820-31822, 标注, 2022 年 3 月 27 日星期日 下午 3:48:55 赫鲁晓夫时期的改革不仅层次浅，而且非常盲目，非常随意，没有经过严密的论证，这也是其改革虽然顺应潮流，但是改革没有成效的重要原因。如何评价赫鲁晓夫的改革，也许正如著名的抽象派艺术家涅伊兹韦斯内给他设计的墓碑一样：黑白各半。 31854-31858, 标注, 2022 年 3 月 27 日星期日 下午 3:52:59 苏联的僵化保守与勃列日涅夫的个性也有密切的关系，仅从其对勋章的热爱就可以看出来。勃列日涅夫的照片，能够迅速给人留下各种深刻印象的就是衣服上琳琅满目的勋章。在他去世之后的送葬队伍里面，竟然有 44 个人是专门给他捧着各种勋章的。除了“英雄母亲”的勋章之外，他获得了苏联境内所有可能获得的勋章，同时还有外国领导人送给他的各种勋章。爱慕荣誉之人，焉能脚踏实地做好事情 31854-31858, 标注, 2022 年 3 月 27 日星期日 下午 3:53:06 苏联的僵化保守与勃列日涅夫的个性也有密切的关系，仅从其对勋章的热爱就可以看出来。勃列日涅夫的照片，能够迅速给人留下各种深刻印象的就是衣服上琳琅满目的勋章。在他去世之后的送葬队伍里面，竟然有 44 个人是专门给他捧着各种勋章的。除了“英雄母亲”的勋章之外，他获得了苏联境内所有可能获得的勋章，同时还有外国领导人送给他的各种勋章。爱慕荣誉之人，焉能脚踏实地做好事情呢？ 31932-31934, 标注, 2022 年 3 月 27 日星期日 下午 4:03:53 戈尔巴乔夫在政治上信奉绝对哲学，坚信“绝对的自由”“绝对的公开”与“绝对的多元化”，刺激人们开始疯狂地揭露社会的阴暗面，从而走上了自己打到自己、自己瓦解自己的道路。最终，苏联经济搞穷了，政治搞乱了，人心涣散了，国家解体 31956-31958, 标注, 2022 年 3 月 27 日星期日 下午 4:08:06 1985 年，玻利维亚的通货膨胀率已经高达 24000%，经济负增长竟然达到了 12%的惊人数字，但是仅仅几个星期之内，在使用此方法之后，通货膨胀率已经下降到两位数字。 35593-35593, 标注, 2022 年 9 月 6 日星期二 下午 2:15:09 在三岛由纪夫之后的昭和岁月中，日本文坛依旧有着不少璀璨之星，比 952-1112, 标注, unknown 宪法原文由序言和 7 条正文组成，规定美国由原来的邦联制改为实行联邦制政体，建立总统制民主共和国，立法、行政、司法三权分立、相互制衡。立法权属于美国国会，行政权属于美国总统，司法权属于美国联邦最高法院。对于国会、总统、最高法院的产生与组成，宪法中都做出了明确的规定。 1114-1270, 标注, unknown 为了让这种行为合理化，美国国内渐渐出现了一种“天定命运”的理论。约翰·奥沙利文是杂志《民主评论》的编辑，他在 1845 年创造了这个词。这个特别的词汇表达了一种信念，即美国优越的制度和文化赋予美国人将其文明传播到整个北美大陆的权利乃至责任，这符合上帝的旨意。 1272-1547, 标注, unknown 年幼的卡内基先后曾在纺织厂、锅炉房中担任童工，艰辛劳动之余，晚上参加夜校学习。在学习中他掌握的会计知识，可能对其一生起到了重要作用。14 岁时，卡内基成为一名送电报的小报童。但他并未局限于手头的电报分发工作，而是利用这一机会牢记了匹兹堡这个工业中心城市中每家公司的名称和特点，同时也了解到了这些公司的经济和业务状况。18 岁时，他被宾夕法尼亚铁路公司的一个主管看中，成为其私人电报员和秘书。6年后，他便当上了这家公司西部管理区的主任。在这里，他进一步掌握了现代大型企业的管理方法，并开始进行投资。 1768-2008, 标注, unknown 1982 年 3 月 23 日，在一篇演说中，里根总统宣布美国将建立一张“天网”，对袭击美国的导弹进行拦截，建立全方位的反弹道导弹综合主体防御系统。该计划表面上以防御为主，其实是针对苏联的一项战略，该战略既可以确立对苏联的核军事优势，又能够把与苏联的军备竞赛引向太空，达到“以压促变”分流苏联经济的目的。同时，它还有利于推动美国高科技发展的目标。为了应对美国的“星球大战计划”，苏联投入了大量的资金，经济发展因此受到严重损害。 2149-2356, 标注, unknown 苏联的僵化保守与勃列日涅夫的个性也有密切的关系，仅从其对勋章的热爱就可以看出来。勃列日涅夫的照片，能够迅速给人留下各种深刻印象的就是衣服上琳琅满目的勋章。在他去世之后的送葬队伍里面，竟然有 44 个人是专门给他捧着各种勋章的。除了“英雄母亲”的勋章之外，他获得了苏联境内所有可能获得的勋章，同时还有外国领导人送给他的各种勋章。爱慕荣誉之人，焉能脚踏实地做好事情 2358-2567, 标注, unknown 苏联的僵化保守与勃列日涅夫的个性也有密切的关系，仅从其对勋章的热爱就可以看出来。勃列日涅夫的照片，能够迅速给人留下各种深刻印象的就是衣服上琳琅满目的勋章。在他去世之后的送葬队伍里面，竟然有 44 个人是专门给他捧着各种勋章的。除了“英雄母亲”的勋章之外，他获得了苏联境内所有可能获得的勋章，同时还有外国领导人送给他的各种勋章。爱慕荣誉之","date":"2024-10-09","objectID":"/%E7%AC%94%E8%AE%B0%E4%B8%8D%E5%8F%AF%E4%B8%8D%E7%9F%A5%E7%9A%84%E5%8E%86%E5%8F%B2%E7%B3%BB%E5%88%97-%E6%9D%A8%E4%B9%89%E6%88%90%E7%AD%89/:0:0","tags":["bukebuzhidel","note","ireader"],"title":"[笔记]不可不知的历史系列-杨义成;等","uri":"/%E7%AC%94%E8%AE%B0%E4%B8%8D%E5%8F%AF%E4%B8%8D%E7%9F%A5%E7%9A%84%E5%8E%86%E5%8F%B2%E7%B3%BB%E5%88%97-%E6%9D%A8%E4%B9%89%E6%88%90%E7%AD%89/"},{"categories":null,"content":" 114-115, 标注, 2020 年 7 月 2 日星期四 下午 1:15:47 向前展望，倒后推理” 109-109, 标注, 2020 年 7 月 2 日星期四 下午 1:15:59 我们希望你可以从别人的角度观察这个世界。 114-116, 标注, 2020 年 7 月 2 日星期四 下午 1:16:12 向前展望，倒后推理”的法则却告诉你，应该首先确定自己最后希望达到什么目标，然后从这个结果倒后研究，直到找出自己现在应该选择哪条道路，这样才能保证以后可以达到那个目标。 340-340, 标注, 2020 年 7 月 2 日星期四 下午 1:30:15 策略思维从你的基本技巧开始，考虑的是怎样将这些基本技巧最大限度地加以发挥。 419-423, 标注, 2020 年 7 月 3 日星期五 下午 9:32:33 帆船比赛给我们提供了一个很好的机会，观察“跟随领头羊”策略的一个很有意思的反例。成绩领先的帆船，通常都会照搬尾随船只的策略。一旦遇到尾随的船只改变航向，那么成绩领先的船只也会照做不误。实际上，即便成绩尾随的船只采用一种显然非常低劣的策略时，成绩领先的船只也会照样模仿。为什么？因为帆船比赛与在舞厅里跳舞不同，在这里，成绩接近是没有用的，只有最后胜出才有意义。假如你成绩领先了，那么，维持领先地位的最可靠的办法就是看见别人怎么做，你就跟着怎么做。 433-435, 标注, 2020 年 7 月 3 日星期五 下午 9:34:10 而在商界，等得越久越有利，这是因为，商界与体育比赛不同，这里的竞争通常不会出现赢者通吃的局面。结果是，市场上的领头羊们，只有当它们对新生企业选择的航向同样充满信心时，才会跟随这些企业的步伐 467-470, 标注, 2020 年 7 月 3 日星期五 下午 9:43:16 囚徒困境的故事还体现了一个普遍的现象：大多数经济的、政治的或社会的博弈游戏都跟类似橄榄球或扑克这样的博弈游戏不同。橄榄球和扑克是零和博弈：一个人的得就是另一个人的失。但在囚徒困境里，有可能出现共同利益，也有可能出现利益冲突；不招供的结果对两个囚徒都是有利的，而不是相反。 471-473, 标注, 2020 年 7 月 3 日星期五 下午 9:43:46 任何一个关于博弈的有用的分析，都应该考虑到怎样处理冲突与利益同时存在的情形。我们通常将博弈游戏的参加者称为“对立者”，不过，你也要记住，有时候，策略可能将原本毫不相干的人变成一条绳上相互依存的两只蚂蚱。 538-539, 标注, 2020 年 7 月 4 日星期六 上午 9:52:22 不过，要想使我们所做的努力奏效，我们必须看清问题产生的机制，即“手风琴效应”，每一个折叠都会推动或拉动邻近一个折叠。 575-576, 标注, 2020 年 7 月 4 日星期六 上午 9:57:00 能够预见到上述后果的策略家会赶在他们的讨价还价能力仍然存在的时候充分利用，换句话说就是在他们订下契约之前。 591-591, 标注, 2020 年 7 月 4 日星期六 上午 9:59:54 实施多管齐下策略，诀窍在于不可预测性。 687-689, 标注, 2020 年 7 月 7 日星期二 下午 1:02:32 在博弈游戏里，抢占先机、率先出手并不总是好事。因为这么做会暴露你的行动，其他参与者可以利用这一点占你的便宜。第二个出手可能使你处于更有利的策略地位。 715-716, 标注, 2020 年 7 月 7 日星期二 下午 1:05:55 法则 1：向前展望，倒后推理。 733-736, 标注, 2020 年 7 月 7 日星期二 下午 1:07:49 称为“决策树”。如何正确使用这样一张图或这么一棵树呢？绝对不是选择第一个岔道口看上去最好的分枝，然后等到下一个岔道口出现再去思考接下来应该怎么办；相反，你应该预计到以后将面临的选择，利用这些信息倒过头来确定前面几个岔道口你应该怎么决断。 741-743, 标注, 2020 年 7 月 7 日星期二 下午 1:08:57 为了强调一下这个做法与前面一个做法的区别，我们把一棵反映一场策略博弈当中的决策次序的树称为“博弈树”，而把“决策树”留做描述只有一个人参加的情形。 985-985, 标注, 2020 年 7 月 16 日星期四 下午 8:16:46 假如你不得不冒一点风险，通常都是越早冒险越好。 1018-1018, 标注, 2020 年 7 月 16 日星期四 下午 8:24:39 向前展望，倒后推理。 1029-1029, 标注, 2020 年 7 月 16 日星期四 下午 8:25:50 寻找优势策略是每一个人的首要任务。 1098-1100, 标注, 2020 年 7 月 18 日星期六 下午 7:30:13 优势策略”的优势是指你的这个策略对你的其他策略占有优势，而不是对你的对手的策略占有优势。无论对手采用什么策略，某个参与者如果采用优势策略，就能使自己获得比采用任何其他策略更好的结果。 1651-1693, 标注, unknown 法则 1：向前展望，倒后推理。 ","date":"2024-10-09","objectID":"/%E7%AC%94%E8%AE%B0%E7%AD%96%E7%95%A5%E6%80%9D%E7%BB%B4%E5%95%86%E7%95%8C%E6%94%BF%E7%95%8C%E5%8F%8A%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB%E4%B8%AD%E7%9A%84%E7%AD%96%E7%95%A5%E7%AB%9E%E4%BA%89-%E9%98%BF%E7%BB%B4%E7%BA%B3%E4%BB%80k%E8%BF%AA%E5%85%8B%E8%A5%BF%E7%89%B9/:0:0","tags":null,"title":"[笔记]策略思维——商界、政界及日常生活中的策略竞争-阿维纳什·K·迪克西特","uri":"/%E7%AC%94%E8%AE%B0%E7%AD%96%E7%95%A5%E6%80%9D%E7%BB%B4%E5%95%86%E7%95%8C%E6%94%BF%E7%95%8C%E5%8F%8A%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB%E4%B8%AD%E7%9A%84%E7%AD%96%E7%95%A5%E7%AB%9E%E4%BA%89-%E9%98%BF%E7%BB%B4%E7%BA%B3%E4%BB%80k%E8%BF%AA%E5%85%8B%E8%A5%BF%E7%89%B9/"},{"categories":null,"content":" 268-268, 标注, 2020 年 7 月 26 日星期日 下午 7:16:53 倔强二字，却不可少。功业文章，皆须有此二字贯注其中，否则柔靡不能成一事。 355-358, 标注, 2020 年 7 月 26 日星期日 下午 7:48:34 第一，笨拙的人没有智力资本，因此比别人更虚心，更肯付出。第二，笨拙的人从小接受挫折教育多，总是失败，因此“逆商”也就是逆境商数比较高，抗打击能力特别强。第三，笨拙的人不懂取巧，不走捷径，遇到问题只知硬钻过去，因此做事不留死角 355-358, 标注, 2020 年 7 月 26 日星期日 下午 7:48:40 作为一个笨人，曾国藩发现下笨功夫有下笨功夫的好处。 第一，笨拙的人没有智力资本，因此比别人更虚心，更肯付出。第二，笨拙的人从小接受挫折教育多，总是失败，因此“逆商”也就是逆境商数比较高，抗打击能力特别强。第三，笨拙的人不懂取巧，不走捷径，遇到问题只知硬钻过去，因此做事不留死角 361-366, 标注, 2020 年 7 月 26 日星期日 下午 7:49:42 曾国藩的人生哲学是“尚拙”。既然天性钝拙，那么曾国藩就充分发挥钝拙的长处。他一生做事从来不绕弯子，不走捷径，总是按最笨拙、最踏实的方式去做。涓滴积累，水滴石穿，追求的是扎实彻底，一步一个脚印。他做人讲究“拙诚”，人以伪来，我以诚往，不玩心眼。他带兵讲究“结硬寨、打呆仗”(35)，从不凭奇谋诡计，只凭坚忍踏实，死磕到底。这种方式正如“重剑无锋”，表面上看起来迟钝，实际上锋利。就好比郭靖的降龙十八掌，表面上简单笨拙，实际上却大气厚重，所向披靡。这是曾国藩一生成功的秘诀，也是他常向别人谈及的道理。 727-728, 标注, 2020 年 7 月 26 日星期日 下午 9:08:45 凡人作一事，便须全副精神注在此一事，首尾不懈，不可见异思迁，做这样想那样，坐这山望那山。人而无恒，终身一无所成 731-733, 标注, 2020 年 7 月 26 日星期日 下午 9:09:44 以强悍的蛮劲打通此关。他以练习书法为喻，说明人在困难、倦怠、麻木面前应该如何做：“（写字写到）手愈拙，字愈丑，意兴愈低，所谓困也。困时切莫间断，熬过此关，便可少进。再进再困，再熬再奋，自有亨通精进之日。不特习字，凡事皆有极困难之时，打得通的，便是好汉。” 747-749, 标注, 2020 年 7 月 26 日星期日 下午 9:14:20 他用三十天戒了烟，然后用三十年，来戒掉其他更难戒的毛病。在一次又一次的反复磨炼中，曾国藩的气质性格渐渐发生着变化。他做事越来越有恒心有毅力，待人接物越来越宽厚、周到、真诚，朋友一天比一天多。他的品质越来越纯粹，站得越来越高，看得越来越远。 768-770, 标注, 2020 年 7 月 26 日星期日 下午 9:16:20 曾国藩一生成功的第一个要诀，就是立志高远。这一志向，驱动他一生不在小诱惑、小目标面前止步。促使他在多大的困难面前都不苟且、不退缩 871-872, 标注, 2020 年 7 月 26 日星期日 下午 10:06:01 在日记当中，他给自己立下十二条做人的规矩和课程的标准： 936-936, 标注, 2020 年 7 月 26 日星期日 下午 10:10:53 习俗染人，所谓与鲍鱼处，亦与之俱化也。 2505-2505, 标注, 2020 年 8 月 2 日星期日 上午 10:00:26 ，天下事有所激有所逼而成者居多。 2507-2509, 标注, 2020 年 8 月 2 日星期日 上午 10:00:49 对于有志者来说，挫辱是最大的动力，打击是最好的帮助。咬紧牙关，把挫辱活生生吞下，就成了滋养自己意志和决心的营养。这构成了曾国藩生命经验中最核心的部分。几十年后，他还在家书中教育儿子说：“ 2507-2509, 标注, 2020 年 8 月 2 日星期日 上午 10:00:59 对于有志者来说，挫辱是最大的动力，打击是最好的帮助。咬紧牙关，把挫辱活生生吞下，就成了滋养自己意志和决心的营养。这构成了曾国藩生命经验中最核心的部分。 2509-2512, 标注, 2020 年 8 月 2 日星期日 上午 10:01:08 天下事无所为而成者极少，有所贪有所利而成者居其半，有所激有所逼而成者居其半。”(84)“百端拂逆之时……亦只有逆来顺受之法。”(85)“所谓‘好汉打脱牙和血吞’……真处逆境之良法也 2516-2520, 标注, 2020 年 8 月 2 日星期日 下午 12:22:09 湘军的战斗力来自曾国藩的“反思”习惯。 我在这句话里所说的“反思”，用的字面意思，也就是反向思考。曾国藩在创建湘军的时候，并没有首先去想“湘军怎么才有战斗力”，而是先来分析“绿营兵为什么没有战斗力”。这是一个很重要的切入点。其实很多时候做事不需要你有什么超天才的想法。你只要好好总结一下别人都犯了哪些错误，然后你反着来，你可能就成功了 2627-2628, 标注, 2020 年 8 月 2 日星期日 下午 12:32:15 知止而后有定，定而后能静，静而后能安，安而后能虑，虑而后能 2627-2628, 标注, 2020 年 8 月 2 日星期日 下午 12:32:21 知止而后有定，定而后能静，静而后能安，安而后能虑，虑而后能得’ 2604-2604, 标注, 2020 年 8 月 2 日星期日 下午 12:34:09 选士人领山农” 2708-2710, 标注, 2020 年 8 月 3 日星期一 下午 7:14:50 曾国藩并不比别人聪明，然而他做事却非常高明。曾国藩的高明，就是建立在笨拙之上，建立在绞尽脑汁、殚精竭虑之上。“笨”到极致就是“聪明”，“拙”到极点就成了“巧”。 2712-2714, 标注, 2020 年 8 月 3 日星期一 下午 7:18:26 曾国藩一生经历千难万险，处理过无数大事，大体都很得当。其过人之处就是不怕费心费力，对事物进行不留死角的深入分析。在对事物进行精到分析的基础上，再找出要害，把握关键。每次处理完了之后，还要总结经验教训，为下一次做参考 2921-2922, 标注, 2020 年 8 月 3 日星期一 下午 7:19:51 他这个人的做事特点一直是功虽大而不喜，过虽小而必究。他常说“悔生吉”，所谓“悔”，就是总结反省失败。在曾国藩看来，“失败”是一个人一生的宝贵财富，每一次失败都要吃透，才能不白白付出这个代价。 3131-3132, 标注, 2020 年 8 月 3 日星期一 下午 9:19:14 所谓战略，就是基于宏观性和长远性，把各种纷繁复杂的要素按轻重缓急、先后次序进行整理排列，然后拿出最有效的行动方 3169-3169, 标注, 2020 年 8 月 3 日星期一 下午 9:21:51 自古平江南之策，必踞上游之势，建瓴而下，乃能成功。 3663-3664, 标注, 2020 年 8 月 4 日星期二 下午 7:24:57 太自傲、太急切、一味蛮干、一味刚强。 3664-3666, 标注, 2020 年 8 月 4 日星期二 下午 7:25:33 ，行事过于方刚者，表面上似乎是强者，实际上却是弱者。这片土地上真正的强者，是表面上看起来柔弱退让之人。所谓“天下之至柔，驰骋天下之至坚”，“江海所以能为百谷王者，以其善下之”。所谓“大柔非柔，至刚无刚” 3764-3765, 标注, 2020 年 8 月 4 日星期二 下午 9:20:31 他认识到“不妄保举，不乱用钱”，则“人心不附”。只有诱之以“名”，笼之以“利”，才能网罗天下英才。 4257-4258, 标注, 2020 年 8 月 5 日星期三 下午 9:41:56 古今中外，具有雄才大略的用兵者，无不能够始终从战略的高度来把握问题，能够透过暂时的纷乱看到重点，在利害交织中看清本质，牢牢把握好长远与眼前、全局与局部的关系。 4260-4261, 标注, 2020 年 8 月 5 日星期三 下午 9:42:27 “用兵以审势为第一要义”(57)，“‘势’则指大计大局”(58) 4260-4262, 标注, 2020 年 8 月 5 日星期三 下午 9:42:44 “用兵以审势为第一要义”(57)，“‘势’则指大计大局”(58)。还说应该从大的地方去分清界限，不要斤斤于小处去剖析微芒。这个大利大害、大计大局，就是战略重心的所在。 4303-4305, 标注, 2020 年 8 月 5 日星期三 下午 9:45:13 战略上有一条基本的原则，就是致人而不致于人，也就是要迫使对方按照自己的战略安排行动，迫使对方跟着我们的步子走，而不是按照对方的战略安排行动。说白了，就是将战略的主动权掌握在自己的手中 4483-4483, 标注, 2020 年 8 月 5 日星期三 下午 10:11:32 太平天国》 4482-4482, 标注, 2020 年 8 月 5 日星期三 下午 10:11:40 李秀成自述 4826-4828, 标注, 2020 年 8 月 6 日星期四 下午 3:29:01 巴蜀书社，1998 年，第 1641 页。 (33)　沈守之：《借巢笔记》，第 25 页。转引自 5151-5152, 标注, 2020 年 8 月 6 日星期四 下午 10:12:19 古来大战争、大事业，人谋仅占十分之三，天意恒居十分之七。往往积劳之人非即成名之人，成名之人非即享福之人 5340-5343, 标注, 2020 年 8 月 7 日星期五 上午 7:10:04 在其耽于饮宴作乐的这十年中，它是否有什么业绩？什么也没有。它是否曾对人民给予了最起码的尊重","date":"2024-10-09","objectID":"/%E7%AC%94%E8%AE%B0%E6%9B%BE%E5%9B%BD%E8%97%A9%E4%BC%A0-%E5%BC%A0%E5%AE%8F%E6%9D%B0/:0:0","tags":["cengguofanch","note","ireader"],"title":"[笔记]曾国藩传-张宏杰","uri":"/%E7%AC%94%E8%AE%B0%E6%9B%BE%E5%9B%BD%E8%97%A9%E4%BC%A0-%E5%BC%A0%E5%AE%8F%E6%9D%B0/"},{"categories":null,"content":" 179-179, 标注, 2020 年 7 月 14 日星期二 下午 12:39:17 至于当大事，全在明强二字。 欲成大事，“明强”为本。 196-197, 标注, 2020 年 7 月 15 日星期三 下午 10:00:06 《中庸》中所说的博学、审问、慎思、明辨、笃行，其要点就是要使愚蠢变为贤明，柔弱变得坚强。 198-199, 标注, 2020 年 7 月 15 日星期三 下午 10:00:59 要知道凡事没有倔犟的志气是做不成的，没有刚毅的性格也不能成大事，即使是修身齐家，也必须以“明强”二字作为修身的根本。 206-207, 标注, 2020 年 7 月 15 日星期三 下午 10:03:15 博学、审问、慎思、明辨、笃行， 212-213, 标注, 2020 年 7 月 14 日星期二 下午 12:34:42 和顺而不随波逐流，保持中立而不偏不倚，政治清明时不改变志向，政治黑暗时坚持操守，宁死不变，这才是真正的强。 237-237, 标注, 2020 年 7 月 14 日星期二 下午 9:41:43 凡郁怒最易伤人。 262-263, 标注, 2020 年 7 月 16 日星期四 下午 10:17:02 必须能忍受别人不能忍受的触犯和忤逆，才能成就别人难及的事业功名。 267-270, 标注, 2020 年 7 月 14 日星期二 下午 9:43:43 事实如此，生活中总会存在这样的一些人：他们为了自己的利益而不择手段地去挑拨离间，而且斤斤计较得理不饶人，甚至会为了一点利益跟别人大打出手。所以，这种人是难以成就大事的。而如果这些人都能看破这些人情世故，那么就会如曾国藩所说：“知道世上道路的艰难，那么内心就会更加抑制畏惧，心气反而会更加平和了。” 271-271, 标注, 2020 年 7 月 14 日星期二 下午 9:46:32 满招损，谦受益 274-274, 标注, 2020 年 7 月 14 日星期二 下午 9:47:04 思自进于谨言慎行之路， 276-277, 标注, 2020 年 7 月 14 日星期二 下午 9:47:39 但不可傲，满招损，谦受益， 280-281, 标注, 2020 年 7 月 14 日星期二 下午 10:09:53 大约军事之败，非傲即惰，二者必居其一。巨室之败，非傲即惰，二者必居其一。 302-303, 标注, 2020 年 7 月 14 日星期二 下午 10:12:49 在曾国藩看来，无论军事失败还是达官贵人家的落魄，都是因为骄傲和懒惰其中一点所造成的，所以他认为去掉傲字为第一重要。 316-317, 标注, 2020 年 7 月 14 日星期二 下午 10:14:29 曾国藩是把众人的智慧为己所用的典型人物。他胸怀广大，心平气和，从不居功自傲，看上去就像一位老儒。凡是有人向他进言，对的就采纳，不对的他也不予以辩驳。 330-330, 标注, 2020 年 7 月 14 日星期二 下午 10:17:16 骄傲自满是人生的大敌，盛气凌人是人际交往中的败笔。《 333-335, 标注, 2020 年 7 月 14 日星期二 下午 10:18:16 谦逊就是对自己的短处和不足有高度的自觉，永远以自己的短处和他人的长处相比较，虚心向他人学习，以不断充实和完善自己。自满自足的人总是只见自己的长处和他人的短处，总觉得自己什么都好，而别人一无是处，于是自高自大，瞧不起任何人。 335-336, 标注, 2020 年 7 月 14 日星期二 下午 10:19:40 谦逊的人能发现他人的优点，虚心向他人学习，集众人之长，补己之短。谦逊作为一种美德，既能在人际交往中体现出对他人的尊重，又表现了对自己的严格要求和积极的进取精神。 375-376, 标注, 2020 年 7 月 15 日星期三 上午 10:56:15 李申夫尝谓余怄气从不说出，一味忍耐，徐图自强，因引谚曰：“好汉打脱牙，和血吞”。此二语是余生平咬牙立志之诀，不料被申夫看破。 378-379, 标注, 2020 年 7 月 15 日星期三 上午 11:00:23 唯有一字不说，咬定牙根，徐图自强而已。 407-408, 标注, 2020 年 7 月 15 日星期三 下午 1:22:44 君子稳重而有威严，有坚强的忍耐性格，在困难面前不退缩，即使刀架在脖子上也不畏惧。这样才能够所向无敌。 420-421, 标注, 2020 年 7 月 15 日星期三 下午 1:23:53 有利的情况和主动的恢复，产生于再坚持一下的努力之中。事情的成功与否，就在于你的意志是否坚定。 426-427, 标注, 2020 年 7 月 15 日星期三 下午 1:24:19 当苦到极点和难到极点的时候，最需要的不是力气，更不是放弃，而是坚忍和打脱牙和血吞的精神。 431-431, 标注, 2020 年 7 月 15 日星期三 下午 4:17:53 凡畏人，不敢妄议论者，谦谨者也；凡好讥评人短者，骄傲者也。 453-455, 标注, 2020 年 7 月 15 日星期三 下午 4:22:19 若想做一个好人，做一个完人，要始终怀着敬畏的心对待别人，如果能作到不轻易对任何人进行评论，那么就能够使鬼服神钦，见识日进，正气日刚。否则，不知不觉坠入卑污一流，必定有被别人看不起的那一天，所以不可不慎重。 455-457, 标注, 2020 年 7 月 15 日星期三 下午 4:24:27 凡是属于敬畏别人而不敢妄加议论别人的人都是谦和恭谨的人。凡是属于喜欢讽刺和批评别人短处的人都是骄傲的人。其意是告诫我们在修身做人上，一定要谨慎行事。 462-462, 标注, 2020 年 7 月 15 日星期三 下午 7:56:51 他对同僚也非常友善，主张“说人长每长一分，说人短每短一分”。 474-477, 标注, 2020 年 7 月 15 日星期三 下午 8:00:18 曾国藩说，要成为一个不骄傲的人，就要以不轻易议论和讥笑别人为第一要点。这是为官、做人所必须具备的品德，也是当领导的处理好同事之间、上下级之间关系的准则。 譬如说：同事之间、上下级之间，在日常工作、生活中难免会产生一些矛盾，这时就应该坦诚相见，加强相互之间的沟通与理解，消除隔阂，化解矛盾，增进友谊。 482-483, 标注, 2020 年 7 月 15 日星期三 下午 8:01:50 我们一定要谨记曾国藩的告诫，不轻易议论和讥笑别人，让自己凝聚更多的人脉，被更多的人所欣赏，开创出一片新的天地。 504-505, 标注, 2020 年 7 月 15 日星期三 下午 8:03:55 顺境比逆境更能考验一个人。一个人战胜了逆境，那么他是一个强者，如果一个人战胜了顺境，那么他就是一个理智的强者。 519-521, 标注, 2020 年 7 月 15 日星期三 下午 8:10:03 “裕无咎”里的这个“裕”字有两层意思：其一，是暂缓，待时，有退一步之意，就是懂得忍耐；其二，就是宽阔、宽广，即心胸宽广。能以宽广的胸怀对待晋升中的挫折，所谓大肚能容，能容领导的不信任，能容竞争对手的打击，能容晋升受挫的事实。 592-594, 标注, 2020 年 7 月 15 日星期三 下午 8:28:43 大器晚成的人很多。从这些大器晚成的伟大人物的发展历程里，我们还可以看到他们都是不断刻苦钻研，朝着自己感兴趣的山峰不断攀登。不在乎起步迟早，无论年龄大小，只要为成功付出了相当的努力，就有希望成功。 只要将成功寄希望于长期努力上，不急于求成，一旦悟透“大器晚成”的道理，不求速度、不求数量，始终坚持把眼前的事情做得更完美，那么就会比别人更快地获得人生的成功。 639-641, 标注, 2020 年 7 月 15 日星期三 下午 9:28:25 在他看来为国家做事，就该认真不能松懈，一律按规矩办理。 做事尽心尽责，一丝不苟，能够培养人坚毅的品格，它能带领人走向好的方面，又能鼓励优秀的人成就一番大的事业。 676-676, 标注, 2020 年 7 月 16 日星期四 下午 7:50:28 盖无故而怨天，则天必不许；无故而尤人，则人必不服。 677-678, 标注, 2020 年 7 月 16 日星期四 下午 7:51:04 凡遇牢骚欲发之时，则反躬自思：吾果有何不足而蓄此不平之气？猛然内省，决然去之。 708-709, 标注, 2020 年 7 月 16 日星期四 下午 7:56:20 毫无缘故地怨天，天一定不会允许；无缘无故地埋怨别人，人也不会服气。天人感应之理，只能顺其自然，不要过于强求。 735-738, 标注, 2020 年 7 月 16 日星期四 下午 7:57:50 强调了力除牢骚的重要，并且告诫他的四个弟弟不要一味发牢骚，凡要发牢骚的时候，必须躬身自问：有什么事情使你不满足？为何你心中怀不平之气？积极反省自己的内心，心怀一团和气，养本固元，这样就没有什么事情是不能接受的。接受后，再想法去改变；能改变的改变它，不能改变的接受它，没有什么值得埋怨的 741-743, 标注, 2020 年 7 月 16 日星期四 下午 8:00:07 圣人也和我们一样有时会发出感慨，但是，圣人与我们不同的是，他不会陷入苦恼之中，不会因为大道不能推行于天下而怨天尤人，更不会牢骚满腹不付诸行动。 772-774, 标注, 2020 年 7 月 16 日星期四 下午 8:05:01 人处在心烦意乱的时候，很难作出正确的判断和抉择，会使事情难以成功；如果长期让自己的心情处于这种状态，也会容易生出病来。所以，息怒、忍耐很重要，只有静心凝神才能万事可达。 792-793, 标注, 20","date":"2024-10-09","objectID":"/%E7%AC%94%E8%AE%B0%E6%9B%BE%E5%9B%BD%E8%97%A9%E6%99%BA%E6%85%A7%E7%B2%BE%E9%AB%93%E5%A4%A7%E5%90%88%E9%9B%86-%E6%B8%85%E6%9B%BE%E5%9B%BD%E8%97%A9/:0:0","tags":["zengguofanzh","note","ireader"],"title":"[笔记]曾国藩智慧精髓大合集-（清）曾国藩","uri":"/%E7%AC%94%E8%AE%B0%E6%9B%BE%E5%9B%BD%E8%97%A9%E6%99%BA%E6%85%A7%E7%B2%BE%E9%AB%93%E5%A4%A7%E5%90%88%E9%9B%86-%E6%B8%85%E6%9B%BE%E5%9B%BD%E8%97%A9/"},{"categories":null,"content":" 35-36, 标注, 2020 年 2 月 12 日星期三 上午 7:41:44 “时代的一粒灰，落在个人头上，就是一座山。”对现在还挣扎在痛苦中的人们，谈生活太奢侈了，有些时候，光是活着，就已经拼尽全力。 38-40, 标注, 2020 年 2 月 12 日星期三 上午 7:42:28 多年以后，春天来了又去，当阳光铺洒在草地，当我们自由地呼吸空气，当我们开心的欢聚，我们必须记得起若干年前，雪曾落在这片土地。 死亡，是一个人的悲剧，遗忘是一个民族的悲剧。 43-46, 标注, 2020 年 2 月 12 日星期三 上午 7:43:08 墨写的谎言掩盖不住血写的事实。“有的人， 为了守住不会带到棺材里去的利益与权柄，在他们还活着的时候， 就因为贪婪而吞食了自己的心肝。当他们开始习惯性撒谎的时候， 也在将自己的亲友与同胞推向深渊”。 46-47, 标注, 2020 年 2 月 12 日星期三 上午 7:43:34 历史不会因为无视而消失，责任也不能因为回避而逃脱。 50-50, 标注, 2020 年 2 月 12 日星期三 上午 7:43:48 说真话的人，我们应该为他们竖碑，要有名有姓，拒绝一切匿名的纪念。 54-55, 标注, 2020 年 2 月 12 日星期三 上午 7:44:56 灾难面前，最容易看清人性；一场瘟疫，撕下了谁出将入相的遮羞布？又有哪些媚骨在哗众取宠中捡拾着人血馒头？ 58-58, 标注, 2020 年 2 月 12 日星期三 上午 7:45:39 灾难面前，也最容易看到人类内心深处的光芒。 66-67, 标注, 2020 年 2 月 12 日星期三 上午 7:46:08 这些真实的一切，应该让孩子们知道。一张安静的书桌来之不易，不能只安放没有思想的大脑。 ","date":"2024-10-09","objectID":"/%E7%AC%94%E8%AE%B0%E6%88%90%E9%83%BD%E4%B8%83%E4%B8%AD%E8%80%81%E5%B8%88%E5%BC%80%E8%AF%BE%E8%87%B4%E8%BE%9E-kindle@eub-inc/:0:0","tags":["chengduqizho","note","ireader"],"title":"[笔记]成都七中老师开课致辞-kindle@eub-inc.com","uri":"/%E7%AC%94%E8%AE%B0%E6%88%90%E9%83%BD%E4%B8%83%E4%B8%AD%E8%80%81%E5%B8%88%E5%BC%80%E8%AF%BE%E8%87%B4%E8%BE%9E-kindle@eub-inc/"},{"categories":null,"content":" 16-18, 标注, 2019 年 7 月 2 日星期二 下午 9:31:15 老师教给我，要学骆驼，沉得住气的动物。看它从不着急，慢慢地走，慢慢地嚼；总会走到的，总会吃饱的。也许它们天生是该慢慢的，偶然躲避车子跑两步，姿势很难看。 ","date":"2024-10-09","objectID":"/%E7%AC%94%E8%AE%B0%E5%9F%8E%E5%8D%97%E6%97%A7%E4%BA%8B-%E4%B9%A6%E8%AF%AD%E8%80%85%E7%94%B5%E5%AD%90%E5%9B%BE%E4%B9%A6%E9%A6%86/:0:0","tags":["chengnanjius","note","ireader"],"title":"[笔记]城南旧事-[书语者电子图书馆]","uri":"/%E7%AC%94%E8%AE%B0%E5%9F%8E%E5%8D%97%E6%97%A7%E4%BA%8B-%E4%B9%A6%E8%AF%AD%E8%80%85%E7%94%B5%E5%AD%90%E5%9B%BE%E4%B9%A6%E9%A6%86/"},{"categories":null,"content":" 77-78, 标注, 2022 年 7 月 2 日星期六 上午 9:35:26 事物之所以无我，是因为它随缘生灭，缘起则生，缘灭则灭，这便是因果。 104-105, 标注, 2022 年 7 月 2 日星期六 上午 9:39:58 人生充满烦恼，但如果能以烦恼为契机去勘悟世间万象的本质，从烦恼入手去实现止息烦恼的最终目的，那么这样一个充满烦恼的人生就是我们解脱的最好机缘。 113-114, 标注, 2022 年 7 月 2 日星期六 上午 9:56:45 当身处逆境时，不妨有意识地训练自己以更加现实的态度去面对生活的考验，看看从逆境中能得到什么于己有益的东西 159-160, 标注, 2022 年 7 月 2 日星期六 下午 4:00:57 “问题若有办法解决，就不必担心；若没办法解决，担心也没有用。 ","date":"2024-10-09","objectID":"/%E7%AC%94%E8%AE%B0%E6%AC%A1%E7%AC%AC%E8%8A%B1%E5%BC%80-%E5%B8%8C%E9%98%BF%E8%8D%A3%E5%8D%9A%E5%A0%AA%E5%B8%83/:0:0","tags":["cidihuakai","note","ireader"],"title":"[笔记]次第花开-希阿荣博堪布","uri":"/%E7%AC%94%E8%AE%B0%E6%AC%A1%E7%AC%AC%E8%8A%B1%E5%BC%80-%E5%B8%8C%E9%98%BF%E8%8D%A3%E5%8D%9A%E5%A0%AA%E5%B8%83/"},{"categories":null,"content":" 14344-14345, 标注, 2019 年 9 月 14 日星期六 上午 9:44:16 越简单的机关设计越可靠，而越珍贵的事物被毁掉越会被重视 15253-15254, 标注, 2019 年 9 月 14 日星期六 下午 2:04:34 太阳就在那里，你怎么遮掩，也总会被人看到，如果你不喜欢被人看着，那么你要做的事情就是让自己更明亮，亮瞎他们的眼。 18609-18609, 标注, 2019 年 9 月 14 日星期六 下午 8:47:52 有所得便是欢喜。 20999-20999, 标注, 2019 年 9 月 15 日星期日 下午 4:43:33 他身上的衣服更是夸张，便是五彩斑斓都不能形容，仿佛把世间所有颜色都涂在了上边。 31809-31810, 标注, 2019 年 9 月 22 日星期日 下午 5:10:13 如果境界高便意味着厉害，那修行界又怎么会有如此多无聊的战斗，见面的时候报报境界便好了。 45009-45009, 标注, 2019 年 10 月 2 日星期三 下午 9:36:00 我们是父母的孩子，是孩子的父母，是伴侣的伴侣，是酒友 45009-45010, 标注, 2019 年 10 月 2 日星期三 下午 9:36:09 我们是父母的孩子，是孩子的父母，是伴侣的伴侣，是酒友的酒友，是赌伴的赌伴，是世界眼里的我们。 54436-54436, 标注, 2019 年 10 月 7 日星期一 上午 10:26:11 因为正义的胜利千篇一律，有趣的灵魂必死无疑。 ","date":"2024-10-09","objectID":"/%E7%AC%94%E8%AE%B0%E5%A4%A7%E9%81%93%E6%9C%9D%E5%A4%A9-%E7%8C%AB%E8%85%BB/:0:0","tags":["dadaochaotia","note","ireader"],"title":"[笔记]大道朝天-猫腻","uri":"/%E7%AC%94%E8%AE%B0%E5%A4%A7%E9%81%93%E6%9C%9D%E5%A4%A9-%E7%8C%AB%E8%85%BB/"},{"categories":null,"content":" 564-565, 标注, 2018 年 8 月 11 日星期六 下午 8:56:08 所有的写操作只追加而不修改老的数据。在 Bitcask 系统中，每个文件有一定的大小限制，当文件增加到相应的大小时，就会产生一个新的文件，老的文件只读不写。 644-645, 标注, 2018 年 8 月 12 日星期日 下午 3:31:39 存储系统的数据模型主要包括三类：文件、关系以及随着 NoSQL 技术流行起来的键值模型。 690-692, 标注, 2018 年 8 月 12 日星期日 下午 4:01:13 表格模型往往还支持无模式（schema-less）特性，也就是说，不需要预先定义每行包括哪些列以及每个列的类型，多行之间允许包含不同列。 842-844, 标注, 2018 年 8 月 12 日星期日 下午 4:29:58 需要将内存中的数据定期转储（Dump）到磁盘，这种技术称为 checkpoint（检查点）技术。系统定期将内存中的操作以某种易于加载的形式（checkpoint 文件）转储到磁盘中，并记录 checkpoint 时刻的日志回放点，以后故障恢复只需要回放 checkpoint 时刻的日志回放点之后的 REDO 日志。 746-822, 标注, unknown NoSQL 系统带来了很多新的理念，比如良好的可扩展性，弱化数据库的设计范式，弱化一致性要求，在一 824-897, 标注, unknown NoSQL 系统带来了很多新的理念，比如良好的可扩展性，弱化数据库的设计范式，弱化一致性要求 899-1082, 标注, unknown 需要将内存中的数据定期转储（Dump）到磁盘，这种技术称为 checkpoint（检查点）技术。系统定期将内存中的操作以某种易于加载的形式（checkpoint 文件）转储到磁盘中，并记录 checkpoint 时刻的日志回放点，以后故障恢复只需要回放 checkpoint 时刻的日志回放点之后的 REDO 日 1084-1237, 标注, unknown 需要将内存中的数据定期转储（Dump）到磁盘，这种技术称为 checkpoint（检查点）技术。系统定期将内存中的操作以某种易于加载的形式（checkpoint 文件）转储到磁盘中，并记录 checkpoint 时刻的日志回放点，以后故障恢复只需要回放 1239-1436, 标注, unknown 需要将内存中的数据定期转储（Dump）到磁盘，这种技术称为 checkpoint（检查点）技术。系统定期将内存中的操作以某种易于加载的形式（checkpoint 文件）转储到磁盘中，并记录 checkpoint 时刻的日志回放点，以后故障恢复只需要回放 checkpoint 时刻的日志回放点之后的 REDO 日志。 由于将内存数据转储到磁 1438-1623, 标注, unknown 需要将内存中的数据定期转储（Dump）到磁盘，这种技术称为 checkpoint（检查点）技术。系统定期将内存中的操作以某种易于加载的形式（checkpoint 文件）转储到磁盘中，并记录 checkpoint 时刻的日志回放点，以后故障恢复只需要回放 checkpoint 时刻的日志回放点之后的 REDO 日志。 1625-1867, 标注, unknown 存储系统在选择压缩算法时需要考虑压缩比和效率。读操作需要先读取磁盘中的内容再解压缩，写操作需要先压缩再将压缩结果写入到磁盘，整个操作的延时包括压缩/解压缩和磁盘读写的延迟，压缩比越大，磁盘读写的数据量越小，而压缩/解压缩的时间也会越长，所以这里需要一个很好的权衡点。Google Bigtable 系统中使用了 BMDiff 以及 Zippy 两种压缩算法，它们通过牺牲一定的压缩比换取算法执行速度的大幅提升，从而获得更好的折衷。 1869-1981, 标注, unknown 设计容错系统的一个基本原则是：网络永远是不可靠的，任何一个消息只有收到对方的回复后才可以认为发送成功，系统设计时总是假设网络将会出现异常并采取相应的处理措施。 （3）磁盘 1983-2066, 标注, unknown 设计容错系统的一个基本原则是：网络永远是不可靠的，任何一个消息只有收到对方的回复后才可以认为发送成功，系统设计时 2068-2174, 标注, unknown 设计容错系统的一个基本原则是：网络永远是不可靠的，任何一个消息只有收到对方的回复后才可以认为发送成功，系统设计时总是假设网络将会出现异常并采取相应的处理措施。 1099-1100, 标注, 2018 年 8 月 12 日星期日 下午 7:51:48 分布式存储系统需要能够自动识别负载高的节点，当某台机器的负载较高时，将它服务的部分数据迁移到其他机器，实现自动负载均衡。 1100-1101, 标注, 2018 年 8 月 12 日星期日 下午 7:52:06 分布式存储系统的一个基本要求就是透明性，包括数据分布透明性，数据迁移透明性，数据复制透明性，故障处理透明性 1413-1414, 标注, 2018 年 8 月 14 日星期二 下午 12:33:53 Paxos 协议用于保证同一个数据分片的多个副本之间的数据一致性 1414-1415, 标注, 2018 年 8 月 14 日星期二 下午 12:34:05 2PC 协议用于保证属于多个数据分片上的操作的原子性 1573-1574, 标注, 2018 年 8 月 16 日星期四 下午 3:43:17 Master 创建了一个 chunk，它会根据如下因素来选择 chunk 副本的初始位置：1）新副本所在的 ChunkServer 的磁盘利用率低于平均水平；2）限制每个 Chunk-Server“最近”创建的数量；3）每个 chunk 的所有副本不能在同一个机架 1616-1617, 标注, 2018 年 8 月 16 日星期四 下午 3:50:23 在设计 GFS 时认为节点失效是常态，通过在软件层面进行故障检测，并且通过 chunk 复制操作将原有故障节点的服务迁移到新的节 1803-1806, 标注, 2018 年 8 月 16 日星期四 下午 4:16:50 考虑到节点的异构性，不同节点的处理能力差别可能很大，Dynamo 使用了改进的一致性哈希算法：每个物理节点根据其性能的差异分配多个 token，每个 token 对应一个“虚拟节点”。每个虚拟节点的处理能力基本相当，并随机分布在哈希空间中。存储时，数据按照哈希值落到某个虚拟节点负责的区域，然后被存储在该虚拟节点所对应的物理节点中。 1815-1817, 标注, 2018 年 8 月 16 日星期四 下午 4:25:27 所有节点每隔固定时间（比如 1s）通过 Gossip 协议的方式从其他节点中任意选择一个与之通信的节点。如果连接成功，双方交换各自保存的集群信息。 Gossip 协议用于 P2P 系统中自治的节点协调对整个集群的认识，比如集群的节点状态、负载情 1967-1968, 标注, 2018 年 8 月 16 日星期四 下午 6:02:29 Bigtable 的设计理念是构建在廉价的硬件之上，通过软件层面提供自动化容错和线性可扩展性能力。 2957-2960, 标注, 2018 年 8 月 21 日星期二 下午 8:25:52 整个系统设计时完全摒弃了随机写，除了操作日志总是顺序追加写入到普通 SAS 盘上，剩下的写请求都是对响应时间要求不是很高的批量顺序写，SSD 盘可以轻松应对，而大量查询请求的随机读，则发挥了 SSD 良好的随机读的特性。摒弃随机写，采用批量的顺序写，也使得固态盘的使用寿命不再成为问题。 3006-3008, 标注, 2018 年 8 月 22 日星期三 下午 7:47:01 内存管理是 C++高性能服务器的核心问题。一些通用的内存管理库，比如 Google TCMalloc，在内存申请/释放速度、小内存管理、锁开销等方面都已经做得相当卓越了，然而，我们并没有采用。这是因为，通用内存管理库在性能上毕竟不如专用的内存池 3363-3533, 标注, unknown 整个系统设计时完全摒弃了随机写，除了操作日志总是顺序追加写入到普通 SAS 盘上，剩下的写请求都是对响应时间要求不是很高的批量顺序写，SSD 盘可以轻松应对，而大量查询请求的随机读，则发挥了 SSD 良好的随机读的特性。摒弃随机写，采用批量的顺序写，也使得固态盘的使用寿命不再成为问题， 3535-3684, 标注, unknown 内存管理是 C++高性能服务器的核心问题。一些通用的内存管理库，比如 Google TCMalloc，在内存申请/释放速度、小内存管理、锁开销等方面都已经做得相当卓越了，然而，我们并没有采用。这是因为，通用内存管理库在性能上毕竟不如专用的内存池 3686-3754, 标注, unknown 释放内存时，如果没有超出线程缓存的内存块个数限制，则将内存块还给线程局部的空闲链表 ","date":"2024-10-09","objectID":"/%E7%AC%94%E8%AE%B0%E5%A4%A7%E8%A7%84%E6%A8%A1%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90%E4%B8%8E%E6%9E%B6%E6%9E%84%E5%AE%9E%E6%88%98--%E6%9D%A8%E4%BC%A0%E8%BE%89/:0:0","tags":["ireader","daguimo","fenbushi","cunchu"],"title":"[笔记]大规模分布式存储系统：原理解析与架构实战  杨传辉","uri":"/%E7%AC%94%E8%AE%B0%E5%A4%A7%E8%A7%84%E6%A8%A1%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90%E4%B8%8E%E6%9E%B6%E6%9E%84%E5%AE%9E%E6%88%98--%E6%9D%A8%E4%BC%A0%E8%BE%89/"},{"categories":null,"content":" 198-198, 标注, 2020 年 6 月 14 日星期日 下午 7:11:48 这些最近公开的文件前所未有地、清楚地表明布什及白宫的顾问做了许多事情来延长苏联的寿命。 343-345, 标注, 2020 年 6 月 14 日星期日 下午 7:37:24 俄国著名剧作家安东·契科夫曾言，若是戏剧第一幕的舞台上放了把枪，下一幕它将开火。两个超级大国已在全球舞台上布满了核武器，迟早会有某位演员在第二幕擦枪走火。 642-643, 标注, 2020 年 6 月 14 日星期日 下午 8:12:32 戈尔巴乔夫的翻译帕维尔·帕拉日琴科事后回忆那次谈话的要旨是：“世界日渐多样化和多极化，但是世界需要轴心，我们两个国家就能成为轴心。” 737-738, 标注, 2020 年 6 月 14 日星期日 下午 8:40:57 如果说，戈尔巴乔夫的攀升之路靠的是种粮，以及伺候好那些来他那里泡温泉的莫斯科政坛大佬们，那么，叶利钦则是靠工业产量和建筑业定额来达到目的。 1254-1255, 标注, 2020 年 6 月 16 日星期二 下午 9:39:11 几位女士手捧当地的花束，有些人高举起孩子，还有一位男子带来一只大面包和一袋盐，用这种传统的方式表示欢迎。” 1361-1363, 标注, 2020 年 6 月 17 日星期三 下午 10:54:42 我们担心如果我们直接支持民族独立运动，暴力活动将随之而起，在共和国内，中央对核武器的管控遭到削弱，所以我们希望看到苏联体系日趋衰微，改革之势渐弱，苏联平稳地衰弱才符合我们的利益。 2955-2957, 标注, 2020 年 6 月 27 日星期六 下午 2:56:04 原则上，这完全正确：我处事灵活、老到，我很少当人面说出事实真相，我很少畅所欲言。多年的经验告诉我，政治上的任何坦率或是公开都可能反过来将自己置于不利的境地。” 568-630, 标注, unknown 世界日渐多样化和多极化，但是世界需要轴心，我们两个国家就能成为轴心。” ","date":"2024-10-09","objectID":"/%E7%AC%94%E8%AE%B0%E5%A4%A7%E5%9B%BD%E7%9A%84%E5%B4%A9%E6%BA%83%E8%8B%8F%E8%81%94%E8%A7%A3%E4%BD%93%E7%9A%84%E5%8F%B0%E5%89%8D%E5%B9%95%E5%90%8E-%E7%BE%8E%E6%B2%99%E5%B8%8C%E5%88%A9%E6%B5%A6%E6%B4%9B%E5%9F%BA/:0:0","tags":null,"title":"[笔记]大国的崩溃：苏联解体的台前幕后-[美]沙希利·浦洛基","uri":"/%E7%AC%94%E8%AE%B0%E5%A4%A7%E5%9B%BD%E7%9A%84%E5%B4%A9%E6%BA%83%E8%8B%8F%E8%81%94%E8%A7%A3%E4%BD%93%E7%9A%84%E5%8F%B0%E5%89%8D%E5%B9%95%E5%90%8E-%E7%BE%8E%E6%B2%99%E5%B8%8C%E5%88%A9%E6%B5%A6%E6%B4%9B%E5%9F%BA/"},{"categories":null,"content":" 518-663, 标注, unknown Pain is inevitable．Suffering is optional．这便是他的真言。其微妙的含义难以正确地翻译，明知其不可译而硬译， 不妨译成最为简单的：“痛楚难以避免，而磨难可以选择。”关键词是这个 optional。 754-951, 标注, unknown 自从今年五月末，开始在马萨诸塞州的剑桥生活以来，跑步便再度成为我日常生活的一根支柱。我跑得相当认真。非要举出具体的数字加 以说明，便意味着每星期跑六十公里，亦即说每周跑六天，每天跑十公里。本来每周七天、每天跑十公里最好，可是有的日子会下雨，有 的日子会因为工作太忙抽不出时间，还有觉得身子疲惫实在不想动步的时候，所以预先设定了一天“休息日” 998-1233, 标注, unknown 跑步对我来说，不独是有益的体育锻炼，还是有效的隐喻。我每日一面跑步，或者说一面积累参赛经验，一面将目标 的横杆一点点地提高，通过超越这高度来提高自己。至少是立志提高自己，并为之日日付出努力。我固然不是了不起 的跑步者，而是处于极为平凡的-–—毋宁说是凡庸的-–—水准。然而这个问题根本不重要。我超越了昨天的自己， 哪怕只是那么一丁点儿，才更为重要。在长跑中，如果说有什么必须战胜的对手，那就是过去的自己。 1280-1497, 标注, unknown 说起来，我这个人是那种喜爱独处的性情，表达得准确一点，是那种不太以独处为苦的性情。每天有一两个小时跟谁 都不交谈，独自一人默默地跑步也罢，四五个小时伏案独坐，默默地写文章也罢，我都不觉得难熬，也不感到无聊。 这种倾向从年轻时起便一以贯之，始终存在于我的身上。和同什么人一起做什么事相比，我更喜欢一人默不作声地读 书，或是全神贯注地听音乐。只需一个人做的事情，我可以想出许多许多来。 1544-1717, 标注, unknown 跑步时浮上脑际的思绪，很像天际的云朵，形状各异，大小不同。它们飘然而来，又飘然而去。然而天空犹自是天空， 一成不变。云朵不过是匆匆过客，它穿过天空，来了去了。唯有天空留存下来。所谓天空。，是既在又不在的东西， 既是实体又不是实体。对于天空这种广漠容器般的存在状态，我们唯有照单收下，全盘接受。 1764-1859, 标注, unknown 跑的距离长于平日，便是强化了自己的肉体，哪怕是一点点。发怒的话，就将那份怒气冲着自己发好了。感到懊恼的 话，就用那份懊恼来磨炼自己好了。 1906-2031, 标注, unknown 因为我，就是这样一个人。想就河流作一番思考，还想就云朵作一番思考，然而心中却是空空。我在自制的小巧玲珑 的空白之中、在令人怀念的沉默之中，一味地跑个不休。这是相当快意的事情，哪还能管别人如何言说? 2123-2240, 标注, unknown 跑步有好几个长处。首先是不需要伙伴或对手，也不需要特别的器具和装备，更不必特地赶赴某个特别的场所。只要 有一双适合跑步的鞋，有一条马马虎虎的路，就可以在兴之所至时爱跑多久就跑多久。 2287-2454, 标注, unknown 原来略呈增加的体重逐渐趋于稳定。每天坚持运动，适合自己的体重自然而然确定下来。最易驱动身体的肌肉开始显 现。随即，吃的食物也一点点发生了变化，食物以蔬菜为主，蛋白质主要靠吃鱼摄取。我一直不太喜欢吃肉，愈发吃 得少了。少吃米饭，减少酒量，使用天然材质的调味品。而甜的东西，我本不喜欢 2501-2818, 标注, unknown 我常常寻思：“人生真是不公平啊!”一些人不努力便得不到的东西，有些人却无须努力便唾手可得。不过细想起来， 这种生来易于肥胖的体质，或许是一种幸运。比如说，我这种人为了不增加体重，每天得剧烈地运动，留意饮食，有 所节制。何等费劲的人生啊!然而倘使从不偷懒，坚持努力，代谢便可以维持在高水平，身体愈来愈健康强壮，老化 恐怕也会减缓。什么都不做也不发胖的人无须留意运动和饮食。并无必要，却去寻这种麻烦事儿做的人，为数肯定不 会太多，因此这种体质的人，每每随着年龄增长而体力日渐衰退。不着意锻炼的话，自然而然，肌肉便会松弛，骨质 便会变弱。什么才是公平，还得以长远的眼光观之，才能看明白。 2865-3229, 标注, unknown 天生才华横溢的小说家，哪怕什么都不做，或者不管做什么，都能自由自在写出小说来。就仿佛泉水从泉眼中汩汩涌 出一般，文章自然喷涌而出，作品遂告完成，根本无须付出什么努力。这种人偶尔也有。遗憾的是，我并非这种类型。 此言非自夸：任凭我如何在周遭苦苦寻觅，也不见泉眼的踪影。如果不手执钢凿孜孜不倦地凿开磐石，钻出深深的孔 穴，就无法抵及创作的水源。为了写小说，非得奴役肉体、耗费时间和劳力不可。打算写一部新作品，就必得重新一 一凿出深深的孔穴来。然而，长年累月地坚持这种生活，久而久之，就技术或体力而言，我都能相当高效地找寻到新 的水源，在坚固的磐石上凿穴钻孔；感觉一个水源变得匮乏时，也能果决而迅疾地移到下一个去。而习惯仅仅依赖一 处自然水源的人，冷不丁地这么做，只怕轻易做不来。 3276-3353, 标注, unknown 学校就是这样一种地方：在学校里，我们学到的最重要的东西，就是“最重要的东西在学校里学不到”这一真理。 3448-3552, 标注, unknown 到了最后关头，我很想用尽最后的死力，加速猛冲，然而两条腿怎么也不肯往前去。我想不起来该如何运动身体。浑 身的肌肉仿佛被人拿着锈迹斑斑的刨子在拼命刨挖一般。 3599-3712, 标注, unknown 在早晨的马拉松村咖啡馆里，我尽情享用了冰镇的阿姆斯特尔啤酒。啤酒诚然好喝，却远不似我在奔跑时热切向往的 那般美妙。失去理智的人怀抱的美好的幻想，在现实世界中根本是子虚乌有。 3812-3996, 标注, unknown 因为希冀长命百岁而跑步的人，大概不太多。怀着“不能长命百岁不打紧，至少想在有生之年过得完美”这种心情跑步 的人，只怕多得多。同样是十年，与其稀里糊涂地活过，目的明确、生气勃勃地活当然令人远为满意。跑步无疑大有 魅力：在个人的局限性中，可以让自己有效地燃烧-–—哪怕是一丁点儿，这便是跑步一事的本质，也是活着( 4092-4275, 标注, unknown 新英格兰那独特的短暂而美丽的秋，便忽进忽退地来了。那周遭尽是、直人满眼的深绿色，一点一点，将位子让予了 依约而来的金黄。继而到了在跑步时穿的短裤外再加一条宽松运动裤的时候，枯叶随凤起舞，橡子敲打在沥青路面上， 发出咚咚的声响，那坚硬而干燥的声响传向四方。此时，勤勉的松鼠为了过冬的食粮四下奔忙，累得连神色都变了。 4322-4589, 标注, unknown 过完万圣节，冬天好像一个干练的税务官，简洁少语、确实无误地姗姗走来。曾几何时，河里已然结上一层厚厚的冰， 赛艇也消失了踪影。愿意的话，你可以徒步从冰面走到河对岸去。树木连一片叶子也不剩，悉数落光，细细的枝条被 风吹得碰来撞去，如同干枯的骨头，发出咔嗒咔嗒的声响。在那高高的树上，可以看见松鼠筑好的窝。它们大概正在 那巢中做着宁静的梦。从不怯场的黑额黑雁成群地由北向南飞来，哦，北边还有比这里更加寒冷的地方。刮过河面的 风好似刚刚磨亮的大砍刀，寒冷锐利。白天迅速变短，云层愈来愈厚。 4636-4860, 标注, unknown 大小不同形状各异的云朵随兴所至，突然现身遂又逝去。河流承受着太阳的光辉，将那白色光影的去来忽而鲜明忽而 暖味地映在水面上。根据季节的不同，简直有如切换开关，风向会发生变化。而根据触感、气味和风向，我们能明确 地感受到季节推移的刻度。在这样一种伴随着实感的流移变幻之中，我认识到自己在自然这巨大的马赛克当中，只不 过一块微小的彩片；亦如河里的水，不过是流过桥下奔向大海的、可以置换的自然的一部分。 4907-5216, 标注, unknown 沿着清晨的查尔斯河，我依照自己的步调信步慢跑，却被大概是哈佛新生的女生们从背后一一赶超过去。她们大多娇 小玲珑，苗条瘦削，身穿印有哈佛标志的深红色 T 恤，一头金发扎成马尾辫子，一面听着崭新的 iPod，一面英姿飒爽 地沿着道路向前直奔。人们从其中毫无疑义地感觉到某种攻击性、挑战性的东西。她们似乎习惯一个个地超越众人， 不习惯为别人超越。她们一望而知是优秀的，是健康的，深具魅力，严肃认真，而且充满自信。她们的奔跑，怎么看 都不是适合长跑的跑法，而是典型的中距离跑。步幅很大，蹬踏锐利而有力。一边赏玩周边的风景一边优哉游哉地跑 步，恐怕与她们的思维方式格格不入。 5263-5427, 标注, unknown 尤其是《爬行动物》，我一边跑步一边听，听了一遍又一遍。允许我谈谈个人意见的话，我想说：((爬行动物》是最 最适合在不慌不忙地跑步的早晨听的歌集。丝毫没有咄咄逼人和矫揉造作。节奏永远可靠，旋律自然无比。我的意识 被静静地拽进音乐之中，双腿配合着节奏有规律地向前踏出，向后蹬去。 5474-5598, 标注, unknown 跑步时很适合背诵演讲稿之类。一边几乎无意识地迈步，一边在大脑中依序排列词语，检验文章的节奏，设想词句的 韵律。就这样，一面将意识放置于别处，一面放脚奔跑，便能毫不费力地以自然的速度奔跑很久很久。 5684-5831, 标注, unknown 那是入秋以来的第一场淫雨。雨忽强忽弱，仿佛突发奇想，虽有雨住的时候，却片刻不曾露过爽朗的晴空。天空白始 至终为这个地方特有的厚厚灰色云层紧紧遮覆。好似一个优柔寡断、狐疑不决的人，那雨磨磨蹭蹭地下了又下，最后 终于下定了决心，变成了一场豪雨。 ","date":"2024-10-09","objectID":"/%E7%AC%94%E8%AE%B0%E5%BD%93%E6%88%91%E8%B0%88%E8%B7%91%E6%AD%A5%E6%97%B6%E6%88%91%E8%B0%88%E4%BA%9B%E4%BB%80%E4%B9%88-n-a/:0:0","tags":["dangwotanpao","note","ireader"],"title":"[笔记]当我谈跑步时，我谈些什么-N/A","uri":"/%E7%AC%94%E8%AE%B0%E5%BD%93%E6%88%91%E8%B0%88%E8%B7%91%E6%AD%A5%E6%97%B6%E6%88%91%E8%B0%88%E4%BA%9B%E4%BB%80%E4%B9%88-n-a/"},{"categories":null,"content":" 129-129, 标注, 2022 年 7 月 2 日星期六 下午 5:11:22 阿丽克西斯永远是他们的女儿，不过不会永远是她记忆中的那个孩子。 1041-1042, 标注, 2022 年 7 月 3 日星期日 下午 5:09:44 迪米特里听到许多成年人的谈话，察觉到大人们就同一件事翻来覆去地谈个不休，像狗啃着早就没有肉的骨头一样 1570-1571, 标注, 2022 年 7 月 3 日星期日 下午 8:15:46 每天更多故事从四下里传来，就像蒲公英种子飘散在空中。 ","date":"2024-10-09","objectID":"/%E7%AC%94%E8%AE%B0%E5%B2%9B-%E7%BB%B4%E5%A4%9A%E5%88%A9%E4%BA%9A%E5%B8%8C%E6%96%AF%E6%B4%9B%E6%99%AE/:0:0","tags":["dao","note","ireader"],"title":"[笔记]岛-维多利亚·希斯洛普","uri":"/%E7%AC%94%E8%AE%B0%E5%B2%9B-%E7%BB%B4%E5%A4%9A%E5%88%A9%E4%BA%9A%E5%B8%8C%E6%96%AF%E6%B4%9B%E6%99%AE/"},{"categories":null,"content":" 523-525, 标注, 2024 年 9 月 26 日星期四 上午 8:04:45 有些西方人对邓小平的直率和务实留有深刻印象，这使他们误以为他骨子里是个资本主义分子，他会将中国引向西方式的民主。他一向乐于学习，但他最终认为，自己要比他们更清楚什么对中国有利，而那不应该是资本主义和西方式的民主。 582-584, 标注, 2024 年 9 月 26 日星期四 上午 8:11:16 邓小平养成了一种刚毅的品格，能够做到不论愤怒还是受挫都不形于色，不让情绪左右自己的决策，而是把它创建在对党和国家需要的认真分析之上。毛泽东曾经 582-583, 标注, 2024 年 9 月 26 日星期四 上午 8:11:21 邓小平养成了一种刚毅的品格，能够做到不论愤怒还是受挫都不形于色，不让情绪左右自己的决策，而是把它创建在对党和国家需要的认真分析之上。 605-608, 标注, 2024 年 9 月 26 日星期四 上午 8:18:20 。他对内战和文革的混乱记忆犹新，因此认为中国的社会秩序很脆弱；如果他断定它受到威胁，就会作出强硬的反应。作为最高领导人，他准备按自己的日程表大胆实行改革开放。简言之，当他成为中国最高领导人时，他是个严守纪律、经验丰富的干部，决心为党和国家的需要而服务。 687-688, 标注, 2024 年 9 月 26 日星期四 上午 8:30:58 邓小平 1974 年会见一个美国的大学代表团时说：“我没有上过大学，但我一向认为，从我出生那天起，就在上着人生这所大学。它没有毕业的一天，直到去见上帝。” 978-980, 标注, 2024 年 9 月 26 日星期四 下午 12:29:55 当时他还无从知道，从长远看，他因被指为“毛派头子”而受到惩罚其实是他的运气，因为这使毛泽东长期相信邓小平是忠实于自己的。在后来的岁月里，即便在毛泽东让激进派批邓时，也绝不同意把邓小平开除出党。 1145-1146, 标注, 2024 年 9 月 26 日星期四 下午 6:33:38 邓小平很快就意识到，对斯大林的全面批判将殃及那些和斯大林一起工作的人，削弱苏共的权威。 1146-1146, 笔记, 2024 年 9 月 26 日星期四 下午 6:34:28 所以日后对毛的功过评论很保守 1170-1171, 标注, 2024 年 9 月 26 日星期四 下午 6:37:21 反右运动毁掉了中国大批最优秀的科技人才，也使很多人疏远了中共。本来有可能阻止毛泽东发动大跃进的批评者变得噤若寒蝉 1184-1186, 标注, 2024 年 9 月 26 日星期四 下午 6:39:05 虽然难以估算在最糟糕的三年——从 1959 年到 1961 年——到底饿死了多少人，但按大陆官方统计，估计有 1,600 万到 1,700 万人死于非正常原因，外国分析家的估计则高达 4,500 万。 1365-1367, 标注, 2024 年 9 月 26 日星期四 下午 6:48:45 文革对国家、对邓小平本人和家庭的影响让他感到痛心。但是，据在江西最后两年的大多数时间跟父母住在一起的邓榕说：“他没有意气用事，没有情绪消沉，没有放弃哪怕是最后的一线希望。” 1380-1384, 标注, 2024 年 9 月 26 日星期四 下午 6:50:12 ，邓小平发现，这一段退出日常政治的在野岁月使他能够对国家的重大和长远目标形成清晰的认识。倘若邓小平没有对中国需要进行的改革的性质以及如何加以落实作过长期思考，很难想像他在 1977 年以后能够采取那些熟练而有力的措施。毛泽东曾经利用他在延安那段被封锁隔绝的时间思考中共夺取政权后全国的整体战略，邓小平也利用了他在江西的时光，思考着他所要进行的改革的大方向 1497-1499, 标注, 2024 年 9 月 26 日星期四 下午 7:10:27 一些了解邓小平的人说，他在权衡如何惩罚人时，绝大多数情况下都不会让个人感情影响决定，然而他特别严厉地坚持要判聂元梓十年徒刑，因为正是聂在北京大学发动的政治批斗导致了邓朴方的瘫痪和大约 60 名教职工的死亡。 4461-4464, 标注, 2024 年 9 月 27 日星期五 下午 8:54:02 华国锋与“四人帮”的斗争后来被一再说成善恶之间的伟大斗争，是追求正确路线的党与“四人帮”反党集团的斗争。就像中国历史文献中记录的很多故事一样，这其实属于成王败寇的老生常谈。不过，这一次就像 1949 年一样，获胜者确实得到了真诚而普遍的拥护。 4731-4734, 标注, 2024 年 9 月 27 日星期五 下午 9:17:18 ，一些宣传家和毛泽东的坚定追随者，却不断批评他偏离了毛泽东为党制定的路线。为了回应这些批评，华国锋授意他的拥护者写一篇理论文章，以证明他忠实于毛的遗志。由此而出笼的文章，便是 1977 年 2 月 7 日的《人民日报》、《红旗》杂志和《解放军报》社论。这篇社论宣佈，凡是毛主席作出的决策都要执行，凡是毛主席的指示都要照办，此即后来著名的“两个凡是”，它成了华国锋表明自己完全忠实于毛主席遗志的标志。 4766-4769, 标注, 2024 年 9 月 27 日星期五 下午 9:20:19 时常有人说，中国的对外开放政策——包括愿意学习国外经验和急迫地想要引进外国技术——源于 1978 年 12 月邓小平领导下的三中全会。其实这些做法始于 1977–1978 年华国锋的领导，而华国锋提出的政策也并非由他首创。华国锋和邓小平所推行的，是被很多中共干部视为中国必由之新路的政策。 4914-4916, 标注, 2024 年 9 月 28 日星期六 上午 8:27:09 邓力群带来了邓小平写作班子前负责人胡乔木的一封检讨信，胡为自己参与批邓表示道歉。邓小平没有看那封信，而是让邓力群把它退了回去。他说，胡乔木的批评我不介意，胡乔木只是讲了一些套话，这可以理解；没有必要为这种装样子的事道歉。 5177-5181, 标注, 2024 年 9 月 28 日星期六 上午 9:03:06 《理论动态》在 1978 年 5 月 10 日出了第 60 期简报，标题是“实践是检验真理的唯一标准”。 [6-71] 该文已经酝酿了数月，是由南京大学哲学系青年教师胡福明、中央党校理论教研室孙长江和《光明日报》总编杨西光——他是中央党校 1977 年秋季入学的学员——数易其稿而完成。 5391-5394, 标注, 2024 年 9 月 28 日星期六 上午 9:17:57 1978 年 12 月 2 日，他告诉那些为他起草启动改革开放政策讲稿的人：“基本的要点是，必须承认自己落后，我们的很多做法都不对头，需要加以改变。 [7-4] 出国考察使很多高层干部更加相信邓小平的看法是正确的：中国必须改弦易辙。 5408-5410, 标注, 2024 年 9 月 28 日星期六 上午 9:20:22 当时广东存在着实际的治安问题：每年都有成千上万的年轻人逃往香港。邓小平 1977 年视察广东时有人向他谈到这个问题，邓小平说，出路不是用更多的铁丝网和边境哨所强化治安，而是集中精力发展广东经济，这样年轻人就会觉得没有必要再逃到香港谋生了。 5830-5831, 标注, 2024 年 9 月 28 日星期六 上午 9:54:21 。就像他过去多次讲过的那样，他再次建议首先看大局，然后再想局部；先讲大道理，再讲小道理。 5856-5861, 标注, 2024 年 9 月 28 日星期六 上午 10:00:13 在 12 月 13 日下午中央工作会议的闭幕会上，邓小平一开口就直奔主题：“今天我主要讲一个问题，就是解放思想，开动脑筋，实事求是，团结一致向前看。”邓小平称赞这次工作会议是 1957 年以来党内最好、最开放的一次讨论会。他说，要允许大家说出对真实情况的看法。“必须有充分的民主，才能做到正确的集中。当前这个时期，特别需要强调民主。因为在过去一个相当长的时间内⋯⋯民主太少。⋯⋯应当允许群众提一些意见，即使有个别心怀不满的人，想利用民主闹一点事，也没有什么可怕⋯⋯最可怕的是鸦雀无声。” 5865-5869, 标注, 2024 年 9 月 28 日星期六 上午 10:03:54 他再次重复了自己的观点，认为毛泽东犯过错误，他本人也犯过错误，任何想做事的领导人都会犯错误。他表达了党内高层的一种主流观点：中国的两次大灾难——大跃进和文革，是由于制度造成的，这种制度允许一人统治，容不下不同的声音。因此中国需要创建法制，这样的话一个人不管能力有多大，都不能由他一个人说了算。法制一开始可能不健全、不完善，但可以逐步使其变得公正合理。 6131-6131, 标注, 2024 年 9 月 28 日星期六 上午 10:21:45 文化大革命其实是一场“反文化的革命”，它攻击了旧文化，却并没有创造出新文化。 6230-6233, 标注, 2024 年 9 月 28 日星期六 上午 10:29:23 尽管《人民日报》没有报道西单的事情，但报社里支持“民主墙”的人在 1979 年 1 月 3 日发表了一篇大胆的社论〈发扬民主和实现四化〉，其中说：“让人说话，天不会塌下来。⋯⋯真正可怕的倒是听不到不同的声音。⋯⋯害怕人民讲话，实际是软弱和神经衰弱的表现。⋯⋯安定团结和发扬民主并不是对立的。” 8654-8656, 标注, 2024 年 9 月 28 日星期六 上午 11:15:38 除了为数不多的人事和军队职位外，他在选择领导人时，首先不是看他们是否对自己忠诚（对军队的任命见第 18 章）。他需要的是最称职的人，他坚信，只要他们素质高，忠于党，他就能与他们共事。","date":"2024-10-09","objectID":"/%E7%AC%94%E8%AE%B0%E9%82%93%E5%B0%8F%E5%B9%B3%E6%97%B6%E4%BB%A3-%E9%AB%98%E5%8D%8E/:0:0","tags":null,"title":"[笔记]邓小平时代（无删节完整版）-高华","uri":"/%E7%AC%94%E8%AE%B0%E9%82%93%E5%B0%8F%E5%B9%B3%E6%97%B6%E4%BB%A3-%E9%AB%98%E5%8D%8E/"},{"categories":null,"content":" 285-287, 标注, 2024 年 8 月 5 日星期一 下午 10:16:27 社会不提供免费教育是有罪的，应当为它制造出的黑暗负责。倘若人的灵魂充满了黑暗，必然要产生罪恶。有罪的人并不是那个犯罪的人，而是制造黑暗的人。” 340-341, 标注, 2024 年 8 月 5 日星期一 下午 10:40:33 他知道信仰有益无害。他用驯顺的人去极力劝导悲恸欲绝的人，并用仰望一颗星的悲痛去极力扭转俯视一个墓穴的悲痛。 350-351, 标注, 2024 年 8 月 5 日星期一 下午 10:41:28 如果再有时间，他就干活儿。有时在园子里挖土，有时看书或写东西。这两种活儿，被他统称为“耕耘”。他常说：“精神就是一块园地。” 506-507, 标注, 2024 年 8 月 5 日星期一 下午 10:53:49 永远也不要害怕盗贼和凶手。那是身外的危险，是小危险。还是害怕我们自身吧。偏见就是盗贼，恶习就是凶手。巨大的危险存在于我们自身。威胁我们的脑袋或者钱袋的危险，何足挂齿!一心考虑威胁我们灵魂的危险吧!” 557-558, 标注, 2024 年 8 月 6 日星期二 上午 6:22:23 我生前存在吗？不存在。我死后还会存在吗？不会。我 557-560, 标注, 2024 年 8 月 6 日星期二 上午 6:22:37 我生前存在吗？不存在。我死后还会存在吗？不会。我是什么呢？不过是某种机体聚合的一点尘埃。在这尘世上，我能做什么呢？倒是可以选择受罪或者享乐。受罪，能把我引到何处呢？引到虚无。白受了一辈子罪。享乐又能把我引到何处呢？也是虚无。但我毕竟享乐了一生。 568-570, 标注, 2024 年 8 月 6 日星期二 上午 6:23:43 至于下等人，那些赤脚汉、穷光蛋、可怜虫，当然需要点什么。那就给他们享用传说、虚幻、灵魂、永生、天堂和星宿。给他们大吃大嚼吧，让他们涂在干面包上吧。一无所有的人总算还有个慈悲的上帝。这是最起码的了。 2420-2421, 标注, 2024 年 8 月 12 日星期一 下午 12:32:45 从前那身仿佛由快乐、轻狂和音乐织成的，缀满响铃和散发丁香味儿的锦带罗纱衣裙，就像阳光下看似钻石的美丽耀眼的霜花，早已融化消失。霜化了，露出黝黑的树枝。 2420-2420, 标注, 2024 年 8 月 12 日星期一 下午 12:33:00 从前那身仿佛由快乐、轻狂和音乐织成的，缀满响铃 2448-2448, 标注, 2024 年 8 月 12 日星期一 下午 12:40:23 触景生情，心里十分激动，就在那位母亲唱歌换气的工 2461-2461, 标注, 2024 年 8 月 12 日星期一 下午 12:45:16 接着，她又从蒙勃勒走到蒙菲郿，小家伙能走几步路，但到底 2455-2455, 标注, 2024 年 8 月 12 日星期一 下午 12:45:23 情态：女不女，男不男，一副忸怩作态的样子。 2511-2513, 标注, 2024 年 8 月 12 日星期一 下午 12:50:17 世间就有一种人像虾子一样，不停地退向黑暗，他们不思前进，只是回头看生活，阅历只用来增加他们的扭曲形态，而且越变越坏，心肠越来越污黑丑恶。 3342-3344, 标注, 2024 年 8 月 12 日星期一 下午 9:32:05 逾墙盗窃，折断树枝，偷走几个苹果，如果是小孩干的，就是淘气行为；如果是成年人干的，就是过失；如果是一个苦役犯干的，就是犯罪。 3512-3514, 标注, 2024 年 8 月 18 日星期日 上午 9:11:28 在精神的眼睛看来，人心比任何地方都更眩目，也更黑暗；精神的眼睛所注视的任何东西，都没有人心这样可怕，这样复杂，这样神秘，这样无边无际。有一种比海洋更宏大的景象，那就是天空；还有一种比天空更宏大的景象，那就是人的内心世界。 3515-3520, 标注, 2024 年 8 月 18 日星期日 上午 9:12:48 [231]诗中的那种神龙蛇怪的混杂和成群成群的鬼魂，有但丁诗中的那种螺旋形的幻视。每人负载的这种无限，虽然幽深莫测，但总是用来衡量自己头脑的意愿和生活的行为，而且总是大失所望。 3604-3605, 标注, 2024 年 8 月 18 日星期日 上午 9:20:17 人们阻止不了思想回到一个念头，如同不能阻止海水回到岸边。对水手来说，这叫作潮流；对罪人来说，这叫悔恨。人的灵魂经上帝掀动，好似汹涌澎湃的海洋。 4664-4666, 标注, 2024 年 8 月 18 日星期日 上午 10:53:19 德兰先生被捕的消息，在海滨蒙特伊引起轰动，更准确地说，是引起了异常的震动。我们十分遗憾，不能掩饰这样一个事实，只因“他当过苦役犯”这一句话，几乎所有的人就都把他抛弃了。他做过的好事，不到两个小时就被人遗忘，而他不过是一个“苦役犯”了。 4741-4742, 标注, 2024 年 8 月 18 日星期日 上午 10:58:59 就这样，芳汀葬在义冢：那一角地方属于大家，而不属于任何人，穷人就是在那里湮没无闻了。 4741-4743, 标注, 2024 年 8 月 18 日星期日 上午 10:59:09 就这样，芳汀葬在义冢：那一角地方属于大家，而不属于任何人，穷人就是在那里湮没无闻了。幸而上帝知道在什么地方招魂。他们让芳汀在黑暗中，伴随乱骨长眠，让她躺在男女混杂的骨灰上。她被抛进公墓。她的坟墓如同她生前的床铺。 5932-5937, 标注, 2024 年 8 月 18 日星期日 下午 8:44:12 客店老板的职责，就是有客人来时，要赶紧把烩肉、歇息、烛光、炉火、脏被单、女用人、跳蚤、笑脸卖给他；要拉住行客，掏空他们的小钱包，客客气气地减轻他们大钱包的分量，恭恭敬敬地招待旅行的人家住宿，剁男人的肉，拔女人的毛，剥孩子的皮；什么都要开出价——敞开的窗户、关起来的窗户、壁炉周围、扶手椅、普通座椅、圆凳、矮凳、鸭绒被、褥子和草垫——都要收钱；要知道没有光亮，镜子多么容易发污，这也得收费；总之，要想出五十万个鬼主意，无论什么都要让旅客出钱，就连他们的狗吃的苍蝇也不能免!” 6044-6045, 标注, 2024 年 8 月 20 日星期二 下午 9:44:16 在空间或在自己的头脑里，有时会看到莫名其妙的东西在游动，既朦胧又难以捕捉，犹如鲜花的睡梦。 6770-6770, 标注, 2024 年 8 月 25 日星期日 上午 8:17:50 孩子都像葡萄藤的幼枝，遇到什么都攀附， 9299-9301, 标注, 2024 年 9 月 4 日星期三 下午 10:12:05 他周围的一切，这静谧的园子、芬芳的花朵，这些欢叫的孩子，这些严肃而朴实的女人，这寂静的修道院，都慢慢进入他的心扉；他的心境逐渐变化，也像这修道院一样寂静，像这些鲜花一样芬芳，像这园子一样静谧，像这些女人一样朴实，像这些孩子一样欢乐了。 9315-9320, 标注, 2024 年 9 月 4 日星期三 下午 10:15:27 身上没穿衬衫，脚下没穿鞋子，头上没有屋顶，这些东西一样也没有，就好似空中的飞虫。小家伙的年龄，在七岁至十三岁之间，过着群体生活，终日在街上游荡，露宿街头，穿着自己父亲的一条旧裤，裤角拖在脚后跟，头戴另一个父亲的一顶破帽，一直扣到耳朵上，只挎着一条黄边背带，总是跑来跑去，东瞧瞧，西望望，到处耗时间，烟斗抽得挂满烟炱，满嘴脏话，搅扰酒馆，结识盗贼，亲近窑姐儿，会讲黑话，哼唱淫荡小曲，而心地却没有一点邪恶。这是因为他心灵里有一颗珍珠，天真无邪，珍珠不会融化在污泥里。人只要处于童年，就天真无邪，这是天意。 9681-9681, 标注, 2024 年 9 月 5 日星期四 上午 7:52:11 这孩子就生活在这种缺乏亲情的环境里，就像地窖里长出的苍白的小草。 9681-9682, 标注, 2024 年 9 月 5 日星期四 上午 7:52:25 这孩子就生活在这种缺乏亲情的环境里，就像地窖里长出的苍白的小草。他并不因此感到难过，也不怨恨任何人。他还弄不清楚父母应该是什么样子。 ","date":"2024-10-09","objectID":"/%E7%AC%94%E8%AE%B0%E8%AF%BB%E5%AE%A2%E7%BB%8F%E5%85%B8%E6%96%87%E5%BA%93%E6%82%B2%E6%83%A8%E4%B8%96%E7%95%8C%E5%85%A83%E5%86%8C-%E7%BB%B4%E5%85%8B%E5%A4%9A%E9%9B%A8%E6%9E%9C/:0:0","tags":null,"title":"[笔记]读客经典文库：悲惨世界（全3册）-维克多•雨果","uri":"/%E7%AC%94%E8%AE%B0%E8%AF%BB%E5%AE%A2%E7%BB%8F%E5%85%B8%E6%96%87%E5%BA%93%E6%82%B2%E6%83%A8%E4%B8%96%E7%95%8C%E5%85%A83%E5%86%8C-%E7%BB%B4%E5%85%8B%E5%A4%9A%E9%9B%A8%E6%9E%9C/"},{"categories":null,"content":" 1061-1061, 标注, 2022 年 6 月 14 日星期二 下午 10:27:54 在中国，任何超脱飞扬的思想都会砰然坠地的，现实的引力太沉重了。 435-511, 标注, unknown 她的面庞有一种淫荡的妩媚，让人想起宁可美艳地腐烂也不悄然枯萎的花朵一个妓女，混得还不算坏的那种。她 513-588, 标注, unknown 她的面庞有一种淫荡的妩媚，让人想起宁可美艳地腐烂也不悄然枯萎的花朵一个妓女，混得还不算坏的那种。 590-656, 标注, unknown 魔法时代开始于公元 1453 年 5 月 3 日 16 时，那时高维碎块首次接 658-852, 标注, unknown 在塔的二层，被剑钉在墙上的女魔法师死了，她可能是人类历史上唯一真正的魔法师。而在这之前约十小时，短暂的魔法时代也结束了。魔法时代开始于公元 1453 年 5 月 3 日 16 时，那时高维碎块首次接触地球；结束于 1453 年 5 月 28 日 21 时，这时碎块完全离开地球；历时二十五天五小时。之后，这个世界又回到了正常的轨道上。 854-890, 标注, unknown ETO（地球三体组 892-930, 标注, unknown ETO（地球三体组织） 932-1107, 标注, unknown 三体危机带来的文化冲击，其影响之深远也远超过人们当初的想象。如果为其寻找一个类比，在生物学上，相当于哺乳动物的远祖从海中爬上陆地；在宗教上，相当于亚当和夏娃被逐出伊甸园；而在历史和社会学上，根本找不到类比，人类文明所经历的一切与这一事件相比都微不足道。事实上，这一事件从根本上动摇了人类社会的文化 1109-1297, 标注, unknown 三体危机带来的文化冲击，其影响之深远也远超过人们当初的想象。如果为其寻找一个类比，在生物学上，相当于哺乳动物的远祖从海中爬上陆地；在宗教上，相当于亚当和夏娃被逐出伊甸园；而在历史和社会学上，根本找不到类比，人类文明所经历的一切与这一事件相比都微不足道。事实上，这一事件从根本上动摇了人类社会的文化、政治、宗教和经济的根基。 1299-1367, 标注, unknown 他甚至能感觉到她的体温，那时他真希望夜风转个方向，那样她的长发就能拂到他的面庞上。 1369-1456, 标注, unknown 自己的骨灰最大的可能也就是放在八宝山上的一个小格子里。不过如果有墓碑，上面应该写– 来了，爱了，给了她一颗星星，走了。 1458-1517, 标注, unknown 心说出一句完全意外的话：“天明，知道吗？安乐死法是为你通过的。” 1519-1637, 标注, unknown 化学动力火箭就像工业革命初期的大烟筒，那时的诗人赞美如林的大烟筒，认为那就是工业文明；现在人们同样赞美火箭，认为它代表着航天时代。事实上，依靠化学火箭可能永远也无法进入真正的航天时代 1639-1715, 标注, unknown 业人员一副老死不相往来的样子，捂紧口袋总怕被别人偷走些什么；情报人员则异常活跃友好，总想偷到些什么 1717-1778, 标注, unknown 照动量原理，要使飞船达到光速的百分之一，喷出的工质要首先超过那个速度 1780-1902, 标注, unknown 程心是来让他死。 接下来的一个简单推论更是让他笑得窒息：从程心到来的时间看，她肯定不知道云天明已经选择了安乐。换句话说，假如云天明没有选择安乐，她来了以后也要让他安乐，引诱他，甚至逼他安乐。 1904-2088, 标注, unknown 公元 20 世纪 80 年代可能是最后一个崇尚男性气质的年代，那以后，虽然男人还在，但社会和时尚所喜欢的男人越来越女性化。她想起了 21 世纪初的某些日韩男明星，第一眼看上去也是美丽女孩的样子，那时人们称之为男色时代来临。大低谷打断了人类的女性化进程，但随着威慑时代而来的半个多世纪的舒适的和平；使这一进程加速了。 2090-2169, 标注, unknown 特别之处只是她的女人味太浓了，像一滴浓缩的颜料，如果把她扔到一个大湖中溶化开来，那整个湖都是女人的色彩了 2171-2410, 标注, unknown 已知宇宙的尺度是一百六十亿光年，还在膨胀中，可光速却只有每秒三十万千米，慢得要命。这意味着，光永远不可能从宇宙的一端传到另一端，由于没有东西能超过光速，那宇宙一端的信息和作用力也永远不能传到另一端。如果宇宙是一个人，就意味着他没有一个神经信号能够传遍全身，他的大脑不知道四肢的存在，四肢不知道大脑的存在，同时每个肢体也不知道其他肢体的存在。这不是截瘫病人是什么？其实我有一个比这更糟的印象，宇宙只不过是一具膨胀中的死尸①。\" 2412-2778, 标注, unknown 关一帆手指灿烂的银河，眼睛却盯着韦斯特，像在指给他看一个突然出现的巨大怪物，“它是一个高位截瘫的病人！” “为什么？ \" 关一帆抱着双膝把自己缩成一团，这动作也同时使他在失重中慢慢旋转起来，他看到壮丽的银河系围绕着自己运行，自己成了宇宙中心。 “因为光速，已知宇宙的尺度是一百六十亿光年，还在膨胀中，可光速却只有每秒三十万千米，慢得要命。这意味着，光永远不可能从宇宙的一端传到另一端，由于没有东西能超过光速，那宇宙一端的信息和作用力也永远不能传到另一端。如果宇宙是一个人，就意味着他没有一个神经信号能够传遍全身，他的大脑不知道四肢的存在，四肢不知道大脑的存在，同时每个肢体也不知道其他肢体的存在。这不是截瘫病人是什么？其实我有一个比这更糟的印象，宇宙只不过是一具膨胀中的死尸①。” 2780-2971, 标注, unknown 的内脏。“褚岩说，“不过只要不用力也问题不大，可能有点儿疼或恶心，有时还会造成轻微的感染。也别乱动周围的东西，除非你确实知道那是什么。现在飞船上的一切都是裸露的，你可能触到高压电缆或高温蒸汽什么的，还可能接触到集成电路，造成系统故障。总之，对于三维世界来说你们现在有神一样的力量，但必须经过一段时间对四维的适应才能使用这种力量。 2973-3188, 标注, unknown “你们注意手不要乱动，不小心可能会触到别人或自己的内脏。“褚岩说，“不过只要不用力也问题不大，可能有点儿疼或恶心，有时还会造成轻微的感染。也别乱动周围的东西，除非你确实知道那是什么。现在飞船上的一切都是裸露的，你可能触到高压电缆或高温蒸汽什么的，还可能接触到集成电路，造成系统故障。总之，对于三维世界来说你们现在有神一样的力量，但必须经过一段时间对四维的适应才能使用这种力量。 3190-3227, 标注, unknown 方寸之间，深不见底啊 3229-3397, 标注, unknown 三体世界与太阳系的情况不同。首先，被广播的是三体星系的坐标，如果由此觉察到地球文明的存在，就要查阅近三个世纪前双方首次通信的资料；肯定会被查阅的，但查阅和决定发起打击同时发生的概率比较小；肯定会发生，但需要时间。还有更重要的一点：从远距离观察，三体星系看起来比太阳系更危险。” 程心 3399-3564, 标注, unknown 三体世界与太阳系的情况不同。首先，被广播的是三体星系的坐标，如果由此觉察到地球文明的存在，就要查阅近三个世纪前双方首次通信的资料；肯定会被查阅的，但查阅和决定发起打击同时发生的概率比较小；肯定会发生，但需要时间。还有更重要的一点：从远距离观察，三体星系看起来比太阳系更危险。” 3566-3743, 标注, unknown 了异世界的偷窥，屏蔽室中的人们都有一种前所未有的解脱感。智子屏蔽技术是在大移民结束后不久实现的，据说第一批进入屏蔽室的人都患上了一种\"屏蔽综合征”，他们像喝醉酒一样特别多话，无所顾忌地向身边的人倾诉自己的隐私。有一名记者用诗意的语言形容道：“在这个狭窄的天堂，人们敞开了心扉，我们对视的目光不再含蓄。 3745-3847, 标注, unknown 果真发现了光粒。不发警报可能是更好的选择，反正也没什么用。本来嘛，在不知不觉中突然完蛋是一种幸运，你却又要把几十亿人折磨二十四小时，这简直是反人类罪。 3849-3893, 标注, unknown 弱小和无知不是生存的障碍，傲慢才是 ","date":"2024-10-09","objectID":"/%E7%AC%94%E8%AE%B0%E8%AF%BB%E5%AE%A2%E7%BB%8F%E5%85%B8%E6%96%87%E5%BA%93%E4%B8%89%E4%BD%93%E5%85%A8%E9%9B%86-%E5%88%98%E6%85%88%E6%AC%A3/:0:0","tags":["santi","three","body"],"title":"[笔记]读客经典文库：三体全集-刘慈欣","uri":"/%E7%AC%94%E8%AE%B0%E8%AF%BB%E5%AE%A2%E7%BB%8F%E5%85%B8%E6%96%87%E5%BA%93%E4%B8%89%E4%BD%93%E5%85%A8%E9%9B%86-%E5%88%98%E6%85%88%E6%AC%A3/"},{"categories":null,"content":" 499-547, 标注, unknown 知我者， 谓我心忧； 不知我者，谓我何求。 606-690, 标注, unknown 一只羸弱的马拖着几千斤的辎重车，走上了险峻的山坡，一步步的往上爬，要往后退是不可能，要再往前去是实在不 能胜任了。 737-831, 标注, unknown 欲罢不能的疲劳使我永久感觉一种无可形容的重厌[压]。精神上政治上的倦怠，使我渴望“甜密[蜜]的”休息，以致于 脑筋麻木停止一切种种思想 878-988, 标注, unknown 我愿意到随便一个小市镇上去当一个教员，并不是为着发展什么教育，只不过求得一口饱饭罢了，在余的时候，读读 自己所爱读的书，文艺、小说、诗词、歌曲之类，这不是很逍遥的吗？ 1047-1136, 标注, unknown 我很小的时候，就不知怎样有一个古怪的想头。为什么每一个读书人都要去“治国平天下”呢？各人找一种学问或是文 艺研究一下不好吗？ 1197-1276, 标注, unknown 武汉分共以后，我们接着就决定贺叶的南昌暴动和两湖、广东的秋收暴动（一九二七年），到十一月又决定广州暴动。 1321-1461, 标注, unknown 暴动，官话不是叫起义么？ 因为当时整个路线错误，所以不管主观上怎样了解盲动主义现象的不好， 费力于枝枝节节的纠正，客观上却在领导着盲动主义的发展。 1518-1584, 标注, unknown 真正的懦怯不在这里。首先是差不多完全没有自信力，每一个见解都是动摇的，站不稳的 1631-1839, 标注, unknown 其实最理想的世界是大家不要争论，“和和气气的过日子”。我有许多标本的“弱者的道德”-–—忍耐、躲避、讲和气， 希望大家安静些、仁慈些等等。固然从[少]年时候起，我就憎恶贪污、卑鄙……以至一切恶浊的社会现象，但是我 从来没有想做侠客。我只愿意自己不做那些罪恶，有可能呢，去劝劝他们不要再那样做；没有可能呢，让他们去罢， 他们也有他们的不得已的苦衷罢？ 1894-2063, 标注, unknown 你们去算账罢，你们在斗争中勇猛精进着，我可以羡慕你们，祝贺你们，但是已经不能够跟随你们了。我不觉得可惜， 同样我也不觉得后悔，虽然我枉费了一生心力在我所不感兴味的政治上。过去的已经过去了，懊悔徒然增加现在的烦 恼。应当清洗出队伍的，终究应当清洗出去，而且愈好[快]愈好，更用不着可惜。 2110-2187, 标注, unknown 如果不幸而我没有机会告诉你们我的最坦白最真实的态度而骤然死了，那你们也许还把我当做一个共产主义的烈士 2234-2427, 标注, unknown 到苏区听到这个消息，真叫我不寒而栗，以叛徒而冒充烈士，实在太那个了。因此，虽然我现在已经囚在监狱里，虽 然我现在很容易装腔做[作]势慷慨激昂而死，可是我不敢这样做。历史是不能够，也不应当欺骗的。我骗着我一个人 的身后不要紧，叫革命同志误认叛徒为烈士却是大大不应该的。所以虽然反正是一死，同样是结束我的生命，而我决 不愿意冒充烈士而死 2474-2583, 标注, unknown 我的脱离队伍，不简单的因为我要结束我的革命，结束这一出滑稽剧，也不简单的因为我的痼疾和衰惫，而是因为我 始终不能够克服自己的绅士意识，我终究不能成为无产阶级的战士。 2630-2700, 标注, unknown 别人的痛快，就是对于被揭穿的也很痛快，尤其是自己能够揭穿。现在我丢掉了最后一层假面具。 ","date":"2024-10-09","objectID":"/%E7%AC%94%E8%AE%B0%E5%A4%9A%E4%BD%99%E7%9A%84%E8%AF%9D-n-a/:0:0","tags":["duoyudehua","note","ireader"],"title":"[笔记]多余的话-N/A","uri":"/%E7%AC%94%E8%AE%B0%E5%A4%9A%E4%BD%99%E7%9A%84%E8%AF%9D-n-a/"},{"categories":null,"content":" 10-13, 标注, 2024 年 9 月 24 日星期二 下午 1:29:45 我曾以为，我的一生将致力于对生命的痛苦作出反应。后来，我发现，这过于沉重、过于灰暗。如果我只看到痛苦，我的心难免会被乌云所笼罩，被绝望所吞没。在徘徊中，终于有一天，我发现，我的人生可以对生命的美丽作出反应。当我看到了美——自己、他人以及其他生命的美，我心中充满了柔情，也找回了生活的热情与活力。 44-46, 标注, 2024 年 9 月 24 日星期二 下午 1:33:10 在那里，肤色随时都可能给你招来无情的刺激。十岁那年，白人打了我，他们认为我太黑了；接着，黑人又打了我，他们认为我太白了。 49-50, 标注, 2024 年 9 月 24 日星期二 下午 1:33:45 非暴力生活的一个关键就是：感激生活的赐予，而不贪心。 108-110, 标注, 2024 年 9 月 24 日星期二 下午 6:23:19 一旦专注于彼此的观察、感受及需要，而不反驳他人，我们便能发现内心的柔情，对自己和他人产生全新的体会。这将最大限度地避免暴力。通过强调倾听——倾听自己及他人，非暴力沟通培育彼此的尊重、关注与爱，使人乐于互助。 139-140, 标注, 2024 年 9 月 24 日星期二 下午 6:29:42 非暴力沟通的另一方面是借助它们关切地倾听。我们首先通过体会他人此刻的观察、感受和需要，与他们建立联系，然后聆听他们的请求，来发现做什么可以帮助他们。 138-140, 标注, 2024 年 9 月 24 日星期二 下午 6:29:59 借助这四个要素诚实地表达自己，是非暴力沟通的一个方面。非暴力沟通的另一方面是借助它们关切地倾听。我们首先通过体会他人此刻的观察、感受和需要，与他们建立联系，然后聆听他们的请求，来发现做什么可以帮助他们。 189-190, 标注, 2024 年 9 月 24 日星期二 下午 6:34:23 非暴力沟通提醒我们专注于彼此的观察、感受、需要和请求。它鼓励倾听，培育尊重与爱，使我们情意相通，乐于互助。 247-249, 标注, 2024 年 9 月 24 日星期二 下午 6:39:45 暴力的根源在于人们忽视彼此的感受与需要，而将冲突归咎于对方——至少大部分暴力的根源都是如此，不论是语言、精神或身体的暴力，还是家庭、部落以及国家的暴力。 253-253, 标注, 2024 年 9 月 24 日星期二 下午 8:55:23 如果真的想过上悲惨生活，就去与他人做比较。 221-223, 标注, 2024 年 9 月 24 日星期二 下午 9:08:43 我发现某些语言和表达方式的负面影响。它们虽然致力于满足某种愿望，却倾向于忽视人的感受和需要，以致彼此的疏远和伤害。这些语言和表达方式，我称为“异化的沟通方式”。 327-327, 标注, 2024 年 9 月 24 日星期二 下午 9:11:43 非暴力沟通的第一个要素是观察。我们仔细观察正在发生的事情，并清楚地说出观察结果。 328-329, 标注, 2024 年 9 月 24 日星期二 下午 9:12:45 强调区分观察和评论的重要性。将观察和评论混为一谈，人们将倾向于听到批评，甚至会产生逆反心理。 329-330, 标注, 2024 年 9 月 24 日星期二 下午 9:12:54 非暴力沟通不鼓励绝对化的评论，而主张评论要基于特定时间和环境中的观察。 354-355, 标注, 2024 年 9 月 24 日星期二 下午 9:14:12 印度哲学家克里希那穆提（J.Krishnamurti）曾经说，“不带评论的观察是人类智力的最高形式。” 377-378, 标注, 2024 年 9 月 24 日星期二 下午 9:17:43 “每次”“曾”等词语在以下句子中表达的是观察结果。 379-380, 标注, 2024 年 9 月 24 日星期二 下午 9:19:03 “总是”、“从不”等词语在以下句子中表达的是评论。 384-386, 标注, 2024 年 9 月 24 日星期二 下午 9:20:24 非暴力沟通的第一个要素是观察。将观察和评论混为一谈，别人就会倾向于听到批评，并反驳我们。非暴力沟通是动态的语言，不主张绝对化的结论。它提倡在特定的时间和情境中进行观察，并清楚地描述观察结果。例如，它会说“欧文在过去的 5 场比赛中没有进一个球”，而不是说“欧文是个差劲的前锋”。 433-435, 标注, 2024 年 9 月 24 日星期二 下午 9:23:50 非暴力沟通的第二个要素是感受。心理学家罗洛·梅（Rollo May）认为：“成熟的人十分敏锐，就像听交响乐的不同乐章，不论是热情奔放，还是柔和舒缓，他都能体察到细微的起伏。”然而，根据罗洛·梅的叙述，大多数人的感受“像军号声那样单调”。 477-478, 标注, 2024 年 9 月 24 日星期二 下午 9:29:02 我们注意区分感受和想法。 482-482, 标注, 2024 年 9 月 24 日星期二 下午 9:29:09 当我们说“我觉得”，我们常常并不是在表达感受，而是在表达想法。 503-506, 标注, 2024 年 9 月 24 日星期二 下午 9:30:01 非暴力沟通的第二个要素是感受。通过建立表达感受的词汇表，我们可以更清楚地表达感受，从而使沟通更为顺畅。在表达感受时，示弱有助于解决冲突。此外，非暴力沟通还对表达具体感受的词语与陈述想法、评论以及观点的词语作了区分。 545-546, 标注, 2024 年 9 月 24 日星期二 下午 9:33:23 如果我们想利用他人的内疚，我们通常采取的办法是，把自己不愉快的感受归咎于对方。 545-548, 标注, 2024 年 9 月 24 日星期二 下午 9:33:43 如果我们想利用他人的内疚，我们通常采取的办法是，把自己不愉快的感受归咎于对方。家长也许会和孩子说：“你成绩不好让爸爸妈妈伤透了心！”言下之意是，他们快乐或不快乐是孩子的行为造成的。看到父母的痛苦，孩子可能会感到内疚，并因此调整行为来迎合他们。遗憾的是，这种调整只是为了避免内疚，而非出自对学习的热爱。 554-554, 标注, 2024 年 9 月 24 日星期二 下午 9:40:14 我们可以通过“我（感到）……因为我……”这种表达方式来认识感受与自身的关系。 558-559, 标注, 2024 年 9 月 24 日星期二 下午 9:41:01 批评往往暗含着期待。对他人的批评实际上间接表达了我们尚未满足的需要。 559-562, 标注, 2024 年 9 月 24 日星期二 下午 9:41:12 如果太太说“这个星期你每天都工作到很晚，你喜欢工作，不喜欢我”，那反映了她看重亲密关系。如果我们通过批评来提出主张，人们的反应常常是申辩或反击。反之，如果我们直接说出需要，其他人就较有可能作出积极的回应。 561-562, 标注, 2024 年 9 月 24 日星期二 下午 9:41:20 如果我们通过批评来提出主张，人们的反应常常是申辩或反击。反之，如果我们直接说出需要，其他人就较有可能作出积极的回应。 574-575, 标注, 2024 年 9 月 24 日星期二 下午 9:42:22 一旦人们开始谈论需要，而不指责对方，他们就有可能找到办法来满足双方的需要。 646-648, 标注, 2024 年 9 月 24 日星期二 下午 9:48:37 他人的言行也许和我们的感受有关，但并不是我们感受的起因。感受根源于我们自身的需要——非暴力沟通的第三个要素。听到不中听的话时，我们可以有四种选择： 1）责备自己； 2）指责他人； 3）体会自己的感受和需要； 4）体会他人的感受和需要。 709-711, 标注, 2024 年 9 月 24 日星期二 下午 9:57:51 首先，清楚地告诉对方，我们希望他们做什么。如果我们请求他人不做什么，对方也许会感到困惑，不知道我们到底想要什么。而且，这样的请求还容易引起别人的反感。 770-771, 标注, 2024 年 9 月 24 日星期二 下午 10:01:30 如果我们只是表达自己的感受，别人可能就不清楚我们想要什么。 781-785, 标注, 2024 年 9 月 24 日星期二 下午 10:02:34 在之前的对话中，太太感到了先生的不安，但不清楚他想要什么。然而，如果一个人提出了明确的请求，却没有提及感受和需要，也有可能导致交流的困难。例如，如果父母问“为什么还不去理发呢”，孩子一般会把它看作是命令或指责。如果父母想避免误解，那么，他们可以先说出感受和需要：“你的头发这么长，我们担心这会影响你的视线，特别是在骑自行车的时候。去理发好吗？” 904-922, 标注, 2024 年 9 月 24 日星期二 下午 10:10:26 非暴力沟通的第四个要素是请求。我们告诉人们，为了改善生活，我们希望他们做什么。我们避免使用抽象的语言，而借助具体的描述，来提出请求。 906-907, 标注, 2024 年 9 月 24 日星期二 下午 10:10:36 发言时，我们将自己想要的回应讲得越清楚，就越有可能得到理想的回应。由于我们所要表达的意思与别人的理解有可能不一致，有时，我们需要请求他人的反馈。 910-911, 标注, 2024 年 9 月 24 日星期二 下午 10:10:50 非暴力沟通的目的不是为了改变他人来迎合我们。相反，非暴力沟通重视每个人的需要，它的目的是帮助我们在诚实和倾听的基础上与人联系。 1015-1015, 标注, 2024 年 9 月 24 日星期二 下午 1","date":"2024-10-09","objectID":"/%E7%AC%94%E8%AE%B0%E9%9D%9E%E6%9A%B4%E5%8A%9B%E6%B2%9F%E9%80%9A-%E9%A9%AC%E6%AD%87%E5%B0%94%E5%8D%A2%E6%A3%AE%E5%A0%A1/:0:0","tags":["feibaoligout","note","ireader"],"title":"[笔记]非暴力沟通-马歇尔•卢森堡","uri":"/%E7%AC%94%E8%AE%B0%E9%9D%9E%E6%9A%B4%E5%8A%9B%E6%B2%9F%E9%80%9A-%E9%A9%AC%E6%AD%87%E5%B0%94%E5%8D%A2%E6%A3%AE%E5%A0%A1/"},{"categories":null,"content":" 1175-1177, 标注, 2021 年 2 月 3 日星期三 下午 10:16:10 没有一个国家的工业化道路是平坦的；它是一个过程，特征是低工资、恶劣的工作环境，以及并通常是政治压迫。工业化完成得越早，一个国家就越有可能更加和平与稳定。我们必须找出一个国家当前所处的发展阶段。在一个正经历着工业化的国家，我们可以预期到该国有欧洲早期存在的那种紧张关系 1629-1630, 标注, 2021 年 2 月 4 日星期四 下午 10:29:16 大宪章意味着国王要与贵族保持平衡，防止出现专制统治或无政府状态。这是欧洲大陆的并发症，大陆国家要么 1629-1629, 标注, 2021 年 2 月 4 日星期四 下午 10:29:23 大宪章意味着国王要与贵族保持平衡，防止出现专制统治或无政府状态。 1746-1746, 标注, 2021 年 2 月 5 日星期五 下午 10:17:06 权力倾向于腐败；绝对权力导致绝对腐败。 1786-1787, 标注, 2021 年 2 月 28 日星期日 下午 9:08:11 ”进步不是来源于抛弃旧有的东西，而是来自于逐渐地改变需要改变的部分，同时保存整个结构，保持形式，但是要改革内容。 ","date":"2024-10-09","objectID":"/%E7%AC%94%E8%AE%B0%E5%9B%BD%E5%AE%B6%E7%9A%84%E5%B8%B8%E8%AF%86-%E7%BE%8E%E8%BF%88%E5%85%8B%E5%B0%94%E7%BD%97%E6%96%AF%E9%87%91/:0:0","tags":["guojiadechan","note","ireader"],"title":"[笔记]国家的常识-[美]迈克尔·罗斯金","uri":"/%E7%AC%94%E8%AE%B0%E5%9B%BD%E5%AE%B6%E7%9A%84%E5%B8%B8%E8%AF%86-%E7%BE%8E%E8%BF%88%E5%85%8B%E5%B0%94%E7%BD%97%E6%96%AF%E9%87%91/"},{"categories":null,"content":" 11-12, 标注, 2024 年 10 月 9 日星期三 上午 7:41:40 不可避免，苦杏仁的气味总是让他想起爱情受阻后的命运。 107-109, 标注, 2024 年 10 月 9 日星期三 上午 8:00:44 睡梦中，他听见女仆们在枝繁叶茂的芒果树下唱歌，听着街上的叫卖声，以及海湾里燃油机和马达发出的轰鸣声—炎热的下午，它们排出的废气在整座房中弥漫，就像一个被判腐烂而死的天使在扑腾翅膀。 119-120, 标注, 2024 年 10 月 9 日星期三 上午 8:02:30 所谓的宿命论人道主义者：“每个人都是自己死亡的主宰者，时间一到，我们唯一能做的就是帮助他们没有恐惧和痛苦地死去。” 231-234, 标注, 2024 年 10 月 9 日星期三 下午 6:42:10 在这里，鲜花会生锈，盐巴会腐烂。四个世纪以来，除了在凋谢的月桂树和腐臭的沼泽间慢慢衰老，这里什么都没有发生。冬天，瞬间而至、席卷一切的暴雨使厕所里的污水漫溢，把街道变成令人作呕的泥塘。夏天，有一种看不见的灰尘，粗糙得就像烧红的白垩粉，被狂风一吹，便会从各个缝隙钻进屋里，堵得再严实也无济于事。 388-391, 标注, 2024 年 10 月 10 日星期四 上午 7:38:52 穿衣。两人才刚刚庆祝完金婚，谁离开谁都无法生存片刻，甚至每一刻都不能不想着对方，而且随着年纪越来越老，就越来越是如此。可无论他，还是她，都无法说清这种相互依赖究竟是建立在爱情的基础上，还是习惯使然。他们从不曾为此问过自己，因为两人都宁愿不知道答案。 425-427, 标注, 2024 年 10 月 10 日星期四 上午 7:42:19 这次事件也让他们有机会联想起其他无数个朦胧清晨发生的无数次口角。一阵反感掀起另一阵反感，旧伤疤被揭开，变成了新伤口。 609-610, 标注, 2024 年 10 月 10 日星期四 下午 6:26:03 他被悲伤惊醒了。不是上午他站在朋友尸体前的那种悲伤，而是一种无形的伤感迷雾，在午觉后充斥着他的灵魂。 1066-1067, 标注, 2024 年 10 月 11 日星期五 下午 10:50:19 这些信对她而言只是一种消遣，用来维持炭火不灭，但不必把手伸到火中，而弗洛伦蒂诺·阿里萨却在信中的每一行里把自己燃烧殆尽。 1250-1250, 标注, 2024 年 10 月 12 日星期六 上午 7:53:49 唯一比坏身体更糟的，就是坏名声。” 1338-1340, 标注, 2024 年 10 月 12 日星期六 上午 8:09:46 费尔明娜·桑切斯对这段受阻的爱情盲目而义无反顾地下定了决心，不顾家人的反对嫁给了他。她嫁得那么匆忙，那么秘密，就好像不是为爱而嫁，而是为了用那块神圣的头纱掩盖某种早熟的过失。 1626-1629, 标注, 2024 年 10 月 12 日星期六 下午 6:51:10 他把手放在胸口，对自己说，眼前的这一切都不足以让他用故乡加勒比四月的一瞬间来抵换。他还太年轻，尚不知道回忆总是会抹去坏的，夸大好的，而也正是由于这种玄妙，我们才得以承担过去的重负。可当他站在甲板的栏杆前，再一次看到殖民区那白色的山冈，屋顶上一动不动的兀鹫，以及阳台上晒着的穷人的破衣烂衫—到了这个时候，他才明白自己是多么轻易地掉进了思乡之情设下的慈悲圈套。 1754-1755, 标注, 2024 年 10 月 13 日星期日 上午 9:51:09 死亡天使在办公室那凉爽的昏暗中一闪而过，又从窗子飞了出去，所到之处，散落下几片羽毛，但孩子却没有看见。 3189-3190, 标注, 2024 年 10 月 14 日星期一 上午 7:44:17 像他那样一个天主教的卫士，向她提供的竟然仅限于世俗的好处：安全感、和谐和幸福，这些东西一旦相加，或许看似爱情，也几乎等于爱情。但它们终究不是爱情。 3201-3203, 标注, 2024 年 10 月 14 日星期一 上午 7:46:22 一切的疑虑都烟消云散，她毫无内疚地做出了理智指示她做的最体面的事：用一块没有泪水的海绵将有关弗洛伦蒂诺·阿里萨的记忆彻底抹掉，让他在她记忆中所占据的那块空间里长出一片罂粟花。 3217-3221, 标注, 2024 年 10 月 14 日星期一 上午 7:49:17 当他从她的身体里滑出去时，她感到一种摆脱了某件不属于自己的东西的轻松。而当接生婆把活生生、浑身沾满油脂和血污、脐带还缠在脖子上的婴儿抱给她看时，她发现自己对这个从她腹中出来的小牛犊竟然没有一丁点儿感情，这把她自己也吓了一跳。然而，在孤独的侯爵府邸，她学会了认识他，母子俩相互熟识了，她欣喜万分地发现人们爱孩子并非因为他们是自己的孩子，而是因为养育中产生的情意。 ","date":"2024-10-09","objectID":"/%E7%AC%94%E8%AE%B0%E9%9C%8D%E4%B9%B1%E6%97%B6%E6%9C%9F%E7%9A%84%E7%88%B1%E6%83%85-%E5%8A%A0%E8%A5%BF%E4%BA%9A%E9%A9%AC%E5%B0%94%E5%85%8B%E6%96%AF/:0:0","tags":["huoluanshiqi","note","ireader"],"title":"[笔记]霍乱时期的爱情 加西亚·马尔克斯","uri":"/%E7%AC%94%E8%AE%B0%E9%9C%8D%E4%B9%B1%E6%97%B6%E6%9C%9F%E7%9A%84%E7%88%B1%E6%83%85-%E5%8A%A0%E8%A5%BF%E4%BA%9A%E9%A9%AC%E5%B0%94%E5%85%8B%E6%96%AF/"},{"categories":null,"content":" 107-109, 标注, 2018 年 2 月 25 日星期日 下午 9:46:08 有一种人类的时间，被我们感知，并以钟表计量；还有一种上帝的时间，是瞬间而非流动的。人类时间这条无限长直线，向前也向后延伸到无穷，在牛顿的上帝眼中，却只是一个瞬间。他只在眨眼之间就已看到一切。 205-207, 标注, 2018 年 2 月 25 日星期日 下午 10:03:49 热核聚变反应（以小原子创造大原子）能够发生的一个必要条件是巨大的能量，太阳压倒一切的自身引力就是这种巨大能量的来源。这个引力将一切物质拉向太阳的核心，以巨大的压力挤压它们。 271-275, 标注, 2018 年 2 月 25 日星期日 下午 10:19:29 你将顺道拜访一下你的远房表兄弟，那些我们太阳系里的巨人们。 你现在离太阳的距离大约是地球离太阳距离的三倍。水星、金星、地球与火星是四颗较小也是离太阳最近的岩石状行星，它们已经被你甩在身后。从这里看过去，我们的恒星太阳是一个闪闪发亮的圆点，大约就像伸长手臂看你手中拿着的一个一分钱硬币的一半大小。如果地球处在这个位置，英国一个典型的炎热七月中午，一年中最热的时候，在气温上也会给你比南极洲的严冬更寒冷的感觉。 631-637, 标注, 2018 年 2 月 26 日星期一 下午 9:56:57 你还在向前飞，期待着黑暗将占据一切，突然，你来到了一个光穿不过的地方。 这是一道时间与空间的墙。 在这道墙后，宇宙并不是黑暗，而是不透明。你停在这道墙前，伸出你虚拟的手，轻柔地感触墙后的世界。 你那并不存在的肌肤上起了一身鸡皮疙瘩，你所触到的似乎是一种巨大的能量。这些能量如此密集，你忽然明白为什么光线无法透过，就像是在墙里点了一个火炬，虽然光线就在里面，但它被束缚其中，没有运动的自由。 你所到达的地方不是你想象力的产物， 647-648, 标注, 2018 年 2 月 26 日星期一 下午 9:57:44 那道标记着与黑暗世纪及隐秘世界之界限的墙！ 631-636, 标注, 2018 年 2 月 26 日星期一 下午 9:57:57 你还在向前飞，期待着黑暗将占据一切，突然，你来到了一个光穿不过的地方。 这是一道时间与空间的墙。 在这道墙后，宇宙并不是黑暗，而是不透明。你停在这道墙前，伸出你虚拟的手，轻柔地感触墙后的世界。 你那并不存在的肌肤上起了一身鸡皮疙瘩，你所触到的似乎是一种巨大的能量。这些能量如此密集，你忽然明白为什么光线无法透过，就像是在墙里点了一个火炬，虽然光线就在里面，但它被束缚其中，没有运动的自由。 827-829, 标注, 2018 年 2 月 27 日星期二 上午 6:50:17 在相似条件下，大自然在任何时间与空间都遵循同样的定律——无论在此处还是彼处，在现在还是过去或未来，在我们看到的时候还是没看到的时候。我们把这个称为宇宙第一原则。 1004-1005, 标注, 2018 年 2 月 27 日星期二 上午 6:54:35 在光谱中，意味着宇宙远处所产生的颜色往红色方向移动，它们被“红移”了。 1012-1013, 标注, 2018 年 2 月 27 日星期二 上午 6:55:03 这意味着远处星系与我们之间的距离正在变大，一直如此。这意味着星系间的空间在拉伸，也就是变大，自发的。这意味着我们的宇宙随着时间发生着变化。 1018-1019, 标注, 2018 年 2 月 27 日星期二 上午 6:55:18 明确地说，不是说星系在离我们远去。而是那些本就离我们很远的恒星和星系与我们之间的距离在变大。是星系间虚空的空间本身在变大。科学家们给这个现象起了更专门的名词，他们称其为“宇宙膨胀”。 1048-1049, 标注, 2018 年 2 月 27 日星期二 上午 6:59:40 要猜想离地球很远很远的地方所发生的事情，人类必须假定宇宙中没有一个特别的位置——这就是宇宙第二原则 1049-1050, 标注, 2018 年 2 月 27 日星期二 上午 7:00:12 这就是宇宙第二原则——如果某个观察者在宇宙各处观察，对于他来说，任何方向看出去都是一样的。 1049-1050, 标注, 2018 年 2 月 27 日星期二 上午 7:00:35 这就是宇宙第二原则——如果某个观察者在宇宙各处观察，对于他来说，任何方向看出去都是一样的。远处的星系总是远离他所在的观察点，同那些星系远离地球一样——这是宇宙第三原则。 1048-1050, 标注, 2018 年 2 月 27 日星期二 上午 7:00:59 要猜想离地球很远很远的地方所发生的事情，人类必须假定宇宙中没有一个特别的位置——这就是宇宙第二原则——如果某个观察者在宇宙各处观察，对于他来说，任何方向看出去都是一样的。远处的星系总是远离他所在的观察点，同那些星系远离地球一样——这是宇宙第三原则。 1080-1083, 标注, 2018 年 2 月 27 日星期二 上午 7:03:44 是的。远处星系之间的距离的确一直在变大。邻近天体之间却没有这种现象，因为引力在短距离内足够强大。星系产生的万有引力抵消了这种膨胀，无论是在它们边界的内部（比如太阳和邻近恒星之间的距离不会扩大），还是在边界的周围（邻近星系确实在逐渐靠近）。但在大距离上，膨胀无处不在。 ","date":"2024-10-09","objectID":"/%E7%AC%94%E8%AE%B0%E6%9E%81%E7%AE%80%E5%AE%87%E5%AE%99%E5%8F%B2-%E5%85%8B%E9%87%8C%E6%96%AF%E6%89%98%E5%BC%97%E5%8A%A0%E5%B0%94%E6%B3%95%E5%BE%B7/:0:0","tags":["jijianyuzhou","note","ireader"],"title":"[笔记]极简宇宙史 克里斯托弗·加尔法德","uri":"/%E7%AC%94%E8%AE%B0%E6%9E%81%E7%AE%80%E5%AE%87%E5%AE%99%E5%8F%B2-%E5%85%8B%E9%87%8C%E6%96%AF%E6%89%98%E5%BC%97%E5%8A%A0%E5%B0%94%E6%B3%95%E5%BE%B7/"},{"categories":null,"content":" 3279-3280, 标注, 2019 年 10 月 25 日星期五 下午 9:59:57 用 DVC 不重要，关键是要用好，说她喷 DVC 喷多了，就像是说她拿钞票烧着点香烟一样没品 4859-4860, 标注, 2019 年 10 月 26 日星期六 下午 9:04:28 眼与眼的对视，其实只是为了肉与肉的摩擦，体液与体液间的交换。” 4861-4863, 标注, 2019 年 10 月 26 日星期六 下午 9:04:51 长久的安静，餐厅远处的钢琴正在流淌着音符，间或有几声银制刀叉触碰在瓷面上的声音响起。在这片沉默之中，许乐低着头等待着对方的回答，没有注意到张小萌在长久的沉默之后，正用一种负疚而哀怨的眼光看着他 6977-6978, 标注, 2019 年 10 月 27 日星期日 上午 8:15:43 怕死要来，不怕死也要来……怕死不怕死，我都带着诚意扑面而来 8036-8036, 标注, 2019 年 10 月 27 日星期日 上午 11:25:19 ，一朵新年的礼花在天边绽开，映着这两个年轻人的身影，显得无比寂寞。 8036-8036, 笔记, 2019 年 10 月 27 日星期日 上午 11:26:23 真的是比烟花还要寂寞了。 8700-8701, 标注, 2019 年 10 月 27 日星期日 上午 11:57:56 当你开始旅程时偏移正确方向一公分，当你结束旅程的时候，你会发现自己已经远离了目的地一千公里 10397-10397, 标注, 2019 年 10 月 27 日星期日 下午 4:17:24 看来自古以来都是同样，敌人，永远是内部的最为残酷。 12201-12202, 标注, 2019 年 10 月 27 日星期日 下午 7:43:39 往年远观可以赏之为奇山妙石，如今近处，才发现那是艰涩山路，并不好过 13766-13767, 标注, 2019 年 10 月 27 日星期日 下午 10:13:39 “我总以为，宇宙中的一切，总应该是有规律可循，或者说是有道理可讲 17089-17091, 标注, 2019 年 10 月 29 日星期二 上午 3:18:04 珀色的烈酒还放在黑白纹石桌面上，葡萄发酵蒸馏混着数年地窖里的光阴，在半空的杯中逐渐渗漫，钻入人们的鼻中，虽然不如酒馆外面那个橡木桶喷放的稀释香精清晰，但像是有生命力一般，感染力十足。 23441-23442, 标注, 2019 年 10 月 31 日星期四 下午 10:05:20 这大概便是联邦社会的写照？不能飞或不想飞的才能留下，那些敢在大人物头顶拉屎的家伙，只有离开。 23569-23572, 标注, 2019 年 10 月 31 日星期四 下午 10:13:40 在首都特区宪章广场边上，居然藏着如此大的一家私人会所，举头望去便是历史，空气中呼吸的便是权力，四周布设简洁之中隐藏着奢华到极致的绚烂意味，虽不如林园有山水相伴，开阔清丽，但从贵重感觉上，却早已攀到了极致。 23587-23589, 标注, 2019 年 10 月 31 日星期四 下午 10:14:39 青石为路，古意从微湿的石缝里渗了出来，在四周老式工艺的粉墙上一润，配着温暖的脚下生风，硬生生在这寒冷的首都冬天里，把流风坡会所变成了春秋季的园林 25724-25724, 标注, 2019 年 11 月 2 日星期六 下午 4:30:29 人们在做某件大事之前，总是习惯性地要用很多精神上的事情，来提升自己的勇气或是信心，许 25922-25923, 标注, 2019 年 11 月 2 日星期六 下午 4:37:41 皇帝从来没有消失，他只不过换了几身衣服。 —— 31079-31081, 标注, 2019 年 11 月 3 日星期日 下午 12:30:49 时光如流水，早已将他心上那些少年时的酸楚心痛痕迹冲洗的淡然，只是就像西林名产醋腌茄子一样，被水冲过的皮本身没有什么味道，内里却依然酸的让人想要流眼泪 34969-34969, 标注, 2019 年 11 月 5 日星期二 上午 7:59:58 怀念是一行潦草的诗 41885-41885, 标注, 2019 年 11 月 10 日星期日 下午 10:08:50 靠牺牲他人而获取的未来，只能是全无未来的一种无聊重复。” 58784-58785, 标注, 2019 年 11 月 24 日星期日 上午 9:02:11 在某些特定时刻，总是需要做出一定的妥协和让步，而这种妥协与让步往往比大踏步前进更需要智慧和勇气。” 59049-59049, 标注, 2019 年 11 月 24 日星期日 上午 9:15:41 我将来的墓志铭会写：一个都不原谅，所以你们也不用原谅我。 63260-63260, 标注, 2019 年 11 月 30 日星期六 下午 5:47:39 ，垃圾是从来不会自己走进垃圾箱的。” 63286-63287, 标注, 2019 年 11 月 30 日星期六 下午 5:49:19 ：人死并不如灯灭，灯有光明，照不见的地方是黑暗。做错了事情，就必须付出代价。” 63324-63325, 标注, 2019 年 11 月 30 日星期六 下午 5:51:36 信息不对称是联邦社会不公平的根源，我们想做的，就是敞开这些信息，由联邦普通公民进行最有效最直 67859-67861, 标注, 2019 年 12 月 2 日星期一 上午 7:50:58 要知道真实的世界里，从来没有小说中那样的奇遇，小概率事件必然有其内部的原因，富人的后代是富人，传奇的身边是传奇，白手起家，傻小子遇明师的故事，终究只能是故事 67891-67891, 标注, 2019 年 12 月 2 日星期一 上午 7:57:28 即将来临的一天，比过去的一年更加悠长。 69831-69831, 标注, 2019 年 12 月 2 日星期一 下午 7:51:31 一个都不原谅，你们也不用原谅我 73709-73710, 标注, 2019 年 12 月 3 日星期二 下午 8:24:00 一个社会的落后先是精英的落后，而精英的落后最显著的标志是他们经常指责人民的落后。 ","date":"2024-10-09","objectID":"/%E7%AC%94%E8%AE%B0%E9%97%B4%E5%AE%A2-%E7%8C%AB%E8%85%BB/:0:0","tags":["jianke","note","ireader"],"title":"[笔记]间客-猫腻","uri":"/%E7%AC%94%E8%AE%B0%E9%97%B4%E5%AE%A2-%E7%8C%AB%E8%85%BB/"},{"categories":null,"content":" 4260-4261, 标注, 2020 年 10 月 24 日星期六 下午 1:42:42 只要走在正确的道路上，你悟性再差，只要够勤奋坚韧，每天终究是在进步。走在错误的方向上，你越聪明越努力，只会做越多错越多。 34624-34624, 标注, 2020 年 11 月 13 日星期五 下午 9:13:21 该省之省，一文铜钱，即是家族根本。该花则花，一掷千金，根本无需眨眼。 39306-39307, 标注, 2020 年 11 月 15 日星期日 下午 2:02:16 窗外的阳光溜进了屋子，像一群不爱说笑的稚童，累了后，然后它们便懒洋洋趴在桌上，地上，少年的肩头。 42902-42905, 标注, 2020 年 11 月 16 日星期一 下午 8:00:21 读书一事，不可求全，贪多嚼不烂，以精读为上，细嚼慢咽，真正把一本经典的精妙，全部吃进肚子里，将那些美好的意象、真知灼见的道理、隐匿于句章之间的精气神，一一化为己用，这才叫读书，否则只是翻书，翻过千万卷，撑死也是个两脚书柜。 ","date":"2024-10-09","objectID":"/%E7%AC%94%E8%AE%B0%E5%89%91%E6%9D%A5-%E7%83%BD%E7%81%AB%E6%88%8F%E8%AF%B8%E4%BE%AF/:0:0","tags":["jianlai","note","ireader"],"title":"[笔记]剑来-烽火戏诸侯","uri":"/%E7%AC%94%E8%AE%B0%E5%89%91%E6%9D%A5-%E7%83%BD%E7%81%AB%E6%88%8F%E8%AF%B8%E4%BE%AF/"},{"categories":null,"content":" 26-28, 标注, 2019 年 6 月 23 日星期日 下午 2:28:38 人生在世不能独来独往，有几个朋友是平常事，虽然朋友多了路好走，但是大千世界人心如面是复杂多样的，有些人是不可以深交的；我们交往一个人，要根据他的为人处事来判断是否可以深交，那些正直善良有道德修养的人可以做好朋友的，要远离那些流氓无赖，如果一旦交错了朋友，引狼入室会造成不必要的损失。 30-32, 标注, 2019 年 6 月 23 日星期日 下午 2:28:50 物以类聚，人以群分。一个人人品如何，做人怎样，可以通过他的人际关系、通过他交的朋友知道大概，如果他总是喜欢与（世上公认的）无赖交朋友，同情（世上公认的）恶霸，那他本身就有问题。 所以，圈子很重要，关系格局和档次。 38-41, 标注, 2019 年 6 月 23 日星期日 下午 2:29:06 人生—世最大最难最重要的—项工程就是自我突破和改变的工程，突破和改变最最重要的就是脑袋里的想法，常言道:开颅容易开窍难啦！其实认真一想，一个人所有的问题都是他的想法造成的，要想改变命运，首先就得改变想法，要想改变想法首先就得改变环境和朋友圈子。 41-41, 标注, 2019 年 6 月 23 日星期日 下午 2:29:12 生活圈子决定你的命运，接近什么样的人就会走什么样的路。 ","date":"2024-10-09","objectID":"/%E7%AC%94%E8%AE%B0%E8%AE%B2%E4%B8%AA%E5%AF%93%E8%A8%80%E4%B8%8E%E6%97%A0%E8%B5%96%E5%81%9A%E6%9C%8B%E5%8F%8B%E7%9A%84%E4%B8%8B%E5%9C%BA..-kindle@eub-inc/:0:0","tags":null,"title":"[笔记]讲个寓言：与无赖做朋友的下场..-kindle@eub-inc.com","uri":"/%E7%AC%94%E8%AE%B0%E8%AE%B2%E4%B8%AA%E5%AF%93%E8%A8%80%E4%B8%8E%E6%97%A0%E8%B5%96%E5%81%9A%E6%9C%8B%E5%8F%8B%E7%9A%84%E4%B8%8B%E5%9C%BA..-kindle@eub-inc/"},{"categories":null,"content":" 464-694, 标注, unknown 不管是骚扰还是恶作剧，写这些信给浪矢杂货店的人，和普通的咨询者在本质上是一样的。他们都是内心破了个洞，重要的东西正从那个 破洞逐渐流失。证据就是，这样的人也一定会来拿回信，他会来查看牛奶箱。因为他很想知道，浪矢爷爷会怎样回复自己的信。你想想看， 就算是瞎编的烦恼，要一口气想出三十个也不简单。既然费了那么多心思，怎么可能不想知道答案？所以我不但要写回信，而且要好好思 考后再写。人的心声是绝对不能无视的。” 696-769, 标注, unknown 虽然至今为止的道路绝非一片坦途，但想到正因为活着才有机会感受到痛楚，我就成功克服了种种困难。 787-859, 标注, unknown 除了积极向上的旅行，家人应该尽可能在一起。因为反感、厌倦等理由而离开，不是家人应有的姿态。 861-936, 标注, unknown 也许距离问题全部解决需要很长的时间，也许中间会经历很多苦难，但正因为这样，全家人才更有必要在一起 938-989, 标注, unknown 无论现在多么不开心，你要相信，明天会比今天更好。 ","date":"2024-10-09","objectID":"/%E7%AC%94%E8%AE%B0%E8%A7%A3%E5%BF%A7%E6%9D%82%E8%B4%A7%E5%BA%97-n-a/:0:0","tags":["jieyouzahuod","note","ireader"],"title":"[笔记]解忧杂货店-N/A","uri":"/%E7%AC%94%E8%AE%B0%E8%A7%A3%E5%BF%A7%E6%9D%82%E8%B4%A7%E5%BA%97-n-a/"},{"categories":null,"content":" 24-25, 标注, 2019 年 3 月 7 日星期四 下午 9:11:59 在一个信息爆炸却多半无用的世界，清晰的见解就成了一种力 24-25, 标注, 2019 年 3 月 7 日星期四 下午 9:12:04 在一个信息爆炸却多半无用的世界，清晰的见解就成了一种力量。从 24-25, 标注, 2019 年 3 月 7 日星期四 下午 9:12:09 在一个信息爆炸却多半无用的世界，清晰的见解就成了一种力量。 108-109, 标注, 2019 年 3 月 7 日星期四 下午 9:21:20 非民主政权的一个特征是很难做到言论自由。而随着这些政权的扩张，要对人类物种的未来进行批判性思考也就越来越危险。 125-126, 标注, 2019 年 3 月 7 日星期四 下午 9:23:05 这三大故事是：法西斯主义故事、共产主义故事，以及自由主义故事。 125-128, 标注, 2019 年 3 月 7 日星期四 下午 9:23:30 这三大故事是：法西斯主义故事、共产主义故事，以及自由主义故事。第二次世界大战打倒了法西斯主义故事，于是从 20 世纪 40 年代末到 80 年代末，世界成为共产主义故事和自由主义故事的战场。等到共产主义受挫，自由主义故事就成为人类了解过去的主要指南、未来无法取代的使用手册 124-128, 标注, 2019 年 3 月 7 日星期四 下午 9:23:40 在 20 世纪，来自纽约、伦敦、柏林和莫斯科的全球精英讲述了三大故事，号称能够解释人类过去、预测全球未来。这三大故事是：法西斯主义故事、共产主义故事，以及自由主义故事。第二次世界大战打倒了法西斯主义故事，于是从 20 世纪 40 年代末到 80 年代末，世界成为共产主义故事和自由主义故事的战场。等到共产主义受挫，自由主义故事就成为人类了解过去的主要指南、未来无法取代的使用手册 143-144, 标注, 2019 年 3 月 7 日星期四 下午 9:26:56 1997 年，美国总统克林顿甚至信心满满地指责中国“站在历史错误的一边 148-149, 标注, 2019 年 3 月 7 日星期四 下午 9:27:09 今天，几乎没有人能够再次信心满满地宣称中国共产党站在历史错误的一边。 2016 年，国际社会 148-148, 标注, 2019 年 3 月 7 日星期四 下午 9:27:21 今天，几乎没有人能够再次信心满 148-149, 标注, 2019 年 3 月 7 日星期四 下午 9:27:25 今天，几乎没有人能够再次信心满满地宣称中国共产党站在历史错误的一边。 161-162, 标注, 2019 年 3 月 7 日星期四 下午 10:39:01 许多自由主义者担心，英国脱欧、特朗普上台，可能代表着人类文明即将终结。 180-181, 标注, 2019 年 3 月 7 日星期四 下午 10:41:51 通过生物技术和信息技术的革命，我们将会有能力控制自己的内在世界，也能设计和制造生命 182-182, 标注, 2019 年 3 月 7 日星期四 下午 10:42:25 类发明工具的时候很聪明，但使用工具的时候就没那么聪明了。 200-202, 标注, 2019 年 3 月 7 日星期四 下午 10:45:25 TED[1]演讲、政府智库或高科技研讨会上，总有许多神秘的词语被不断提及：全球化、区块链、基因工程、人工智能、机器学习。 200-203, 标注, 2019 年 3 月 7 日星期四 下午 10:45:34 TED[1]演讲、政府智库或高科技研讨会上，总有许多神秘的词语被不断提及：全球化、区块链、基因工程、人工智能、机器学习。但对一般人来说，这些好像和自己都没什么关系。 221-224, 标注, 2019 年 3 月 7 日星期四 下午 10:49:37 自由主义这套故事证明自己比其他任何对手都更加柔韧、更加灵活。自由主义分别学习了帝国主义、法西斯主义和共产主义某些最优秀的概念。特别值得一提的是，自由主义学习了共产主义，于是扩大了同理的范围，开始在重视自由之外也同时重视平等。 一开始，自由主义这套故事主要只关注 221-223, 标注, 2019 年 3 月 7 日星期四 下午 10:49:50 自由主义这套故事证明自己比其他任何对手都更加柔韧、更加灵活。自由主义分别学习了帝国主义、法西斯主义和共产主义某些最优秀的概念。特别值得一提的是，自由主义学习了共产主义，于是扩大了同理的范围，开始在重视自由之外也同时重视平等。 232-234, 标注, 2019 年 3 月 7 日星期四 下午 10:52:26 自由主义也开始认识到共产主义式福利计划的重要性。自由主义同样需要有类似这样的社会安全网，否则必将难以为继。于是出现了社会民主福利国家，既有民主和人权，又结合了由国家出资的教育和医疗保健制度 242-242, 标注, 2019 年 3 月 7 日星期四 下午 10:53:20 特朗普时期所散发的是浓浓的虚无主义。 246-247, 标注, 2019 年 3 月 7 日星期四 下午 10:54:31 多数投票支持特朗普和英国脱欧的人，并不是完全反对整个自由主义组合，而只是对全球化失去了信心。他们仍然相信民主、自由市场、人权，以及社会责任，但认为这些好点子只要在国内流通就行 246-247, 标注, 2019 年 3 月 7 日星期四 下午 10:54:40 多数投票支持特朗普和英国脱欧的人，并不是完全反对整个自由主义组合，而只是对全球化失去了信心。他们仍然相信民主、自由市场、人权，以及社会责任，但认为这些好点子只要在国内流通就行了。 246-248, 标注, 2019 年 3 月 7 日星期四 下午 10:55:04 多数投票支持特朗普和英国脱欧的人，并不是完全反对整个自由主义组合，而只是对全球化失去了信心。他们仍然相信民主、自由市场、人权，以及社会责任，但认为这些好点子只要在国内流通就行了。事实上，他们相信为了维护约克郡或肯塔基州的自由和繁荣，最好在边界筑起一道墙，并对外国人采取非自由主义的政策。 255-257, 标注, 2019 年 3 月 7 日星期四 下午 10:56:09 亚伯拉罕·林肯提出的原则：你可以在某些时候欺骗所有人，也可以在所有时候欺骗某些人，但你无法在所有时候欺骗所有人。 266-266, 标注, 2019 年 3 月 7 日星期四 下午 10:58:14 俄罗斯 87%的财富集中在最富有的 10%的人手中。 288-289, 标注, 2019 年 3 月 7 日星期四 下午 11:02:06 由主义幻灭后形成思想空缺，暂时由地方的怀旧幻想来填补，缅怀着往日的荣光——这可以说是正在全球发生的事 292-292, 标注, 2019 年 3 月 7 日星期四 下午 11:02:40 至于俄罗斯，普京的官方愿景可不是要建立腐败的寡头政治，而是要复兴沙皇时代的帝国。在 292-292, 标注, 2019 年 3 月 7 日星期四 下午 11:02:50 至于俄罗斯，普京的官方愿景可不是要建立腐败的寡头政治，而是要复兴沙皇时代的帝国 287-289, 标注, 2019 年 3 月 7 日星期四 下午 11:04:02 着要主宰世界，而是先把自己的事管好？ 自由主义幻灭后形成思想空缺，暂时由地方的怀旧幻想来填补，缅怀着往日的荣光——这可以说是正在全球发生的事 288-289, 标注, 2019 年 3 月 7 日星期四 下午 11:04:06 的怀旧幻想来填补，缅怀着往日的荣光——这可以说是正在全球发生的事 287-289, 标注, 2019 年 3 月 7 日星期四 下午 11:04:10 主宰世界，而是先把自己的事管好？ 自由主义幻灭后形成思想空缺，暂时由地方的怀旧幻想来填补，缅怀着往日的荣光——这可以说是正在全球发生的事 288-289, 标注, 2019 年 3 月 7 日星期四 下午 11:04:18 自由主义幻灭后形成思想空缺，暂时由地方的怀旧幻想来填补，缅怀着往日的荣光——这可以说是正在全球发生的事 295-296, 标注, 2019 年 3 月 7 日星期四 下午 11:04:32 至于印度、波兰、土耳其和其他许多国家，同样也是靠着将民族主义与宗教传统结合起来的类似怀旧梦想，形成政权的基础 296-296, 笔记, 2019 年 3 月 7 日星期四 下午 11:04:52 中国梦吗？ 303-304, 标注, 2019 年 3 月 7 日星期四 下午 11:05:36 开放市场、问责治理、民主、人权、国际法等原则仍然是这个世纪人类进步最坚实的基础” 302-304, 标注, 2019 年 3 月 7 日星期四 下午 11:05:48 2016 年 9 月，奥巴马在其最后一次联合国演说中提醒听众，别让世界再次“依循着古老的民族、部落、种族和宗教界线，严重分裂，最终导致冲突”。他还认为，“开放市场、问责治理、民主、人权、国际法等原则仍然是这个世纪人类进步最坚实的基础” 302-306, 标注, 2019 年 3 月 7 日星期四 下午 11:05:53 2016 年 9 月，奥巴马在其最后一次联合国演说中提醒听众，别让世界再次“依循着古老的民族、部落、种族和宗教界线，严重分裂，最终导致冲突”。他还认为，“开放市场、问责治理、民主、人权、国际法等原则仍然是这个世纪人类进步最坚实的基础”。 11 奥巴马指出一个事实：虽然自由主义那一套存在诸多缺陷，但在历史上的表现还是远优于其他方案。在 299-306, 标注, 2019 年 3 月 7 ","date":"2024-10-09","objectID":"/%E7%AC%94%E8%AE%B0%E4%BB%8A%E6%97%A5%E7%AE%80%E5%8F%B2%E4%BA%BA%E7%B1%BB%E5%91%BD%E8%BF%90%E5%A4%A7%E8%AE%AE%E9%A2%98-%E4%BB%A5%E8%89%B2%E5%88%97-%E5%B0%A4%E7%93%A6%E5%B0%94%E8%B5%AB%E6%8B%89%E5%88%A9/:0:0","tags":null,"title":"[笔记]今日简史：人类命运大议题-[以色列] 尤瓦尔·赫拉利","uri":"/%E7%AC%94%E8%AE%B0%E4%BB%8A%E6%97%A5%E7%AE%80%E5%8F%B2%E4%BA%BA%E7%B1%BB%E5%91%BD%E8%BF%90%E5%A4%A7%E8%AE%AE%E9%A2%98-%E4%BB%A5%E8%89%B2%E5%88%97-%E5%B0%A4%E7%93%A6%E5%B0%94%E8%B5%AB%E6%8B%89%E5%88%A9/"},{"categories":null,"content":" 22818-22818, 标注, 2019 年 12 月 13 日星期五 下午 10:19:09 宁作太平犬，莫为乱世人 22851-22852, 标注, 2020 年 4 月 27 日星期一 下午 10:26:27 壮志饥餐胡虏肉，笑谈渴饮匈奴 22851-22852, 标注, 2020 年 4 月 27 日星期一 下午 10:26:38 壮志饥餐胡虏肉，笑谈渴饮匈奴血。’ 22883-22884, 标注, 2020 年 4 月 28 日星期二 下午 9:37:29 山外青山楼外楼，西湖歌舞几时休？ 暖风薰得游人醉，直把杭州作汴州 32021-32021, 标注, 2020 年 5 月 1 日星期五 下午 4:57:39 看人挑担不吃力，自己挑担压断脊。 144890-144891, 标注, 2022 年 3 月 22 日星期二 下午 10:53:32 现代电影和电视的编剧人最爱“加添蛇足”，非此不足以示其陋，总认为原作有所不足，再加蛇足方为完全，不明艺术中“空白”的道理。近代中国影视殊少佳作，固不足异。）《 ","date":"2024-10-09","objectID":"/%E7%AC%94%E8%AE%B0%E9%87%91%E5%BA%B8%E5%85%A8%E9%9B%86-%E9%87%91%E5%BA%B8/:0:0","tags":["jinyongquanj","note","ireader"],"title":"[笔记]金庸全集-金庸","uri":"/%E7%AC%94%E8%AE%B0%E9%87%91%E5%BA%B8%E5%85%A8%E9%9B%86-%E9%87%91%E5%BA%B8/"},{"categories":null,"content":" 53-54, 标注, 2020 年 6 月 14 日星期日 下午 5:04:36 金字塔原理的基本结构是：结论先行，以上统下，归类分组，逻辑递进。先重要后次要，先总结后具体，先框架后细节，先结论后原因，先结果后过程，先论点后论据。 77-80, 标注, 2020 年 6 月 14 日星期日 下午 5:05:36 在金字塔结构中，各种思想之间只有非常少的几种逻辑关系（向上、向下或横向联系），这种简单性使我们有可能找到这些逻辑关系的通用规则。一个人要想写出条理清晰的文章，关键是在开始写作前，先将自己的思想组织成金字塔结构，并按照逻辑关系的规则检查和修改。 ","date":"2024-10-09","objectID":"/%E7%AC%94%E8%AE%B0%E9%87%91%E5%AD%97%E5%A1%94%E5%8E%9F%E7%90%86-%E7%BE%8E%E8%8A%AD%E8%8A%AD%E6%8B%89%E6%98%8E%E6%89%98/:0:0","tags":["jinzitayuanl","note","ireader"],"title":"[笔记]金字塔原理-[美]芭芭拉·明托","uri":"/%E7%AC%94%E8%AE%B0%E9%87%91%E5%AD%97%E5%A1%94%E5%8E%9F%E7%90%86-%E7%BE%8E%E8%8A%AD%E8%8A%AD%E6%8B%89%E6%98%8E%E6%89%98/"},{"categories":null,"content":" 31-32, 标注, 2020 年 2 月 1 日星期六 下午 10:15:12 无意识是如此之深，以至于常常看不见他人，对自己也熟视无睹。 要想“看见”，就要从蒙昧中睁开眼来。 39-40, 标注, 2020 年 2 月 1 日星期六 下午 10:16:36 死亡不可怕，最可怕的是无意识，那才相当于死。 40-41, 标注, 2020 年 2 月 1 日星期六 下午 10:16:55 就像叶子从痛苦的蜷缩中要用力舒展一样，人也要从不假思索的蒙昧里挣脱，这才是活着。 41-42, 标注, 2020 年 2 月 1 日星期六 下午 10:17:06 不要因为走得太远，忘了我们为什么出发。 166-167, 标注, 2020 年 2 月 1 日星期六 下午 10:30:03 一个新闻事实至少可以深入到知识、行业、社会三个不同的层面，越深，覆盖的人群就越广， 177-179, 标注, 2020 年 2 月 1 日星期六 下午 10:31:24 部里安排所有主持人拍合影，我是刚来的小姑娘，自然而然站在最后一排边上。崔永元回头看见我，扶一下我的胳膊，把我带到第一排正中间他的位子上，他当时连我的名字都不知道。 247-248, 标注, 2020 年 2 月 1 日星期六 下午 11:22:12 新闻本身是最重要的。如果有一个人能够接近新闻的核心，那你这期节目就让他一个人说话，其他两个坐在那儿一言不发也无所谓。” 279-279, 标注, 2020 年 2 月 1 日星期六 下午 11:25:22 你问一个问题的时候，你期待答案么？你要不期待，你就别问了。” 312-313, 标注, 2020 年 2 月 1 日星期六 下午 11:28:25 人们声称的最美好的岁月其实都是最痛苦的，只是事后回忆起来的时候才那么幸福。” 502-502, 标注, 2020 年 2 月 1 日星期六 下午 11:43:55 那年天热得晚，来得快，路上迎春花像是憋疯了，纯金的枝子胡乱抽打着往外长，衬着灰扑扑的荒街。 538-540, 标注, 2020 年 2 月 1 日星期六 下午 11:47:39 我站在水龙头下，开着冷水，水流过皮肤，一下浮出颤栗的粗颗粒，涂上洗面奶，把脸上擦得都是泡沫，突然觉得是死神在摸着我的脸。我一下子睁大眼睛，血管在颈上嘣嘣地跳。我摸着血管，这就是最原始的东西。活着就是活着。在所有的灾难中，这个温热的跳动就是活着。 553-554, 标注, 2020 年 2 月 1 日星期六 下午 11:49:13 九·一一”后不久，美国人就开始做娱乐脱口秀，一边捶着桌子忍住眼泪，一边继续说笑话。我当时不太明白，现在理解了，人们还能笑的时候，是不容易被打败的。 643-645, 标注, 2020 年 2 月 2 日星期日 下午 1:47:17 一张张椅子依然摆在那里，原样，从四月到五月底，谁也没动过，蓝色的油漆在太阳底下已晒得褪色，快变成了绿的，面对大门口敞开放着，像一群哑口无言的人。 931-932, 标注, 2020 年 2 月 2 日星期日 下午 10:42:16 人性自身却有它的力量，它从故事的枝条上抽枝发芽长出来，多一根枝条，就多开一层花，越来越繁茂广大。 933-934, 标注, 2020 年 2 月 2 日星期日 下午 10:42:38 对人的认识有多深，呈现才有多深。 1070-1070, 标注, 2020 年 2 月 3 日星期一 下午 9:41:20 你看玩电脑游戏的孩子，什么时候说过自己累？有乐趣的人从不说累。” 1232-1233, 标注, 2020 年 2 月 3 日星期一 下午 10:01:35 为了一个目的——哪怕是一个正义的目的，就像车轮一样狠狠辗过人的心，也是另一种戾气。 1267-1269, 标注, 2020 年 2 月 4 日星期二 上午 8:00:28 六月的广东，下着神经质的雨，一下起来就像牛绳一样粗，野茫茫一片白。草树吸饱了水，长疯了，墨一样的浓绿肥叶子，地上蒸出裹脚的湿热，全是蛮暴之 1267-1269, 标注, 2020 年 2 月 4 日星期二 上午 8:00:37 六月的广东，下着神经质的雨，一下起来就像牛绳一样粗，野茫茫一片白。草树吸饱了水，长疯了，墨一样的浓绿肥叶子，地上蒸出裹脚的湿热，全是蛮暴之气。 502-503, 标注, 2020 年 2 月 4 日星期二 下午 9:58:14 那年天热得晚，来得快，路上迎春花像是憋疯了，纯金的枝子胡乱抽打着往外长，衬着灰扑扑的荒街。老金杯在长安街上开到一百二十码，窗开着，外头没人，风野蛮地拍在脸上。 1299-1301, 标注, 2020 年 2 月 4 日星期二 下午 10:07:47 他说了一句：“你想采访弱者。就要让弱者同情你。”看我不明白，又补了一句：“当初我拍那些小姐，因为我比她们还穷，我连吃饭的钱都没有，她们可怜我，让我拍，拍完了，她们请我吃饭。” 1333-1334, 标注, 2020 年 2 月 4 日星期二 下午 10:24:29 知道和感觉到，是两回事。 当年看照片时我写过：她的目光一下一下打在我的身上，让我感到疼痛的亲切。 1373-1374, 标注, 2020 年 2 月 4 日星期二 下午 10:29:21 王小波说过，你在家里，在单位，在认识的人面前，你被当成一个人看，你被尊重，但在一个没人认识你的地方，你可能会被当成东西对待。我想在任何地方都被当成人，不是东西，这就是尊严。 1456-1458, 标注, 2020 年 2 月 4 日星期二 下午 10:36:18 我问张北川：“我们的社会为什么不接纳同性恋者？” 他说：“因为我们的性文化里，把生育当作性的目的，把无知当纯洁，把愚昧当德行，把偏见当原则。” 1520-1521, 标注, 2020 年 2 月 4 日星期二 下午 10:51:17 生和死，苦难和苍老，都蕴涵在每一个人的体内，总有一天我们会与之遭逢。 我们终将浑然难分，像水溶于 1520-1521, 标注, 2020 年 2 月 4 日星期二 下午 10:51:23 生和死，苦难和苍老，都蕴涵在每一个人的体内，总有一天我们会与之遭逢。 我们终将浑然难分，像水溶于水中。 1543-1544, 标注, 2020 年 2 月 4 日星期二 下午 10:53:17 家庭是最小的社会单元，门吱呀一声关上后，在这里人们如何相待，多少决定了一个社会的基本面目。 1851-1852, 标注, 2020 年 2 月 6 日星期四 下午 10:16:00 怕黑，死盯着一天碎星星，一直到瓷青的天里透着淡粉， 1856-1858, 标注, 2020 年 2 月 6 日星期四 下午 10:17:13 苦闷时也只有盯着天看，晚霞奇诡变化，觉得未来有无限可能。阵雨来得快，乌黑的云团滚动奔跑，剩了天边一粒金星没来得及遮，一小粒明光闪烁，突然一下就灭了。折身跑时，雨在后边追，卷着痛痛快快的土腥气扑过来。 1855-1858, 标注, 2020 年 2 月 6 日星期四 下午 10:17:24 天蓝得不知所终，头顶肥大松软的白云，过好久笨重地翻一个身。 苦闷时也只有盯着天看，晚霞奇诡变化，觉得未来有无限可能。阵雨来得快，乌黑的云团滚动奔跑，剩了天边一粒金星没来得及遮，一小粒明光闪烁，突然一下就灭了。折身跑时，雨在后边追，卷着痛痛快快的土腥气扑过来。 1748-1748, 标注, 2020 年 2 月 6 日星期四 下午 11:02:42 可以恨爸爸错误的行为，不要恨爸爸这个人。” 1764-1766, 标注, 2020 年 2 月 6 日星期四 下午 11:04:08 我问打架最恨的那个：“你不怕死？” “不怕。”他头一昂。 他不是不怕，他连生死的概念都没有，所以也不会有悲悯之心。 1792-1793, 标注, 2020 年 2 月 6 日星期四 下午 11:06:07 一个得不到爱、得不到教育的人，对这个社会不可能有责任感。 1827-1828, 标注, 2020 年 2 月 6 日星期四 下午 11:09:07 最难受的不是头上和胳膊上的擦伤，也不是愤怒和委屈，是自憎的感觉——厄运中的人多有一种对自己的怨憎，认为是自我的某种残破才招致了某种命运。 1834-1835, 标注, 2020 年 2 月 6 日星期四 下午 11:10:26 万物流变，千百万年，谁都是一小粒，嵌在世界的秩序当中， 1903-1903, 标注, 2020 年 2 月 7 日星期五 下午 10:26:15 青色砖雕繁复美丽，只不过很多都塌落地上，尽化为土。 1930-1940, 标注, 2020 年 2 月 7 日星期五 下午 10:33:25 文峪河是汾河的支流，我就在汾河边上长大。我奶奶当年进城赶集的时候，圆髻上插枚碧玉簪，簪上别枚铜钱，是渡船的费用。我爸年轻时河里还能游泳，夏天沼泽里挖来鲜莲藕，他拿根筷子，扎在藕眼里哄我吃，丝拉得老长。 我小学时大扫除，用的大扫帚举起来梆梆硬，相当扎手吃力，是芦苇的花絮做成的，河边还有明黄的水凤仙，丁香繁茂，胡枝子、野豌豆、白羊草……蓝得发紫的小蝴蝶从树上像叶子一样垂直飘下来，临地才陡然一翻。还有蟋蟀、蚂蚱、青蛙、知了、蚯蚓、瓢虫……吃的也多，累累红色珠子的火棘，青玉米秆用牙齿劈开，嚼里面的甜汁。回家前挖点马苋菜拿醋拌了，还有一种灰白的蒿，回去蒸熟与碎馒头拌着蒜末吃，是我妈的最爱。最不济，河滩里都是枣树，开花时把鼻子塞进米黄的小碎蕊里拱着，舔掉那点甜香，蜜蜂围着鼻子直转，秋天我爸他们上树打枣，一竿子抡去，小孩子在底下捡拾，叮叮当当被凿得痛快。 风一过，青绿","date":"2024-10-09","objectID":"/%E7%AC%94%E8%AE%B0%E7%9C%8B%E8%A7%81-%E6%9F%B4%E9%9D%99/:0:0","tags":["kanjian","note","ireader"],"title":"[笔记]看见-柴静","uri":"/%E7%AC%94%E8%AE%B0%E7%9C%8B%E8%A7%81-%E6%9F%B4%E9%9D%99/"},{"categories":null,"content":" 466-599, 标注, unknown 总有一些公司很幸运地、有意识或者无意识地站在技术革命的浪尖之上。一旦处在了那个位置，即使不做任何事，也可以随着波浪顺顺当 当地向前漂个十年甚至更长的时间。在这十几年间，它们代表着科技的浪潮，直到下一波浪潮的来临。 601-714, 标注, unknown 原来的贝尔实验室因为有 AT\u0026T 这个大靠山，从来不发愁自己的经费。现在，朗讯的利润不足以养活有两万人的巨型实验室，开始要求那 里的科学家和工程师开发能尽快赚钱的研究上来。 716-801, 标注, unknown 一般来讲，一个公司当前的股价，已经反映了当前和几年后的盈利能力。如果想让股价快速增长，公司的盈利就必须高于大家的预期 803-880, 标注, unknown 短线投资者发现最快的挣钱方法不是把一个企业搞好，而是炒作和包装上市。将公司的一部分拆了卖无疑挣钱最快 882-1051, 标注, unknown 回顾 AT\u0026T 百年历史，几乎每个人都为这个百年老店的衰落而遗憾。它曾经是电话业的代名词，而它的贝尔实验室曾经是创新的代名词， 现在这一切已成为历史。我和很多 AT\u0026T 的主管和科学家们聊过此事，大家普遍认为 AT\u0026T 的每一个大的决定，在当时的情况下都很难避免， 即使知道它是错的。 1072-1184, 标注, unknown IBM 能成为科技界的常青树，要归功于它的二字秘诀-–—保守。毫无疑问，保守使得 IBM 失去了无数发展机会，但是也让它能专注于最重 要的事，并因此而立于不败之地。 1186-1234, 标注, unknown 社会的需求对科技进步的作用要超过十所大学。 1236-1342, 标注, unknown IBM 从它开始做计算机起，基本上遵循性能优先与价格和集中式服务的原则。高性能的，服务于多用户的主机一直是 IBM 硬件制造的重点， 直到近十年来才略有转变。 1344-1452, 标注, unknown BM 从来将计算机和服务绑在一起卖，至今也是如此。IBM 一旦签下一个大型机销售的合同，不但可以直接进帐上百万美元，而且每年还可 以收销售价 10%左右的服务费。 1454-1578, 标注, unknown IBM 在百年来历次技术革命中得以生存和发展，自有其生存之道。它在技术上不断在开拓和发展，以领导和跟随技术潮流；在经营上，死 死守住自己核心的政府、军队企事业部门的市场，对进入新的市场非常谨慎。 1610-1843, 标注, unknown 乔布斯高中毕业后进了一所学费很贵的私立大学。他贫困的养父母倾其所有的积蓄为他付了大学学费。读了半年，乔布斯一方面觉得学非 所用，另一方面不忍心花掉养父母一辈子的积蓄，就退了学。但是，他并没有离开学校，开始旁听他感兴趣的、将来可能对他有用的课。 乔布斯没有收入，靠在同学宿舍地板上蹭块地方睡觉，同时靠捡玻璃瓶、可乐罐挣点小钱。每星期天，为了吃一顿施舍的饭，他要走十公 里到一个教堂去。当时，乔布斯只做自己想做的事。 1845-1928, 标注, unknown 乔布斯送给年轻人两句话，永远渴望、大智若愚（Stay Hungry. Stay Foolish），愿与诸君共勉。 1949-2183, 标注, unknown 个人电脑工业整个的生态链是这样的：以微软为首的软件开发商吃掉硬件提升带来的全部好处，迫使用户更新机器让惠普和戴尔等公司收 益，而这些整机生产厂再向英特尔这样的半导体厂订货购买新的芯片、同时向 Seagat e 等外设厂购买新的外设。在这中间，各家的利润先 后得到相应的提升，股票也随着增长。各个硬件半导体和外设公司再将利润投入研发，按照摩尔定理制定的速度，提升硬件性能，为微软 下一步更新软件、吃掉硬件性能做准备。 2185-2313, 标注, unknown Google（谷歌）的 CEO 埃里克•施密特在一次采访中指出，如果你反过来看摩尔定理，一个 IT 公司如果今天和十八个月前卖掉同样多的、 同样的产品，它的营业额就要降一半。IT 界把它称为反摩尔定理。 2315-2430, 标注, unknown 反摩尔定理使得 IT 行业不可能像石油工业或者是飞机制造业那样只追求量变，而必须不断寻找革命性的创造发明。因为任何一个技术发 展赶不上摩尔定理要求的公司，用不了几年就会被淘汰。 2459-2688, 标注, unknown 世界上最大的三个半导体公司都在日本，PC 里面日本芯片一度占到数量的 60%（注意：不是价钱的 60%）。以至于日本有些政治家盲目自 大，认为日本到了全面挑战美国的时候，全世界都在怀疑美国在半导体技术上是否会落后于日本。但是冷静地分析一下全世界半导体市场 就会发现，日本的半导体工业集中在技术含量低的芯片上，如存储器等芯片（即内存），而全世界高端的芯片工业，如计算机处理器和通 信的数字信号处理器全部在美 2690-2823, 标注, unknown 八十年代，英特尔果断地停掉了它的内存业务，将这个市场完全让给了日本人，从此专心做处理器。当时日本半导体公司在全市界挣了很 多钱，日本一片欢呼，认为它们打败了美国人。其实，这不过是英特尔等美国公司弃子求势的一招棋。 2825-3003, 标注, unknown 英特尔对世界最大的贡献在于，它证明了处理器公司可以独立于计算机整机公司而存在。在英特尔以前，所有计算机公司都必须自己设计 处理器，这使得计算机成本很高，而且无法普及。英特尔不断地为全世界的各种用户提供廉价的、越来越好的处理器，直接地使个人微机 得以普及。它大投入、大批量的做法成为当今半导体工业的典范。 3027-3207, 标注, unknown 我们在以后会专门讨论“中国制造”的效应。它基本的影响是，当一个原本只能在美欧生产的产品，经过一段时间则可以过渡到日本和韩国， 进而落脚于中国。美欧公司能赚钱的时间只有从美国到中国这段时间差，以前这段时间可以长达数十年，现在只有几年。一旦一项产品可 以由中国制造，那么它的利润空间就会薄到让美欧公司退出市场。 3231-3487, 标注, unknown 当时 Dell 占美国微机市场的 31 %，而康柏加惠普占 37 %。菲奥莉娜的如意算盘是通过合并打造世界最大的微机公司，形成对戴尔的优 势。其实，惠普在和 Dell 的竞争中处于劣势的根本原因在于，惠普的问题是资金周转不够快。Dell 的资金一年大约可以周转两次以上， 而惠普只有一次。也就是说，即使 Dell 的利润率只有惠普的一半，它也可以获得和后者相同的利润。这样，Dell 计算机降价的空间就很 大，很容易占领市场。显然收购康柏并不能解决这个问题。 3489-3680, 标注, unknown 在商业史上，类似的事情时常发生，两个在竞争中处于劣势的公司合并后，不仅没有得到累加的市场份额，而且只达到两者合并前少的那 份。原因很简单，在竞争中处于劣势的公司必定有它经营管理的问题。如果这些问题得不到解决，合并后问题会翻倍，在竞争中会更加处 于劣势，从而进一步丢失市场份额。这就好比几块煤放在一起是一堆煤，而不是能发亮的钻石。 3704-3837, 标注, unknown 美国过去未曾有过贵族，今后也不会有。无论是巨富盖茨或者是年轻美貌、聪明而富有的女继承人伊万卡.特朗普都不是任何意义上的贵 族。实际上贵族这个词在整个西方本身就是一个没落的词汇，虽然在东方一些人或许沉迷在贵族梦中。 3855-3918, 标注, unknown 首先，创始人很重要。任何梦想家都不足以成事，因为所有的成功者都是实干家。 3920-4039, 标注, unknown 成功的创业者必须有一个小而精的好团队，里面每个人都得不计较个人得失，同甘共苦，否则成则争功，败则互相推诿。在技术上，他们 必须有自己的金刚钻，他们的技术必须是不容易被别人学会和模仿的。 4041-4123, 标注, unknown 光有好的团体和技术又远远不够，他们有商业头脑而且必须找到一个能盈利的商业模型（Business Model）。 4125-4319, 标注, unknown 再接下来是判断力和执行力。通常，办起一个公司并不难，把它从小做到大，并且做到盈利就不容易。在这个过程中有很多路要走，不免 要遇到数不清的岔路，任何一次错误的选择都可能使原本看上去不错的公司运营不下去而关门大吉，因为小公司对抗大公司时是不能有任 何一次失误的。执行力是保证正确的决定能够最终实现的因素。判断力和执行力很大程度上来自于经验 4321-4406, 标注, unknown 初创公司的成功很大程度上还要看外部环境好不好，很多很有前途的公司因为创办的时机不对，也会随着经济大环境的衰退而夭折。 4408-4463, 标注, unknown 一将功成万骨枯，无数失败的公司在为少数几个成功者做分母。 4465-4593, 标注, unknown 不仅公司不迷信权威，硅谷的个人也是如此。一个年轻的工程师，很少会因为 IBM 或者斯坦福的专家说了该怎么做就循规蹈矩，而是会不 断挑战传统寻找新的办法。在公司内部，职位高的人不能以权压人而必须以理服人。 4595-4672, 标注, unknown 半导体并不是硅谷真正的本质。硅谷的灵魂是创新。硅没有了，创新的灵魂留下了，它保证了硅谷的繁荣和发展。 4707-4789, 标注, unknown 太阳公司从 1982 年成立到 2000 年达到顶峰用了近二十年时间，而走下坡路只用了一年，足以令经营者为戒。 4791-4978, 标注, unknown 衰落要比繁荣来得快，在很短时间内，西班牙从欧洲的富国沦为","date":"2024-10-09","objectID":"/%E7%AC%94%E8%AE%B0%E6%B5%AA%E6%BD%AE%E4%B9%8B%E5%B7%85-n-a/:0:0","tags":["langchaozhid","note","ireader"],"title":"[笔记]浪潮之巅-N/A","uri":"/%E7%AC%94%E8%AE%B0%E6%B5%AA%E6%BD%AE%E4%B9%8B%E5%B7%85-n-a/"},{"categories":null,"content":" 227-229, 标注, 2024 年 9 月 5 日星期四 下午 10:39:04 小说和绘画在艺术手法上是相通的。真正高明的画作要表达某个对象，总是重点刻画其最突出的特征，而其他地方则不多加描摹，甚至留白，比如中国古代的山水或者花鸟画，这样透露出来的美感，往往是面面俱到的摄影作品无法比拟的。 254-256, 标注, 2024 年 9 月 5 日星期四 下午 10:41:23 被许多美国人引为国民精神的美国梦，是新教伦理和宪政主义相结合的产物，它的核心含义是：任何人在美国，只要足够勤奋，坚持不懈地奋斗，便能拥有更美好的生活。 316-317, 标注, 2024 年 9 月 5 日星期四 下午 10:46:38 “每当你要批评别人，”他告诉我，“要记住，世上不是每个人都有你这么好的条件。” 331-332, 标注, 2024 年 9 月 6 日星期五 上午 7:39:28 使我暂时对人世徒劳之悲哀和易逝之欢欣丧失兴趣的，是盖茨比身边那些食客，是那阵在他的梦想破灭之后飘散的污浊灰尘。 387-391, 标注, 2024 年 9 月 6 日星期五 上午 7:51:25 [12]，前方就是海湾。草坪从沙滩开始，跑过四分之一英里，来到前门，跳过日晷、砖径和几个万紫千红的花园，抵达墙角之后，仿佛借助奔跑的势头，变成常春藤继续往墙上冲。房子正面有一排落地玻璃窗，在金色斜晖的照耀之下闪闪发亮，敞开着迎接午后暖煦的和风。 407-410, 标注, 2024 年 9 月 6 日星期五 上午 7:54:51 我们穿过高高的门厅，来到明艳的玫瑰色客厅，客厅很雅致，两端是落地窗。两扇玻璃窗都开着，映照着户外绿油油的草地，显得那些草儿好像长到厅里来了。和风穿堂而过，将一边的窗帘吹进来，又将一边的窗帘吹出去，让白旗般的窗帘飘向婚礼蛋糕似的天花板，然后拂过酒红色的地毯，在其上留下波浪起伏的影子，宛如劲风刮过海面。 492-494, 标注, 2024 年 9 月 6 日星期五 上午 8:12:04 最后的余晖带着罗曼蒂克的色彩，将她的面容照得神采奕奕，而她美妙的声线吸引我屏住呼吸凑上前去倾听。片刻之后，那神采消失了，每道光线恋恋不舍地离她而去，就像儿童在黄昏时离开充满乐趣的街道那样。 1014-1016, 标注, 2024 年 9 月 6 日星期五 下午 6:51:23 圆圆的月亮照耀着盖茨比的豪宅，使夜色美好得如同往常。他的花园里仍是灯火辉煌，但欢声笑语已消逝，唯有明月依旧在。一阵突如其来的空虚仿佛正从那些窗户和房门流溢而出，让主人的身影益发显得孤独：此际他独自站在门廊上，举手摆出依依惜别的姿势。 1033-1035, 标注, 2024 年 9 月 6 日星期五 下午 6:54:32 这大都会的黄昏很迷人，可我偶尔会有挥之不去的孤寂，每当看见那些囊中羞涩的年轻职员在商店橱窗之前倘佯，捱到晚饭时间形影相吊地去餐厅填肚子，我知道他们也深有同感——我们这些薄暮中的年轻职员啊，正在虚度一生中最灿烂的年华、一夜中最美好的时辰。 323-324, 标注, 2024 年 9 月 6 日星期五 下午 10:17:49 基本的道德观念并非与生俱来、人人皆有的东西。 2631-2633, 标注, 2024 年 9 月 7 日星期六 上午 11:29:14 一切都是因为自私冷漠和思维混乱。他们是自私冷漠的人，汤姆和黛熙——他们把东西打碎，毁掉别人的生活，然后龟缩到金钱、巨大的冷漠或者随便什么让他们蝇营狗苟地相处的东西里面，让别人来清理他们留下的残局…… 2653-2655, 标注, 2024 年 9 月 7 日星期六 上午 11:31:26 盖茨比信奉的那盏绿灯，是年复一年在我们眼前渐渐消失的极乐未来。我们始终追它不上，但没有关系——明天我们会跑得更快，把手伸得更长……等到某个美好的早晨—— 于是我们奋力前进，却如同逆水行舟，注定要不停地退回过去。 ","date":"2024-10-09","objectID":"/%E7%AC%94%E8%AE%B0%E4%BA%86%E4%B8%8D%E8%B5%B7%E7%9A%84%E7%9B%96%E8%8C%A8%E6%AF%94-%E5%BC%97%E6%9C%97%E8%A5%BF%E6%96%AF%E5%8F%B8%E5%90%84%E7%89%B9%E8%8F%B2%E5%85%B9%E6%9D%B0%E6%8B%89%E5%BE%B7/:0:0","tags":null,"title":"[笔记]了不起的盖茨比-弗朗西斯·司各特·菲兹杰拉德","uri":"/%E7%AC%94%E8%AE%B0%E4%BA%86%E4%B8%8D%E8%B5%B7%E7%9A%84%E7%9B%96%E8%8C%A8%E6%AF%94-%E5%BC%97%E6%9C%97%E8%A5%BF%E6%96%AF%E5%8F%B8%E5%90%84%E7%89%B9%E8%8F%B2%E5%85%B9%E6%9D%B0%E6%8B%89%E5%BE%B7/"},{"categories":null,"content":" 308-309, 标注, 2020 年 12 月 1 日星期二 下午 8:40:19 在鸦片战争以前，我们不肯给外国平等待遇；在以后，他们不肯给我们平等待遇。 463-464, 标注, 2020 年 12 月 1 日星期二 下午 9:19:00 苟利国家生死以，岂因祸福避趋之！ 3147-3149, 标注, 2020 年 12 月 3 日星期四 下午 9:43:19 黄兴的妻子（徐宗汉）的妹妹（徐文）的第二个女儿（龚澎）的第二个丈夫（乔冠华）的第二个妻子（章含之）的第一个丈夫（洪君彦）的女儿（洪晃）的第二个丈夫是陈凯歌。 3373-3374, 标注, 2020 年 12 月 3 日星期四 下午 10:12:12 一般来说，领导说话要讲技巧，一定要说得高深，务必值得下属揣摩才算上乘，下属揣摩对了并且做得好那是领导有方，揣摩错了干得不好那是没有领会精神，千错万错都是下属的错就是这个意思。 3530-3530, 标注, 2020 年 12 月 4 日星期五 上午 6:36:58 简单的占有是小聪明，暂时的放弃才是大智慧 3535-3537, 标注, 2020 年 12 月 4 日星期五 上午 6:38:30 虽然贵为状元，但他没有学王文韶那样死抱着八股科举不放，而是向袁世凯等人学习，办新式教育，教化国人。二十年间，他倾尽所能创建了包括今复旦大学、今南京大学在内的三百七十多所高校，直到破产为止！ 救国救到破产，千古又有几人！ 2751-2751, 标注, 2020 年 12 月 6 日星期日 上午 8:33:54 狱中题壁 2751-2751, 标注, 2020 年 12 月 6 日星期日 上午 8:34:20 谭嗣同死之前在狱中写了 8395-8398, 标注, 2020 年 12 月 6 日星期日 下午 8:30:48 需要有人站出来为国家民族争取利益的时代，他们走出校园来到街头，为求真理，奋勇抗争；他们跋山涉水来到彩云之南，于艰难困苦中书声依旧，于烽火连天里薪继火传，缔造西南联大的传奇；他们弃笔从戎踏上抗战之路，筚路蓝缕，血洒疆场，却一往无前 8395-8398, 标注, 2020 年 12 月 6 日星期日 下午 8:31:04 在这个中华民族岌岌可危的时代，在这个需要有人站出来为国家民族争取利益的时代，他们走出校园来到街头，为求真理，奋勇抗争；他们跋山涉水来到彩云之南，于艰难困苦中书声依旧，于烽火连天里薪继火传，缔造西南联大的传奇；他们弃笔从戎踏上抗战之路，筚路蓝缕，血洒疆场，却一往无前 9910-9912, 标注, 2020 年 12 月 8 日星期二 下午 8:55:42 全书至此，关于孙中山的笔墨甚多，其中有褒有抑，这一切都是按照史料行笔，旨在还原一个真实的孙中山，一个有血有肉的孙中山 10389-10391, 标注, 2020 年 12 月 9 日星期三 下午 10:43:52 战败国德国，则身背两百六十亿美元左右的战争赔款，“一夜回到解放前”。要知道，那时的美元是很值钱的，中国近代史上所有的赔款加一块也就相当于德国赔款的十分之一，由此可见德国面临的压力之大 14303-14304, 标注, 2020 年 12 月 16 日星期三 下午 8:15:52 所以，从通车时起，滇缅公路就成了一条不折不扣的生命线。这条生命线是埋葬日本灭亡中国梦想的大道！必须保护好，不容有失。这就是后来中国组织远征军进入缅甸的真正原因。 ","date":"2024-10-09","objectID":"/%E7%AC%94%E8%AE%B0%E5%8E%86%E5%8F%B2%E6%B7%B1%E5%A4%84%E7%9A%84%E6%B0%91%E5%9B%BD-%E6%B1%9F%E5%9F%8E/:0:0","tags":["lishishenchu","note","ireader"],"title":"[笔记]历史深处的民国-江城","uri":"/%E7%AC%94%E8%AE%B0%E5%8E%86%E5%8F%B2%E6%B7%B1%E5%A4%84%E7%9A%84%E6%B0%91%E5%9B%BD-%E6%B1%9F%E5%9F%8E/"},{"categories":null,"content":" 326-328, 标注, 2019 年 10 月 20 日星期日 下午 9:59:21 我被控违犯了美国《反海外腐败法》，而对于这项控罪，她此前根本不了解。根据这部法律，无论任何人，无论国籍，只要涉嫌向外国公职人员行贿，只要该罪行和美国有一丝一缕的联系，美国司法部即可将他投入监狱。[ 519-521, 标注, 2019 年 10 月 21 日星期一 下午 9:58:13 2000 年 9 月，法国在批准并签署与经济合作与发展组织关于反腐败斗争的协议之前，利用中间人来获取国际市场项目是一个被容许的惯例。贿赂之举越是在法国领土上被禁止，就越是在国外被纵容。 591-592, 标注, 2019 年 10 月 21 日星期一 下午 10:23:55 面对所有复杂局面，我都采用运算的方式处理。我先排列出加号、减号，再做加法和减法。 有一条好消息：我在这个地狱般的看守所 591-592, 标注, 2019 年 10 月 21 日星期一 下午 10:24:05 面对所有复杂局面，我都采用运算的方式处理。我先排列出加号、减号，再做加法和减法。 788-792, 标注, 2019 年 10 月 22 日星期二 下午 9:49:48 这部法律允许美国政府随意逮捕一个公司的任何一名员工，不论他在这个世界的哪个角落，不论什么时候。而且他们可以把这个人投入监狱，刑期会非常长。” “你说得有点儿夸张吧？” “没有，弗雷德。我不愿意让你不安，但是美国当局认为，哪怕只是和美国有一丝关联，比如在美国证券交易所上市、使用美元交易、使用美国的邮箱，都能成为美国采取行动的理由。这听起来有些疯狂，但这种事情经常发生。 954-954, 标注, 2019 年 10 月 23 日星期三 下午 7:54:54 美国司法体系就是一个大市场。 1093-1096, 标注, 2019 年 10 月 23 日星期三 下午 10:58:10 永远不要相信你的律师，大部分律师私底下都是为政府卖命的。尤其是永远不要向你的律师认罪，否则他就会强迫你和他做交易，如果你拒绝，他就会向检察官把你兜个底儿掉。还有，要当心其他犯人。犯人里有很多‘告密者’，他们听到一点儿风吹草动就会立马去报告，因为这能够减轻他们的刑罚。” 1182-1183, 标注, 2019 年 10 月 24 日星期四 上午 11:09:47 只要我不认罪，检察官就一定不会把我放出去；我必须和美国司法部进行交易，即使交易只能在黑暗中摸索进行。 1186-1190, 标注, 2019 年 10 月 24 日星期四 下午 9:27:21 在美国电视剧和电影中，美国人为了鼓吹自己的司法体系，往往会拍摄这样的场景：万人瞩目的庭审现场，一位经验丰富的律师作为正义的化身为被告人辩护。我们早已被这种剧情洗脑，误以为即使是最为弱势的群体的案件，也会有人倾听，更会有人为之辩护。然而事实恰恰相反，因为与这个群体有关的犯罪案件，基本都不会走到庭审这一步。在 90%的案件中，被告人会选择放弃申辩，原因非常简单：高昂的辩护费必须由被告人全额承担。只有那群最有钱的人——必须是真的非常有钱的人——才能负担得起律师事务所的费用。 1289-1291, 标注, 2019 年 10 月 24 日星期四 下午 10:01:45 如果我认罪，阿尔斯通就不再为我支付律师费，将完全抛弃我；如果我不认罪，我可能就要被判蹲 125 年监狱。我要在两天内做出决定，是因为彭波尼有可能‘窃取’我的位置。而导致目前这一状况的根源是，我无法阅览我的卷宗，因为太多了，足足有 150 万件，而您的事务所无法分析它们。 1408-1408, 标注, 2019 年 10 月 24 日星期四 下午 10:41:31 如果你坚持出庭应诉，他们便用多年的重刑期吓唬你，然后用一个少很多的刑期逼你认罪。 1408-1409, 标注, 2019 年 10 月 24 日星期四 下午 10:41:37 如果你坚持出庭应诉，他们便用多年的重刑期吓唬你，然后用一个少很多的刑期逼你认罪。如此这般，我也进入了这个任何人都不能逃脱的定律。 1493-1494, 标注, 2019 年 10 月 25 日星期五 上午 8:19:59 他们遵循着一个毫无人性的原则：剥夺待审犯人——除非是有钱人——一切能够为自己辩护的手段，以迫使他们最终认罪。 1587-1588, 标注, 2019 年 10 月 26 日星期六 上午 10:54:02 立即禁止美国公司向“外国公职人员”（包括公务员、政治领导人、受托管理公共事务的人）支付佣金。 506-625, 标注, unknown 2000 年 9 月，法国在批准并签署与经济合作与发展组织关于反腐败斗争的协议之前，利用中间人来获取国际市场项目是一个被容许的惯例。贿赂之举越是在法国领土上被禁止，就越是在国外被纵容。 1282-1545, 标注, unknown 在美国电视剧和电影中，美国人为了鼓吹自己的司法体系，往往会拍摄这样的场景：万人瞩目的庭审现场，一位经验丰富的律师作为正义的化身为被告人辩护。我们早已被这种剧情洗脑，误以为即使是最为弱势的群体的案件，也会有人倾听，更会有人为之辩护。然而事实恰恰相反，因为与这个群体有关的犯罪案件，基本都不会走到庭审这一步。在 90%的案件中，被告人会选择放弃申辩，原因非常简单：高昂的辩护费必须由被告人全额承担。只有那群最有钱的人——必须是真的非常有钱的人——才能负担得起律师事务所的费用。 1547-1709, 标注, unknown 如果我认罪，阿尔斯通就不再为我支付律师费，将完全抛弃我；如果我不认罪，我可能就要被判蹲 125 年监狱。我要在两天内做出决定，是因为彭波尼有可能‘窃取’我的位置。而导致目前这一状况的根源是，我无法阅览我的卷宗，因为太多了，足足有 150 万件，而您的事务所无法分析它们。 ","date":"2024-10-09","objectID":"/%E7%AC%94%E8%AE%B0%E7%BE%8E%E5%9B%BD%E9%99%B7%E9%98%B1-%E5%BC%97%E9%9B%B7%E5%BE%B7%E9%87%8C%E5%85%8B%E7%9A%AE%E8%80%B6%E9%B2%81%E9%BD%90%E9%A9%AC%E4%BF%AE%E9%98%BF%E4%BC%A6/:0:0","tags":["meiguoxianji","note","ireader"],"title":"[笔记]美国陷阱-弗雷德里克·皮耶鲁齐;马修·阿伦","uri":"/%E7%AC%94%E8%AE%B0%E7%BE%8E%E5%9B%BD%E9%99%B7%E9%98%B1-%E5%BC%97%E9%9B%B7%E5%BE%B7%E9%87%8C%E5%85%8B%E7%9A%AE%E8%80%B6%E9%B2%81%E9%BD%90%E9%A9%AC%E4%BF%AE%E9%98%BF%E4%BC%A6/"},{"categories":null,"content":" 94-95, 标注, 2020 年 3 月 22 日星期日 下午 9:57:13 年龄偏高的种族群比年龄偏低的种族群挣的钱要多，这种现象是不足为奇的。令人莫名其妙的倒是将这些差距归咎为某种程度上的雇主歧视或种族“无能”。 110-111, 标注, 2020 年 3 月 22 日星期日 下午 10:00:08 ，最贫困的阶层总是具有最高的生育率，所谓“富人发财，穷人养孩”。 234-234, 标注, 2020 年 3 月 23 日星期一 下午 10:05:33 能公允地证明平民百姓具有未被开发的潜力的，莫过于美国经验。 262-264, 标注, 2020 年 3 月 23 日星期一 下午 10:08:28 对绝大多数美籍爱尔兰人来说，经过一个多世纪的努力方才获得成功，使他们在收入、从业、智商以及其他社会—经济地位的指标方面，跻身于其他美国人之列。社会接受他们是缓慢的，而且这种接受一般是他们成功的结果，而不是成功的前提。 593-594, 标注, 2020 年 3 月 24 日星期二 下午 8:59:17 爱尔兰人在政界、金融、工会领导、体育和新闻方面一马当先，而犹太人则在经商、技术行业、学术和科学方面独占鳌头。 606-607, 标注, 2020 年 3 月 24 日星期二 下午 9:01:06 在欧洲主要国家当中，唯独爱尔兰没能在中世纪建立起一所大学。 664-667, 标注, 2020 年 3 月 24 日星期二 下午 9:28:52 。在几个世纪以前的爱尔兰，每逢见到别人，一个爱尔兰人立即就会将其区分为：（1）或者是另一个爱尔兰同胞，（2）或者是一个死敌。而死敌当然就是可憎的，该打的，而且要狠狠地打。爱尔兰人远在他们的双脚踏上美国的土地之前，早就抱有强烈的本族认同感了。 694-695, 标注, 2020 年 3 月 25 日星期三 下午 9:46:16 德国移民造成的最重大社会变化之一，是在美国推广了各式各样天真活泼而且适于整个家庭在公开场合进行的娱乐活动。 1140-1140, 标注, 2020 年 3 月 26 日星期四 下午 10:00:37 欧洲犹太文化的典型特征之一，就是对知识的尊重和景仰。 1137-1139, 标注, 2020 年 3 月 26 日星期四 下午 10:00:47 美籍德国人的真正历史，不在于他们为自己获得了什么，而在于他们对美国工业、科学、文化、军事实力和娱乐活动的发展所作出的贡献。因为有了美籍德国人的这许多贡献，由各种不同肤色和种族组成的美利坚民族，才是一个不同的民族，而且是更为兴旺发达的民族。 1153-1156, 标注, 2020 年 3 月 26 日星期四 下午 10:03:09 基督教在整个欧洲取代了多神信仰之后，犹太人变为欧洲大陆唯一不信奉基督教的民族，故所到之处皆成“局外人”。这就使犹太人在基督教狂热时期（比如十字军东征）或宗教大恐怖时期（比如中世纪不时发生毁坏整个地区的灾祸）处于自身难保的境地。十字军穿过欧洲，向东讨伐穆斯林人，沿途时常停下来屠杀所在地区的犹太人， 1441-1443, 标注, 2020 年 3 月 29 日星期日 下午 9:29:10 1912 年对俄国犹太人居民地段的公立图书馆所进行的一项调查表明，借阅过的书籍有 53%是非小说类，而馆藏小说的大部分也是托尔斯泰、大仲马和狄更斯这样一些名家的作品。浅薄的畅销之作则无人问津，“待在书架上，布满灰尘”。 2209-2211, 标注, 2020 年 3 月 29 日星期日 下午 10:03:18 中华民族的悠久历史和文化，可以追溯到基督降生之前的几千年。中国曾在很长的时期内一直是世界上经济、技术和社会组织最先进的国家。中国在 11 世纪所达到的经济发展水平，任何一个欧洲国家在 18 世纪之前都没能赶上。 2209-2213, 标注, 2020 年 3 月 29 日星期日 下午 10:03:29 中华民族的悠久历史和文化，可以追溯到基督降生之前的几千年。中国曾在很长的时期内一直是世界上经济、技术和社会组织最先进的国家。中国在 11 世纪所达到的经济发展水平，任何一个欧洲国家在 18 世纪之前都没能赶上。现存最古老的一本印刷书籍，是公元 9 世纪在中国印刷出来的。中国的铸铁术比欧洲要早 1000 年。在 10～12 世纪的宋朝，中国就有了钢铁工业，年产生铁十多万吨。马可·波罗在中国发现了一个有 200 万人口的城市，而当时欧洲最大城市的居民也不超过区区 5 万人。时至 16 世纪，中国仍具有世界上最高的生活水平。 2217-2218, 标注, 2020 年 3 月 29 日星期日 下午 10:04:18 中国现代史上的一大讽刺是，中国人在世界各国都能发财致富，但他们在国内却贫困不堪。 2311-2316, 标注, 2020 年 3 月 29 日星期日 下午 10:19:21 1882 年，美国单方面地降低中国人移美的数量，结果造成华人两性比例失调，其程度之严重，超过任何别的种族。 1860 年，在美华人的男女比例约为 20∶1，到 1890 年更上升到 27∶1。时至 1930 年，这个比例仍为 4∶1。很明显，在这种情况下，许多早期的华人无从繁衍后代。这意味着，华人作为一个种族群体，融入美国文化的时间被耽误了。在美国出生的第二代华人几乎没有，直到 1940 年大多数华人仍然不是在美国出生的，所以无从通过学校来学习英语和美国习俗，更谈不上像其他种族那样有第二代孩子来帮助其父母去适应美国文化了。 2317-2318, 标注, 2020 年 3 月 29 日星期日 下午 10:19:36 在一个既不为人所需而他们自己也不想待下去的国度里，数以千计本来就没有打算终生留居美国的华人，孤独地度过了他们的一生。 2322-2324, 标注, 2020 年 3 月 29 日星期日 下午 10:20:43 各种华人互助组织最后终于合并为华人慈善总会，还出现了各种各样的互助组织。这些组织起到就业介绍所、轮流借贷协会、调解机构和社会团体的作用。因为这种互助组织有多项功能，所以它能赢得华人的尊重或认可。没有这种组织，这些流落异国他乡的苦命人就将失去许多必需的服务和享受。各种华人互助组织最后终于合并为华人慈善总会 2393-2394, 标注, 2020 年 3 月 30 日星期一 下午 10:54:44 大多数美籍华人已不再住在唐人街，唐人街的居民只是那些早期移民当中因无法返回祖国而被困在美国的上了年纪的老华侨，以及那些重蹈早期华人贫困经历的新一代华人难民。 2430-2433, 标注, 2020 年 3 月 30 日星期一 下午 10:59:54 在中国文化中，妇女的作用历来都是从属的，至少对外是如此。但是，即便是在中国本土，中国男子也博得了世界上最怕老婆的名声。在美籍华人当中，单是男女比例失调这个现状就足以使女人易于占上风。尽管华人丈夫对外是一家之主，但是妻子决定家中大事的现象很普遍，而且不限于家务事。 2743-2744, 标注, 2020 年 4 月 5 日星期日 下午 9:30:56 。放纵的个人主义在日本的价值体系中素无立足之地，他们视集体利益高于一切。日语中压根儿就没有“隐私”这个词。 2825-2826, 标注, 2020 年 4 月 7 日星期二 下午 9:56:04 在“二战”中的悲惨经历，最终被证明是美籍日本人在美国站稳脚跟的一个转折点。从来没有一个民族在如此艰难的条件下证明自己对美国的忠诚。 2830-2831, 标注, 2020 年 4 月 7 日星期二 下午 9:56:47 尽管第一代日本移民遭受了巨大而不可弥补的损失，但对第二代人来说，拘留营成了他们迈入美国社会的开端，从此就沿着社会和经济的阶梯青云直上。 2850-2851, 标注, 2020 年 4 月 7 日星期二 下午 10:02:47 ，许多日裔美国人自己，包括参议员 S·I·早川，都认为战时拘留反倒有利于他们从长计议，最后得以飞黄腾达。 1794-1795, 标注, 2020 年 4 月 19 日星期日 下午 10:14:22 南部意大利人奉行的准则是，客气但坚定地警告对方不可轻举妄动，一旦对方置之不理，继续寻衅，则毫不留情地进行报复，这 4326-4327, 标注, 2020 年 4 月 23 日星期四 上午 9:34:55 。在一个重视个人价值的社会里，种族史提醒我们，每个人都生在世代相传的特定文化模式之中，这种文化模式有着深远的影响，此点不可忘记 ","date":"2024-10-09","objectID":"/%E7%AC%94%E8%AE%B0%E7%BE%8E%E5%9B%BD%E7%A7%8D%E6%97%8F%E7%AE%80%E5%8F%B2-epubw/:0:0","tags":["meiguozhongz","note","ireader"],"title":"[笔记]美国种族简史-ePUBw.COM 【美】托马斯·索威尔","uri":"/%E7%AC%94%E8%AE%B0%E7%BE%8E%E5%9B%BD%E7%A7%8D%E6%97%8F%E7%AE%80%E5%8F%B2-epubw/"},{"categories":null,"content":" 348-350, 标注, 2020 年 10 月 16 日星期五 下午 10:01:03 长期的困难生活，最能磨炼一个人的意志。有很多人在遇到困难后，只能怨天尤人，得过且过，而另外一些人虽然也不得不在困难面前低头，但他们的心从未屈服，他们不断地努力，相信一定能够取得最后的胜利。 1951-1951, 标注, 2020 年 10 月 17 日星期六 下午 2:59:28 天道好还，中国有必伸之理；人心效顺，匹夫无不报之仇。 4373-4374, 标注, 2020 年 10 月 18 日星期日 下午 7:38:26 绝对不要做你的敌人希望你做的事情，原因很简单，因为敌人希望你这样做。 —— 拿破仑 1710-1710, 标注, 2020 年 11 月 26 日星期四 下午 9:41:27 性格决定命运。 9978-9981, 标注, 2021 年 4 月 9 日星期五 下午 9:09:13 当你感到畏惧和痛苦，支撑不下去的时候，你应该同时意识到，决定你命运的时候到了。 因为畏惧并不是消极的，事实上，它是一个人真正强大的开始，也是成为英雄的起点。 不懂得畏惧的人不知道什么是困难，也无法战胜困难。 只有懂得畏惧的人，才能唤起自己的力量。 只有懂得畏惧的人，才有勇气去战胜畏惧。 懂得畏惧的可怕，还能超越它、征服它的人，就是英雄。 这就是我所认为真正的英雄——畏惧并战胜畏惧的人。 关键只在于那畏惧的一刻，你是选择战胜它，还是躲避它。 人生的分界线就在这里，跨过了这一步就是英雄，退回这一步就是懦夫 24546-24547, 标注, 2021 年 6 月 27 日星期日 下午 8:21:20 王安石之所以失败，是因为他自以为聪明；而张居正之所以成功，是因为他自以为愚蠢。 24564-24565, 标注, 2021 年 6 月 27 日星期日 下午 8:22:49 因为在中国历史上，共同创业的人大都逃不过“四同”的结局：同舟共济——同床异梦——同室操戈——同归于尽。 26663-26665, 标注, 2021 年 7 月 1 日星期四 下午 11:04:22 在这场惨烈的战役中，李如松领悟了极其重要的两点秘诀： 一、要让对方绝望，必先给他希望，此所谓围师必缺。 二、要攻破城池，最好的攻击点，不是最弱的位置，而是对方想象不到的地方。 35887-35889, 标注, 2021 年 7 月 13 日星期二 下午 9:44:03 批判应试教育的人曾说，今日之高考，即是古代之进士科举，罪大恶极。 我觉得这句话是不恰当的，因为客观地讲，高考上榜的人，换到明代，最多就是秀才，举人可以想想，进士可以做梦。 37896-37897, 标注, 2021 年 7 月 18 日星期日 下午 4:50:04 就是先解决内部矛盾，再解决外部矛盾。 ","date":"2024-10-09","objectID":"/%E7%AC%94%E8%AE%B0%E6%98%8E%E6%9C%9D%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF-%E5%BD%93%E5%B9%B4%E6%98%8E%E6%9C%88/:0:0","tags":["mingzhaonaxi","note","ireader"],"title":"[笔记]明朝那些事儿-当年明月","uri":"/%E7%AC%94%E8%AE%B0%E6%98%8E%E6%9C%9D%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF-%E5%BD%93%E5%B9%B4%E6%98%8E%E6%9C%88/"},{"categories":null,"content":" 163-164, 标注, 2019 年 12 月 13 日星期五 下午 9:48:32 欧洲不只是一个地理概念，它更是一个文化的概念。它不仅仅是 geographical Europe，还是 cultural Europe。 180-181, 标注, 2019 年 12 月 13 日星期五 下午 9:52:44 黑格尔把中国和印度划在了世界历史之外，就是把中国和印度看做了世界历史发展规律之外的国家，是“另类”。 182-182, 标注, 2019 年 12 月 13 日星期五 下午 9:56:08 客观地说，中国进入世界历史的发展进程，才一百多年， 185-185, 标注, 2019 年 12 月 13 日星期五 下午 9:57:04 历史的长期合理性”，就是说历史是不能责怪的。 193-194, 标注, 2019 年 12 月 13 日星期五 下午 9:58:38 做学问，包括你们本科生的学习，没有一种“情结”，是不行的。总之要有“情结”，要有兴趣的升华，甚至升华到带有感情色彩了，你才能学得下去。 201-202, 标注, 2019 年 12 月 13 日星期五 下午 10:00:42 做学问这个事情，有两点很重要——现在我姑且把大家都算做做学问的人—— 203-203, 标注, 2019 年 12 月 13 日星期五 下午 10:01:04 第一，要怀疑。没有怀疑，就没有知识， 203-205, 标注, 2019 年 12 月 13 日星期五 下午 10:01:48 第一，要怀疑。没有怀疑，就没有知识，大家都知道，笛卡儿的这句话：“我思，故我在。”但常常忘了他说“我思，故我在”之前的论证。前面的论证，如果我要给他概括的话，可以是五个字：“我疑，故我思”——我有怀疑，所以我思想；因为我有思想，所以我存在 206-207, 标注, 2019 年 12 月 13 日星期五 下午 10:01:59 假如把这两句话连在一起，确实构成了知识论的完整的东西：“我疑，故我思；我思，故我在。”就是说，一个人，要有怀疑，才有知识。 208-208, 标注, 2019 年 12 月 13 日星期五 下午 10:02:52 第二点，要经常感到缺憾，经常感到自己缺点什么东西，知识才能见长。 209-210, 标注, 2019 年 12 月 13 日星期五 下午 10:03:42 生命是有限的，知识是无穷的。 203-206, 标注, 2019 年 12 月 13 日星期五 下午 10:04:43 第一，要怀疑。没有怀疑，就没有知识，大家都知道，笛卡儿的这句话：“我思，故我在。”但常常忘了他说“我思，故我在”之前的论证。前面的论证，如果我要给他概括的话，可以是五个字：“我疑，故我思”——我有怀疑，所以我思想；因为我有思想，所以我存在。他这个存在主要是本体论的存在， 211-213, 标注, 2019 年 12 月 13 日星期五 下午 10:20:02 西方人就是这样，不断提出问题，不断假设问题；解决一个问题，提出一个问题；解决一个问题，再提出一个问题。中国不是这样。中国解决了一个问题，敲锣打鼓好几年。 240-241, 标注, 2019 年 12 月 13 日星期五 下午 10:23:24 得一位老师，兴一个学科。 260-261, 标注, 2019 年 12 月 13 日星期五 下午 10:27:31 欧洲文明的源头——大家公认的，我的书里面也是这样写的——是“两希文明”，就是希伯来和希腊。 260-261, 标注, 2019 年 12 月 13 日星期五 下午 10:27:41 欧洲文明的源头——大家公认的，我的书里面也是这样写的——是“两希文明”，就是希伯来和希腊。然后呢，就是罗马，再加上基督教文明，这就是欧洲文明的源头 304-304, 标注, 2019 年 12 月 13 日星期五 下午 10:58:57 欧洲文明的源头是希腊，希腊文明的源头是同两河流域的交流。 304-305, 标注, 2019 年 12 月 13 日星期五 下午 10:59:21 欧洲文明的源头是希腊，希腊文明的源头是同两河流域的交流。不是说从两河流域的文化发展出了一个希腊文化，而是说希腊文化受到了两河流域文化的影响。 308-309, 标注, 2019 年 12 月 13 日星期五 下午 11:00:20 黑格尔经常说只要一提到希腊，就有一种“家园之感”。那么大的欧洲把那么小的希腊当作自己的家园，这话不是偶然 312-312, 标注, 2019 年 12 月 13 日星期五 下午 11:01:01 我们常说现在欧洲文明的核心——我自己就经常这样说——是科学和民主， 317-318, 标注, 2019 年 12 月 13 日星期五 下午 11:02:17 广泛阅读对于你们国际关系学科可能看起来比较遥远，但是在文化的修养和历史文化的积淀上会给你们很大的好处。 366-367, 标注, 2019 年 12 月 13 日星期五 下午 11:10:09 这个地方的文化，是挽救这个地方的一个决定性的因素。 272-272, 标注, 2019 年 12 月 14 日星期六 上午 8:17:37 两河流域——幼发拉底和底格里斯——这两条河是贯穿着伊拉克的，下面一直流到叙利亚。 458-459, 标注, 2019 年 12 月 14 日星期六 上午 8:17:55 地理和人文方面的希腊和古希腊文明还有一个来源，就是两河 458-459, 标注, 2019 年 12 月 14 日星期六 上午 8:18:00 地理和人文方面的希腊和古希腊文明还有一个来源，就是两河流域。 487-488, 标注, 2019 年 12 月 14 日星期六 上午 8:22:24 悼词里边还讲到了“雅典精神”——“冒险”，我体会这个“冒险”就是“进取”的意思，不达到目的决不罢休的精神，勇敢的精神、探险的精神、不怕牺牲的精神。 497-497, 标注, 2019 年 12 月 14 日星期六 上午 8:23:51 希腊人是爱美的，但是绝不娇柔；希腊人是勇敢的，但是绝不蛮干。 500-500, 标注, 2019 年 12 月 14 日星期六 上午 8:24:16 黑格尔一再强调希腊的精神是自由，是雄伟的、美丽的， 508-511, 标注, 2019 年 12 月 14 日星期六 上午 8:26:03 雅典的文明进一步的发展、繁荣。在思想界里出现了“诡辩派”，有些老先生不太同意这样的译法，因为诡辩这个词给人的印象就是没理搅三分，所以他们主张把它翻译成“智术之士”。后人为什么把它叫做诡辩派呢？我想这是后人总结的，后人觉得这帮人称不上是哲学家，他们只满足于口头上的舌辩之辞。 512-515, 标注, 2019 年 12 月 14 日星期六 上午 8:26:54 诡辩派也是从这里出发的，去研究自然，探讨自然界的问题。那个时候雅典确实已经到了非常自由的时期，思想是自由的，街谈巷议，组织各种讨论会，很随便。逐步地，这些辩者有的就变成了无理搅三分，把真理抛在了一边，专门为了辩论而辩论，所以后来人们就叫他们诡辩者。 521-522, 标注, 2019 年 12 月 14 日星期六 上午 8:31:49 这些先哲们在探讨一些问题时，是可能有通感的。什么叫正当的辩论，什么叫无理搅三分，是有一个共同的标准、共同的心理的。 517-519, 标注, 2019 年 12 月 14 日星期六 上午 8:32:00 在这种辩论过程当中产生了哲学。在古希腊，哲学和科学是不分的，哲学就是追求知识、寻求智慧的学问，和科学在当时是不可分的。古希腊出现了各种文学和艺术、诗歌、戏剧，戏剧也是在辩论过程中产生的。 528-529, 标注, 2019 年 12 月 14 日星期六 上午 8:33:31 苏格拉底的死是一个悲剧，死于雅典的民主，而民主制度是欧洲文明的源泉之一，这是矛盾的，也是辩证的。 530-531, 标注, 2019 年 12 月 14 日星期六 上午 8:34:07 柏拉图写了很多的“对话集”，就是以苏格拉底为主，和他周围的学生、朋友一起谈话，有的是学生提问，苏格拉底回答，有的是苏格拉底请一位学生开讲。 531-531, 笔记, 2019 年 12 月 14 日星期六 上午 8:34:27 子曰:。。。。 551-553, 标注, 2019 年 12 月 14 日星期六 上午 8:43:06 我们发现公元前 4 世纪的时候，希腊人已经知道中国人了，但是我们查不到很多的记载，最古老的记载是公元前 4 世纪，在古文献里提到了“seres”这个字，这个词的词根是“丝”的意思，蚕丝、丝 554-555, 标注, 2019 年 12 月 14 日星期六 上午 8:43:26 看到“丝之国”里面的羊毛是长在树上的！还有的说“丝之国”的人做买卖非常狡猾。 589-592, 标注, 2019 年 12 月 14 日星期六 上午 8:54:56 这次战争里边有很多故事，比如说马拉松（现在奥林匹克运动中的马拉松比赛），就是出在希波战争中。马拉松是一个海湾，距离雅典 40 多公里，在这个地方雅典人和波斯人会战，战争打得很惨。在胜负初决的时候，有一个雅典士兵从马拉松海滩跑回雅典去报告前方的军情。他跑得非常快，40 多公里一口气从马拉松海湾一直跑到雅典城下，大声喊：“胜利了！”这马拉松赛跑就从这儿来的，就是长跑。 610-610, 标注, 2019 年 12 月 14 日星期六 上午 9:00:35 这些改革的重点用两句话概括就是：一句叫主权在民；一句叫轮番为治。 661-663, 标注","date":"2024-10-09","objectID":"/%E7%AC%94%E8%AE%B0%E6%AC%A7%E6%B4%B2%E6%96%87%E6%98%8E%E5%8D%81%E4%BA%94%E8%AE%B2--%E9%99%88%E4%B9%90%E6%B0%91/:0:0","tags":["ouzhouwenmin","note","ireader"],"title":"[笔记]欧洲文明十五讲 -陈乐民","uri":"/%E7%AC%94%E8%AE%B0%E6%AC%A7%E6%B4%B2%E6%96%87%E6%98%8E%E5%8D%81%E4%BA%94%E8%AE%B2--%E9%99%88%E4%B9%90%E6%B0%91/"},{"categories":null,"content":" 97-97, 标注, 2019 年 12 月 12 日星期四 下午 9:53:39 自打贫穷一出现，我们就产生了某种以约定俗成的方式来贬低穷人的冲动。 117-119, 标注, 2019 年 12 月 12 日星期四 下午 10:08:18 我们所关注的焦点是世界上最贫穷的人，就全球穷人最多的 50 个国家来说，其平均贫穷线为每人每天 16 印度卢比。2各国政府将生活费低于这一水平的人定位为贫穷状态。根据当前的汇率标准，16 卢比相当于 36 美分， 127-129, 标注, 2019 年 12 月 12 日星期四 下午 10:10:00 每天 99 美分的生活意味着，你接收信息的渠道也会受限——报纸、电视和书籍都要花钱来买。因此，你常常会对世界上其他人得到的特定信息一无所知。 174-175, 标注, 2019 年 12 月 12 日星期四 下午 10:15:37 学生们愿意为了罗西娅而承担一点儿责任，但在面对广泛的全球性问题时，他们就不免有些 174-175, 标注, 2019 年 12 月 12 日星期四 下午 10:15:42 学生们愿意为了罗西娅而承担一点儿责任，但在面对广泛的全球性问题时，他们就不免有些泄气了。 232-233, 标注, 2019 年 12 月 12 日星期四 下午 10:23:18 贫穷并不仅仅意味着缺钱，它会使人丧失挖掘自身潜力的能力。 248-249, 标注, 2019 年 12 月 12 日星期四 下午 10:26:18 真正有用的方式是从实际问题的角度去思考，这样就可以有针对性地找出解决具体问题的方法， 271-274, 标注, 2019 年 12 月 12 日星期四 下午 10:28:46 那些自己花钱购买蚊帐的人可能都比较富有，受过良好的教育，而且知道自己为什么需要这种蚊帐；而那些免费得到蚊帐的人可能是因为贫穷，才会被某家非政府组织选中。不过，情况也可能恰恰相反：免费得到蚊帐的人社会关系优越，而穷人由于封闭只好以全价购买。无论是哪种情况，我们都无法从他们使用蚊帐的方式上得出任何结论。 319-321, 标注, 2019 年 12 月 13 日星期五 下午 12:44:37 对于几乎无钱可投的人来说，一旦收入或财富迅速增长的范围受限，那么他就会掉入“贫穷陷阱”；但对于有能力投入的人来说，这一范围就会极大地扩展。 190-191, 标注, 2019 年 12 月 13 日星期五 下午 12:46:24 如果没有大量的原始投资助其解决这些地方性问题，这些国家很难提高自己的生产力。然而，这些国家却因为贫穷，无法支付投资回报——这就是经济学家们所谓的“贫穷陷阱”。 330-330, 标注, 2019 年 12 月 13 日星期五 下午 12:49:06 这条S形曲线就是“贫穷陷阱”的来源。 ","date":"2024-10-09","objectID":"/%E7%AC%94%E8%AE%B0%E8%B4%AB%E7%A9%B7%E7%9A%84%E6%9C%AC%E8%B4%A8%E6%88%91%E4%BB%AC%E4%B8%BA%E4%BB%80%E4%B9%88%E6%91%86%E8%84%B1%E4%B8%8D%E4%BA%86%E8%B4%AB%E7%A9%B7--%E5%8D%B0%E5%BA%A6-%E7%8F%AD%E7%BA%B3%E5%90%89%E6%B3%95%E8%BF%AA%E5%BC%97%E6%B4%9B/:0:0","tags":null,"title":"[笔记]贫穷的本质：我们为什么摆脱不了贫穷-( 印度) 班纳吉;（法）迪弗洛","uri":"/%E7%AC%94%E8%AE%B0%E8%B4%AB%E7%A9%B7%E7%9A%84%E6%9C%AC%E8%B4%A8%E6%88%91%E4%BB%AC%E4%B8%BA%E4%BB%80%E4%B9%88%E6%91%86%E8%84%B1%E4%B8%8D%E4%BA%86%E8%B4%AB%E7%A9%B7--%E5%8D%B0%E5%BA%A6-%E7%8F%AD%E7%BA%B3%E5%90%89%E6%B3%95%E8%BF%AA%E5%BC%97%E6%B4%9B/"},{"categories":null,"content":" 380-381, 标注, 2019 年 10 月 11 日星期五 下午 10:05:18 现在他们虽然到了一个大学校，但这里的一切都常常出现在他们的睡梦中。 482-483, 标注, 2019 年 10 月 11 日星期五 下午 10:14:27 他们村叫个罐子村，他就是罐子村的破罐子！去他妈的，破罐子破摔，反正总是个破了！ 613-615, 标注, 2019 年 10 月 12 日星期六 上午 7:21:14 一次又一次，使他的心脏渐渐地强有力起来，并且在一次次的磨难中也尝到了生活的另一种滋味。他觉得自己正一步步迈向了成年人的行列。他慢慢懂得，人活着，就得随时准备经受磨难。 631-633, 标注, 2019 年 10 月 12 日星期六 上午 7:22:08 玉厚老汉在心里时常为自己的子女而骄傲。孩子们一个个都懂事明理，长得茁茁壮壮的。 这就是他生命的全部意义。这就是他活着的全部价值。 1094-1095, 标注, 2019 年 10 月 12 日星期六 下午 10:06:44 吉普赛人只爱飘泊，不爱劳动。但河南人除过个别不务正业者之外，不论走到哪里，都用自己的劳动技能来换取报酬。 1871-1873, 标注, 2019 年 10 月 13 日星期日 下午 12:27:12 在眼前这样的社会里，又是十七、八岁，他们谁有火眼金睛望穿未来的时代？别说他们了，就是一些饱经沧桑的老革命，这时候也未必具有清醒的认识，许多人不也是一天一天混日子吗？ 2035-2036, 标注, 2019 年 10 月 13 日星期日 下午 5:02:42 这是人生的一个火山活跃期，熔岩突奔，炽流横溢，在每一个感情的缝隙中，随时都可能咝咝地冒烟和喷火！ 2313-2316, 标注, 2019 年 10 月 13 日星期日 下午 7:19:44 这一点自留地，他宝贵得不知种什么好，从庄稼到蔬菜，互相套作，边边畔畔，见缝插针。种什么都是精心谋划的——有些要补充口粮，有些要换成零用钱……他一年不知要在这块土地上洒多少汗水。不管他怎样劳累，一旦进了这个小小的天地，浑身的劲就来了。有时简直不是在劳动，而是在倾注一腔热情。是的，这里的每一种收获，都将全部属于自己。只要能切实地收获，劳动者就会在土地上产生一种艺术创作般的激情…… 2308-2310, 标注, 2019 年 10 月 13 日星期日 下午 8:01:57 队里几乎所有的社员，都常抱怨他把他们扣得太紧，简直到了残酷的程度——山里休息往往连烟瘾都过不了就又被他赶起来干活。有人甚至背后叫他“孙阎王”。但他不管这些。他想，如果不这样下苦，秋后一分粮食，你们就要骂我是“龟孙子”了。 2650-2650, 标注, 2019 年 10 月 13 日星期日 下午 8:32:36 人啊！有时候都比不上飞禽走兽，自由自在地在天空飞，在地上走…… 2773-2774, 标注, 2019 年 10 月 13 日星期日 下午 8:46:23 虽然天旱得快把庄稼晒死了，但该做的活路一点也不能少；俗话说，锄头下面有雨，多锄一遍地就大不一样啊！ 2894-2897, 标注, 2019 年 10 月 13 日星期日 下午 8:54:44 太阳象火盆一样高悬在空中，山上的庄稼叶子都快晒干了，所有的绿颜色都开始变灰，阳坡上有的庄稼甚至已经枯黄了。庄稼人出于习惯和本能，依然在这些毫无收获指望的土地上辛勤地劳作着，抚哺这些快要死亡的、用他们的血汗浇灌起来的生命。整个村子已经失去了生气，任何人的脸上都再也看不出一丝的笑容来了。到处都 4087-4088, 标注, 2019 年 10 月 14 日星期一 下午 6:35:12 原西河对岸的山湾里，桃花又一次红艳艳地盛开了。河 4087-4089, 标注, 2019 年 10 月 14 日星期一 下午 6:35:19 原西河对岸的山湾里，桃花又一次红艳艳地盛开了。河两岸的缓坡上，刚出地皮的青草芽子和枯草夹杂在一起，黄黄绿绿，显出了一派盎然的生机。柳丝如同少女的秀发，在春风中摇曳。 4466-4469, 标注, 2019 年 10 月 14 日星期一 下午 10:46:48 人们现在还不能预料未来；但一个不能再让人忍受的年代已经结束，这就应该大声地欢呼！谁也不会天真地认为，积了十年的垃圾，就能在一夜之间清理干净。但是人们坚信：尽管在原轨道上刹住的车子还要在惯性中滑一段路程，但中国历史的大轮必将重新启动，进入到一个转折性的弯道上…… 4660-4661, 标注, 2019 年 10 月 14 日星期一 下午 11:08:18 她感到头晕目眩，甚至不知道自己身在何地。命运啊，多么无情！这不是婚礼，而是她青春的葬礼…… 6204-6206, 标注, 2019 年 10 月 16 日星期三 下午 10:55:07 在这些日子里，山乡圪崂有些不讲卫生的“懒大嫂”们，冷得不想出门，往往就让自己的娃娃把大便拉在炕席片上，然后把狗唤过来给他“打扫卫生”，因此就有了那句著名的乡谚“三九四九，隔门叫狗”……气候的确是寒冷啊！ 7061-7061, 标注, 2019 年 10 月 17 日星期四 下午 8:01:26 人们在土地上付出血汗和艰辛，那是应该收获欢乐和幸福，而不是收获忧虑和苦痛的…… 8454-8454, 标注, 2019 年 10 月 17 日星期四 下午 9:44:30 俗话说，人有三年旺，神鬼不敢挡。 11547-11548, 标注, 2019 年 10 月 19 日星期六 下午 7:59:14 没能耐的人还得用双手在土地上刨挖着吃。 14391-14391, 标注, 2019 年 10 月 20 日星期日 上午 10:02:00 现在这社会，即是办正事，也得走旁门拐道！ 14545-14546, 标注, 2019 年 10 月 20 日星期日 上午 10:11:41 应该提醒我们不能老是用一种眼光来看待人。不要以为一个人一时正确，就认为他永远正确。也不要因为一个人犯过错误，就断定他永远不可再加入优秀者的队伍。道理 14939-14942, 标注, 2019 年 10 月 20 日星期日 上午 10:33:59 我们承认伟人在历史过程中的贡献。可人类生活的大厦从本质上说，是由无数普通人的血汗乃至生命所建造的。伟人们常常企图用纪念碑或纪念堂来使自己永世流芳。真正万古长青的却是普通人的无人纪念碑——生生不息的人类生活自身。是的，生活之树常青。 14939-14942, 标注, 2019 年 10 月 20 日星期日 上午 10:34:14 我们承认伟人在历史过程中的贡献。可人类生活的大厦从本质上说，是由无数普通人的血汗乃至生命所建造的。伟人们常常企图用纪念碑或纪念堂来使自己永世流芳。真正万古长青的却是普通人的无人纪念碑——生生不息的人类生活自身。是的，生活之树常青。 这就是我们对一个平凡世界的死者所能做的祭文。 19429-19431, 标注, 2019 年 10 月 20 日星期日 下午 9:36:05 要旨仍然应该是首先战胜自己，并将精神提升到不断发展着的生活所要求的那种高度，才有可能使自己重新走出洼地，亦步亦趋跟着生活进入新的境界。 ","date":"2024-10-09","objectID":"/%E7%AC%94%E8%AE%B0%E5%B9%B3%E5%87%A1%E7%9A%84%E4%B8%96%E7%95%8C-%E8%B7%AF%E9%81%A5/:0:0","tags":["pingfandeshi","note","ireader"],"title":"[笔记]平凡的世界-路遥","uri":"/%E7%AC%94%E8%AE%B0%E5%B9%B3%E5%87%A1%E7%9A%84%E4%B8%96%E7%95%8C-%E8%B7%AF%E9%81%A5/"},{"categories":null,"content":" 41-41, 标注, 2018 年 2 月 24 日星期六 上午 3:59:43 一个没有“浪费”过时间的人终将一事无成。 55-56, 标注, 2018 年 2 月 24 日星期六 上午 4:01:36 广义相对论”，这是他的杰作。伟大的苏联物理学家列夫·朗道（Lev Landau）称之为“最美的理论”。 81-82, 标注, 2018 年 2 月 24 日星期六 上午 4:05:39 引力场不“弥漫”于空间，因为它本身就是空间。这就是广义相对论的思想。 83-84, 标注, 2018 年 2 月 24 日星期六 上午 4:07:56 空间不再是一种有别于物质的东西，而是构成世界的“物质”成分之一，一种可以波动、弯曲、变形的实体。 85-87, 标注, 2018 年 2 月 24 日星期六 上午 4:09:30 太阳会使其周围的空间发生弯曲，所以地球并不是在某种神秘力量的牵引下绕着太阳旋转，而是在一个倾斜的空间中行进，就好像弹珠在漏斗中滚动一样：漏斗中心并不会产生什么神秘的“力量”，是弯曲的漏斗壁使弹珠滚动的。所以无论是行星绕着太阳转，还是物体下落，都是因为空间发生了弯曲。 91-92, 标注, 2018 年 2 月 24 日星期六 上午 4:12:19 任何一个弯曲空间的特征都可以用一个数学量来描述，如今我们称之为“黎曼曲率”，用大写的“R”来表示。 93-93, 标注, 2018 年 2 月 24 日星期六 上午 4:12:39 空间在有物质的地方会发生弯曲。 105-105, 标注, 2018 年 2 月 24 日星期六 上午 4:18:13 空间不可能一直保持静止，它一定是在不断膨胀的。 105-105, 笔记, 2018 年 2 月 24 日星期六 上午 4:20:17 恒星会因能量耗尽,无法支撑其自身 105-105, 笔记, 2018 年 2 月 24 日星期六 上午 4:20:57 恒星会因能量耗尽,无法支撑其自身重量而坍塌, 105-105, 笔记, 2018 年 2 月 24 日星期六 上午 4:25:40 恒星会因能量耗尽,无法支撑其自身重量而坍塌,使空间扭曲,那是什么在支撑宇宙空间的膨胀? 什么时候宇宙会开始收缩?宇宙收缩时,人类会变成什么样?会受到哪些影响? 557-563, 标注, 2018 年 2 月 24 日星期六 下午 1:22:43 我认为，我们这个物种不会延续很久。我们似乎没有乌龟的那种本事，能够几亿年来一直保持着原来的样子，那可是人类存在时间的好几百倍。我们属于一个短命的物种，所有的表亲都已经全部灭绝。而且我们一直在破坏。我们已经造成气候和环境的恶化，恐怕自己也难逃恶果。对地球来说，这只是一个无关紧要的小挫折，但我认为，人类将很难安然无恙地渡过这个难关。更糟的是，公众舆论和政治观点倾向于把头深埋在沙子里，无视我们正在面临的危险。在地球上，我们也许是唯一知道我们的个体必将死亡的物种，我害怕在不久的将来我们也会成为唯一一个眼睁睁看着自己末日到来的物种，或至少是见证自己文明灭亡的物种。 ","date":"2024-10-09","objectID":"/%E7%AC%94%E8%AE%B0%E4%B8%83%E5%A0%82%E6%9E%81%E7%AE%80%E7%89%A9%E7%90%86%E8%AF%BE-%E6%84%8F%E7%BD%97%E9%9F%A6%E5%88%A9/:0:0","tags":["﻿qitangjijia","note","ireader"],"title":"[笔记]﻿七堂极简物理课 【意】罗韦利","uri":"/%E7%AC%94%E8%AE%B0%E4%B8%83%E5%A0%82%E6%9E%81%E7%AE%80%E7%89%A9%E7%90%86%E8%AF%BE-%E6%84%8F%E7%BD%97%E9%9F%A6%E5%88%A9/"},{"categories":null,"content":" 24-25, 标注, 2019 年 12 月 25 日星期三 上午 9:49:35 因为故事发生在庆国，而那位病人很奢侈地拥有了多出来的一截生命，所以取名为：庆余年——很有乡土气息的名字， 1382-1383, 标注, 2019 年 12 月 25 日星期三 下午 10:04:14 人的生命如果只有一次的话，那总是需要去看些不同的风景，遇到不同的人，这样才能让不能重来的游戏玩的尽兴 3631-3633, 标注, 2019 年 12 月 26 日星期四 下午 9:23:04 生命对于每个人只有一次，这仅有的一次生命应当怎样度过呢？当我们回首往事的时候，不因虚度年华而悔恨，也不因碌碌无为而羞耻。在我临死的时候我可以骄傲的说：我已经做了所有自己想做的事情，就算没有成功，但我毕竟努力过。” 7621-7622, 标注, 2019 年 12 月 29 日星期日 上午 6:52:39 范闲的性情温柔之中带着几丝厉杀，但更多的却是蔫儿坏，知道自己不生气，对方才会更生气，所以更加温柔说道：“我来探望自己的未婚妻，于 7621-7622, 标注, 2019 年 12 月 29 日星期日 上午 6:52:47 范闲的性情温柔之中带着几丝厉杀，但更多的却是蔫儿坏，知道自己不生气，对方才会更生气， 8907-8909, 标注, 2019 年 12 月 29 日星期日 下午 8:10:27 能保护我们每一个人的，只有自己的力量。没妈的孩子像根草，小草也得往石头缝外面跑，别理会什么阳光雨露，自己把根扎得深些，把茎整得结实些，这才是正道。 27535-27536, 标注, 2020 年 1 月 12 日星期日 下午 5:19:00 铅笔在雪白的纸面上滑行着，就像是美人的脚尖在平滑的冰面上起舞，偶尔刮起几丝冰屑雪痕。 34078-34079, 标注, 2020 年 1 月 18 日星期六 下午 10:24:27 明家看似风光，其实还不是他们眼中一只会下蛋的老母鸡，如果老母鸡不下蛋了，那些本来支持咱们的人物，只怕会比钦差大人更想宰了咱们，最后吃一顿香喷喷的鸡肉。” ","date":"2024-10-09","objectID":"/%E7%AC%94%E8%AE%B0%E5%BA%86%E4%BD%99%E5%B9%B4-sobooks/:0:0","tags":["qingyunian","note","ireader"],"title":"[笔记]庆余年-SoBooKs.cc 猫腻","uri":"/%E7%AC%94%E8%AE%B0%E5%BA%86%E4%BD%99%E5%B9%B4-sobooks/"},{"categories":null,"content":" 618-620, 标注, 2019 年 3 月 1 日星期五 下午 11:06:38 我像一个没经验的登山者，筋疲力尽地攀上了一个自以为无人到过的高度，但环顾四周时却看到了前人留下来的帐篷和他们继续向上延伸的脚印。 ","date":"2024-10-09","objectID":"/%E7%AC%94%E8%AE%B0%E7%90%83%E7%8A%B6%E9%97%AA%E7%94%B5-%E5%88%98%E6%85%88%E6%AC%A3/:0:0","tags":["qiuzhuangsha","note","ireader"],"title":"[笔记]球状闪电-刘慈欣","uri":"/%E7%AC%94%E8%AE%B0%E7%90%83%E7%8A%B6%E9%97%AA%E7%94%B5-%E5%88%98%E6%85%88%E6%AC%A3/"},{"categories":null,"content":" 142-145, 标注, 2022 年 3 月 27 日星期日 下午 6:05:30 被他人责难、怒斥时，或许不会有人还抱着好心情。但我却在他人怒不可遏的脸上，看到了比狮子、鳄鱼、蛟龙还可怕的动物性。平时，都是隐藏着本性，但就像牛儿沉静地睡卧在草原上，尾巴却会在突然间“啪啪”地甩动，打死停在肚子上的牛蝇一样，一有机会，人们可怕的本体便会在不经意间透过暴怒而显露出来， 255-257, 标注, 2022 年 3 月 27 日星期日 下午 9:03:05 对戏子而言，最难演的场所应该是故乡的剧场吧，而且当所有的远亲近邻通通聚在一起坐在房间里，就算再怎么有名的演员，其演技也无法发挥得淋漓尽致 499-502, 标注, 2022 年 3 月 27 日星期日 下午 9:52:28 俗话说“小腿带伤、心里有鬼”，但这伤口却是我襁褓时便自然出现在一边小腿上的，不但未随时间增长而痊愈，反而越来越深，痛入骨髓，夜夜痛楚可比喻成千变万化的地狱。然而（这么说或许很奇怪）这个伤却逐渐变得比自己的血肉还要亲切，会觉得那伤口的痛楚，是表露着伤口滋长的情绪，甚至是热情地低语。 619-621, 标注, 2022 年 3 月 28 日星期一 下午 7:47:53 而有种无言的强烈孤寂感，如气流般流窜在身体外围，只要一靠近她，自己的身体也会被那股气流所包围，与自己原本那带刺的阴郁气流交会融合，如同“静静地躺在水底石头下的枯叶”一般，我可以从恐惧与不安中脱离出来。 ","date":"2024-10-09","objectID":"/%E7%AC%94%E8%AE%B0%E4%BA%BA%E9%97%B4%E5%A4%B1%E6%A0%BC-%E5%A4%AA%E5%AE%B0%E6%B2%BB-%E8%AE%B8%E6%97%B6%E5%98%89/:0:0","tags":["renjianshige","note","ireader"],"title":"[笔记]人间失格-太宰治 许时嘉","uri":"/%E7%AC%94%E8%AE%B0%E4%BA%BA%E9%97%B4%E5%A4%B1%E6%A0%BC-%E5%A4%AA%E5%AE%B0%E6%B2%BB-%E8%AE%B8%E6%97%B6%E5%98%89/"},{"categories":null,"content":" 130-131, 标注, 2018 年 7 月 14 日星期六 下午 10:19:10 讲述的就是这三大革命如何改变了人类和其他生物。 141-141, 标注, 2018 年 7 月 14 日星期六 下午 10:21:08 所谓属于同一物种，就是它们会彼此交配，能够产出下一代。 145-146, 标注, 2018 年 7 月 14 日星期六 下午 10:21:26 从同一个祖先演化而来的不同物种，会属于同一个“属”（genus） 150-151, 标注, 2018 年 7 月 14 日星期六 下午 10:22:30 许多属还能再归类为同一科（family），例如猫科（狮子、猎豹、家猫）、犬科（狼、狐狸、豺）、象科（大象、长毛象、乳齿象）。同一科的所有成员，都能追溯到某个最早的雄性或雌性祖先。 235-236, 标注, 2018 年 7 月 15 日星期日 上午 6:49:49 有比较大的大脑、会使用工具、有超凡的学习能力还有复杂的社会结构，都可说是人类巨大的优势 254-255, 标注, 2018 年 7 月 15 日星期日 上午 6:51:05 人类历史上众多的灾难，不论是生灵涂炭的战乱还是生态遭逢的浩劫，其实都是源自这场过于仓促的地位跳 254-255, 标注, 2018 年 7 月 15 日星期日 上午 6:51:09 人类历史上众多的灾难，不论是生灵涂炭的战乱还是生态遭逢的浩劫，其实都是源自这场过于仓促的地位跳跃。 269-269, 标注, 2018 年 7 月 15 日星期日 上午 6:52:42 不经意之间，烹调让尼安德特人与智人走上了让大脑更大的道路。 387-388, 标注, 2018 年 7 月 15 日星期日 上午 7:15:53 大约就是在距今 7 万到 3 万年前，出现了新的思维和沟通方式，这也正是所谓的认知革命 474-475, 标注, 2018 年 7 月 15 日星期日 下午 2:32:45 任何大规模人类合作的根基，都在于某种只存在于集体想象中的虚构故事 477-477, 标注, 2018 年 7 月 15 日星期日 下午 2:34:15 所谓的国家，也是立基于国家故事。 478-478, 标注, 2018 年 7 月 15 日星期日 下午 2:34:25 至于司法制度，也是立基于法律故事 534-535, 标注, 2018 年 7 月 15 日星期日 下午 2:40:17 历史上也就不断围绕着这个问题打转：究竟某个人是如何说服数百万人去相信神、民族或是有限公司这些故事 589-591, 标注, 2018 年 7 月 15 日星期日 下午 2:56:49 爱尔兰岛曾经住着一些智人，他们会使用一种叫作黑曜石的火山晶体，制造出特别坚硬且尖锐的工具。然而，新爱尔兰岛其实并不产黑曜石。化验结果显示，他们用的黑曜石来自超过 400 公里远的新不列颠岛。 591-591, 笔记, 2018 年 7 月 15 日星期日 下午 2:57:28 冰与火之歌的原型吗？ 1335-1338, 标注, 2018 年 7 月 22 日星期日 上午 11:17:45 人类一心追求更轻松的生活，于是释放出一股巨大的力量，改变了世界的面貌，但结果并没有任何人料想得到，甚至也不是任何人所乐见的。并没有人在背后操纵农业革命发生，或是意图让人依赖谷类维生。一开始只是各种小事，主要就是希望吃饱一点、生活安全一点，但最后累积引起的效应，就是让远古的采集者开始 1335-1338, 标注, 2018 年 7 月 22 日星期日 上午 11:17:58 人类一心追求更轻松的生活，于是释放出一股巨大的力量，改变了世界的面貌，但结果并没有任何人料想得到，甚至也不是任何人所乐见的。并没有人在背后操纵农业革命发生，或是意图让人依赖谷类维生。一开始只是各种小事，主要就是希望吃饱一点、生活安全一点，但最后累积引起的效应，就是让远古的采集者开始花上整天的时间，在烈日之下挑水务农。 1261-1264, 标注, 2018 年 7 月 22 日星期日 上午 11:18:43 人类就像许多哺乳动物一样，自然有荷尔蒙和遗传机制来控制生育数。营养充足的时候，女性比较早进入青春期，成功怀孕的概率也比较高。而在土地贫瘠、营养不足的时候，女性进入青春期要来得晚，生育能力也下降。 人口管制除 1261-1263, 标注, 2018 年 7 月 22 日星期日 上午 11:18:51 人类就像许多哺乳动物一样，自然有荷尔蒙和遗传机制来控制生育数。营养充足的时候，女性比较早进入青春期，成功怀孕的概率也比较高。而在土地贫瘠、营养不足的 1261-1263, 标注, 2018 年 7 月 22 日星期日 上午 11:19:07 人类就像许多哺乳动物一样，自然有荷尔蒙和遗传机制来控制生育数。营养充足的时候，女性比较早进入青春期，成功怀孕的概率也比较高。而在土地贫瘠、营养不足的时候，女性进入青春期要来得晚，生育能力也下降。 1499-1499, 标注, 2019 年 2 月 22 日星期五 下午 10:49:34 正是这些征收来的多余食粮，养活了政治、战争、艺 1499-1502, 标注, 2019 年 2 月 22 日星期五 下午 10:49:44 正是这些征收来的多余食粮，养活了政治、战争、艺术和哲学，建起了宫殿、堡垒、纪念碑和庙宇。在现代晚期之前，总人口有九成以上都是农民，日出而作、胼手胝足。他们生产出来的多余食粮养活了一小撮的精英分子：国王、官员、战士、牧师、艺术家和思想家，但历史写的几乎全是这些人的故事。于是，历史只告诉了我们极少数的人在做些什么，而其他绝大多数人的生活就是不停挑水耕田。 1554-1554, 笔记, 2019 年 2 月 23 日星期六 上午 8:10:18 就是真命天子的意思呗 1553-1554, 标注, 2019 年 2 月 23 日星期六 上午 8:10:18 法典开头指出，美索不达米亚的几位大神安努（Anu）、恩利尔（Enlil）和马杜克（Marduk）任命汉谟拉比“在这片土地伸张正义，驱除不义罪恶，阻绝恃强凌弱”36 1574-1576, 标注, 2019 年 2 月 23 日星期六 上午 8:12:03 小孩并不是独立的人，而是父母的财产。因此，如果一个上等人杀了另一个上等人的女儿，惩罚就是把凶手的女儿给杀了。这对我们看来可能荒谬至极，凶手本人逍遥自在，但他无辜的女儿却得赔上一命。 1580-1581, 标注, 2019 年 2 月 23 日星期六 上午 8:12:26 美国的《独立宣言》宣告自己是普遍和永恒的正 1580-1584, 标注, 2019 年 2 月 23 日星期六 上午 8:12:38 美国的《独立宣言》宣告自己是普遍和永恒的正义原则，而这则宣言也像《汉谟拉比法典》一样找了神祇来背书。然而，美国神指示的至高原则，却似乎和巴比伦神指示的有所出入？美国《独立宣言》主张： 我们认为下面这些真理是不言而喻的：人人生而平等，造物者赋予他们若干不可剥夺的权利，其中包括生命权、自由权和追求幸福的权利。 1598-1602, 标注, 2019 年 2 月 23 日星期六 上午 8:15:25 演化铁定没有“平等”这回事，所谓平等的概念，是与“创造”的概念紧密相关。美国人的“平等”观念来自基督教，基督教认为每个人的灵魂都是由上帝创造，而所有灵魂在上帝面前一律平等。但是，如果我们不相信基督教那一套关于上帝、创造和灵魂的神话故事，那所谓人人“平等”究竟是什么意思？演化的基础是差异，而不是平等。每个人身上带的基因码都有些许不同，而且从出生以后就接受着不同的环境影响，发展出不同的特质，导致不同的生存概率。“生而平等”其实该是“演化各有不同”。 1614-1616, 标注, 2019 年 2 月 23 日星期六 上午 8:41:25 学、科学的角度来写该是如何： 我们认为下面这些真理是不言而喻的：人人演化各有不同，出生就有某些可变的特性，其中包括生命和追求快感。 上面这段推 1615-1616, 标注, 2019 年 2 月 23 日星期六 上午 8:41:33 我们认为下面这些真理是不言而喻的：人人演化各有不同，出生就有某些可变的特性，其中包括生命和追求快感。 上面这段推 1615-1616, 标注, 2019 年 2 月 23 日星期六 上午 8:41:38 我们认为下面这些真理是不言而喻的：人人演化各有不同，出生就有某些可变的特性，其中包括生命和追求快感。 1614-1616, 标注, 2019 年 2 月 23 日星期六 上午 8:41:52 因此，我们来看看美国《独立宣言》改用生物学、科学的角度来写该是如何： 我们认为下面这些真理是不言而喻的：人人演化各有不同，出生就有某些可变的特性，其中包括生命和追求快感。 1618-1620, 标注, 2019 年 2 月 23 日星期六 上午 8:42:46 我们相信某种秩序，并非因为它是客观的现实，而是因为相信它可以让人提升合作效率、打造更美好的社会。这种由想象所建构的秩序绝非邪恶的阴谋或是无用的空谈，而是唯一能让大群人类合作的救命仙丹。 1643-1646, 标注, 2019 年 2 月 23 日星期六 上午 8:46:44 关于那些站在社会金字塔顶端的人。如果他们并不相信这些想象的秩序，他们又为什么要推动这种秩序呢？常有人说这些人其实什么都不信，只是贪婪而已。但这种说法有问题。如果真的是什么都不信（像是犬儒学派），就很难是个贪婪的人，毕竟客观来说，只是单纯要满足智人的基本生理需求并不难。 1647-1650, 标注, ","date":"2024-10-09","objectID":"/%E7%AC%94%E8%AE%B0%E4%BA%BA%E7%B1%BB%E7%AE%80%E5%8F%B2%E4%BB%8E%E5%8A%A8%E7%89%A9%E5%88%B0%E4%B8%8A%E5%B8%9D-yuval-noah-harari/:0:0","tags":null,"title":"[笔记]人类简史：从动物到上帝 yuval noah harari","uri":"/%E7%AC%94%E8%AE%B0%E4%BA%BA%E7%B1%BB%E7%AE%80%E5%8F%B2%E4%BB%8E%E5%8A%A8%E7%89%A9%E5%88%B0%E4%B8%8A%E5%B8%9D-yuval-noah-harari/"},{"categories":null,"content":" 382-455, 标注, unknown 小人哪儿没有啊？哪儿都有，街道也不例外。寻常看不见，偶尔露峥嵘。一露峥嵘，好人就不得太平了。 457-670, 标注, unknown 估计是鸟儿将几粒喇叭花的种子带到那儿的，它的花开得挺别致，下边的花尽是白色，中间部分的花是蓝色。秉义更想要紫色的花，偏偏那 紫色的花开在最高处，高到了秉义伸手够不到的地方。这让它缠绕的那棵白桦树如同穿上了一件旗袍，一件绣满了白、蓝、紫三色花朵的绿 绸布做成的旗袍，使人联想到穿旗袍的高挑美人儿。白桦树的树干，似裸露着的白皙修长的腿，最上边的紫色的喇叭花形成了华丽旗袍的高领 672-831, 标注, unknown 他挑开炉盖，凝视着信纸化成的灰烬。它们如同黑色蝴蝶，有的边缘向上翻卷，似要飞将起来；有的边缘朝下拥抱炭火，如同在用黑的翼为 红的花遮风挡雨。又仿佛看上去像一个人，像一个披着黑斗篷叫吕川的人，蹲在炉膛里经受着火烧的痛苦，然而心甘情愿，尝试裹紧斗篷护 住身体却不能够。 833-899, 标注, unknown 一晃多少年的“晃”字虽属民间口头语，但把那种如变脸般快的无奈感传达得淋漓尽致。 901-1013, 标注, unknown 性格怎样和人心怎样往往是两回事。性格像皮肤，大太阳下晒久了谁都黑了，关在屋里一年半载的谁都会变得白了点儿。皮肤黑了白了，只 要心没变，还是一颗好人心，那就还是先前那个好人 1015-1151, 标注, unknown 啥叫出息？啥叫没出息？咱们老百姓人家的女儿，将来是好人，走正道，我认为就是出息了。咱们女儿善良，知仁义，对人对事有正义感， 只要这三点在她身上不变，其他方面任性一点儿就随她吧。别管教太严，把个原本挺好的孩子管出问题来。 1153-1321, 标注, unknown 有人说往前看总比连说这种话的人都没有强吧？” “你信那种话吗？” “干吗不信呢？不信又能怎么样呢？如果不信不是就根本没希望了？所以信比不信好！信就是像我这样，该快活就快活。不信就会像你这 样，明明并没走到绝路上，却老是想明天眼前必是绝路了，结果该快活的时候也不肯快活了。 1323-1397, 标注, unknown 我父亲总是这么教我急事当前，人心纷乱，要留心见人所未见，留心听人所未听，才能先于别人发现真相。 ","date":"2024-10-09","objectID":"/%E7%AC%94%E8%AE%B0%E4%BA%BA%E4%B8%96%E9%97%B4-n-a/:0:0","tags":["renshijian","note","ireader"],"title":"[笔记]人世间-N/A","uri":"/%E7%AC%94%E8%AE%B0%E4%BA%BA%E4%B8%96%E9%97%B4-n-a/"},{"categories":null,"content":" 501-635, 标注, unknown 虽然在战败后失去了一切，却从焦土上顽强复苏，其傲人的经济增速和发展势头就如同现在的中国一样，成为世界瞩目的对象。“日本制 造”给人的印象也曾是价格低廉、容易发生故障，可当时却已蜕变为“质量优于美国货的可信赖商品”。 692-899, 标注, unknown 父亲同时也如此告诫我：“不要以为自己高高在上就可以盛气凌人，你既要明确自己的决定，也要明确分配给下属的任务，并必须对此负 全责。”父亲这样的苦口婆心，是对我大有裨益的启蒙教育，使我不会在出现问题时一味地责骂部下或推卸责任。通过这种家庭教育的熏 陶，我学会了日本式的思维方式-–—只有找出能够实现双赢的利益共通点，才能达成自己的目的。因为人人都渴望获得成功 958-1014, 标注, unknown “只要决心坚定，一切皆有可能”，这是我至今不变的哲学信念。 1071-1274, 标注, unknown 当时她与父亲和一个姐姐留在了东京，其他家人则在乡下的亲戚那里避难。每当空袭开始，父女三人只能逃到院子里的防空壕中，他们挤 在狭小的防空壕里，总算是熬过了一次次的轰炸。然而，一天夜里，他们那历史悠久的大房子不幸被燃烧弹击中，化为一堆瓦砾。于是他 们只得在防空壕中度过了数周时间。由于家中有大量藏书，因此燃烧了数日，而良子就在余烬上做饭，就这样生存了下来。 1335-1504, 标注, unknown 由于军方的洗脑教育，战时有不少日本青年盲目崇拜天皇、鼓吹“光荣战死”，最终失去理智、酿成大错。日本人有一种“羊群”般的从众心 理，在一种特殊的集团心理状态下，人们就像共同吸入了一种特殊空气，采取一致的行动，类似“集体催眠”。战争期间，军方在招募志愿 兵时，日本人的这种特性便体现了出来 1551-1688, 标注, unknown 白木屋百货公司里残破不堪，到处是火灾后的疮痍，他的新公司就在其中的一间房里，令人感到凄凉唏嘘，但井深先生的脸上却热情洋溢。 在那个前途渺茫的时代，许多人不安彷徨，而他和员工们至少还有工作、有奔头，因此大家看起来都很愉快。 1750-1852, 标注, unknown 要想把录音机卖出去，就必须找到懂得其价值所在的个人和机构。机缘使然，在那家古董店的经历，让我茅塞顿开-–—推销的关键在于 让买家明白商品的价值。 1920-2004, 标注, unknown 我希望新的公司名能够与众不同、引人注目，还要简短，并且是英文字母。最后一点，不管用什么语言念出来，发音都必须一样。 2067-2192, 标注, unknown 为了不被外国人误认为是粗劣产品，我们确实也不想刻意强调“日货”的身份。不得不承认，我们起初故意把出口产品上的“Made in Japan”字样印得很小，由于字体实在太小，有时美国海关会命令我们重印 2239-2414, 标注, unknown 我们不会调查消费者的需求，也不会制造迎合消费者需求的产品，而是通过制造新产品来引导他们消费，这便是我们公司的方针。因为消 费者不懂技术，他们不知道哪些产品能够实现，而我们知道。所以我们并不热衷于市场调研，而是专注于研究新产品及其各种用途，然后 与消费者直接交流，传达我们的意图，从而不断开拓市场。 2461-2545, 标注, unknown 《公司宗旨》里有这样一段话-–—“最大限度地发挥员工努力认真的技术实力，建设自由宽容且氛围愉快的理想工厂”。 2606-2797, 标注, unknown 香川博士和我第一次同行时，我和先前一样，订廉价酒店，带他去 Automat 吃饭。结果他说，这么做欠妥，生意人应该维护自己的尊严和 公司的颜面，出门在外，衣食住行都应该讲究一点。他还给我一系列忠告。比如，住廉价酒店的高等房，不如住高级酒店的低等房；在高 档餐厅吃饭，就能渐渐辨别出菜肴和服务的优劣，这是生意人必须具备的素养… 2858-2951, 标注, unknown ，我问起她对夏令营生活的感想时，她坦言，每晚一熄灯，她就会忍不住孤单而哭泣。为了减轻自己的恐惧，她会怀抱手电筒，让手电筒 一直开着。 3012-3124, 标注, unknown 首先必须确立销售网络、充分常握市场情况，然后才能在海外建厂。换言之，在了解市场、学会如何生存、建立企业信誉之前，不应该贸 然行动，而一旦准备充分，就要全力以赴、放手一搏。 3171-3285, 标注, unknown 我虽然从很早以前就考虑在美国开厂生产，但一直在等待时机完全成熟-–—稳固市场份额、确定销售方式、保障售后服务。如果这些条 件完备，产品供给地离目标市场自然是越近越有利。 3352-3477, 标注, unknown 无论是日本还是美国，都不存在能让企业走向成功的“速成秘诀宝典”。要想做成生意，不能靠理论，不能靠计划，更不能靠政府的政策扶 持，而应该靠人。如果硬要说日企经营有什么秘诀，我觉得只能是“以人为本”。 3524-3625, 标注, unknown 在日本，人们常说企业家的重要职责是“与员工建立良好的关系”，即在企业中营造一种“亲如一家”的团结氛围。换言之，要让员工与企业 家“同呼吸、共命运”。 3672-3763, 标注, unknown 若从长远来看，无论高层经营者如何优秀、不管业绩多么辉煌，企业的未来最后还是取决于员工。说得夸张一点，真正掌握企业命运的是 员工。 3810-3976, 标注, unknown 新劳动法使企业难以解雇员工，一旦解雇员工，就必须支付一笔高额赔偿费，但这并不一定是坏事。日本的企业家和雇员双方开始明白， 只有本着共同利益、制订长期发展计划，才能实现共赢。由此催生出了终生雇用制度。它不但使日本人摆脱了阶级斗争的旋涡，还使劳资 双方“齐心协力、共获福利”成为可能 4023-4152, 标注, unknown 企业家应该铭记一个道理，人们之所以工作，并非只为了金钱。换言之，要想激发员工的工作积极性，金钱绝非效果最好的工具。要想让 员工发挥主观能动性，必须使其“爱厂如家”，在企业这个“大家庭”中成为受人尊重的一员 4199-4465, 标注, unknown 日本的企业家不会把工人视为劳动工具，企业家创立企业，是为了实现自己的创意，要想实现自己的创意，就少不了员工的力量，因此雇 员是事业上的伙伴和助手。身为企业家，自然应该保障股东的利益，让投资者有所回报，但与此同时，也必须重视自己的伙伴-–—雇员。 他们是公司发展的原动力，企业家应该对他们的付出给予充分的回报。换言之，企业家应该对股东和员工一视同仁。甚至可以说，员工更 为重要。股东以利益为目的，既可以入股，也可以撤资，但员工与公司的关系却是长期的。正所谓“员工成就企业”。 4512-4654, 标注, unknown 不少日企文化排斥个性鲜明的员工，因此经常用“协调性”和“一致性”之类的字眼来抹杀异见。我这人直来直去，针对这种情况，我经常毫 不客气地指出：“如果一名董事或高管只知道强调一致性，只能说明他不具备发掘员工才能、整合不同意见的能力。” 4701-4819, 标注, unknown 每位‘SONY 人’皆应最大限度地发掘、锻炼和提升自我。同时，个人能力通过巧妙整合，能发挥出巨大合力。SONY 乃开拓者，旨在不断成就 员工、信任员工、激发员工，并视进步发展为生命。 4883-5110, 标注, unknown 如果一个人由于犯错便被打上“失败者”的烙印，从而丧失了未来的新机会，那么不管在生活中还是工作中，都会挫伤其志气，这种影响会 伴随其一生。对公司而言，便失去了此人原本在未来能够创造的业绩。反之，如果采取对事不对人的方针，找出失败的原因，犯错者便会 铭记在心，周围的人也会吸取教训。因此，我经常鼓励员工：“只要是自己认为正确的事，就尽管放手去做。即便失败，也能从中学到东 西。但下次切勿再犯同样的错误。” 5157-5255, 标注, unknown 我对公司的干部说：“我希望各位不要成为孤独的‘杂技演员’，让员工看着你们独自在高处走钢丝。而应该让员工都乐于追随你们，大家 一起为公司打拼。” 5302-5479, 标注, unknown 一味追求利益回报的美国企业管理者有句“名言”-–—“我干吗非得考虑企业多年后的事情？干吗非得牺牲当下与我相关的利益？难道是 为将来接替我的人做贡献？”正因为这种思想作怪，许多欧美企业会以“研发费用过高”为由，暂时搁置原本市场前景广阔的产品项目。这 实在是目光短浅之举，最终会导致企业丧失竞争力。 5555-5665, 标注, unknown 。模仿是人类的天性，是一种初级的学习手段。随着不断学习，自身获得成长，然后便会将自身的天赋与习得的知识有机结合，从而创造 出全新的成果。人是这样，企业和产业亦是如此。 5712-5835, 标注, unknown 只有在技术开发、产品企划和市场营销三个环节都发挥出创造力，消费者才能真正获得新科技所带来的幸福感。不仅如此，企业必须建立 能够让这三方面协同作业的组织结构，才能做到行之有效，从而获得商业利益。 5907-6102, 标注, unknown 美企和日企之间的差异不仅是文化上的，还包括经营理念。如果问日本的企业高管“何为企业的社会责任”，得到的回答往往是“使企业获 得可持续发展，确保提供就业岗位，改善员工生活”。企业创造和提高利润的目的就在于此，而并非单纯的“一切向利润看齐”。反之，美 国的企业高管在面对上述提问时，几乎都会回答“首要责任是尽量赚取高利润，从而给股东分红”。 6162-6328, 标注, unknown 如果说日企的经营理念比美企有先进之处，我认为其核心便是日企拥有的企业","date":"2024-10-09","objectID":"/%E7%AC%94%E8%AE%B0%E6%97%A5%E6%9C%AC%E5%88%B6%E9%80%A0-n-a/:0:0","tags":["ribenzhizao","note","ireader"],"title":"[笔记]日本制造-N/A","uri":"/%E7%AC%94%E8%AE%B0%E6%97%A5%E6%9C%AC%E5%88%B6%E9%80%A0-n-a/"},{"categories":null,"content":" 1337-1338, 标注, 2024 年 9 月 29 日星期日 下午 9:11:22 关于这件事儿，你在学校里可能会听到有些人出言不逊，但是请你为我做一件事，如果你愿意的话——那就是高昂起头，放下拳头。不管别人对你说什么，都不要恼怒。试着用你的头脑去抗争…… 1543-1544, 标注, 2024 年 9 月 30 日星期一 下午 10:20:42 说脏话是所有孩子都会经历的一个阶段，随着他们一天天长大，他们会发现满口脏话并不能让他们成为众人瞩目的明星，他们就会改掉这个毛病。 1839-1840, 标注, 2024 年 10 月 1 日星期二 下午 8:22:57 我在接受他人之前，首先要接受自己。有一种东西不能遵循从众原则，那就是人的良心。 1961-1963, 标注, 2024 年 10 月 1 日星期二 下午 9:29:11 我想让你见识一下什么是真正的勇敢，而不是错误地认为一个人手里拿把枪就是勇敢。勇敢就是，在你还没开始的时候就知道自己注定会输，但依然义无反顾地去做，并且不管发生什么都坚持到底。一个人很少能赢，但也总会有赢的时候。 2164-2164, 标注, 2024 年 10 月 2 日星期三 上午 6:48:27 一个人没必要把自己懂的东西都展现出来。 4208-4209, 标注, 2024 年 10 月 3 日星期四 下午 8:48:49 那年夏天发生的大大小小的事情始终缠绕在我们心头，挥之不去，就像是在一个封闭房间里萦绕不绝的烟雾。 4856-4857, 标注, 2024 年 10 月 3 日星期四 下午 10:12:32 你永远也不可能真正了解一个人，除非你穿上他的鞋子走来走去，站在他的角度考虑问题。 ","date":"2024-10-09","objectID":"/%E7%AC%94%E8%AE%B0%E6%9D%80%E6%AD%BB%E4%B8%80%E5%8F%AA%E7%9F%A5%E6%9B%B4%E9%B8%9F-%E7%BE%8E%E5%9B%BD-%E5%93%88%E7%8F%80%E6%9D%8E%E6%9D%8E%E8%82%B2%E8%B6%85/:0:0","tags":["shasiyizhizh","note","ireader"],"title":"[笔记]杀死一只知更鸟 [美国] 哈珀·李;李育超","uri":"/%E7%AC%94%E8%AE%B0%E6%9D%80%E6%AD%BB%E4%B8%80%E5%8F%AA%E7%9F%A5%E6%9B%B4%E9%B8%9F-%E7%BE%8E%E5%9B%BD-%E5%93%88%E7%8F%80%E6%9D%8E%E6%9D%8E%E8%82%B2%E8%B6%85/"},{"categories":null,"content":" 459-517, 标注, unknown 自律是解决人生问题最主要的工具，也是消除人生痛苦最主要的方法。 530-691, 标注, unknown 人生是一连串的难题，面对它，你是哭哭啼啼，还是奋勇前进？你是束手无策地哀叹，还是积极想办法去解决，并将方法毫无保留地传给 后人？解决人生问题的关键在于自律。人若缺少自律，就不可能解决任何麻烦和问题。在某些方面自律，只能解决某些问题，全面的自律 才能解决人生所有的问题。 693-773, 标注, unknown 问题可以开启我们的智慧，激发我们的勇气。为解决问题而努力，我们的思想和心灵就会不断成长， 心智就会不断成熟 775-815, 标注, unknown “唯有痛苦才能给人带来教益 817-963, 标注, unknown 在某种程度上，人人都害怕承受痛苦，遇到问题时都想回避，甚至慌不择路，望风而逃。有的人不断 拖延时间，希望问题自行消失；有的人对问题假装视而不见，或尽量忘记它们的存在；还有的人用药 物和毒品来麻痹自己，企图把问题排除在意识之外，换得片刻解脱 965-1016, 标注, unknown 回避问题和逃避痛苦的倾向，是人类心理疾病的根源。 1018-1108, 标注, unknown 我们要让我们自己，也要让我们的孩子认识到，人生的问题和痛苦具有非凡的价值。勇于承担责任， 敢于面对困难，才能够使心灵变得健康。 1110-1202, 标注, unknown 简单地说，所谓自律，就是主动要求自己以积极的态度去承受痛苦，解决问题。自律有四个原则：推 迟满足感、承担责任、忠于事实、保持平衡。 1214-1338, 标注, unknown 推迟满足感，就是不贪图暂时的安逸，先苦后甜，重新设置人生快乐与痛苦的次序：首先，面对问题 并感受痛苦；然后，解决问题并享受更大的快乐。在充满问题和痛苦的人生中，推迟满足感是唯一可 行的生活方式。 1353-1401, 标注, unknown 自律是自我照顾，自我珍惜，而不是自暴自弃。 1420-1531, 标注, unknown 不少人兼具神经官能症和人格失调症，统称为“人格神经官能症”。在某些问题上，他们把别人的责任 揽到自己身上，内心充满内疚感；而在另一些问题上，他们却拒绝相信责任在于自己。 1533-1603, 标注, unknown 心理学界有一种公认的说法：“神经官能症患者让自己活得痛苦，人格失调症患者让别人活得痛苦 1605-1680, 标注, unknown 上世纪 60 年代，美国黑人作家埃尔德里奇·克里佛的一句话：“你不能解决问题，你就会成为问题。” 1696-1784, 标注, unknown 抱着残缺的人生地图不放，与现实世界处处脱节，这是不少人的通病，也是造成诸多心理疾病的根源。 心理学家把这种情形称之为“移情 1786-1873, 标注, unknown 把产生和适用于童年时期的那些感知世界、对世界做出反应的方式，照搬到成年后的环境中，尽管这 些方式已经不再适用于新的环境。 1875-2069, 标注, unknown 在国际关系中，移情是个有趣的研究课题。国家首脑同样是人，他们的部分人格同样是童年经验塑造 的结果。譬如，希特勒追随的是什么样的人生地图，它从何而来？越战期间，美国历经几任总统，他 们各自都有怎样的人生地图？我想，他们的地图肯定各不相同。经历过经济大萧条对他们的地图有着 怎样的影响？而在五六十年代成长的一代，他们的地图又是什么模样呢？ 2081-2158, 标注, unknown 完全忠于事实的生活到底意味着什么呢？首先，它意味着我们要用一生的时间进行不间断地严格地自 我反省。我 2160-2214, 标注, unknown 忠于事实的生活还意味着我们要敢于接受外界的质疑和挑战。 2216-2306, 标注, unknown 完全忠于事实的第三个要求，就是我们需要一辈子保持诚实。我们必须不断自我反省，确保我们的言 语能够准确地表述出我们所认知的事实。 2308-2403, 标注, unknown 所谓心理治疗，其实就是“鼓励说真话的游戏”。心理医生最重要的任务，就是让患者说出真话。长时 间自欺欺人，使人的愧疚积聚，就会导致心理疾病 2415-2459, 标注, unknown 一个人应该有选择地表达意见和想法。 2461-2559, 标注, unknown 一方面，我们担心祸从口出；另一方面，我们又不想违背诚实和公正的原则。二者之间几乎没有回旋的余地，我们很难取得理想的平衡， 这的确是高难度的挑战 2561-2629, 标注, unknown 一个人越是诚实，保持诚实就越是容易，而谎言说得越多，则越要编造更多的谎言自圆其说。 2641-2745, 标注, unknown 大脑的高级中枢-–—判断力，必须约束低级中枢-–—情绪。在这个复杂多变的世界里，要想人生 顺遂，我们不但要有生气的能力，还要具备克制脾气的能力 2758-2891, 标注, unknown 兼容并包的道理在于，你获得的永远比放弃的多。自律的过程，就是自我发展、自我完善的过程。放弃的痛苦是死亡的痛苦，但是旧事物 的死亡带来的是新事物的诞生。死亡的痛苦与诞生的痛苦是同一回事。生与死，好比是一枚硬币的两面 2902-3062, 标注, unknown 你描述的不是爱，而是一种过分的依赖感。确切地说，是一种寄生的心理。没有别人就无法生存，意味着你是个寄生者，而对方是寄主。 你们的关系和感情并不是自由的，而是因为需要依赖才结合在一起的。真正的爱是自由的选择。真正相爱的人，不一定非要生活在一起， 只是选择生活在一起罢了 3064-3304, 标注, unknown 不管我们看起来多么强壮，不管我们花多大的心思装出无所谓的样子，但在内心深处，我们都曾渴望过依赖他人。不管年龄大小，不管成 熟与否，我们都希望获得别人的关心和照顾。心理健康的人承认这种感觉的合理性，却不会让它控制自己的生活。假如它牢牢控制了我们 的言行，控制了我们的一切感受和需要，那么它就不再是单纯的渴望了，而是变成了一种心理问题。因过分依赖而引起的心理失调，心理 学家称之为“消极性依赖人格失调”，这是最常见的心理失调症状。 3306-3383, 标注, unknown 这正是消极性依赖人格失调症患者的典型特征。他们不在乎依赖的对象是谁，只要有人可以依赖，就 会心满意足 3395-3478, 标注, unknown 不是所有的“精神贯注”都是爱，那些与心智成熟无关，不能给心灵带来任何滋养的“精神贯注”，都不 是真正意义上的爱。 3480-3529, 标注, unknown 爱的唯一目标，乃是促进心智的成熟和人性的进步 3531-3629, 标注, unknown 如果我们与某个人相处，局面就完全不同了，我们必然会容许他（她）拥有独立的思维和意志，因为 真正的爱的本质之一，就是希望对方拥有独立自主的人格。 3631-3735, 标注, unknown 父母应该成为值得尊敬的领导者与指挥官，告诉孩子该做什么，不该做什么。要进行理性地判断，而 不能仅凭直觉，必须认真思考和周密计划，甚至是做出令人痛苦的决定。 3749-3823, 标注, unknown 受虐狂把忍受虐待视为真正的爱，然而她们寻求报复快感的前提和忍受虐待的动机，是来自恨而不是 爱。 3825-4013, 标注, unknown 有的父母会这样告诉孩子：“你应该感激我们为你所做的一切。”可以肯定地说，这样的父母对孩子缺 少真正的爱。其实，我们真心去爱某个人，是因为我们自己需要去爱别人；我们生儿育女，是因我们 自己想要孩子；我们爱自己的孩子，是因为我们渴望自己成为充满爱心的父母。真正的爱能够使人发 生改变，在本质上是一种自我扩展，而非纯粹的自我牺牲 4027-4138, 标注, unknown 爱的感觉也许是无限的，爱的火苗随时有可能在心头燃起，但是我们能够付出的爱是有限的，不能随 意选择爱的对象。真正的爱不是忘乎所以，而是深思熟虑，是奉献全部身心的重大决定。 4151-4232, 标注, unknown 拓展自我界限就如同走路一样，每多走一步或多走一里，都可以逐步对抗与生俱来的惰性，抵御因恐 惧而产生的排斥心理 4234-4303, 标注, unknown 孩子感受到你的尊重和爱，就会感受到自己的价值。充分地尊重孩子，才能让他们懂得自尊自爱 4305-4358, 标注, unknown 玩游戏时三心二意，你就有可能培养出做事三心二意的孩子 4360-4505, 标注, unknown 真正的倾听，意味着把注意力放在他人身上，这是爱的具体表现形式。此时，倾听者需要暂时把个人 想法和欲望放在一旁，努力去体会说话人的内心世界和感受。这样一来，听者与说者便通过语言结合 在了一起，实际上，这一过程本身就是彼此自我界限的一种拓展 4507-4624, 标注, unknown 对于 12 岁的孩子，家长可以和他们打羽毛球。给孩子读书，指导他们做功课，都是表达关怀的形式。 也可以进行其他家庭娱乐活动，比如看电影、外出野餐、开车兜风、出门旅行、观赏球赛等等。 4637-4724, 标注, unknown 你是我们所爱的孩子，你是可爱的人。无论你做什么，无论你成为什么样的人，只要你努力而且敢于 冒险，我们始终都会支持你、爱你 4737-4867, 标注, unknown 家长的角色和心理医生相似。聆听子女的心声，满足他们的需要，而不是盲目坚守权威，颐指气使， 才有助于家长拓展自我，实现自身的完善。因此，只有恰如其分地做出改变，使人格和心灵不断完善， 才能担负起做父母的职责","date":"2024-10-09","objectID":"/%E7%AC%94%E8%AE%B0%E5%B0%91%E6%9C%89%E4%BA%BA%E8%B5%B0%E7%9A%84%E8%B7%AF-n-a/:0:0","tags":["shaoyourenzo","note","ireader"],"title":"[笔记]少有人走的路-N/A","uri":"/%E7%AC%94%E8%AE%B0%E5%B0%91%E6%9C%89%E4%BA%BA%E8%B5%B0%E7%9A%84%E8%B7%AF-n-a/"},{"categories":null,"content":" 579-580, 标注, 2018 年 9 月 2 日星期日 下午 3:28:17 它是一个能保持自身复杂性并能进行复制的过程。复制的对象并不是由原子组成的物质，而是能阐明原子是如何排列的信息，这种信息由比特组成。 581-582, 标注, 2018 年 9 月 2 日星期日 下午 3:36:09 我们可以将生命看作一种自我复制的信息处理系统，它的信息软件既决定了它的行为，又决定了其硬件的蓝图。 607-607, 标注, 2018 年 9 月 2 日星期日 下午 3:40:18 生命 1.0 是说：生命的硬件和软件都是靠进化得来的，而不是靠设计。 607-608, 标注, 2018 年 9 月 2 日星期日 下午 3:40:25 属于“生命 2.0”：生命的硬件是进化而来，但软件在很大程度上却是依靠设计的。 620-621, 标注, 2018 年 9 月 2 日星期日 下午 3:42:06 突触存储着我们所有的知识和技能，大约相当于 100TB 的信息，而我们的 DNA 却只存储了大约 1GB 的信息，还不如一部电影的容量大呢。 640-641, 标注, 2018 年 9 月 2 日星期日 下午 3:44:44 生命 3.0 是自己命运的主人，最终能完全脱离进化的束缚。 646-649, 标注, 2018 年 9 月 2 日星期日 下午 3:45:18 我们可以根据生命设计自身的能力，把生命的发展分成三个阶段： ◦　生命 1.0（生物阶段）：靠进化获得硬件和软件； ◦　生命 2.0（文化阶段）：靠进化获得硬件，但大部分软件是由自己设计的； ◦　生命 3.0（科技阶段）：自己设计硬件和软件。 794-796, 标注, 2018 年 9 月 2 日星期日 下午 4:46:53 这是历史上头一遭，我们或许能发明出足够强大的科技，可以将那些灾害永久性地清除出去；又或者，它也可能将人类推向末日。 893-894, 标注, 2018 年 9 月 2 日星期日 下午 5:26:32 尤其是那些目标与我们的目标不一致的智能。 892-894, 标注, 2018 年 9 月 2 日星期日 下午 5:26:46 人工智能有益运动支持者最担忧的并不是机器人，而是智能本身：尤其是那些目标与我们的目标不一致的智能。 1103-1104, 标注, 2018 年 9 月 2 日星期日 下午 7:22:28 智能这样的无形之物可以体现在有形的物质形式之上。 1148-1149, 标注, 2018 年 9 月 2 日星期日 下午 7:48:48 计算是由一个记忆状态向另一个记忆状态转变的过程。 1212-1213, 标注, 2018 年 9 月 2 日星期日 下午 8:10:19 计算和信息一样，是独立于物质层面而存在的：计算就像拥有自己的生命一样，与它采取什么样的物质形态无关。 1946-1947, 标注, 2018 年 9 月 3 日星期一 下午 1:01:11 美国每年因交通事故丧生的人数达 32 000 人；假如无人驾驶汽车将死亡人数减半，汽车厂商很可能并不会收到 16 000 封感谢信，而是 16 000 起官司。 2999-3000, 标注, 2018 年 9 月 5 日星期三 下午 9:55:52 现在有很多人都没有意识到自己的创造潜力，因为，为了谋生，他们需要投入时间和精力到创造性不那么高的活动上。 3169-3170, 标注, 2018 年 9 月 6 日星期四 上午 7:22:44 意识（consciousness）是最了不起的。我认为，意识正是宇宙的意义之来源。星系之所以美丽，是因为我们的目光触及它们，并在主观上体验到它们的存在。 4265-4266, 标注, 2018 年 9 月 16 日星期日 下午 3:17:17 不过，我们必须记住，如今掌权的并不是我们的基因，而是我们的感觉。这意味着人类的行为并不一定有利于种族延续。 4472-4473, 标注, 2018 年 9 月 18 日星期二 下午 10:17:26 真理与美是相通的，我们可以把我们的宇宙视为一件艺术品。 ","date":"2024-10-09","objectID":"/%E7%AC%94%E8%AE%B0%E7%94%9F%E5%91%BD3/:0:0","tags":["shengming3.0","note","ireader"],"title":"[笔记]生命3","uri":"/%E7%AC%94%E8%AE%B0%E7%94%9F%E5%91%BD3/"},{"categories":null,"content":" 308-310, 标注, 2021 年 5 月 21 日星期五 下午 9:54:24 机械”与“生命”这两个词的含义在不断延展，直到某一天，所有结构复杂的东西都被看作是机器，而所有能够自维持的机器都被看作是有生命的。 404-405, 标注, 2021 年 5 月 22 日星期六 上午 10:06:49 这是一个白痴的选举大厅，由白痴选举白痴，其产生的效果却极为惊人。这是民主制度的真髓，是彻底的分布式管理。 492-493, 标注, 2021 年 5 月 22 日星期六 上午 10:28:24 如今根据雷诺兹的算法，群体被看作是一种自适应的技巧，适用于任何分布式的活系统，无论是有机的还是人造的。 482-485, 标注, 2021 年 5 月 22 日星期六 上午 10:28:59 但要遵循算法中植入的几条简单规则：不要撞上其他的蝙蝠，跟上自己旁边的蝙蝠，离队不要太远。当这些“算法蝙蝠”在屏幕上运行起来时，就如同真的蝙蝠一样成群结队而行了。 群体规律是由克雷格·雷诺兹〔10〕发现的。 530-534, 标注, 2021 年 5 月 24 日星期一 下午 9:37:51 “蜂群思维”的神奇在于，没有一只蜜蜂在控制它，但是有一只看不见的手，一只从大量愚钝的成员中涌现出来的手，控制着整个群体。它的神奇还在于，量变引起质变。要想从单个虫子的机体过渡到集群机体，只需要增加虫子的数量，使大量的虫子聚集在一起，使它们能够相互交流。等到某一阶段，当复杂度达到某一程度时，“集群”就会从“虫子”中涌现出来。 536-538, 标注, 2021 年 5 月 24 日星期一 下午 9:39:45 这里有一个关于活系统的普遍规律：低层级的存在无法推断出高层级的复杂性。不管是计算机还是大脑，也不管是哪一种方法——数学、物理或哲学——如果不实际地运行它，就无法揭示融于个体部分的涌现模式。 ","date":"2024-10-09","objectID":"/%E7%AC%94%E8%AE%B0%E5%A4%B1%E6%8E%A7%E4%B8%9C%E8%A5%BF%E6%96%87%E5%BA%93-%E4%B8%9C%E8%A5%BF%E6%96%87%E5%BA%93/:0:0","tags":["shikong-dong","note","ireader"],"title":"[笔记]失控·东西文库-东西文库","uri":"/%E7%AC%94%E8%AE%B0%E5%A4%B1%E6%8E%A7%E4%B8%9C%E8%A5%BF%E6%96%87%E5%BA%93-%E4%B8%9C%E8%A5%BF%E6%96%87%E5%BA%93/"},{"categories":null,"content":" 1671-1671, 标注, 2024 年 8 月 2 日星期五 下午 9:04:37 君子喻于义，小人喻于利。 1677-1680, 标注, 2024 年 8 月 2 日星期五 下午 9:05:44 岭南的雨水绵密而黏稠，像无数条藤蔓自铅云上端倒垂下，搅动着江水。整个江面泛起密密麻麻的小泡，仿佛一釜正“咕嘟咕嘟“熬煮的稻米羹。三伏的暑气非但没被雨水浇散，反而更加闷蒸起来，令舟上的乘客油然生出一种“造化为厨，天地为釜”的错觉，至于自己，只是被日月煎熬的小小一粒米罢了。 3415-3415, 标注, 2024 年 8 月 3 日星期六 下午 4:54:53 嘉所言，可不光是致祭的问题。南越王 ","date":"2024-10-09","objectID":"/%E7%AC%94%E8%AE%B0%E9%A3%9F%E5%8D%97%E4%B9%8B%E5%BE%92-%E9%A9%AC%E4%BC%AF%E5%BA%B8/:0:0","tags":["shinanzhitu","note","ireader"],"title":"[笔记]食南之徒-马伯庸","uri":"/%E7%AC%94%E8%AE%B0%E9%A3%9F%E5%8D%97%E4%B9%8B%E5%BE%92-%E9%A9%AC%E4%BC%AF%E5%BA%B8/"},{"categories":null,"content":" 1246-1301, 标注, unknown 在一条幽静的小路上，一盏路灯在夜色里画出一块明亮的圆区。 1303-1428, 标注, unknown 往事，过去的生活，分为两种：一种是未被意识到的，它们都已无影无踪，甚至谈论它们都已不再可能。另一种被意识到的生活才是真正 存在的，才被保存下来成为意义的载体。一切被意识到的生活都是被意识改造过的， 1429-1619, 标注, unknown 整整那个秋天，整整那个秋天的每个夜晚，我都在那片树林里踽踽独行。一盏和一盏路灯相距很远，一段段明亮与明亮之间是一段段黑暗 与黑暗，我的影子时而在明亮中显现，时而在黑暗中隐没。凭空而来的风一浪一浪地掀动斑斓的落叶，如同掀动着生命给我的印象。我感 觉自己就像是这空空的来风，只在脱落下和旋卷起斑斓的落叶之时，才能捕捉到自己的存在。 1620-1671, 标注, unknown 骄阳如火的下午，到处都有什么东西被烤干了的味儿。 1672-1979, 标注, unknown 就站在那台阶前，青青的枣花洒在他脚下，细细碎碎洒得一地。赤身裸体的小男孩儿看见太阳落在肩上，落在胸前，暖洋洋地落在肚皮上 一起一伏一起一伏，肚脐的凹陷处留一点阴暗，收一口气，太阳无比安详地照耀了那朵小小的男人的标志。微风轻拂，或许是风把他的影 子吹落地上？男孩儿弯腰在地上摸那影子，把红褐色的小屁股眼儿肆无忌惮地悬在太阳里。过去并未消失，而未来已经存在。我仍能看见 男孩儿扶着台阶的青条石走，新鲜而茁壮的两条小腿交替着向前。男孩儿发现墙脚下毛茸茸的青苔，发现石缝中的蚂蚁东奔西跑，发现一 缕阳光在屋檐下变幻形状，仰头看一群鸟儿呼叫着在庭院的空中飞过…… 1981-2190, 标注, unknown 太阳晒热的花草的气味，太阳晒热的砖石的气味，阳光在风中舞蹈、流动。青砖铺成的十字甬道连接起四面的房屋，把院子隔成四块均等 的土地，两块上面各有一棵枣树，另两块种满了西番莲。西番莲顾自开着硕大的花朵，蜜蜂在层叠的花瓣中间钻进钻出，嗡嗡地开采。蝴 蝶悠闲飘逸，飞来飞去，悄无声息仿佛幻影。枣树下落满移动的树影，落满细碎的枣花。青黄的枣花像一层粉，覆盖着地上的青苔… 2191-2246, 标注, unknown 像一片树叶，任飓风吹去，随飓风盘旋，凭飓风安排我的命运。 2247-2333, 标注, unknown 那时我似乎才真正踏进了人世，长者亲昵的抚爱变作惶恐的冷眼，朋辈的戏谑之言成了罪责的依据，亲戚们的阿谀逢迎改为望风而逃。 2334-2435, 标注, unknown 那是因为客观世界里总有一些我们尚未认识的矛盾，而它们却又不依我们的主观愿望为转移，有时会影响我们，甚至伤害我们。这就是被 人神化了的命运的本来面目。 2436-2503, 标注, unknown 我摇着车在街上慢慢走，不急着回家。人有时候只想独自静静地待一会儿。悲伤也成享受。 2504-2588, 标注, unknown 呜呼！灭六国者，六国也，非秦也。族秦者，秦也，非天下也。”有时候，使我们处于不平等之地位上的，是我们自己，非他人也 2589-2730, 标注, unknown 所以我想，“忘我”未必都是好事，有时竟是生命的衰竭和绝望。不争者的不幸，一方面可怜，一方面可怒。这小戏是个象征：人道主义不 仅意味着我们该有人的权利，还意味着我们必须理直气壮地去争取，倘自己先就胆怯，则天上掉大饼的机会微乎其微。 2731-2840, 标注, unknown 四百多年里，它一面剥蚀了古殿檐头浮夸的琉璃，淡褪了门壁上炫耀的朱红，坍圮了一段段高墙又散落了玉砌雕栏，祭坛四周的老柏树愈 见苍幽，到处的野草荒藤也都茂盛得自在坦荡。 2841-2987, 标注, unknown 蜂儿如一朵小雾稳稳地停在半空；蚂蚁摇头晃脑捋着触须，猛然间想透了什么，转身疾行而去；瓢虫爬得不耐烦了，累了，祈祷一回便支 开翅膀，忽悠一下升空了；树干上留着一只蝉蜕，寂寞如一间空屋；露水在草叶上滚动，聚集，压弯了草叶轰然坠地摔开万道金光。 2988-3312, 标注, unknown 幸好有些东西是任谁也不能改变它的。譬如祭坛石门中的落日，寂静的光辉平铺的一刻，地上的每一个坎坷都被映照得灿烂；譬如在园中 最为落寞的时间，一群雨燕便出来高歌，把天地都叫喊得苍凉；譬如冬天雪地上孩子的脚印，总让人猜想他们是谁，曾在哪儿做过些什么， 然后又都到哪儿去了；譬如那些苍黑的古柏，你忧郁的时候它们镇静地站在那儿，你欣喜的时候它们依然镇静地站在那儿，它们没日没夜 地站在那儿从你没有出生一直站到这个世界上又没了你的时候；譬如暴雨骤临园中，激起一阵阵灼烈而清纯的草木和泥土的气味，让人想 起无数个夏天的事件；譬如秋风忽至，再有一场早霜，落叶或飘摇歌舞或坦然安卧，满园中播散着熨帖而微苦的味道。 3313-3519, 标注, unknown 随着小说获奖的激动逐日暗淡，我开始相信，至少有一点我是想错了：我用纸笔在报刊上碰撞开的一条路，并不就是母亲盼望我找到的那 条路。年年月月我都到这园子里来，年年月月我都要想，母亲盼望我找到的那条路到底是什么。母亲生前没给我留下过什么隽永的哲言， 或要我恪守的教诲，只是在她去世之后，她艰难的命运、坚忍的意志和毫不张扬的爱，随光阴流转，在我的印象中愈加鲜明深刻。 3520-4164, 标注, unknown 如果以一天中的时间来对应四季，当然春天是早晨，夏天是中午，秋天是黄昏，冬天是夜晚。如果以乐器来对应四季，我想春天应该是小 号，夏天是定音鼓，秋天是大提琴，冬天是圆号和长笛。要是以这园子里的声响来对应四季呢？那么，春天是祭坛上空漂浮着的鸽子的哨 音，夏天是冗长的蝉歌和杨树叶子哗啦啦地对蝉歌的取笑，秋天是古殿檐头的风铃响，冬天是啄木鸟随意而空旷的啄木声。以园中的景物 对应四季，春天是一径时而苍白时而黑润的小路，时而明朗时而阴晦的天上摇荡着串串杨花；夏天是一条条耀眼而灼人的石凳，或阴凉而 爬满了青苔的石阶，阶下有果皮，阶上有半张被坐皱的报纸；秋天是一座青铜的大钟，在园子的西北角上曾丢弃着一座很大的铜钟，铜钟 与这园子一般年纪，浑身挂满绿锈，文字已不清晰；冬天，是林中空地上几只羽毛蓬松的老麻雀。以心绪对应四季呢？春天是卧病的季节， 否则人们不易发觉春天的残忍与渴望；夏天，情人们应该在这个季节里失恋，不然就似乎对不起爱情；秋天是从外面买一棵盆花回家的时 候，把花搁在阔别了的家中，并且打开窗户把阳光也放进屋里，慢慢回忆慢慢整理一些发过霉的东西；冬天伴着火炉和书，一遍遍坚定不 死的决心，写一些并不发出的信。还可以用艺术形式对应四季，这样春天就是一幅画，夏天是一部长篇小说，秋天是一首短歌或诗，冬天 是一群雕塑。以梦呢？以梦对应四季呢？春天是树尖上的呼喊，夏天是呼喊中的细雨，秋天是细雨中的土地，冬天是干净的土地上的一只 孤零的烟斗。 4165-4768, 标注, unknown 还有一个人，是我的朋友，他是个最有天赋的长跑家，但他被埋没了。他因为在“文革”中出言不慎而坐了几年牢，出来后好不容易找了个 拉板车的工作，样样待遇都不能与别人平等，苦闷极了便练习长跑。那时他总来这园子里跑，我用手表为他计时，他每跑一圈向我招一下 手，我就记下一个时间。每次他要环绕这园子跑二十圈，大约两万米。他盼望以他的长跑成绩来获得政治上真正的解放，他以为记者的镜 头和文字可以帮他做到这一点。第一年他在春节环城赛上跑了第十五名，他看见前十名的照片都挂在了长安街的新闻橱窗里，于是有了信 心。第二年他跑了第四名，可是新闻橱窗里只挂了前三名的照片，他没灰心。第三年他跑了第七名，橱窗里挂前六名的照片，他有点儿怨 自己。第四年他跑了第三名，橱窗里却只挂了第一名的照片。第五年他跑了第一名-–—他几乎绝望了，橱窗里只有一幅环城赛群众场面 的照片。那些年我们俩常一起在这园子里待到天黑，开怀痛骂，骂完沉默着回家，分手时再互相叮嘱：先别去死，再试着活一活看。现在 他已经不跑了，年岁太大了，跑不了那么快了。最后一次参加环城赛，他以三十八岁之龄又得了第一名并破了纪录，有一位专业队的教练 对他说：“我要是十年前发现你就好了。”他苦笑一下什么也没说，只在傍晚又来这园中找到我，把这事平静地向我叙说一遍。不见他已有 好几年了，现在他和妻子和儿子住在很远的地方。 4769-5203, 标注, unknown 谁又能把这世界想个明白呢？世上的很多事是不堪说的。你可以抱怨上帝何以要降诸多苦难给这人间，你也可以为消灭种种苦难而奋斗， 并为此享有崇高与骄傲，但只要你再多想一步你就会坠入深深的迷茫了：假如世界上没有了苦难，世界还能够存在么？要是没有愚钝，机 智还有什么光荣呢？要是没了丑陋，漂亮又怎么维系自己的幸运？要是没有了恶劣和卑下，善良与高尚又将如何界定自己又如何成为美德 呢？要是没有了残疾，健全会否因其司空见惯而变得腻烦和乏味呢？我常梦想着在人间彻底消灭残疾，但可以相信，那时将由患病者代替 残疾人去承担同样的苦难。如果能够把疾病也全数消灭，那么这份苦难又将由（比如说）相貌丑陋的人去承担了。就算我们连丑陋，连愚 昧和卑鄙和一切我们所不喜欢的事物和行为，也都可以统统消灭掉，所有的人都一样健康、漂亮、聪慧、高尚，结果会怎样呢？怕是人间 的剧目就全要收场了，一个失去差别的世界将是一潭死水，是一块没有感觉没有肥力的沙漠。 5204-5283, 标注, unknown 我常以为是丑女造就了美人。我常以为是愚氓举出了智者。我常以为是懦夫衬照了英雄。我常以为是众生度化了佛祖。 5284-5349, 标注, unknown 入圣当然可以，脱凡其实不能，无论僧俗，人能舍弃一切，却无法","date":"2024-10-09","objectID":"/%E7%AC%94%E8%AE%B0%E5%8F%B2%E9%93%81%E7%94%9F%E4%BD%9C%E5%93%81%E5%85%A8%E7%BC%96-n-a/:0:0","tags":["shitieshengz","note","ireader"],"title":"[笔记]史铁生作品全编-N/A","uri":"/%E7%AC%94%E8%AE%B0%E5%8F%B2%E9%93%81%E7%94%9F%E4%BD%9C%E5%93%81%E5%85%A8%E7%BC%96-n-a/"},{"categories":null,"content":" 5-6, 标注, 2022 年 3 月 28 日星期一 下午 9:04:34 杜鲁门总统深知美国拥有巨大的实力，但最令他感到骄傲的是这一实力所包含的人道和民主价值。他更希望后人铭记他是因为美国与敌人实现了和解，而不是战胜了敌人。 66-68, 标注, 2022 年 3 月 28 日星期一 下午 9:42:06 他们要建立一座“山巅之城”，运用其正义的原则和榜样的力量激励整个世界。美国人的世界秩序观认为，一旦其他民族像美国人一样获得了自治权，和平与均势就会自然降临，昔日的宿敌也会捐弃前嫌 66-69, 标注, 2022 年 3 月 28 日星期一 下午 9:43:08 他们要建立一座“山巅之城”，运用其正义的原则和榜样的力量激励整个世界。美国人的世界秩序观认为，一旦其他民族像美国人一样获得了自治权，和平与均势就会自然降临，昔日的宿敌也会捐弃前嫌。因此，外交政策的任务不是追求美国特有的利益，而是培育共同的原则。 90-93, 标注, 2022 年 3 月 28 日星期一 下午 9:56:04 美国仍然坚持认为，它信奉的价值观在建立一个和平的世界秩序方面具有普遍适用性，并保留在全球范围内捍卫这些价值观的权利。然而，在两代人的时间里从三场战争中抽身后——每一场战争都始于理想主义愿望并得到公众的广泛支持，但都以国家蒙受创伤而告 97-98, 标注, 2022 年 3 月 28 日星期一 下午 10:09:40 须采取一种既尊重人类社会异彩纷呈的特点，又尊重人与生俱来对自由的渴望的做法。建立此种意义上的秩序必须靠长期培育，而不能强加于人 135-135, 标注, 2022 年 3 月 29 日星期二 下午 12:48:06 秩序源自平衡，自我认同感源自对大一统的抵抗。 163-165, 标注, 2022 年 3 月 29 日星期二 下午 12:54:56 皇帝的权威来自教皇的授权，但出于政治上和安排上的考虑，这一授权往往被撇在一边。结果是他作为“选出的皇帝”常常多年执掌权力。宗教和政治从未融合成为一个单一的结构。伏尔泰戏言，神圣罗马帝国“一不神圣，二非罗马，三不是帝国” 281-285, 标注, 2022 年 3 月 29 日星期二 下午 8:57:52 塞留的一生中可以得出三点结论。第一，成功的外交政策有一项内容不可或缺：一个基于通盘分析的长期战略观。第二，政治家需要认真分析暧昧不清而且往往相互抵触的纷杂外力，把它们引向服务于一定目标的一致方向，并通过这一过程形成长期战略观。政治家必须了解这一战略的走势及其原因。第三，一位政治家必须尽最大之可能弥合本国社会的现实与所追求目标之间的差距。循规蹈矩会导致僵滞，因此需要敢作敢为。 338-339, 标注, 2022 年 3 月 29 日星期二 下午 9:23:42 19 世纪英国政治家巴麦尊阐述了均势的要义：“我们没有永恒的盟友，也没有永恒的敌人，只有永恒的利益。我们的义务就是维护这些利益 457-461, 标注, 2022 年 3 月 31 日星期四 下午 10:35:13 历史事件从来不是偶然的，而是有其内在原因。借助理性可以发现这些内因，并且要为了公众的利益塑造这些内因： 主宰世界的不是运气……每一个君主政体内都活跃着思想内因和自然内因，它们决定了政体的兴衰存亡。一切（看上去像是）偶发事件都是这些内因的结果。每当一国因一场偶然的战役——即一个特定原因——覆灭时，还存在一个导致该国因一场战役覆灭的一般原因。简而言之，整体局势的发展决定了具体事件的走 457-461, 标注, 2022 年 3 月 31 日星期四 下午 10:35:17 历史事件从来不是偶然的，而是有其内在原因。借助理性可以发现这些内因，并且要为了公众的利益塑造这些内因： 主宰世界的不是运气……每一个君主政体内都活跃着思想内因和自然内因，它们决定了政体的兴衰存亡。一切（看上去像是）偶发事件都是这些内因的结果。每当一国因一场偶然的战役——即一个特定原因——覆灭时，还存在一个导致该国因一场战役覆灭的一般原因。简而言之，整体局势的发展决定了具体事件的走向。 486-488, 标注, 2022 年 4 月 1 日星期五 下午 8:55:50 社会上的种种怨愤情绪汇聚起来冲击毫无警觉的政权之日，也是革命爆发之时。革命同盟越广泛，摧毁现政权结构的能量就越大。变革波及范围越广，重建权威时就越需要采取暴力的手段，否则社会就会走向解体。恐怖统治不是偶然现象，而是革命固有的特征 658-663, 标注, 2022 年 4 月 1 日星期五 下午 9:44:33 如同中国的皇帝，沙皇是一位拥有神秘权力的至高无上的君主，统御广袤的疆土。但沙皇与中国的皇帝有一个重要区别。中国人认为，中国皇帝统治子民靠的是泰山崩于前而色不变的沉稳。俄国人则认为，沙皇维系其统治靠的是一种能力，一种以不容他人挑战自己权威的方式贯彻自己的意志，让所有旁观者深深感受到俄国这个国家无比强大的能力。中国的皇帝被视为优越的中华文明的象征，吸引他国人民“向化”。沙皇则被看作俄国抵御环伺之敌的象征。中国的皇帝因其圣明仁厚受到称赞。而 19 世纪的政治家尼古拉·卡拉姆津把沙皇的严酷看作是他响应内心召唤的表现 2170-2171, 标注, 2022 年 4 月 4 日星期一 下午 12:12:50 在仅仅一个世纪的时间内，日本从完全闭关锁国转变为广泛学习借鉴西方国家最现代化的做 2584-2585, 标注, 2022 年 4 月 4 日星期一 下午 1:08:47 沦肌浃髓。这一理念 2593-2594, 标注, 2022 年 4 月 4 日星期一 下午 1:11:08 在古中国，今天所谓的“外交政策”属于负责决定属国关系等级的礼部和负责管理与游牧部落关系的理藩院的职权范围 2735-2739, 标注, 2022 年 4 月 4 日星期一 下午 1:33:02 两国的文化和政治背景有着重大差异。美国的政策着眼于务实，中国则偏重概念。美国从未受过邻国威胁，中国的边境四周却无时无刻不强敌环伺，虎视眈眈。美国人相信每一个问题都有解决办法，中国人却认为一个问题的解决只会引起新的问题。美国人对眼前形势一定要拿出结果，中国人注重的则是大局的发展。美国人制定实际“可以做到的”计划，中国人只确定总的原则，进而分析它的走向 2741-2742, 标注, 2022 年 4 月 4 日星期一 下午 1:33:36 中国自认为与众不同，基本上自家管自家的事。美国也认为自己独一无二，也就是说它是“例外”，但它相信自己在道义上有义务超越国家利益，在世界上传播自己的价值观 3017-3020, 标注, 2022 年 4 月 10 日星期日 上午 8:57:11 罗斯福至少暂时成功地重新确定了美国的国际角色。在美洲，他比反对外部干预的“门罗主义”走得更远。他承诺，美国不仅要抵制外国对西半球的殖民图谋（他本人威胁说，为了阻止德国对委内瑞拉的觊觎不惜一战），也可以先发制人防患于未然。因此，他在“门罗主义”的基础上提出了“罗斯福推论”，大意是美国有权先行干预其他西半球国家的内部事务，以纠正不能容忍的“恶行或无能 3056-3056, 标注, 2022 年 4 月 10 日星期日 上午 9:05:21 罗斯福最喜欢的谚语说，美国应当“说话温和，手持大棒” 3468-3471, 标注, 2022 年 4 月 11 日星期一 下午 4:54:28 朝鲜战争也许能把中国拖入一场边境危机，把美国的注意力从欧洲引到亚洲，并且无论如何，都可以消耗美国的资源。如果朝鲜在苏联支持下获得成功，朝鲜半岛的统一会让苏联在朝鲜半岛占据支配地位，再加上这几个国家历史上相互猜疑，就会在亚洲对中国形成一定牵制。 3473-3475, 标注, 2022 年 4 月 11 日星期一 下午 4:55:40 有一次一位中国知名人士告诉我，跟在斯大林后面同意卷入朝鲜战争是毛泽东犯下的唯一战略错误。朝鲜战争最终把中国的统一推迟了一个世纪，因为它使美国更加坚定了保护台湾的承诺。 各方都遭受了挫折。一些中国历史学家认为，中国为了支持一个不可靠的盟国，失去了统一台湾的机会。美国失去了“二战”后一直享有的不可战胜的光环，在一定程度上也失去了方向感。 ","date":"2024-10-09","objectID":"/%E7%AC%94%E8%AE%B0%E4%B8%96%E7%95%8C%E7%A7%A9%E5%BA%8F-%E7%BE%8E%E4%BA%A8%E5%88%A9%E5%9F%BA%E8%BE%9B%E6%A0%BC/:0:0","tags":["shijiezhixu","note","ireader"],"title":"[笔记]世界秩序-[美]亨利·基辛格","uri":"/%E7%AC%94%E8%AE%B0%E4%B8%96%E7%95%8C%E7%A7%A9%E5%BA%8F-%E7%BE%8E%E4%BA%A8%E5%88%A9%E5%9F%BA%E8%BE%9B%E6%A0%BC/"},{"categories":null,"content":" 29-30, 标注, 2023 年 7 月 3 日星期一 下午 12:55:35 “将帅必起于卒伍，宰相必起于州部 214-215, 标注, 2023 年 7 月 3 日星期一 下午 10:39:03 合着你是帮我解决了一个本不存在的困难，送了一个本来不需要的人情……怪不得满天神佛个个清净无为、不昧 214-214, 标注, 2023 年 7 月 3 日星期一 下午 10:39:10 合着你是帮我解决了一个本不存在的困难，送了一个本来不需要的人情…… 250-250, 标注, 2023 年 7 月 3 日星期一 下午 10:42:22 这是真正的高手，让你吃个哑巴亏，还得受着人情 347-347, 标注, 2023 年 7 月 4 日星期二 上午 6:54:30 天予不取，反受其咎，时至不行，反受其殃！” 929-930, 标注, 2023 年 8 月 5 日星期六 下午 11:02:37 其实是所谓“拆屋卸窗”之计。先提出一个不合理的要求，待对方被逼到要爆炸，再退一步抛出真正的请求，对方便会如释重负，忙不迭地答应下来。 1124-1126, 标注, 2023 年 8 月 5 日星期六 下午 11:17:40 李长庚曾经历过类似谈话。他知道最麻烦的状况，不是你笨嘴拙舌，而是你根本不知道对方的真实目的。人家东一拂尘西一禅杖，问得云山雾罩，你只能被动应答，不知哪句就会落入彀中 2225-2227, 标注, 2023 年 8 月 6 日星期日 下午 10:03:46 他在启明殿干得最多最熟的活是协调，协调这事儿不怕你提的要求奇葩，就怕不知你要什么。只要掌握了各方的真实诉求，东哄哄，西劝劝，怎么都能妥协出一个多方都能接受的结果 ","date":"2024-10-09","objectID":"/%E7%AC%94%E8%AE%B0%E5%A4%AA%E7%99%BD%E9%87%91%E6%98%9F%E6%9C%89%E7%82%B9%E7%83%A6-%E9%A9%AC%E4%BC%AF%E5%BA%B8/:0:0","tags":["taibaijinxin","note","ireader"],"title":"[笔记]太白金星有点烦-马伯庸","uri":"/%E7%AC%94%E8%AE%B0%E5%A4%AA%E7%99%BD%E9%87%91%E6%98%9F%E6%9C%89%E7%82%B9%E7%83%A6-%E9%A9%AC%E4%BC%AF%E5%BA%B8/"},{"categories":null,"content":" 122-124, 标注, 2024 年 9 月 16 日星期一 上午 10:57:11 这一代人，一个个像悬崖边的孩子。在青春的荒原上，他们忽然看见了光。 他们猛力奔跑，触足之地，或陷泥泞，或长青草，惊心动魄间，天地舒展成一个以自由命名的花园，大河山川，各自生成。时间是玫瑰，他们是玫瑰上的刺。 188-190, 标注, 2024 年 9 月 16 日星期一 上午 11:04:27 小阿尔弗雷德·钱德勒在研究美国早期工商企业的发家史中，提出过著名的“成长四阶段”论，即积累资源、资源的合理化利用、持续增长和对扩展中的资源的合理利用。回顾腾讯的早期成长史，我们清晰地看到了这一演进的轨迹：通过 QQ 实现了用户资源的积累，以创新的盈利模式实现用户资源的获利兑现。 295-295, 标注, 2024 年 9 月 16 日星期一 上午 11:16:02 第一种武器：产品极简主义。 295-295, 笔记, 2024 年 9 月 16 日星期一 上午 11:17:37 这么说,亏心不? 是 Qq 小还是微信小了？ 305-307, 标注, 2024 年 9 月 16 日星期一 上午 11:19:05 在腾讯的 18 年发展史上，决定其命运的几次重大产品创新，如 QQ 秀、QQ 空间及微信，都不是最高层调研决策的结果，而来自中基层的自主突破，这一景象得益于马化腾在内部形成的赛马机制。 307-309, 标注, 2024 年 9 月 16 日星期一 上午 11:19:16 与以标准化、精确化为特征的工业经济相比，互联网经济最本质的差异是对一切完美主义的叛逆。“小步、迭代、试错、快跑”，是所有互联网公司取得成功的八字秘诀。 353-355, 标注, 2024 年 9 月 16 日星期一 上午 11:23:45 几乎每一家中国互联网企业都是美国的克隆版，都可以在那里找到原型，但是，几乎所有成功的企业都在日后找到了完全不同于原版的生存和盈利模式。从 QQ 对 ICQ 的克隆，到微信对 kik 的跟进，腾讯历史上的战略性产品都找得到仿效的影子。而耐人寻味的是，被效仿者很快销声匿迹，而腾讯则据此获得成功。 356-358, 标注, 2024 年 9 月 16 日星期一 上午 11:24:35 中国的互联网人在应用性迭代和对本国消费者的行为了解上，找到了自己的办法。在腾讯的案例中，可以看到种种的东西方消费差异，比如美国人愿意出钱买一首歌给自己听，而中国人愿意出钱买歌给自己的朋友听。 359-359, 标注, 2024 年 9 月 16 日星期一 上午 11:25:16 更乐意购买虚拟类道具， 364-366, 标注, 2024 年 9 月 16 日星期一 上午 11:26:22 如果说美国人总在想如何改变世界，那么，中国人想得更多的是，如何适应正在改变中的世界，他们更乐意改变自己的生活，这是商业价值观——广而言之，更是人生观的区别，也是很多美国与中国商业故事的不同起点。 367-371, 标注, 2024 年 9 月 16 日星期一 上午 11:27:39 中国迄今仍然是一个非典型的现代国家，政府掌控着近乎无限的资源，庞大的国有资本集团盘踞在产业的上游并参与政策的制定。互联网是罕见的阳光产业，因变革的快速和资源的不确定性，国有资本迄今没有找到对其进行有效控制和获取垄断利益的路径。互联网为这个国家带来了意料之外的商业进步和社会空间开放，同时也正在造成新的混乱和遭遇更具技巧性的管制。这显然是一个没有讲完的故事，博弈正在进行，没有人猜得到它的结局。 382-382, 标注, 2024 年 9 月 16 日星期一 上午 11:32:03 预见未来最好的办法就是把它创造出来。 414-415, 标注, 2024 年 9 月 16 日星期一 上午 11:37:58 面对远处的未知迷雾，人们很难摆脱短视的袭扰，而只有把焦距拉大并将视线聚焦于一点，方可能稍稍看清真相的某一部分。 449-450, 标注, 2024 年 9 月 16 日星期一 上午 11:42:13 老师们以无比急切的口吻告诫年轻人，如今是百年一遇的大时代，机会就像河流里的泥鳅，处处可见，都不易抓获。 707-707, 标注, 2024 年 9 月 16 日星期一 下午 1:58:42 生活如一条大河，所谓的“源头”都是后来者标示的产物。 799-801, 标注, 2024 年 9 月 16 日星期一 下午 4:43:51 创业之神”总是这样，它不按常理出牌，视过往的成功与经验为累赘，喜欢在极限的状态下挑战人们的意志力和想象力，它常常带着一丝戏谑的微笑堵住命运的正门，然后，却在腋下露出一条缝隙来。 1053-1055, 标注, 2024 年 9 月 16 日星期一 下午 5:10:10 在那份给 IDG 的商业计划书上，马化腾和曾李青将腾讯估值为 550 万美元，愿意出让 40%的股份，即募资 220 万美元。而这几乎没有什么盈利根据。 王树问马化腾：“腾讯凭什么值 550 万美元？” 马化腾答：“因为我们缺 200 万美元。” 1092-1093, 标注, 2024 年 9 月 16 日星期一 下午 5:13:15 在所有的商业故事里，运气是最神秘的那一部分，几乎有一半的创业者“死”在运气这件事上，而且，你无法解释。 1478-1479, 标注, 2024 年 9 月 16 日星期一 下午 5:48:12 腾讯出售的其实不是“服饰”，而是“情感的寄托”，“代表了一个人在别人眼中的形象，朋友看到我在 QQ 上面的形象，就能够知道我是一个什么样的人”。 1500-1501, 标注, 2024 年 9 月 16 日星期一 下午 5:50:27 对于腾讯而言，QQ 秀也是一个“蜕变之秀”，从此，这家即时通信服务商成为一个发掘人性、出售娱乐体验的供应商。 1646-1647, 标注, 2024 年 9 月 16 日星期一 下午 8:24:06 刘炽平提出，在公司的估值上不妨保守一点，与其一下子就把市值飚得太高，倒不如慢慢地把公司的价值做出来，让那些购买了腾讯股票的股民能享受到增长的福利。 2109-2111, 标注, 2024 年 9 月 16 日星期一 下午 9:40:45 中国市场上，盖茨采取了放任盗版的战略。1998 年，他对《财富》杂志说：“只要中国人做盗版，我们希望他们可以盗版微软的。他们将会盗版上瘾，在接下来的 10 年，我们会想方法把盗版收回来。”事实正是如此，微软一直到 2008 年才开始着手打击中国市场上的盗版行为。 2315-2321, 标注, 2024 年 9 月 16 日星期一 下午 10:27:30 当互联网经济进入马化腾所指出的“服务和用户驱动”的阶段之后，区域性的文化、消费及政策特征成为企业竞争的首要考量指标，而在这一方面，用筷子吃米饭、呼吸着乡土的空气长大的黄皮肤本地人当然比远道而来的美国人或欧洲人更有优势。生产安踏牌运动鞋的丁志忠曾经用一个形象的比喻，描述了中美企业对中国消费市场的不同理解，他说：“耐克、阿迪达斯的篮球鞋主要是在塑胶地板上穿，弹性是重要考核指标，而安踏的消费者只有 1%能在塑胶地板上打球，其他都是在水泥地上。安踏更关心的是，在水泥地上打球的孩子如何才能不扭脚。”丁志忠的这段话，用于互联网产业也非常“合脚”。 3067-3069, 标注, 2024 年 9 月 17 日星期二 上午 7:53:41 亨利·福特曾经说：“成功的秘诀，在于把自己的脚放入他人的鞋子里，进而用他人的角度来考虑事物，服务就是这样的精神，站在客人的立场去看整个世界。”看来，从客户的角度思考商业，是一个公开的秘密。 3126-3128, 标注, 2024 年 9 月 17 日星期二 下午 8:47:01 任何产品都有核心功能，其宗旨就是能帮助到用户，解决用户某一方面的需求，如节省时间、解决问题、提升效率等。核心能力要做到极致。要多想如何通过技术实现差异化，让人家做不到，或通过一年半载才能追上。 3241-3242, 标注, 2024 年 9 月 17 日星期二 下午 9:37:08 马化腾的讲话，概括而言就是“出外抢地盘，对内重协调”，这是一个充满了攻击性的战略布局， 3250-3251, 标注, 2024 年 9 月 17 日星期二 下午 9:37:49 对腾讯的不满，归结为三宗罪：“一直在模仿从来不创新”“走自己的路让别人无路可走”“垄断平台拒绝开放”。 3616-3619, 标注, 2024 年 9 月 18 日星期三 上午 7:39:12 让我们保持敬畏 过去，我们总在思考什么是对的。但是现在，我们要更多地想一想什么是能被认同的。过去，我们在追求用户价值的同时，也享受奔向成功的速度和激情。但是现在，我们要在文化中更多地植入对公众、对行业、对未来的敬畏。 3663-3665, 标注, 2024 年 9 月 18 日星期三 上午 7:43:14 在互联网未来世界里拥有独特魅力和独立的人会成为最终源头，会成为最终的赢家。聚合更多的个人价值，为更多人的自我实现提供平台，把个性魅力和创新的潜力凝聚成为庞大的商业价值，是未来互联网的用武之地，也是腾讯公司的愿景之一。 3718-3720, 标注, 2024 年 9 月 18 日星期三 上午 7:46:49 一位成熟的商业从业者，应该具有两个坚定而又强烈，同时也相互矛盾的信条：你必须破坏原有的秩序和道德规则，同时，你必须致力于秩序和规则的重建，你是破坏的后果承担者和“遗产继承人”。 3798-3799, 标注, 2024年9月18日星期三 上午7:54:03 正如迈克尔·波特","date":"2024-10-09","objectID":"/%E7%AC%94%E8%AE%B0%E8%85%BE%E8%AE%AF%E4%BC%A01998-2016%E4%B8%AD%E5%9B%BD%E4%BA%92%E8%81%94%E7%BD%91%E5%85%AC%E5%8F%B8%E8%BF%9B%E5%8C%96%E8%AE%BA-%E5%90%B4%E6%99%93%E6%B3%A2/:0:0","tags":null,"title":"[笔记]腾讯传1998-2016：中国互联网公司进化论-吴晓波","uri":"/%E7%AC%94%E8%AE%B0%E8%85%BE%E8%AE%AF%E4%BC%A01998-2016%E4%B8%AD%E5%9B%BD%E4%BA%92%E8%81%94%E7%BD%91%E5%85%AC%E5%8F%B8%E8%BF%9B%E5%8C%96%E8%AE%BA-%E5%90%B4%E6%99%93%E6%B3%A2/"},{"categories":null,"content":" 512-720, 标注, unknown 由于文化背景的不同，英国最先进的事物，经过儒家教义的折光，顿时变为最荒谬不堪的东西。君主立宪，在皇权至上面前，有如大臣擅 权；经商贸易，在农本主义面前，显为舍本求末；追逐利润，在性理名教面前，只是小人之举；至于女王主位、男女不辨，更是牝鸡司晨 之类的“夷俗”；即便令人兴叹的西方器物（钟表、玻璃、呢羽等），享用赏玩收藏之余，仍可斥之为“坏人心术”的“奇技淫巧”。 784-976, 标注, unknown 核准历史事实，有关琦善卖国的四项罪名，无一可以成立。然而，我们若放开那些对琦善的具体指责，从更宏观的角度看问题，不难看出， 琦善卖国说的根由在于：他不主张用武力对抗的方式，来制止英国的军事侵略，而企图用妥协的方式，达到中英和解。于是，“妥协”即被 目为“投降”，而“投降”又被提升至“卖国”。帽子正是如此一顶顶地戴到了琦善的头上。 1041-1333, 标注, unknown 在皇权至上的社会中，天子被说成至圣至明，不容许也不“应该”犯任何错误。尽管皇帝握有近乎无限的权力，因而对一切事件均应该负有 程度不一的责任；但是，当时的人们对政治的批判，最多只能到大臣一级。由此而产生了中国传统史学、哲学中的“奸臣模式”：“奸臣”欺 蒙君主，滥用职权，结党营私，施横作恶，致使国运败落；一旦除去“奸臣”，圣明重开，万众欢腾。这一类模式使皇帝避免了直接承担坏 事的责任，至多不过是用人不周不察，而让“奸臣”去承担责任，充当替罪羊。若非如此，将会直接批判到皇帝。这就冲犯了儒家的“礼”， 是士人学子们不会也不愿去做的。 1380-1552, 标注, unknown 忠奸理论和“奸臣模式”，并非是鸦片战争史独有的现象，而是中国传统史学的常用方法。正是它具有掩护君主、掩护道统的特殊功能，因 而屡屡被官僚士子们用来解释那些他们不能解释或不愿解释的历史现象。这种理论和模式，经过他们长久的宣教，成为老百姓耳熟能详、 最易接受的历史分析法，并在今天仍有其影响力。 1612-1767, 标注, unknown 历史学最基本的价值，就在于提供错误，即失败的教训。所谓“以史为鉴”，正是面对错误。从这个意义上讲，一个民族从失败中学到的东 西，远远超过他们胜利时的收获。胜利使人兴奋，失败使人沉思。一个沉思着的民族往往要比兴奋中的民族更有力量。历史学本应当提供 这种力量。 1814-1873, 标注, unknown 一个民族对自己历史的自我批判，正是它避免重蹈历史覆辙的坚实保证。 1933-1991, 标注, unknown 威力无比的社会腐蚀剂，当军队将财神像奉为战旗时，腐败已不可逆转 2038-2096, 标注, unknown 世界上可以有一万种罪恶而安然无事，唯有一种足以致命：执法犯法。 2143-2260, 标注, unknown 以上的描写，颇有专门暴露黑暗之嫌。其实，我为了研究结论的公允，曾千百度地寻找光明，但光明始终远我而去。我不能不得出这样的 结论：鸦片战争时期的清军，本是一个难得见到光明的黑暗世界。 2326-2413, 标注, unknown 因此，他们主张加强查处贩烟、售烟。因为贩运、销售的行为可以解释为过境性、偶然性的，捉住一个便立下一功，捉不住也无责任可究 2460-2555, 标注, unknown 更聪明的方法，就是将禁烟的责任推向海口，内地官员自可摆脱干系：能够推到广东则更妙，禁烟就成了广东一省官员的事务，其余省份 自可乐得轻松。 2602-2723, 标注, unknown 禁烟是禁英国等国贩运之烟，然而，各地官员在奏折中竟全然不提英国可能对此事作出的反应。这说明清朝的上下当时还未把禁烟与中英 关系联系起来看，暴露出他们对鸦片走私情况的懵懂，对国际事务的无知。 2790-2910, 标注, unknown 同样是围绕毒品案件，英国和美国的态度在相隔一个半世纪之后，却是如此的不同。不管今天的人们对这两次战争持何种看法，作何种评 价，但是，贯穿在两次战争之中始终未变的原则是，国际政治中的强权。 2973-3061, 标注, unknown 义律代表鸦片商人缴出鸦片，并不意味着将遵循中国的法令，而是将鸦片商人的货物变为英国政府的财产，图谋以此为由向中国发动战争。 3124-3217, 标注, unknown 处在失败中的人们，找不到胜利的迹象，最容易产生某种希望。林则徐就是这种希望。而且，局势越危急，战争越失利，这种希望之火就 越放光芒。 3288-3382, 标注, unknown 。以贸易为本市场经济的英国，从本国的情势着眼，企图以此扼住中国经济的喉管，哪里会想到以农业为本自然经济的中国对此基本上没 有什么反应。 3429-3542, 标注, unknown 道光帝因此不可能知道南中国的主要海口已经被英军封锁，还兴致勃勃地经常与臣下讨论是否实行封海政策。不过，英军这种以破坏对方 经济为目的的战法，未收到期望的效果后，他们也放弃了 3605-3710, 标注, unknown 尽管每一次调动道光帝都有充足的理由，但毕竟缺乏通盘的考虑。他的那种头痛医头、脚痛医脚的一道道圣旨，是其目光短浅所限。他从 来就没有一种远距离、宽视野的眼光。 3773-3906, 标注, unknown 从江苏吴淞到浙江镇海，由两江总督而钦差大臣，伊里布不再表现出先前的精明、果敢和自信。在英军的肆横面前，他似乎已经看出武力 收复定海的任务不可能完成，但又不敢明言直陈。于是，举措从实在归于空虚，言词由明确变为含混。 3953-4037, 标注, unknown 我们办事，必令你们下得去，亦必令你们回得国，复得命。你们办事须教我们下得去，教我们奏得大皇帝，教我们大皇帝下得去。 4099-4156, 标注, unknown 他对中国的国情颇为了解，善于用曲折的手段达到目的，得寸进尺。 4222-4326, 标注, unknown 大黄滘炮台守军将领在临战前一天，竟派人与英军商议：“你也不要放炮，我也不要放炮，谁都不要放炮。我可以放六次没有炮弹的炮， 给皇帝留面子，然后走掉。”[21 4373-4495, 标注, unknown 与琦善相比，杨芳的违旨行为不知严重多少倍。琦善奉旨主“抚”，始终不肯与英人签订条约。杨芳奉旨主“剿”，却擅与英人达成停战协定。 可杨芳的结局又不知好过琦善多少倍。这里面的关键，在于如何上奏。 ","date":"2024-10-09","objectID":"/%E7%AC%94%E8%AE%B0%E5%A4%A9%E6%9C%9D%E7%9A%84%E5%B4%A9%E6%BA%83-n-a/:0:0","tags":["tianzhaodebe","note","ireader"],"title":"[笔记]天朝的崩溃-N/A","uri":"/%E7%AC%94%E8%AE%B0%E5%A4%A9%E6%9C%9D%E7%9A%84%E5%B4%A9%E6%BA%83-n-a/"},{"categories":null,"content":" 70-73, 标注, 2024 年 9 月 14 日星期六 上午 7:43:21 作为２０世纪的中国人，我们无意寻求昔日的天下，无论如何这已经是历史；但今天的中国是昔日的天下的产物，无论你视为遗产还是包袱，都不能不接受。 作为面向２１世纪的中国人，我们必须放眼未来的天下，在２１世纪的世界上占有我们应有的地位。这就是我们再认识一下昔日的天下的目的－－让自己知道什么应继承，什么该抛弃。 89-90, 标注, 2024 年 9 月 14 日星期六 上午 7:52:49 由于全国就分为九州，所以九州又一直被当作全国、“天下”的代名词。如南 89-91, 标注, 2024 年 9 月 14 日星期六 上午 7:53:01 由于全国就分为九州，所以九州又一直被当作全国、“天下”的代名词。如南宋诗人陆游《示儿》诗中的名句“死去原知万事空，但悲不见九州同”，就是取这样的用意；晚清诗人龚自珍“九州生气恃风雷”一句也是如此。 951-952, 标注, 2024 年 9 月 16 日星期一 上午 9:08:09 中国的历史不应该只是王朝的历史，更不应该只是中原王朝或汉族王朝的历史。 951-953, 标注, 2024 年 9 月 16 日星期一 上午 9:08:37 中国的历史不应该只是王朝的历史，更不应该只是中原王朝或汉族王朝的历史。我们应该站在今天的、中华民族的、客观的立场上看待历史上的一切政权和它们之间的关系，而不能囿于封建的、正统的、汉族的观念。 1154-1155, 标注, 2024 年 9 月 16 日星期一 上午 9:27:20 对中国而言，分裂、分治的时间是主要的，统一的时间是非常短暂的。对中原王朝而言，统一的时间略少于分裂时间。但在元朝之前分裂时间多于统一时间，元朝以后则基本上是统一的。 1159-1162, 标注, 2024 年 9 月 16 日星期一 上午 9:28:18 如果我们联系历史事实来看这套地图的话，那就绝不会只看到简单的色块和杂乱无章的变化，而是兴旺与衰落的交替，建设与毁灭的变换，文明与野蛮的较量，梦想与现实的汇合；数千年的干戈与玉帛，数十对仇敌与兄弟，无数次失败与胜利；多少回扩张和收缩，多少次联合和决裂；终于铸成了这同一颜色的神圣图形。 1903-1886, 标注, 2024 年 9 月 16 日星期一 上午 10:36:59 统一是国家主权和最高行政权力的集中，而不是文化的一致，更不是用一种文化去消灭或代替另一种文化。相反，一个真正稳定繁荣的统一国家，必定会容忍并鼓励多种文化的存在和发展。 2856-2859, 标注, 2024 年 9 月 16 日星期一 上午 10:47:25 昔日的天下的历史完全证明：在统一政权中产生的消极因素和社会弊病的根源并不是统一本身，更不是统一带来的和平安宁和经济繁荣，而是政治制度，或者说是用什么制度来实现统一，如何统一，统一到什么程度。同样，分裂社会中存在的积极因素也不是分裂本身带来的，更不是战争和破坏所能造成的，而是冲击、消弱了旧制度的结果，是外力迫使中央集权制度暂时或局部解体的副产品。 ","date":"2024-10-09","objectID":"/%E7%AC%94%E8%AE%B0%E7%BB%9F%E4%B8%80%E4%B8%8E%E5%88%86%E8%A3%82-%E8%91%9B%E5%89%91%E9%9B%84/:0:0","tags":["tongyiyufenl","note","ireader"],"title":"[笔记]统一与分裂-葛剑雄","uri":"/%E7%AC%94%E8%AE%B0%E7%BB%9F%E4%B8%80%E4%B8%8E%E5%88%86%E8%A3%82-%E8%91%9B%E5%89%91%E9%9B%84/"},{"categories":null,"content":" 1283-1353, 标注, unknown 围在城里的人想逃出来， 城外的人想冲进去， 对婚姻也罢，职业也罢，人生的愿望大都如此。 1408-1462, 标注, unknown 眼睛两条斜缝，眉毛高高在上，跟眼睛远隔得彼此要害相思病 1509-1575, 标注, unknown 忠厚老实人的恶毒，像饭里的砂砾或者出骨鱼片里未净的刺，会给人一种不期待的伤痛。 1622-1657, 标注, unknown 父母在，不言老， 1704-1792, 标注, unknown ；只有国文是国货土产，还需要外国招牌，方可维持地位，正好像中国官吏、商人在本国剥削来的钱要换外汇，才能 保持国币的原来价值 1839-1938, 标注, unknown 葡萄牙人有句谚语说：“运气好的人生孩子，第一胎准是女的。”因为女孩子长大了，可以打杂，看护弟弟妹妹，在未 嫁之前，她父母省得下一个女用人的工钱。 1985-2074, 标注, unknown 假使她没订婚，你有资格得她的爱。刻薄鬼也许要这样解释，她已经另有未婚夫了，你可以享受她未婚夫的权利而不 必履行跟她结婚的义务 2121-2192, 标注, unknown 孙太太眼睛红肿，眼眶似乎饱和着眼泪，像夏天早晨花瓣上的露水，手指那么轻轻一碰就会掉下来。 2246-2337, 标注, unknown 据说“女朋友”就是“情人”的学名，说起来庄严些，正像玫瑰花在生物学上叫“蔷薇科木本复叶植物”，或者休妻的法律 术语是“协议离婚” 2384-2472, 标注, unknown 他们俩虽然十分亲密，方鸿渐自信对她的情谊到此而止，好比两条平行的直线，无论彼此距离怎么近，拉得怎么长， 终合不拢来成为一体 2519-2585, 标注, unknown 张太太上海话比丈夫讲得好，可是时时流露本乡土音，仿佛罩褂太小，遮不了里面的袍子 2632-2710, 标注, unknown 享受了最新的西洋科学设备，而竟抱这种信仰，坐在热水管烘暖的客堂里念佛，可见“西学为用，中学为体”并非难 2764-2879, 标注, unknown 早晨方醒，听见窗外树上鸟叫，无理由地高兴，无目的地期待，心似乎减轻重量，直升上去。可是这欢喜是空的，像 小孩子放的气球，上去不到几尺，便爆裂归于乌有，只留下忽忽若失的无名怅惘。 2926-2974, 标注, unknown 好比杨花在春风里飘荡，而身轻无力，终飞不远 3021-3076, 标注, unknown 他把带到银行里偷空看的书翻开，每个字都认识，没一句有意义 3123-3188, 标注, unknown 诗有出典，给识货人看了，愈觉得滋味浓厚，读着一首诗就联想到无数诗来烘云托月。 3235-3436, 标注, unknown ，从前人不中进士，随你官做得多么大，总抱着终身遗憾。留了学也可以解脱这种自卑心理，并非为高深学问。出洋 好比出痘子，出痧子，非出不可。小孩子出过痧痘，就可以安全长大，以后碰见这两种毛病，不怕传染。我们出过洋， 也算了了一桩心愿，灵魂健全，见了博士硕士们这些微生虫，有抵抗力来自卫。痘出过了，我们就把出痘这一回事忘 了；留过学的人也应说把留学这事忘了 3483-3612, 标注, unknown 女人有女人特别的聪明，轻盈活泼得跟她的举动一样。比了这种聪明，才学不过是沉淀渣滓。说女人有才学，就仿佛 赞美一朵花，说它在天平上称起来有白菜番薯的斤两。真聪明的女人决不用功要做成才女，她只巧妙的偷懒— 3659-3839, 标注, unknown 关于 Bertie 结婚离婚的事，我也和他谈过。他引一句英国古话，说结婚仿佛金漆的鸟笼，笼子外面的鸟想住进去，笼 内的鸟想飞出来；所以结而离，离而结，没有了局。”苏小姐道：“法国也有这么一句话。不过，不说是鸟笼，说是被 围困的城堡 fortresse assiégée，城外的人想冲进去，城里的人想逃出来。 3886-3940, 标注, unknown 不管它鸟笼罢，围城罢，像我这种一切超脱的人是不怕围困的 3987-4088, 标注, unknown 鸿渐身心仿佛通电似的发麻，只知道唐小姐在说自己，没心思来领会她话里的意义，好比头脑里蒙上一层油纸，她的 话雨点似的渗不进，可是油纸震颤着雨打的重量。 4142-4233, 标注, unknown 他个人的天地忽然从世人公共生活的天地里分出来，宛如与活人幽明隔绝的孤鬼，瞧着阳世的乐事，自己插不进，瞧 着阳世的太阳，自己晒不到 4280-4406, 标注, unknown 有人失恋了，会把他们的伤心立刻像叫化子的烂腿，血淋淋地公开展览，博人怜悯，或者事过境迁，像战士的金疮旧 斑，脱衣指示，使人惊佩。鸿渐只希望能在心理的黑暗里隐蔽着，仿佛害病的眼睛避光，破碎的皮肉怕风。 4453-4526, 标注, unknown 他所说的“让她三分”，不是“三分流水七分尘”的“三分”，而是“天下只有三分月色”的“三分”。 4573-4683, 标注, unknown 同乡一位庸医是他邻居，仰慕他的名望，杀人有暇，偶来陪他闲谈。这位庸医在本乡真的是“三世行医，一方尽知”， 总算那一方人抵抗力强，没给他祖父父亲医绝了种，把四方剩了三方 4737-4964, 标注, unknown 你这人真无赖！你倒不说是我自己打鼾，赖在你身上？我只恨当时没法请唱片公司的人把你的声音灌成片子。”假使 真灌成片子，那声气哗啦哗啦，又像风涛澎湃，又像狼吞虎咽，中间还夹着一丝又尖又细的声音，忽高忽低，袅袅不 绝。有时这一条丝高上去、高上去，细得、细得像放足的风筝线要断了，不知怎么像过一个峰尖，又降落安稳下来。 赵辛楣刺激得神经给它吊上去，掉下来，这时候追想起还恨得要扭断鸿渐的鼻子，警告他下次小心。 5011-5238, 标注, unknown 天仿佛听见了这句话，半空里轰隆隆一声回答，像天宫的地板上滚着几十面铜鼓。从早晨起，空气闷塞得像障碍着呼 吸，忽然这时候天不知哪里漏了个洞，天外的爽气一阵阵冲进来，半黄落的草木也自昏沉里一时清醒，普遍地微微叹 息，瑟瑟颤动，大地像蒸笼揭去了盖。雨跟着来了，清凉畅快，不比上午的雨只仿佛天空郁热出来的汗。雨愈下愈大， 宛如水点要抢着下地，等不及排行分列，我挤了你，你拚上我，合成整块的冷水，没头没脑浇下来 5285-5406, 标注, unknown 鸿渐忙叫：“我有个小手电。”打开身上的提箱掏它出来，向地面一射，手掌那么大的一圈黄光，无数的雨线飞蛾见火 似的匆忙扑向这光圈里来。孙小姐的大手电雪亮地光射丈余，从黑暗的心脏里挖出一条隧道。 5453-5617, 标注, unknown ，买到票子的那一堆人全上了车，真料不到小车厢会像有弹性，容得下这许多人。这车厢仿佛沙丁鱼罐，里面的人紧 紧的挤得身体都扁了。可是沙丁鱼的骨头，深藏在自己身里，这些乘客的肘骨膝骨都向旁人的身体里硬嵌。罐装的沙 丁鱼条条挺直，这些乘客都蜷曲波折，腰跟腿弯成几何学上有名目的角度。 5664-5763, 标注, unknown 这是辆病车，正害疟疾，走的时候，门窗无不发抖，坐在车梢的人更给它震动得骨节松脱、腑脏颠倒，方才吃的粳米 饭仿佛在胃里琮跳碰，有如赌场中碗里的骰子 5810-5975, 标注, unknown 这时候，有个三四岁的女孩子两手向头发里乱爬，嚷到那胖女店主身边。胖女人一手拍怀里睡熟的孩子，一手替那女 孩子搔痒。她手上生的五根香肠，灵敏得很，在头发里抓一下就捉到个虱，掐死了，叫孩子摊开手掌受着，陈尸累累。 女孩子把另一手指着死虱，口里乱数：“一，二，五，八，十…… 6022-6148, 标注, unknown 这是暮秋天气，山深日短，云雾里露出一线月亮，宛如一只挤着的近视眼睛。少顷，这月亮圆滑得什么都粘不上，轻 盈得什么都压不住，从蓬松如絮的云堆下无牵挂地浮出来，原来还有一边没满，像被打耳光的脸肿着一边。 6202-6411, 标注, unknown 鸿渐上图书馆找书，馆里通共不上一千本书，老的、糟的、破旧的中文教科书居其大半，都是因战事而停办的学校的 遗产。一千年后，这些书准像敦煌石室的卷子那样名贵，现在呢，它们古而不稀，短见浅识的藏书家还不知道收买。 一切图书馆本来像死用功人大考时的头脑，是学问的坟墓；这图书馆倒像个敬惜字纸的老式慈善机关，若是天道有知， 办事人今世决不遭雷打，来生一定个个聪明、人人博士。 6458-6561, 标注, unknown 现代人有两个流行的信仰。第一：女子无貌便是德，所以漂亮女人准比不上丑女人那样有思想，有品节；第二：男子 无口才，就表示有道德，所以哑巴是天下最诚朴的人。 6608-6683, 标注, unknown 不轻易开口的人总使旁人想他满腹深藏着智慧，正像密封牢锁的箱子，一般人总以为里面结结实实都是宝贝。 6730-6876, 标注, unknown 韩太太虽然相貌丑，红头发，满脸雀斑像面饼上苍蝇下的粪，而举止活泼得通了电似的。鸿渐研究出西洋人丑得跟中 国人不同：中国人丑得像造物者偷工减料的结果，潦草塞责的丑；西洋人丑像造物者恶意的表现，存心跟脸上五官开 玩笑，所以丑得有计划、有作用。 6923-7030, 标注, unknown 事实上，一个人的缺点正像猴子的尾巴，猴子蹲在地面的时候，尾巴是看不见的，直到他向树上爬，就把后部供大众 瞻仰，可是这红臀长尾巴本来就有，并非地位爬高了的新标识。 7077-7170, 标注, unknown 我有一个印象，我们在社会上一切说话全像戏院子的入场券，一边印着‘过期作废’，可是那一边并不注明什么日期， 随我们的便可以提早或延迟。 7217-7421, 标注,","date":"2024-10-09","objectID":"/%E7%AC%94%E8%AE%B0%E5%9B%B4%E5%9F%8E%E6%91%98%E6%8A%84-n-a/:0:0","tags":["weichengzhai","note","ireader"],"title":"[笔记]围城摘抄-N/A","uri":"/%E7%AC%94%E8%AE%B0%E5%9B%B4%E5%9F%8E%E6%91%98%E6%8A%84-n-a/"},{"categories":null,"content":" 388-536, 标注, unknown 当想挑战新事业的时候，大多数人是受到马斯洛需求层次论中前两种需求的驱动，即第四阶段的“尊重需要”（受到他人尊重，对地位的渴望，追求名声、权力、关注等）和第五阶段的“自我实现需要”（最大限度地发挥自己的能力或潜能，完成个人成长，实现个人理想）。 538-618, 标注, unknown 但是我说的控制金钱，并不是让大家“去赚更多的钱”。即使是有限的金钱，我们也可以好好把握，发挥其最大的作用。 ","date":"2024-10-09","objectID":"/%E7%AC%94%E8%AE%B0%E4%B8%BA%E4%BB%80%E4%B9%88%E7%B2%BE%E8%8B%B1%E5%8F%AF%E4%BB%A5%E5%BF%AB%E9%80%9F%E7%A7%AF%E7%B4%AF%E8%B4%A2%E5%AF%8C-n-a/:0:0","tags":["weishenmejin","note","ireader"],"title":"[笔记]为什么精英可以快速积累财富-N/A","uri":"/%E7%AC%94%E8%AE%B0%E4%B8%BA%E4%BB%80%E4%B9%88%E7%B2%BE%E8%8B%B1%E5%8F%AF%E4%BB%A5%E5%BF%AB%E9%80%9F%E7%A7%AF%E7%B4%AF%E8%B4%A2%E5%AF%8C-n-a/"},{"categories":null,"content":" 98-99, 标注, 2019 年 2 月 28 日星期四 下午 10:18:01 在 18 世纪，据称法国王后玛丽·安托瓦尼特（Marie-Antoinette）曾向挨饿的民众说，如果没有面包可吃，何不吃蛋糕呢？ 265-265, 标注, 2019 年 2 月 28 日星期四 下午 10:20:49 契诃夫有一句名言：在第一幕中出现的枪，在第三幕中必然会发射。 265-267, 标注, 2019 年 2 月 28 日星期四 下午 10:21:03 契诃夫有一句名言：在第一幕中出现的枪，在第三幕中必然会发射。纵观历史，如果国王和皇帝手上有了新武器，迟早会禁不住诱惑。但自 1945 年以来，人类已经学会抵抗这种诱惑。比如冷战的第一幕中出现了枪（暗指核武器），却从来没有发射 278-279, 标注, 2019 年 2 月 28 日星期四 下午 11:03:44 就本质而言，恐怖主义就是一种表演。恐怖分子安排一场令人惊恐的暴力演出，抓住我们的想象，让我们以为自己即将再次陷入中世纪时期的那种混乱当中。 280-281, 标注, 2019 年 2 月 28 日星期四 下午 11:04:00 在大多数时候，这种对恐怖主义的过度反应，反而比恐怖主义本身造成的安全威胁更大。 282-284, 标注, 2019 年 2 月 28 日星期四 下午 11:04:23 恐怖分子就像一只想要大闹瓷器店的苍蝇。苍蝇如此弱小，凭一己之力连一只茶杯也挪动不了，于是便找来一头牛，钻到它的耳朵里嗡嗡叫，让牛因为恐惧和愤怒而发狂，从而破坏整个瓷器店。这正是过去 10 年间在中东发生的事情。如果只靠自己，伊斯兰激进组织绝不可能推翻 282-284, 标注, 2019 年 2 月 28 日星期四 下午 11:04:32 恐怖分子就像一只想要大闹瓷器店的苍蝇。苍蝇如此弱小，凭一己之力连一只茶杯也挪动不了，于是便找来一头牛，钻到它的耳朵里嗡嗡叫，让牛因为恐惧和愤怒而发狂，从而破坏整个瓷器店。这正是过去 10 年间在中东发生的事情。如 282-284, 标注, 2019 年 2 月 28 日星期四 下午 11:04:37 恐怖分子就像一只想要大闹瓷器店的苍蝇。苍蝇如此弱小，凭一己之力连一只茶杯也挪动不了，于是便找来一头牛，钻到它的耳朵里嗡嗡叫，让牛因为恐惧和愤怒而发狂，从而破坏整个瓷器店。这正是过去 10 年间在中东发生的事情。 300-301, 标注, 2019 年 2 月 28 日星期四 下午 11:06:30 如果饥荒、瘟疫和战争的发生概率不断减小，必然要有些其他事情成为新的人类议题。我们对此必须慎重考虑，否则很可能在旧战场上全面获胜，却在新战线上措手不及。 309-310, 标注, 2019 年 2 月 28 日星期四 下午 11:07:38 毕竟，人类很少真正知足。每次实现某个成就，人类大脑最常见的反应并非满足，而是想要得到更多。人类总是追求更好、更大、更美味， 315-316, 标注, 2019 年 2 月 28 日星期四 下午 11:08:22 而在提升人性超越挣扎求生的动物性之后，我们现在希望把人类升级为神，让智人化身为神人。 336-338, 标注, 2019 年 2 月 28 日星期四 下午 11:11:08 人类会死亡只有一个原因：人体运行出了点儿技术问题，比如心脏不跳、大动脉被脂肪堵住、癌细胞在肝脏里扩散、病菌在肺里繁殖。到底是什么造成这些技术问题？答案是其他的技术 336-338, 标注, 2019 年 2 月 28 日星期四 下午 11:11:15 人类会死亡只有一个原因：人体运行出了点儿技术问题，比如心脏不跳、大动脉被脂肪堵住、癌细胞在肝脏里扩散、病菌在肺里繁殖。到底是什么造成这些技术问题？答案是其他的技术问题。 352-354, 标注, 2019 年 2 月 28 日星期四 下午 11:12:50 现在只要一出现死亡，诉讼和调查几乎就会自动随之而来。“他们怎么会死？一定是哪里有人做错了！” 绝大多数科学家、医生和学者并不会说自己正在努力实现让人长生不死的梦想，只会说自己正在努力解决这个或那个特定问题。 351-353, 标注, 2019 年 2 月 28 日星期四 下午 11:12:59 如果政府有更好的应对天灾的机制、市政机构运行良好、将领做出更好的军事决策，就能避免死亡。现在只要一出现死亡，诉讼和调查几乎就会自动随之而来。“他们怎么会死？一定是哪里有人做错了！” 358-359, 标注, 2019 年 2 月 28 日星期四 下午 11:13:59 虽然是少数，但已有越来越多的科学家和思想家公开表示，现代科学的代表任务就是要战胜死亡、赋予人类永恒的青春。 363-364, 标注, 2019 年 2 月 28 日星期四 下午 11:14:55 执行官。2015 年 1 月接受采访时，马里斯说：“如果你今天问我，人是否有可能活到 500 岁，我的答案是肯定的。” 372-372, 标注, 2019 年 2 月 28 日星期四 下午 11:15:51 我们已经可以感受到山雨欲来：人类不再平等，不死就在眼前。 379-379, 标注, 2019 年 2 月 28 日星期四 下午 11:17:43 事实上，他们只是达到长生（a-mortal），而不是真正不死（immortal）。这些 379-379, 标注, 2019 年 2 月 28 日星期四 下午 11:17:49 事实上，他们只是达到长生（a-mortal），而不是真正不死（immortal）。 396-397, 标注, 2019 年 2 月 28 日星期四 下午 11:19:23 物理学家马克斯·普朗克（Max Planck）有句名言：科学在一次一次的葬礼中进步。他所说的是，必须等到一个世代离去，新的理论才有机会铲除旧的理论。此种现象绝非科学独有。回想一下你现在 396-397, 标注, 2019 年 2 月 28 日星期四 下午 11:19:28 物理学家马克斯·普朗克（Max Planck）有句名言：科学在一次一次的葬礼中进步。他所说的是，必须等到一个世代离去，新的理论才有机会铲除旧的理论。 404-404, 标注, 2019 年 2 月 28 日星期四 下午 11:20:42 在我看来，在 21 世纪想永葆青春还为时过早， 404-405, 标注, 2019 年 2 月 28 日星期四 下午 11:20:47 在我看来，在 21 世纪想永葆青春还为时过早，现在就抱太大期望大概只会迎来很大的失望。知道自己终将一死并不好过，但如果一心想 404-404, 标注, 2019 年 2 月 28 日星期四 下午 11:20:52 在我看来，在 21 世纪想永葆青春还为时过早，现在就抱太大期望大概只会迎来很大的失望。 404-404, 笔记, 2019 年 2 月 28 日星期四 下午 11:22:24 前面两位也许只是忽悠投资人的 ne。 411-412, 标注, 2019 年 2 月 28 日星期四 下午 11:22:56 事实上，到目前为止，现代医学连自然寿命的一年都还没能延长。现代医学的成功之处，是让我们免于早死，能够完整过完应有的人生。 464-467, 标注, 2019 年 3 月 1 日星期五 上午 7:13:00 就连福利制度，最初也是为了满足国家的利益而设计，而不是为了满足个体的需求。德意志帝国的铁血宰相奥托·冯·俾斯麦于 19 世纪末率先开办国家养老金及社会保障福利，但他的主要目标是确保国民忠诚，而不是增加国民福利。你在 18 岁为国家打仗，在 40 岁愿意纳税，是因为希望到 70 岁的时候能够得到国家的照顾。 468-469, 标注, 2019 年 3 月 1 日星期五 上午 7:57:58 但必须强调，美国《独立宣言》保障的是“追求”幸福的权利，而不是“享有”幸福的权利。 468-470, 标注, 2019 年 3 月 1 日星期五 上午 7:58:05 但必须强调，美国《独立宣言》保障的是“追求”幸福的权利，而不是“享有”幸福的权利。关键的一点是，托马斯·杰斐逊并未要求国家对国民的幸福负起责任，而只是要限制国家的权力。 468-471, 标注, 2019 年 3 月 1 日星期五 上午 7:58:35 但必须强调，美国《独立宣言》保障的是“追求”幸福的权利，而不是“享有”幸福的权利。关键的一点是，托马斯·杰斐逊并未要求国家对国民的幸福负起责任，而只是要限制国家的权力。当时是希望让人能够享有选择的权利，不用受国家监督。 467-471, 标注, 2019 年 3 月 1 日星期五 上午 7:58:42 31 1776 年，除了生命权和自由权以外，美国的开国元勋也把“追求幸福的权利”列为人人不可剥夺的权利。但必须强调，美国《独立宣言》保障的是“追求”幸福的权利，而不是“享有”幸福的权利。关键的一点是，托马斯·杰斐逊并未要求国家对国民的幸福负起责任，而只是要限制国家的权力。当时是希望让人能够享有选择的权利，不用受国家监督。 464-471, 标注, 2019 年 3 月 1 日星期五 上午 7:59:03 就连福利制度，最初也是为了满足国家的利益而设计，而不是为了满足个体的需求。德意志帝国的铁血宰相奥托·冯·俾斯麦于 19 世纪末率先开办国家养老金及社会保障福利，但他的主要目标是确保国民忠诚，而不是增加国民福利。你在 18 岁为国家打仗，在 40 岁愿意纳税，是因为希望到 70 岁的时候能够得到国家的照顾。31 1776 年，除了生命权和自由权以外，美国的开国元勋也把“追求幸福的权利”列为人人不","date":"2024-10-09","objectID":"/%E7%AC%94%E8%AE%B0%E6%9C%AA%E6%9D%A5%E7%AE%80%E5%8F%B2-%E4%BB%A5%E8%89%B2%E5%88%97%E5%B0%A4%E7%93%A6%E5%B0%94%E8%B5%AB%E6%8B%89%E5%88%A9/:0:0","tags":["weilaijiansh","note","ireader"],"title":"[笔记]未来简史-[以色列]尤瓦尔·赫拉利","uri":"/%E7%AC%94%E8%AE%B0%E6%9C%AA%E6%9D%A5%E7%AE%80%E5%8F%B2-%E4%BB%A5%E8%89%B2%E5%88%97%E5%B0%A4%E7%93%A6%E5%B0%94%E8%B5%AB%E6%8B%89%E5%88%A9/"},{"categories":null,"content":" 231-232, 标注, 2020 年 10 月 10 日星期六 下午 9:29:19 作家吴晓波把难以被机器替代的能力，称为“柔软的能力”。目前看上去，有三种能力，机器不大可能实现。 （1）人性化和人格魅力 （2）创意 （3）决策和领导力（即企业家能力 243-244, 标注, 2020 年 10 月 10 日星期六 下午 9:30:35 作为个人来说，人生规划的时候，应该尽量发展这些能力，才能避免与机器“抢工作”。 255-256, 标注, 2020 年 10 月 10 日星期六 下午 9:40:58 你在一个领域钻研多年，都成了专家，突然之间那个领域过时了，你的所学所长没人需要了，那将是怎样的处境？ 254-256, 标注, 2020 年 10 月 10 日星期六 下午 9:41:11 我并不感叹 Flash 这项技术的没落，这也是很正常的事，而是感叹那些从事 Flash 开发的工程师，他们该怎么办呢？你在一个领域钻研多年，都成了专家，突然之间那个领域过时了，你的所学所长没人需要了，那将是怎样的处境？ 260-261, 标注, 2020 年 10 月 10 日星期六 下午 9:43:51 当一种技术消亡的时候，与它相关的工作岗位也就消亡了。这种事情在技术行业特别多，因为技术的升级换代太快了 271-274, 标注, 2020 年 10 月 10 日星期六 下午 9:44:52 一家公司从兴盛到衰败，只要两三年时间，这样的例子太多了。比尔·盖茨一直说“微软离破产只有 18 个月”，意思是说，只要做错一个重大决策，微软很快就会完蛋。作为一个打工者，公司的命运是你无法把控的。你应该做好准备，你服务的公司随时可能收摊。只要进了大公司，职业生涯就安全了，这已经成了一种幻想，而且是很危险的幻想 280-281, 标注, 2020 年 10 月 10 日星期六 下午 9:45:21 “终身学习”这个词完全没错，但是想通过“终身学习”保持职业竞争力，我觉得不太可能。 282-283, 标注, 2020 年 10 月 10 日星期六 下午 9:45:51 程序员，乃至其他很多技术岗位，其实是青春饭。只有底层的技术，还有一些稳定性，越接近应用层，技术的升级换代就越快。你学会一门技术，然后吃上 30 年，这种事情越来越少见了。 387-389, 标注, 2020 年 10 月 10 日星期六 下午 10:05:33 没有学历、技术的人，为了活下去，不是住笼屋就是要工作到半夜，对于他们，最重要的事情是下一顿吃什么，怎么会有时间和精力去思考未来怎么发展？来来去去都在死胡同！ 389-391, 标注, 2020 年 10 月 10 日星期六 下午 10:07:27 每天忙于工作，干到累死，但还是很穷，只能租屋住，没有自己的积蓄，一旦停止工作或者生病在床，生活来源顿时就成问题。田北辰体验的这种人生，社会学家早就注意到了，起名为“穷忙族” 414-414, 标注, 2020 年 10 月 10 日星期六 下午 10:09:37 总的来看，下一代青年不太可能有上一代那么多机会。 430-432, 标注, 2020 年 10 月 10 日星期六 下午 10:10:49 现代科技如此发达，人的寿命越来越长，可是工作又积累不了财富，于是，“清贫青年，流沙中年，下流老人”就成了大多数人必然的命运归宿。 460-462, 标注, 2020 年 10 月 11 日星期日 上午 9:45:20 四年时间足以让一个人在任何领域成为资深业者，甚至专家。可是我们的大学生呢，经过本科四年，不要说领域专家，甚至能力强的学生都寥寥无几。我们的大学制度用了四年时间，培养出了大量一无所长的、迷茫困惑的、市场滞销的年轻人。 484-487, 标注, 2020 年 10 月 11 日星期日 上午 9:54:09 注意，我不是说知识无用，而是说知识（尤其是非学术的知识）不一定要通过大学获得，通过互联网一样可以接受高等教育，而且更高效和便宜。 技术已经成为人类社会发展的主导性力量，学习和教育变得比以往更重要、更关键。 498-500, 标注, 2020 年 10 月 11 日星期日 上午 10:03:53 大学课程是为了那些不知道学什么的人设计的，千万不要因为自己找不到方向，而被这些课程“画地为牢”限制住。你要主动去接触和学习那些自己感兴趣的东西。引用一个网友的话，“你要做的就是自主、跨界、终身学习”。 545-546, 标注, 2020 年 10 月 11 日星期日 上午 10:22:04 想要技术上有造诣，工作经验的积累只是一方面，真正的突破要靠自己业余深造！不然，路就会越走越窄，公司迟早会让你来承担成本，甚至通过摆脱你来降低成本。 580-583, 标注, 2020 年 10 月 11 日星期日 上午 10:25:16 前端编程入门，确实不难，可以短期速成。只要你对计算机有基本的理解，哪怕编程零基础，经过三四个月的培训，也能做出网页和 App。 如果你确实想改行，我觉得，这基本上是一件好事，你应该选择那些更有前景的职业。但问题是，并非每个人都适合编程。现在那么多人一窝蜂学习互联网开发，肯定有人将来会后悔。 597-599, 标注, 2020 年 10 月 11 日星期日 上午 10:26:28 你应该选择那些让你产生最大兴趣和热情的职业。因为未来所有行业，低端的、低技能的岗位都会被机器取代，只有技能最强、最有创造性的人不会被淘汰。兴趣，也只有兴趣，才会让你产生不倦的热情，钻研下去，变得更优秀。 629-630, 标注, 2020 年 10 月 11 日星期日 上午 11:06:09 只是一个负责实现领导意志的技术工人，职责就是根据规格说明书写出代码，其实与一个挖水沟的工人是一样的，从这头挖到那头，仅此而已，从事的都是机械性的工作 633-634, 标注, 2020 年 10 月 11 日星期日 上午 11:06:41 评价骡子的标准是，铁管背得比较多、比较快，评价软件工程师的标准又何尝不是如此呢，都是看是否忠实有效地实现那些外部意志。 761-763, 标注, 2020 年 10 月 11 日星期日 上午 11:47:14 我觉得，每个人都应该想一想，你的雇主如果没有你，是不是就会有重大损失？一个新人或更基层的员工接手你的岗位，他能不能上手，而他要求的报酬又会是多少 857-859, 标注, 2020 年 10 月 11 日星期日 下午 12:19:19 你个人的项目，应该有四分之一会失败，否则就说明你的冒险精神不够。”失败完全可以理解成积极进取的结果，只有生命力充沛的人，才可能会有一次又一次的失败。一味地恐惧失败，只会让自己畏首畏尾，丧失进取心。 867-870, 标注, 2020 年 10 月 11 日星期日 下午 12:20:41 遭受挫折，并不是坏事。因为，人生的最终结果是一个极大值函数（由所有尝试中最成功的一次决定），而不是一个平均值函数。即使现在，我每天在生活中还是会遭到拒绝。朋友想安慰我，但是我却要告诉他：之所以会这样，只是因为我在不停尝试。如果你不是每天被人拒绝，那就说明你的人生目标不够远大。 877-879, 标注, 2020 年 10 月 11 日星期日 下午 12:22:34 通常来说，你应该选择自己最有优势的方面创业，这样才能生产出比别人更好或价格更低的产品/服务。这里的窍门是，你不要站在自己的角度思考问题，而是要站在客户的角度。如果你自己就是客户，什么样的东西最能打动你，让你愿意采购 881-882, 标注, 2020 年 10 月 11 日星期日 下午 12:23:35 他有几条创业建议，我觉得很有启发，可以当作我们的原则 937-939, 标注, 2020 年 10 月 11 日星期日 下午 2:07:34 正确的做法，就是不要在功能上竞争。如果你的产品的核心概念行不通，那就重新定位这个产品，而不是为它添加新功能。 你必须牢记在心，创造一个有竞争力的新产品，不要着眼于它的功能比别人多，而要着眼于它有一个截然不同的市场定位。 你要做的不是添加功能，而是做一个市场定位不同的产品。 950-954, 标注, 2020 年 10 月 11 日星期日 下午 2:08:59 下面是开发新产品时几点可行的做法。 （1）你不是做一个比竞争对手“更好”的产品，而是做一个“不同”的产品。（2）你只提供部分功能，但是很好地满足了用户的需求。（3）如果新产品的市场反响不好，增加新功能并不能解决问题。你应该重新定位你的产品，想想它能向消费者提供哪些不同的价值。（4）在产品设计和推广的每一个环节，都突出它的不同定位。 977-980, 标注, 2020 年 10 月 11 日星期日 下午 2:10:55 你唯一的策略，就是认定一个方向，坚持不懈往下挖，直到挖成。你很可能还是不会找到金子，但是在往下挖的过程中，你可能会找到其他有用的矿物。而且，由于长期地在这个领域奋斗，你会对周围一切极其熟悉，变成这个领域的专家。附近的人遇到各种问题，也会来找你征求意见 1395-1396, 标注, 2020 年 10 月 11 日星期日 下午 5:17:47 迪斯尼乐园总结出来的一条经营原则就是：“如果娱乐节目少一些被动性和纯观赏性，多一些亲身参与，游客就会停留得久一些。 1782-1784, 标注, 2020 年 10 月 11 日星期日 下午 10:27:47 一想到我的寿命只有几十年，我就感到特别难过。倒不是因为我害怕死亡，而是因为我将没有机会看到，未来一千年中各种新奇有趣的新技术 ","date":"2024-10-09","objectID":"/%E7%AC%94%E8%AE%B0%E6%9C%AA%E6%9D%A5%E4%B8%96%E7%95%8C%E7%9A%84%E5%B9%B8%E5%AD%98%E8%80%85-%E9%98%AE%E4%B8%80%E5%B3%B0/:0:0","tags":["weilaishijie","note","ireader"],"title":"[笔记]未来世界的幸存者-阮一峰","uri":"/%E7%AC%94%E8%AE%B0%E6%9C%AA%E6%9D%A5%E4%B8%96%E7%95%8C%E7%9A%84%E5%B9%B8%E5%AD%98%E8%80%85-%E9%98%AE%E4%B8%80%E5%B3%B0/"},{"categories":null,"content":" 520-851, 标注, unknown 客观地说，当今中国的经济和科技发展水平，不但比不了美国，而且连 20 世纪 80 年代正在崛起中的日本都比不了。当时日本已经有索尼、 夏普、丰田、本田、东芝、佳能、尼康等一系列拥有自己的核心技术、自己的设计、自己的品牌，且受到全世界消费者追捧的公司。日本 曾经在芯片上把美国打到近乎绝望。就连韩国，早在一二十年前，也已经有了三星、LG、现代这样的全球知名企业。而当今中国除了华为 和字节跳动，全球品牌还很少，独家技术也很少。中国排在前列的大公司都是像石油、银行、电网和电信这些国有企业，一些国产品牌只 在中国能做到家喻户晓。中国经济体量大、数字好看，而我们的真实经济实力，特别是创新能力，距离发达国家还很远。 898-1085, 标注, unknown 如果让政府主导创新，那就不是创新。政府就不是一个创新部门。创新，首先是有风险的事情，需要奇思妙想，需要你在各个方向自由探 索。创新意味着浪费，意味着对现有格局的颠覆，意味着无情的破产和淘汰……这些都不是政府喜欢的。政府做事总是求稳、求保守、 不冒险。我们整天说创新，殊不知谈创新不谈风险、不谈颠覆的，都是伪创新。 1132-1235, 标注, unknown 不被卡脖子的正确做法不是独立自主，而是让自己变得更值得依赖，让包括美国在内的全世界不得不依赖我们，以此跟美国讨价还价，若 你要再敢卡我脖子我就卡你脖子。 1282-1342, 标注, unknown 所以要做好本手，等待妙手，而且还得注意少用那些光花钱不办事的俗手。 1406-1514, 标注, unknown 1969 年，桑德斯成立了自己的芯片公司 AMD。此后 30 年的大部分时间里，他都在与英特尔就知识产权纠纷进行法律斗争。他向一名记者承认：“我不能逃避战斗。” 1561-1760, 标注, unknown 日本的社会结构倾向于产生大量储蓄，因为战后的婴儿潮和向独生子女家庭的迅速转变，造成了大量中年家庭专注于为退休储蓄。日本不 健全的社会安全网进一步刺激了储蓄。与此同时，对股票市场和其他投资的严格限制让人们别无选择，只能将储蓄存入银行账户。结果， 银行存款充裕，以低利率发放贷款，因为人们手头有太多现金。日本公司的债务比美国同行多，但借贷利率较低。 1824-2199, 标注, unknown 盛田昭夫起初发现他的美国朋友所代表的权力和财富很诱人。但随着美国从一场危机走向另一场危机，基辛格和彼得森等人周围的气场开始减弱。他们国家的制度不起作用，但日本的制度起了作用。到了 20 世纪 80 年代，盛田昭夫意识到了美国经济和社会的深层次问题。长期以来，美国一直把自己视为日本的老师，但盛田昭夫认为，美国在应对不断增长的贸易逆差和高科技行业的危机时，应该吸取教训。盛田昭夫讲道，美国在“忙着培养律师”，日本则在“忙着培养工程师”。相比美国的企业高管们过于关注“今年的利润”，日本企业管理层更关注“长期”的利润。美国的劳资关系等级分明，并且“老派”，企业没有对车间员工进行足够的培训或激励。盛田昭夫认为，美国人应该停止抱怨日本的成功。他认为是时候告诉自己的美国朋友们了：日本的体制运行得更好。 2244-2614, 标注, unknown 眼熟不？！ * 22 颠覆英特尔 格鲁夫在他的畅销书《只有偏执狂才能生存》中，描述了他的管理哲学：“担心竞争、担心破产、 担心被人误解、担心丢掉工作，这些担忧都是强大的动力。” #+END_QUOTE * 35 “真正的男人要有晶圆厂” # note_md5: 4ae5c52e194667166232c6688b3a2cee #+BEGIN_QUOTE 戴劳力士表、开劳斯莱斯车、创立 AMD 的杰瑞·桑德斯喜欢把拥有一家半导体晶圆厂比作在游泳池里养一条宠物鲨鱼。鲨鱼的饲养成本很高， 需要时间和精力来维持，最终还可能会害死你。即便如此，桑德斯仍然确信一件事：他永远不会放弃自己的晶圆厂。 2677-2790, 标注, unknown 一个对不可能实现的技术疯狂下注的时代正被更有组织、专业化和合理化的东西取代。抵押房子式的赌博被经过仔细计算的风险管理取代。 在这一过程中，人们很难摆脱失去了一些东西的感觉。 2856-3259, 标注, unknown 对于中国来说，从机械到软件，在供应链的许多部分缺乏竞争性企业，技术独立更为困难。为了实现技术完全独立，中国需要获得尖端的 设计软件、设计能力、先进材料和制造技术等。毫无疑问，中国将在其中一些领域取得进展，但有些领域的成本太高，难以复制。设想一 下复制一台阿斯麦的 EUV 光刻机需要什么，这台机器花了近 30 年的时间来开发和商业化。EUV 光刻机具有多个部件，这些部件本身构成了极 其复杂的工程挑战。在 EUV 光刻机系统中，复制光源需要完美识别和组装 457329 个零件。一个单一的缺陷可能会导致严重的延迟或可靠性 问题。即使已经获得了阿斯麦的设计规范，这种复杂的机器也不能像文件一样简单地复制和粘贴。即使有接触专业信息的机会，也需要一 位熟悉科学的光学或激光博士。即使有这样的人才，可能仍然缺乏开发 EUV 光刻机的工程师们 30 年来积累的经验。 ","date":"2024-10-09","objectID":"/%E7%AC%94%E8%AE%B0%E8%8A%AF%E7%89%87%E6%88%98%E4%BA%89_%E4%B8%96%E7%95%8C%E6%9C%80%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF%E7%9A%84%E4%BA%89%E5%A4%BA%E6%88%98-n-a/:0:0","tags":["xinpianzhanz","note","ireader"],"title":"[笔记]芯片战争_世界最关键技术的争夺战-N/A","uri":"/%E7%AC%94%E8%AE%B0%E8%8A%AF%E7%89%87%E6%88%98%E4%BA%89_%E4%B8%96%E7%95%8C%E6%9C%80%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF%E7%9A%84%E4%BA%89%E5%A4%BA%E6%88%98-n-a/"},{"categories":null,"content":" 76-76, 标注, 2024 年 9 月 18 日星期三 下午 6:33:01 家有房屋千栋，瞓觉只得三尺。 288-289, 标注, 2024 年 9 月 19 日星期四 上午 7:53:07 “五更三点皇登殿”，是赶早朝的皇帝。下半句是“一世夫妻半世床”，说的便是茶楼的点心师傅，早早起身，不可贪恋床榻家眷。 379-382, 标注, 2024 年 9 月 19 日星期四 上午 8:11:35 可是爆得好不好，全看一个分寸。你瞧这叉烧包，像不像一尊弥勒佛。为什么人人都喜欢弥勒，是因为他爱笑。可是呢，这笑要连牙齿都不露出点，总让人觉得不实诚，收收埋埋。但要笑得太张扬，让人舌头根儿都看见，那又太狂妄无顾忌了。所以啊，好的叉烧包，就是要“爆”开了口，恰到好处。这香味出来了，可又没全出来。让人入口前，还有个想头，这才是真的好。 386-388, 标注, 2024 年 9 月 19 日星期四 上午 8:12:12 他只觉得，自己是个没什么主张的人。没主张或许是因为没来历，把他放在哪里，他便落在了哪里，长在哪里。生了根，发了芽；若是把他拔起来，再落到其他地方。疼是疼一时。慢慢地，也就再生出新根，发了芽，渐渐长出枝叶了。 1066-1066, 标注, 2024 年 9 月 19 日星期四 下午 7:05:02 踏花归来马蹄香”。 1544-1547, 标注, 2024 年 9 月 20 日星期五 上午 8:01:54 他要吃的萝卜糕，可是要费上半天工夫。往日这“私伙”糕都由来婶炮制。先用瑶柱煎水，弃瑶柱留汁煮萝卜。再煎香两条鲮鱼，拣骨留茸，爆香冬菇腊肠，拌入萝卜同煮，掺入黏米粉才上笼蒸。这糕用粉少故而稀削，煎也极需耐性。出炉自然独沽一味，美不见料，软糯清鲜。 1787-1790, 标注, 2024 年 9 月 20 日星期五 下午 6:23:57 阿响看到了成片的果树。都是繁茂的，枝条烂漫地生长，树冠次第地联结着。在一个孩子的眼中，像是一望无垠的绿海。他不禁有些激动。初夏阳光下，那绿也并不是清一色的，有着层叠的深浅与明暗。刚生出的嫩芽，近于鹅黄。而那长有时日的，则黑油油的，闪烁着略艳异的光彩。 1793-1795, 标注, 2024 年 9 月 20 日星期五 下午 6:25:21 阿响静静地听，心里有一种别样的憧憬。他在五小姐的眼睛里，看到的，是一种慧生在看他时常有的光。那是一个母亲，在对旁人提及自己的孩子时，有些羞怯但又急于表达的神情。 1812-1812, 标注, 2024 年 9 月 20 日星期五 下午 6:28:32 譬如朝露，去日苦多。” 2518-2519, 标注, 2024 年 9 月 21 日星期六 上午 8:45:54 一想，或许是一方水土一方人，当味觉留下了记忆后，如烙印一般，会在乡情炽燃间愈见清晰、强烈。一切只是源于一条饥饿的舌头。 3220-3223, 标注, 2024 年 9 月 21 日星期六 上午 9:47:37 去了莲心，少了苦头。它还是一颗不服气的硬莲子。 叶七叹一口气，说，至重要的，还是一个“熬”字。 阿响定定地看着师父。看他执起一颗莲子，对着光，说，这些年，就是一个“熬”字。深锅滚煮，低糖慢火。这再硬皮的湘莲子，火候到了，时辰到了，自然熬它一个稔软没脾气。 3729-3730, 标注, 2024 年 9 月 21 日星期六 上午 10:52:25 每临大事有静气，不信今时无古贤。” 3869-3871, 标注, 2024 年 9 月 21 日星期六 上午 11:11:54 宋子游则遗下名言：“我要证明文章有价。再过三五十年，没有人会记得那些股票、黄金、钱财，世界大事都只是过眼烟云，可是一个好的剧本，过了五十年、一百年，依然有人欣赏，就算我死了，我的名字我的戏，没有人会忘记。这就叫作文章有价。” 4154-4157, 标注, 2024 年 9 月 21 日星期六 上午 11:44:45 盐是百味之宗，又能调百味之鲜。莲蓉是甜的，我们便总想着，要将这甜，再往高处托上几分。却时常忘了万物有序，相左者亦能相生。好比是人，再锦上添花，不算是真的好。经过了对手，将你挡一挡，斗一斗，倒斗出了意想不到的好来。盐就是这个对手，斗完了你，成全了你的好，将这好味道吊出来。它便藏了起来，隐而不见。 4510-4512, 标注, 2024 年 9 月 21 日星期六 下午 10:47:26 他这才蹲下来，烧纸钱。火旺一些，火焰里头，饱满的元宝，一点点地干瘪了。继而发黑、发灰、发白，成为余烬。热力将这灰烬激荡了起来，飞舞到了空中，像是一些碎裂的蝴蝶翅膀。 5451-5452, 标注, 2024 年 9 月 23 日星期一 上午 7:46:10 在火车站人挨着人睡了一晚。戴得记得人汗熏蒸的异味，还有一碗火车站售卖的豆腐花的味道。 5474-5476, 标注, 2024 年 9 月 23 日星期一 上午 7:47:34 这小一年来，因为各自都忙着做工，家中是粗食淡饭惯了。用大锅炒上一顿辣酱，用罐子装好，便可以给孩子们大半个星期的下饭菜。家里若有谁生了病没胃口，给做上一碗烂糊肉丝面，便是格外的照料了。 5493-5494, 标注, 2024 年 9 月 23 日星期一 上午 7:49:40 本帮的红烧肉，原有十六字的秘诀，叫“肥而不腻，甜而不黏，酥而不烂，浓而不咸”。 5607-5613, 标注, 2024 年 9 月 23 日星期一 上午 8:00:11 今天是我这老哥哥的忌日。小辰光我们在十六铺学生意。乡下来的，饭量大得很。可挣的饭钱只够一客蛋炒饭，一碗黄豆骨头汤。吃完了不够，到夜里照样饿得肚皮乱叫。我这哥哥就说，将来发达了，要将这黄豆汤喝个够。他对我说，以后做人啊，就如这汤，表面生不见底，里头可已经熟透了。哥哥一辈子的时间都花在做人上。后来我们有钱了，有势力了。人也老了，来了香港，又想起了这口。老哥哥就请来了上海德兴馆名厨汤水福，专给我们做黄豆汤。他小心翼翼地做。可是，我们却怎么也吃不出当年的味道了。想不到，如今他走了二十年。这味道，却被你做出来了。 6104-6106, 标注, 2024 年 9 月 23 日星期一 下午 6:46:28 心里却如期而至地痛起来。他把牌放下，木木地坐着。过了一会儿，才叹一口气，阖上眼睛，只由那痛一点点地蔓延。自从凤行走后，日日如此。原来是尖锐的疼痛，就是在心尖上疼，痛不欲生。现在这疼渐渐地钝了。他便也不再抗拒， 6104-6107, 标注, 2024 年 9 月 23 日星期一 下午 6:46:35 心里却如期而至地痛起来。他把牌放下，木木地坐着。过了一会儿，才叹一口气，阖上眼睛，只由那痛一点点地蔓延。自从凤行走后，日日如此。原来是尖锐的疼痛，就是在心尖上疼，痛不欲生。现在这疼渐渐地钝了。他便也不再抗拒，由着它去。也就成了日常，朝夕与他问候。 6228-6231, 标注, 2024 年 9 月 23 日星期一 下午 7:00:14 大兵摇摇晃晃地站起来，起了个调门儿，唱：四大红，杀猪的盆，庙上的门，大姑娘裤裆，火烧云；四大娇，木匠斧子，瓦匠刀，跑腿子行李，大姑娘腰；四大白，天上雪，地下鹅，大姑娘屁股，亮粉坨；四大嫩，黄瓜扭儿，嫩豆角，大姑娘妈妈，小孩鸟…… 6390-6393, 标注, 2024 年 9 月 23 日星期一 下午 9:21:32 各色酒吧，更是聚集着本地与外籍的酒女郎，她们刻意地性感妖冶，目光在街面的人群中睃巡，如同暗夜中的猎手。甫一上岸时饥馑的水兵，或者是心思游离的游客，有的是上好的猎物。她们目光如炬。但一旦与某个男人的眼神撞击、呼应，那眼风便立刻绵软下来，带着一些委屈与柔弱，却如同鱼钩，一点点地收线。让对方终于欲念炽烈，见他们如圈中羔羊，一切便功德圆满。 6895-6898, 标注, 2024 年 9 月 24 日星期二 上午 7:57:33 外面风声尖厉，打着呼哨。拍打在窗户上，砰砰作响。五举望见一棵洋紫荆，给刮得东倒西歪，风里头，幼细的枝条忽然断了。像是个垂死的人，头发被无形的力量拉扯着。树叶纷纷被风撕下来，未及落地，已高高扬起，一忽儿不见了踪迹。 6924-6924, 标注, 2024年9月24日星期二 上午7:59:35 人世走一遭，总是辛苦的。 ","date":"2024-10-09","objectID":"/%E7%AC%94%E8%AE%B0%E7%87%95%E9%A3%9F%E8%AE%B0-%E8%91%9B%E4%BA%AE/:0:0","tags":["yanshiji","note","ireader"],"title":"[笔记]燕食记-葛亮","uri":"/%E7%AC%94%E8%AE%B0%E7%87%95%E9%A3%9F%E8%AE%B0-%E8%91%9B%E4%BA%AE/"},{"categories":null,"content":" 328-330, 标注, 2020 年 2 月 14 日星期五 下午 11:17:25 以色列地是世界的中心；耶路撒冷是以色列的中心；圣殿是耶路撒冷的中心；至圣之所是圣殿的中心；神圣约柜[1]是至圣之所的中心；而奠定这个世界的基石就矗立在神圣约柜的前方。 363-364, 标注, 2020 年 2 月 15 日星期六 下午 10:20:35 耶路撒冷是一座不属于任何人的城市，但它又存在于每个人的想象中，这是这座城市的悲剧，也是它的魅力所在。 365-369, 标注, 2020 年 2 月 15 日星期六 下午 10:22:12 每个人都怀着对真实耶路撒冷的美好想象来到这里，然而呈现在他们眼前的耶路撒冷使他们大失所望。他们看到的是一个兴旺过，萎缩过，被重建、被摧毁过许多次的不断变化的城市。但这是耶路撒冷，是所有人的财富，只有他们心中的耶路撒冷才是真正的耶路撒冷，所以那些被玷污、被合成的现实必须被改变；每个人都有权把自己心目中的“耶路撒冷”强加到现实的耶路撒冷之上——而实现这一梦想的手段，通常就是使用他们手中的火与剑。 375-376, 标注, 2020 年 2 月 15 日星期六 下午 10:23:54 圣城”这个词经常被用来表达对它的圣迹的敬畏，但它真正的意思是耶路撒冷已成为人在尘世间与上帝交流的必要场所。 382-383, 标注, 2020 年 2 月 15 日星期六 下午 10:25:16 神圣性为许多无神论游客所厌恶，在他们看来，耶路撒冷弥漫着自以为是的盲从，迷信像流行病一样折磨着整个城市。 382-383, 标注, 2020 年 2 月 15 日星期六 下午 10:25:22 这种神圣性为许多无神论游客所厌恶，在他们看来，耶路撒冷弥漫着自以为是的盲从，迷信像流行病一样折磨着整个城市。 390-392, 标注, 2020 年 2 月 15 日星期六 下午 10:27:19 死亡是我们永恒的伴侣。长久以来，朝圣者为了死在耶路撒冷、葬在圣殿山周围、为末日来临时的复活做准备而前往耶路撒冷，他们还在继续前来。这座城市被墓地包围并且建在墓地之上。古代圣徒的干枯躯体备受尊崇—— 433-434, 标注, 2020 年 2 月 15 日星期六 下午 10:34:03 尘世之城与天堂之城的差别是如此令人难以接受，以至于每年都有一百名病人进入这座城市的精神病院，所患之病是“耶路撒冷综合征”，一种由期望、失望和幻觉组成的精神病。 447-448, 标注, 2020 年 2 月 15 日星期六 下午 10:35:57 在耶路撒冷，真相通常远不如神话重要。“在耶路撒冷，不要问我真相的历史，”巴勒斯坦著名历史学家纳兹米·朱贝（Nazmi al-Jubeh）博士如此说，“若拿走虚构的故事，耶路撒冷就一无所有了。” 474-475, 标注, 2020 年 2 月 15 日星期六 下午 10:40:59 真相有许多层。其他宗教和其他时代的信仰对我们来说似乎很陌生，而我们所处的时代和地方为人熟知的习俗通常看起来都颇为合理。 474-477, 标注, 2020 年 2 月 15 日星期六 下午 10:41:28 真相有许多层。其他宗教和其他时代的信仰对我们来说似乎很陌生，而我们所处的时代和地方为人熟知的习俗通常看起来都颇为合理。就连被许多人认为世俗理性和常识已发展至顶峰的 21 世纪，也有它自己的传统智慧和类宗教的正统，而这些智慧和正统对我们的后辈来说或许是不可思议的荒谬。 669-669, 标注, 2020 年 2 月 16 日星期日 下午 10:08:09 投降时，提图斯将他们处死，理由是“祭司应该和他们的 1016-1017, 标注, 2020 年 2 月 18 日星期二 下午 10:47:28 在统一以色列、把耶路撒冷建设成上帝之城后，大卫走完了他不平凡的一生。临死前，他命令所罗门在摩利亚山上建造圣殿。 1193-1194, 标注, 2020 年 2 月 19 日星期三 下午 11:04:00 拥有耶路撒冷是神圣和体面的事情，但如果一切都失去了，“耶路撒冷也被毁了”， 1218-1221, 标注, 2020 年 2 月 19 日星期三 下午 11:08:13 [1]城里到处是从垮台的北方王国涌来的难民，他们可能随身携带着有关早期以色列历史和传说的古老卷轴。耶路撒冷的学者开始将犹地亚传统和北方部落传统融合在一起。这些像希腊人记录荷马史诗《伊利亚特》那样写成的卷轴，最终成为《圣经》。 1437-1438, 标注, 2020 年 2 月 22 日星期六 下午 10:10:14 流亡者称巴比伦是“世上的淫妇和一切可憎之物的母”，这一称呼流传千古， 1473-1476, 标注, 2020 年 2 月 22 日星期六 下午 10:40:15 波斯的米底国王阿斯提阿格斯（Astyges）做了一个梦，梦见他的女儿尿出一条金色小溪，这条小溪向他的王国奔流而来。他的魔术师，就是波斯祭司们，解释说这意味着他的外孙将威胁他的统治。阿斯提阿格斯把女儿嫁给一个软弱的、不具威胁的邻居——东方的安善国王。这场婚姻孕育了一个名叫库罗什的继承人，他就是后来的居鲁士大帝。 1525-1529, 标注, 2020 年 2 月 22 日星期六 下午 10:47:09 波斯那边，七个叛乱贵族在马背上聚首，谋划夺取帝国大权。由于还未决定谁将成为他们的国王，于是他们同意，拂晓过后“谁座下的马第一个嘶鸣谁就获得王位”。其中一个贵族世家的年轻子弟、冈比西斯的执矛护卫大流士（Darius）的马第一个嘶鸣。希罗多德称大流士作弊了：大流士命令他的马夫把手指伸进一匹母马的阴道，然后马夫在关键时刻让大流士的马闻到一股致其兴奋的气味。希罗多德激动地将一个东方专制君主的崛起归功于那只激发性欲的妙手。 1562-1563, 标注, 2020 年 2 月 22 日星期六 下午 10:56:53 但是大流士达到了他的极限。公元前 490 年，他试图进军希腊，但在马拉松战役中被打败，此后不久就去世了。 1719-1720, 标注, 2020 年 2 月 23 日星期日 下午 9:55:12 神权国家”——这个词是由历史学家约瑟夫斯创造的，用来描述这个“整个国家主权和所有统治权威都掌握在上帝手里”的小国。 1724-1724, 标注, 2020 年 2 月 23 日星期日 下午 9:59:04 圣殿是犹太生活的中心： 2037-2038, 标注, 2020 年 2 月 24 日星期一 下午 10:04:04 帕提亚国王奥拉德二世在观看一出希腊戏剧时，克拉苏的头被扔到舞台上。奥拉德将熔化的黄金倒进克拉苏的嘴里，并对着这颗头颅说：“现在你满足了吧。” 2229-2229, 标注, 2020 年 2 月 25 日星期二 下午 10:57:27 屋大维成为罗马的第一任皇帝，他采用了“奥古斯都”这个名字。 2437-2438, 标注, 2020 年 2 月 26 日星期三 下午 8:57:48 没有证据证明希律曾听说过耶稣或屠杀过新生儿。具有讽刺意味的是，这个恶魔竟然因为他未犯之罪而被特别记住。 2565-2566, 标注, 2020 年 2 月 26 日星期三 下午 10:12:43 当世界终结时，“人子将坐在他的荣耀宝座上”，所有的民族聚集在他面前，听候审判。恶人得永罚，义人得永生。 2557-2560, 标注, 2020 年 2 月 26 日星期三 下午 10:12:59 在这个在一部分人看来可怕而激进的愿景中，耶稣本人作为神秘的半弥赛亚性质的“人子”将起到核心作用。“人子”是《以赛亚书》和《但以理书》中的一个词：“人子要差遣使者，把一切叫人跌倒的和作恶的，从他国里挑出来，丢在火炉里，在那里必要哀哭切齿了。那时义人在他们父的国里，要发出光来。” 2554-2557, 标注, 2020 年 2 月 26 日星期三 下午 10:13:14 十二门徒（包括他的弟弟雅各）的支持下，耶稣再次出现在加利利老家，一边用他巧妙的、朴素的方式（经常使用寓言）宣扬“好消息”，一边向南行走。他传播的信息是直接而激动人心的：“天国近了。你们应当忏悔。”耶稣没有留下任何著作，他的教义被人们没完没了地分析，但四部福音书揭示，他传道生涯的精髓在于对即将来临的世界末日——最后审判——和天国的预言。 2592-2592, 标注, 2020 年 2 月 26 日星期三 下午 10:16:32 七纱舞的传说 2640-2641, 标注, 2020 年 2 月 27 日星期四 下午 9:47:58 利赛人界定为耶稣的敌人，这可能反映了十五年后福音书作者们写书时的情况。法利赛人更加灵活、 2772-2773, 标注, 2020 年 2 月 27 日星期四 下午 10:10:03 从受害人身上取下的铁钉一般会被犹太人和非犹太人当作饰品挂在脖子上，用作抵挡疾病。后来基督徒对十字架纪念品的痴迷实际上是这一悠久传统的延续。 3074-3076, 标注, 2020 年 2 月 29 日星期六 下午 10:09:13 保罗的“耶路撒冷”是天国，而不是现实中的圣殿；他的“以色列”是耶稣的任何一个信徒，而不是犹太民族。他在某些方面出奇地新潮，与古代世界的残酷特质不同，他信奉爱、平等和包容：希腊人和犹太人，女人和男人，所有人都是一体的，所有人都能够通过信仰基督获得救赎。 3558-3559, 标注, 2020 年 2 月 29 日星期六 下午 11:03:54 他用代表耶稣基督的符号，希腊语中“基督”（Christ）一词的前两个字母（ChiRho），装饰士兵的盾牌。 3803-3804, 标注, 2020","date":"2024-10-09","objectID":"/%E7%AC%94%E8%AE%B0%E8%80%B6%E8%B7%AF%E6%92%92%E5%86%B7%E4%B8%89%E5%8D%83%E5%B9%B4-sobooks/:0:0","tags":["yelusalengsa","note","ireader"],"title":"[笔记]耶路撒冷三千年-SoBooKs.cc 西蒙·蒙蒂菲奥里","uri":"/%E7%AC%94%E8%AE%B0%E8%80%B6%E8%B7%AF%E6%92%92%E5%86%B7%E4%B8%89%E5%8D%83%E5%B9%B4-sobooks/"},{"categories":null,"content":" 501-570, 标注, unknown 历史学家们总是这样告诫读者：历史总是有许多随机的扭曲和转折，很少循着一个有序的设定。 617-723, 标注, unknown 多年以后，蓦然回首，对这段历史的最好总结也许正如诗人芙茹弗·法洛克扎德（Forough Farrokhzad）所说的那样：“在回忆的花园中一 次悲伤的漫步。” 778-905, 标注, unknown 希腊人把波斯人称为“野蛮人”（barbaros）。这个词最初的意思是指“异族人”，更具体地说，是指喃喃自语、不知所云的人。这大概是因 为希腊人不懂伊朗语，无论是古波斯语还是阿拉姆语（Aramaic）。 ","date":"2024-10-09","objectID":"/%E7%AC%94%E8%AE%B0%E4%BC%8A%E6%9C%97%E4%BA%94%E7%99%BE%E5%B9%B4-n-a/:0:0","tags":["yilangwubain","note","ireader"],"title":"[笔记]伊朗五百年-N/A","uri":"/%E7%AC%94%E8%AE%B0%E4%BC%8A%E6%9C%97%E4%BA%94%E7%99%BE%E5%B9%B4-n-a/"},{"categories":null,"content":" 97-98, 标注, 2019 年 5 月 31 日星期五 上午 8:59:32 所谓伊斯兰化是一个不可逆转的过程。这种完全封闭自成一体，依靠屠杀和生殖进行扩张的宗教，但凡成势，基本无法根除。 30-30, 标注, 2019 年 5 月 31 日星期五 上午 9:01:15 但凡破落户的不肖子孙，往往对于祖上的荣光都特别重视，张口就是上下几千年。 128-129, 标注, 2019 年 5 月 31 日星期五 上午 9:04:23 不要西方、不要东方，只要伊斯兰”的口号响彻伊朗，和文明世界全面对立的神权模式从此开启。 128-129, 标注, 2019 年 5 月 31 日星期五 上午 9:04:32 ，“不要西方、不要东方，只要伊斯兰”的口号响彻伊朗，和文明世界全面对立的神权模式从此开启。 138-140, 标注, 2019 年 5 月 31 日星期五 上午 9:06:00 这种全然不顾国家实际利益得失，只靠宗教意识形态来决定大政方针的态度，看似儿戏一般，实则是原教旨的必然。他安身立命的东西，就是树立各种各样的敌人，鼓动仇恨，或者说仇恨就是他最根本的利益所在。这一点，我们怕也是深有体会的。 146-149, 标注, 2019 年 5 月 31 日星期五 上午 9:06:56 人民是创造历史的主体不假，但人民的选择却不一定是正确的。在群体性的癫狂之中，人民更多的是一个个随波逐流的水滴，不懂方向，也难辨是非，极易受到霍梅尼之类的打着诱人的信仰旗号的革命灵修蛊惑，欣然接受他们画出来的人人均贫富的大饼。这样的人民，不吃一点亏，恐怕真的对不起他们。 197-197, 标注, 2019 年 5 月 31 日星期五 上午 9:10:16 川建国 ","date":"2024-10-09","objectID":"/%E7%AC%94%E8%AE%B0%E4%B8%AD%E4%B8%9C%E6%B7%B7%E4%B8%8D%E5%90%9D%E4%BC%8A%E6%9C%97%E6%98%AF%E6%80%8E%E4%B9%88%E8%B5%B0%E5%88%B0%E4%BB%8A%E5%A4%A9%E7%9A%84-kindle@eub-inc/:0:0","tags":null,"title":"[笔记]中东混不吝｜伊朗是怎么走到今天的-kindle@eub-inc.com","uri":"/%E7%AC%94%E8%AE%B0%E4%B8%AD%E4%B8%9C%E6%B7%B7%E4%B8%8D%E5%90%9D%E4%BC%8A%E6%9C%97%E6%98%AF%E6%80%8E%E4%B9%88%E8%B5%B0%E5%88%B0%E4%BB%8A%E5%A4%A9%E7%9A%84-kindle@eub-inc/"},{"categories":null,"content":" 170-171, 标注, 2020 年 6 月 1 日星期一 下午 10:27:36 要搞清楚一门学科的本质，认真研究该学科的开创者的想法是一条可行的路径。 181-185, 标注, 2020 年 6 月 1 日星期一 下午 10:31:25 1522 年，有人提议改进法定路德（杆）的确定方法。如图 1–1 所示，当人们从教堂鱼贯而出时，将排成一列的 16 个人的脚的总长度设定为法定路德。[4]从图 1–1 可以看出，这些人的脚长度不一，但通过一群人来设定这个长度单位具有明显的平均效应，因此很多人接受了这个方法。不过，当时似乎还没有人明确提出平均数这个概念。 308-308, 标注, 2020 年 6 月 2 日星期二 下午 9:39:01 期望值是测算价值的正确方法。 318-319, 标注, 2020 年 6 月 2 日星期二 下午 9:40:26 阿布斯诺特引入了在确定的环境中如何正确认识概率的问题。他给出的答案是：概率是人类无知的产物。 321-324, 标注, 2020 年 6 月 2 日星期二 下午 9:41:05 抛硬币是一种有规律可循的物理现象，而不是随机的！为了证明这一点，我们请物理系为我们制造了一台抛硬币机。如图 1–3 所示，在弹簧被松开之后，停留在弹簧上的硬币一边翻转，一边弹起，然后落在一只杯子里。因为弹簧的力量是受控的，所以硬币落下后总是同一面朝上。这个结果令人发自内心地感到不安（本书的两名作者也不例外），魔术师和不诚实的赌徒（包括本书的一位作者）都具有这样的技能。 5065-5066, 标注, 2020 年 6 月 4 日星期四 上午 1:44:58 协约国对奥斯曼帝国领土的划分忽略了种族、宗派和部族差异，因此衍生了一系列严重后果。 7960-7961, 标注, 2020 年 6 月 7 日星期日 下午 10:09:54 杨振宁先生说过：物理做到极致，就会诉诸哲学；哲学做到极致，就会诉诸宗教。 8005-8007, 标注, 2020 年 6 月 7 日星期日 下午 10:16:41 “没有矛盾和佯谬，就不可能有科学的进步。绚丽的思想火花往往闪现在两个同时并存的矛盾的碰撞切磋之中。因此我们教学生、学科学，就得让学生有‘危机感’，学生才觉得自己有用武之地。否则，学生只会看见物理学是一座完美无缺的大厦，却没有问题，还研究什么呢？ 8027-8030, 标注, 2020 年 6 月 7 日星期日 下午 10:18:19 量子力学也能够用于宏观世界，不过，在处理上述宏观问题时，使用量子力学方法会令计算过程极为烦琐，而运用更为简单方便的牛顿三大定律也能达到我们需要的精度。正所谓“杀鸡何须用牛刀”，所以我们刚才强调，量子力学是大多用于微观世界的物理规律。 8179-8180, 标注, 2020 年 6 月 8 日星期一 下午 10:04:39 二象性就是说，我们从不同的角度观察事物会得到不同的结果。 8228-8231, 标注, 2020 年 6 月 8 日星期一 下午 10:11:31 那是 1926 年玻恩给出的概率解释。他假设这个波函数的平方代表电子在空间某点出现的概率，也就是说，量子力学中的电子不像经典粒子那样有决定性的确定轨道，而是随机地出现于空间中某个点。不过，电子出现在特定位置的概率是一定的，是由确定性的方程解出的波函数决定的。也就是说，波函数是描述电子现身位置的“概率幅”。 8271-8273, 标注, 2020 年 6 月 8 日星期一 下午 11:44:46 而微观电子就不一样了：它在被观察之前的状态并无定论，是“既朝上又朝下”的叠加状态，直到我们去测量它，叠加状态才坍缩成一个确定的本征态。 8284-8285, 标注, 2020 年 6 月 8 日星期一 下午 11:46:14 量子理论认为：如果没有揭开盖子进行观察，薛定谔的猫的状态是“死”与“活”的叠加。 8319-8322, 标注, 2020 年 6 月 9 日星期二 下午 1:06:46 经典物理认为，宇宙中不存在真正的随机性。那些貌似随机的现象，如果从更深一层的结构和理论来看或计算，都能得到决定性的结果。关于所谓“更深一层”的详细信息，我们可以把它们统称为我们不知道的、尚未发现的“隐变量”，一旦我们找出了这些隐藏着的变量，随机性就不存在了。或者说，经典物理认为，隐变量是随机性的来源。 8368-8369, 标注, 2020 年 6 月 9 日星期二 下午 1:12:35 玻色子是自旋为整数的粒子，比如光子的自旋为 1。另一类称为费米子的粒子，自旋为半整数， 8372-8373, 标注, 2020 年 6 月 9 日星期二 下午 1:13:51 多个玻色子可以同时占据同一个量子态，而两个费米子不能同时占据同一个量子态，这是玻色子与费米子之间一个很重要的区别。 8377-8379, 标注, 2020 年 6 月 9 日星期二 下午 1:14:27 因为玻色子可以同居一室，所以有时大家会拼命挤到同一个状态。比如，光子就是一种玻色子，许多光子可以处于相同的能级，所以，在激光器中，我们才能让所有的光子都有相同频率、相位、前进方向，形成超高强度的光束。 8376-8376, 标注, 2020 年 6 月 9 日星期二 下午 1:14:39 泡利不相容原理”。 8380-8382, 标注, 2020 年 6 月 9 日星期二 下午 1:15:17 经典的玻尔兹曼统计、玻色–爱因斯坦统计和费米–狄拉克统计，分别适用于三种不同性质的微观粒子：经典粒子、玻色子和费米子。 8514-8515, 标注, 2020 年 6 月 9 日星期二 下午 8:09:13 巨磁阻效应指磁性材料的电阻率在外加磁场后会产生很大变化的现象，它来自电子的自旋， 8827-8828, 标注, 2020 年 6 月 9 日星期二 下午 9:15:58 别轻易相信理论家们构建的各种各样的漂亮理论，你要时刻记得回过头来，看看实验中的那些原始数据。” 9099-9102, 标注, 2020 年 6 月 9 日星期二 下午 9:54:14 量子系统一次计算可以得到 8 个结果，相当于 8 个经典计算器同时进行运算，从某种意义上讲，相当于把计算速度提高到 8 倍。然而，量子计算的结果不能全部输出，因为一旦输出，量子叠加态就会坍缩成 8 个数值中的一个，再也找不回其他数值了。不过，如果我们暂时不输出，这 8 个数可以储存在计算机里，继续进行之后的运算。 14822-14823, 标注, 2020 年 6 月 12 日星期五 下午 11:15:03 哲学介于科学和神学之间，旨在运用人类的理性对一些利用现有知识尚不确定的领域进行思考。 450-637, 标注, unknown 1522 年，有人提议改进法定路德（杆）的确定方法。如图 1–1 所示，当人们从教堂鱼贯而出时，将排成一列的 16 个人的脚的总长度设定为法定路德。[4]从图 1–1 可以看出，这些人的脚长度不一，但通过一群人来设定这个长度单位具有明显的平均效应，因此很多人接受了这个方法。不过，当时似乎还没有人明确提出平均数这个概念。 757-969, 标注, unknown 抛硬币是一种有规律可循的物理现象，而不是随机的！为了证明这一点，我们请物理系为我们制造了一台抛硬币机。如图 1–3 所示，在弹簧被松开之后，停留在弹簧上的硬币一边翻转，一边弹起，然后落在一只杯子里。因为弹簧的力量是受控的，所以硬币落下后总是同一面朝上。这个结果令人发自内心地感到不安（本书的两名作者也不例外），魔术师和不诚实的赌徒（包括本书的一位作者）都具有这样的技能。 1459-1639, 标注, unknown 那是 1926 年玻恩给出的概率解释。他假设这个波函数的平方代表电子在空间某点出现的概率，也就是说，量子力学中的电子不像经典粒子那样有决定性的确定轨道，而是随机地出现于空间中某个点。不过，电子出现在特定位置的概率是一定的，是由确定性的方程解出的波函数决定的。也就是说，波函数是描述电子现身位置的“概率幅”。 1986-2056, 标注, unknown 玻色子是自旋为整数的粒子，比如光子的自旋为 1。另一类称为费米子的粒子，自旋为半整数， 2544-2729, 标注, unknown 量子系统一次计算可以得到 8 个结果，相当于 8 个经典计算器同时进行运算，从某种意义上讲，相当于把计算速度提高到 8 倍。 然而，量子计算的结果不能全部输出，因为一旦输出，量子叠加态就会坍缩成 8 个数值中的一个，再也找不回其他数值了。不过，如果我们暂时不输出，这 8 个数可以储存在计算机里，继续进行之后的运算。 ","date":"2024-10-09","objectID":"/%E7%AC%94%E8%AE%B0%E4%B8%AD%E4%BF%A1%E9%B9%A6%E9%B9%89%E8%9E%BA%E6%9E%81%E7%AE%80%E7%A7%91%E6%99%AE%E5%A5%97%E8%A3%85-%E5%BC%A0%E5%A4%A9%E8%93%89-et/:0:0","tags":["zhongxinying","note","ireader"],"title":"[笔记]中信鹦鹉螺极简科普套装-张天蓉, et.al","uri":"/%E7%AC%94%E8%AE%B0%E4%B8%AD%E4%BF%A1%E9%B9%A6%E9%B9%89%E8%9E%BA%E6%9E%81%E7%AE%80%E7%A7%91%E6%99%AE%E5%A5%97%E8%A3%85-%E5%BC%A0%E5%A4%A9%E8%93%89-et/"},{"categories":null,"content":" 455-597, 标注, unknown 我想告诉他们，在喀布尔，我们折断树枝，拿它当信用卡。哈桑和我会拿着那根木头到面包店去。店主用刀在木头上刻痕，划下一道，表 示他从火焰升腾的烤炉取给我们一个馕饼。每到月底，爸爸按照树枝上的刻痕付钱给他。就是这样。没有问题，不用身份证 610-756, 标注, unknown 我在美国长大，阿米尔。如果说美国让我学到什么东西，那就是，认输简直就像在女童军{GirlScouts，美国女童军是世界上最大的专门 服务于女孩的组织，成员多为成年义工，旨在帮助女孩提高使她们终身受益的素质}的柠檬水罐里面撒尿一样不可原谅。 769-848, 标注, unknown 生活总会继续。他们不关心开始或结束、成功或失败、危在旦夕或柳暗花明，只顾像游牧部落那样风尘仆仆地缓慢前进 ","date":"2024-10-09","objectID":"/%E7%AC%94%E8%AE%B0%E8%BF%BD%E9%A3%8E%E7%AD%9D%E7%9A%84%E4%BA%BA-n-a/:0:0","tags":["zhuifengzhen","note","ireader"],"title":"[笔记]追风筝的人-N/A","uri":"/%E7%AC%94%E8%AE%B0%E8%BF%BD%E9%A3%8E%E7%AD%9D%E7%9A%84%E4%BA%BA-n-a/"},{"categories":null,"content":"前几天看完了《埃隆·马斯克传》，仍然在书写传奇的硅谷钢铁侠。这本书整体上来说非常好，个人感觉比《乔布斯传》要好，更贴近现实，也更有参考意义。 今天只简单记录一下马斯克推崇的 “五步工作法” 。 无论是在特斯拉还是在 SpaceX，在所有生产会议上，马斯克都会抓住机会，像念咒一样念叨他所谓的 “五步工作法” ： 1.质疑每项要求。提出任何一项要求时，都应该附上提出这一要求的人。永远不要接受一项来自某个部门的要求，比如来自“法务部门”或者“安全部门”的要求。你必须知道提出这项要求的人的名字。接下来你应该质疑它，不管这个人有多聪明。聪明人提出的要求才是最危险的，因为人们不太可能质疑他们。这件事要一直做下去，即便这项要求来自我马斯克本人。质疑后，大家就要改进要求，让它变得不那么愚蠢。 2.删除要求当中所有你能删除的部分和流程，虽然你可能还得把它们加回来。事实上，你如果最后加回来的部分还不到删除部分的 10%，那就说明你删减得还不够。 PS: 我尤其喜欢这一条 ：） 3.简化和优化。这应该放在第 2 步之后，因为人们常犯的错误就是简化和优化一个原本不应该存在的部分或者流程。 4.加快周转时间。每个流程都可以加快，但只有遵循了前三个步骤之后才能这么做。在特斯拉工厂，我错误地把很多精力花在加快生产流程上，后来我才意识到有些流程原本就应该被拿掉。 5.自动化。在内华达工厂和弗里蒙特工厂犯下的一个大错就是我一开始试图将每个步骤进行自动化改造。我们本应该先质疑所有要求，删除不必要的部分和流程，把问题筛出来、处理掉，然后再推进自动化。 以及基于此给出的几个推论： 所有技术经理都必须有实战经验，比如说软件团队的管理人员必须至少花 20%的时间进行编程，太阳能屋顶业务的经理必须花时间在屋顶上亲自做安装工作。否则光说不练，他们就像是不会骑马的骑兵队队长、不会舞刀弄枪的将军。 “你好，我好，大家好”是很危险的，人们会因此不再质疑同事的工作成果。人们天然有一种倾向是不想把要好的同事踢下船，而这种危险倾向一定要避免。 犯错没关系，但错了还不肯低头就不行。 永远不要要求你的团队做你自己都不愿意做的事。 每当有问题需要解决时，不要只与你直接管理的相关负责人聊。深入调研就要跨层级沟通，去跟你属下的属下直接交流吧。 招聘要招态度端正的人。技能是可以教的，但要扭转一个人的工作态度可就太费劲了，得给他“换个脑子”。 疯狂的紧迫感是我们公司运作的法则。 唯一要遵守的规则就是物理学定律能推导出来的规则，其他一切都只是建议。 ","date":"2024-10-09","objectID":"/%E5%85%AC%E4%BC%97%E5%8F%B7-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E9%A9%AC%E6%96%AF%E5%85%8B%E4%BC%A0/:0:0","tags":["wechat","masike","note"],"title":"公众号-读书笔记-马斯克传-五步工作法","uri":"/%E5%85%AC%E4%BC%97%E5%8F%B7-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E9%A9%AC%E6%96%AF%E5%85%8B%E4%BC%A0/"},{"categories":null,"content":"几年以前，开过一个公众号，但是一直没有在上面写过任何东西，然后过了一段时间，被冻结了。这几天想着找个地方记录点东西，就又把它给找了回来。 用这个公众号记录点什么呢？主要是读书笔记和徒步记录，以及徒步中顺手收集的杂物吧。技术方面的东西，单独记录到了别的地方，感兴趣的请移步 https://yangyingchao.github.io/ 。 下面这个照片，是此次从宣化宝石谷捡到的小玛瑙蛋，有时间把他们逐个打磨出来，看看最终会得到什么东西。 Figure 1: 六颗小玛瑙蛋子 ","date":"2024-10-08","objectID":"/%E5%BC%80%E5%90%AF%E4%B8%80%E4%B8%AA%E6%9D%82%E7%89%A9%E9%97%B4/:0:0","tags":null,"title":"开启一个杂物间","uri":"/%E5%BC%80%E5%90%AF%E4%B8%80%E4%B8%AA%E6%9D%82%E7%89%A9%E9%97%B4/"},{"categories":null,"content":"https://mp.weixin.qq.com/s?__biz=MjM5MDc0NTY2OA==\u0026mid=2651827832\u0026idx=5\u0026sn=a0520f041de538e6b038ed9e334b0cd3\u0026chksm=bc3b2eecea5ed4cf36a48a58c0461f6165a4e24f5f8df4d9f3ffd88777d1f00c2b6c4d94e64d\u0026mpshare=1\u0026scene=1\u0026srcid=0929H2fLUE47oTnx6TWPQfyz\u0026sharer_shareinfo=9235bdd9165551abae500ca669212c34\u0026sharer_shareinfo_first=9235bdd9165551abae500ca669212c34#rd 昨天半夜，我起床上厕所时，无意发现孩子房门底下透着光。我推门而入，就看见孩子趴在床上，入迷地刷着短视频，丝毫没有发觉我的到来。联想到最近老师多次反馈，孩子上课注意力不集中，经常犯困，哈欠连连。我一把就夺过了手机，并告诉她这学期都不要想再碰手机。结果孩子一下就炸毛了，直接吼出三连问： “你凭什么没收我的手机？” “每天都是学习，学习，我还不能放松一下？” “别人都能玩，为什么就我不能玩？” 我当时沉默了，因为我并不想给她一个专制或敷衍的回答。思考良久，我才想好如何跟孩子聊玩手机的问题： ","date":"2024-09-29","objectID":"/mp_weixin_qq_com_mp.weixin.qq/:0:0","tags":null,"title":"孩子，我为什么不让你玩手机","uri":"/mp_weixin_qq_com_mp.weixin.qq/"},{"categories":null,"content":"1 控制不了欲望的人，终将被欲望控制。 为什么要限制你玩手机？这是因为，玩手机是欲望，而不是需求。 需求是内在的，一旦被满足，它就会消失。 比如你饿了需要吃饭，吃饱了就不会想再吃；困了需要睡觉，睡醒就不会再想睡，这就是需求。 而欲望是外在的，一旦轻易被满足，它就会越来越大。 比如手机玩了一个小时，还想玩两个小时，三个小时，妈妈不反对，不控制，你就会越玩越起劲。 所以，需求可以被满足，但欲望需要被控制。 之前就看过这样一个新闻。青岛一个 14 岁女孩，在医院给奶奶陪床时，想着玩一下手机打发时间。结果，因为无人看管，她一玩就是整整 81 个小时。也因为长时间不睡觉，她险些猝死。 “得到”App 的创始人罗振宇曾告诫用户：“王者荣耀十分钟就有个兴奋点，吃鸡游戏三分钟就要有一个兴奋点，而短视频甚至要追求一分钟一个兴奋点。” 孩子，你以为玩一下手机无关紧要，但在你捧起手机的那一刻，就已经掉进了欲望的陷阱。被大数据的算法牵着走，被无节制的感官刺激淹没。 所以， 千万别高估你的自制力，更别低估了手机的诱惑力。 你若抗拒不了玩手机的欲望，就只能被手机奴役。懂得克制自己，战胜欲望，你才能主宰自己的人生。 ","date":"2024-09-29","objectID":"/mp_weixin_qq_com_mp.weixin.qq/:1:0","tags":null,"title":"孩子，我为什么不让你玩手机","uri":"/mp_weixin_qq_com_mp.weixin.qq/"},{"categories":null,"content":"2 在最该努力的时候选择放纵，未来留给你的只能是无尽的叹息。 学生家长开会那天，班级考试连续多次考第一名的同学的妈妈上台发言，做了一个很有意思的比较。 她问班里的孩子：“如果我们在猴子面前，放上一根香蕉和一沓钱，你们觉得猴子会选什么？” 学生们异口同声地说：“香蕉。” “那你们觉得猴子傻不傻？” 同学们斩钉截铁回答：“傻。” “那如果手机和作业摆在你们面前，你们会选什么？” 同学们哄堂大笑：“手机。” 这位妈妈紧接着说道：“对，傻傻的猴子和傻傻的你们很像，猴子只知道眼前的香蕉拿起来就能吃，却不知道，钱能买到更多的香蕉；而现在的你，只知道拿起手机就能获得眼前的快乐，却不知道，好好学习才能获得一生的快乐。” 孩子，你未来过着怎样的生活，完全取决于你当下的每个选择。 = 当你在最该努力的时候选择放纵，就不要羡慕别人取得的成绩。 当你在最该向上的时候选择安逸，就不要埋怨生活的不如人意。 要知道，世间最大的遗憾，不是“我不行”，而是“我本可以”。 所以，眼光放长远一点，别被眼前一时的快乐，麻痹了自己的意志；更别让一时的放纵，变成了自己一生的遗憾。放不下手机的孩子，往往只能放弃自己的人生。 ","date":"2024-09-29","objectID":"/mp_weixin_qq_com_mp.weixin.qq/:2:0","tags":null,"title":"孩子，我为什么不让你玩手机","uri":"/mp_weixin_qq_com_mp.weixin.qq/"},{"categories":null,"content":"3 唾手可得的快乐背后，都是昂贵的代价。 我们曾一起读过一个寓言故事。说的是，大雁和鸭子是两兄弟，他们都有个共同的理想：当旅行家。可当他们真的要飞往远方时，鸭子却贪恋当下的舒适与快乐，害怕飞行的奔波劳累，一次次不愿启程。一年又一年过去，大雁飞过了高山，越过了大海，体验了无数未知的美好，也见识了世界的广阔。而鸭子则翅膀逐渐退化，身体也越来越笨重，最后想飞也飞不起来了，只能被圈养在小小的围栏里。 孩子，一根网线，一部手机，一屏永远也看不完的短视频，确实能让你短时间内享受到无尽的快乐。 但你要知道： 所有唾手可得的快乐，都早已在暗中标好了价格。 当你像鸭子一样，只顾享乐，那失去的，也将是你最重要的能力。 《限屏教育》一书就指出：人的大脑神经发育，5岁前是“打地基”， 6-18 岁是“建高楼”。 在这两个阶段，假如大脑总是接受游戏，短视频这些简单的刺激，就可能导致大脑失去建立复杂神经元联系结构的机会，并且，那些长期不被刺激的领域也会被默认为“无用”，进而不再发育。最终导致的，就是专注力、想象力、思考力等等都明显落后于普通孩子。同时，也因为适应并习惯了快速、简单、及时的多巴胺快乐。那你将来学习时，那些需要付出努力、思考和探索的才能分泌出来的内啡肽快乐，就很难吸引你。你的大脑，也不愿意去面对学习中的困难和挑战。 这也就是为什么，很多孩子一学习就分心、走神、注意力神游，完全学不进去，满脑子只有“玩手机”。其实，这就是“垃圾快乐”的可怕之处： 当你沉浸其中时，你感觉不到它的伤害。当你有所醒悟时，你已经被吞噬掉了勤奋、自律、意志力和上进心，彻底沦为一个对生活毫无办法的人。 ","date":"2024-09-29","objectID":"/mp_weixin_qq_com_mp.weixin.qq/:3:0","tags":null,"title":"孩子，我为什么不让你玩手机","uri":"/mp_weixin_qq_com_mp.weixin.qq/"},{"categories":null,"content":"4 你把时间花在哪里，你就会拥有怎样的人生。 董宇辉曾在直播间说过一段发人深省的话： “一个手机再破，你都需要它，为什么呢？因为它里面有游戏，这就是它的价值。” 你学历再差，只要脑袋里有知识，社会就需要你，这就是你的价值。 你需要的是游戏，社会需要的是知识，今天的你不去学习，将来的你就还不如一部手机，这就是现实。 是啊，人若没有价值，谁会陪你演戏。 空桶，装上垃圾便只能成为地下的垃圾桶，装上笔杆才能成为桌上有用的笔筒。我们的大脑也是如此。脑袋里装的是知识，就会变得价值连城；脑袋里装的若是手机里那些虚无的东西，只会变得一文不值。所以，请不要在最好的年华里虚度时光，挥霍青春。 一毕业就拿下华为最高档 200 万年薪的“天才少年”左鹏飞在采访中就说过： “哪有什么天才？我只是把别人打游戏的时间用在实验室而已。”时间，是最公平的存在，也是你现在最大的资本。 与其眼红别人手里的手机，不如低头看看自己手上的书籍。 虽然繁重又枯燥，却能引领你迈向更广阔的人生。 ","date":"2024-09-29","objectID":"/mp_weixin_qq_com_mp.weixin.qq/:4:0","tags":null,"title":"孩子，我为什么不让你玩手机","uri":"/mp_weixin_qq_com_mp.weixin.qq/"},{"categories":null,"content":"5 今天多吃一点学习的苦，明天才能收获多一点生活的甜。 最后，妈妈想跟你谈一下，什么是真正的苦。 不可否认，六点起床很难，刷题背书很累，家庭学校两点一线很烦，十年如一日的坚持也很苦。但你不知道的是，在你看不见的地方：菜市场的商贩们凌晨 3 点已经在忙碌了，环卫工人凌晨 4 点也已经工作了。工地上，工人风吹日晒，不敢懈怠；马路上，外卖员风里来雨里去，没日没夜都在跑单；餐厅里，厨师一站就是几个小时，吃不上一顿正经饭…… 孩子， 学习的苦，是有限的且回馈巨大，它会带来更多的选择权，会给你打开生活更多的可能性，让你收获自己想要的生活。 生活的苦，夜以继日，是让人绝望的茫茫无期，这种苦看不见，摸不着，却要痛苦一生，这才是真正的苦。 为什么要跟你说这些呢？ 这是因为，人生有一个“苦难守恒定律”，即每个人一生都会吃一定量的苦，既不会凭空消失，也不会无故产生。今天，你沉迷游戏，贪图安逸，不思进取，明天，你就要因为没有学历、没有技术，不得不为生活奔波、在底层摸爬滚打一辈子。妈妈不让你玩手机，是希望你能做一个自律的人。这样，将来的你才能站在更高的起点，自由选择你喜欢的职业，去你喜欢的地方，过真正自由的人生。而不是被迫谋生、养家糊口，浑浑噩噩地过这一辈子。 ","date":"2024-09-29","objectID":"/mp_weixin_qq_com_mp.weixin.qq/:5:0","tags":null,"title":"孩子，我为什么不让你玩手机","uri":"/mp_weixin_qq_com_mp.weixin.qq/"},{"categories":null,"content":"6 结语 歌德有一句话说得很对： “谁若游戏人生，他就一事无成；谁不能主宰自己，便永远是一个奴隶。” 成长只有一次，每一个阶段都是现场直播，错过就无法重来。所以，别再执着于手机了！ 没有什么事情，比自律和坚持，更能让人充实。 也没有什么快乐，比自由主宰人生更加痛快。 你现在的每一分努力，都是在为你的未来铺路。将来的你，一定会感谢今天拼命努力的自己！ ","date":"2024-09-29","objectID":"/mp_weixin_qq_com_mp.weixin.qq/:6:0","tags":null,"title":"孩子，我为什么不让你玩手机","uri":"/mp_weixin_qq_com_mp.weixin.qq/"},{"categories":null,"content":" Table of Contents 1 脚本优化 1.1 使用内置命令 1.2 减少子 shell 使用 1.3 使用数组处理大量数据# 1.4 Enable Noclobber# 1.5 使用函数# 1.6 高效的文件操作# 1.7 并行处理# 2 错误处理# 2.1 当发生错误时立即退出# 2.2 自定义错误消息# 2.3 捕获信号# 2.4 验证输入# 2.5 记录日志# 本文为摘录(或转载)，侵删，原文为： https://omid.dev/2024/06/19/advanced-shell-scripting-techniques-automating-complex-tasks-with-bash/ ","date":"2024-09-13","objectID":"/omid_dev_advanced-shell-scripting-techniques-automating-complex-tasks-with-bash/:0:0","tags":["bash","tip"],"title":"Advanced Shell Scripting Techniques: Automating Complex Tasks with Bash","uri":"/omid_dev_advanced-shell-scripting-techniques-automating-complex-tasks-with-bash/"},{"categories":null,"content":"1 脚本优化 优化对于确保脚本高效运行至关重要，特别是在处理大型数据集或密集任务时。以下是一些优化 Bash 脚本的关键技巧。 ","date":"2024-09-13","objectID":"/omid_dev_advanced-shell-scripting-techniques-automating-complex-tasks-with-bash/:1:0","tags":["bash","tip"],"title":"Advanced Shell Scripting Techniques: Automating Complex Tasks with Bash","uri":"/omid_dev_advanced-shell-scripting-techniques-automating-complex-tasks-with-bash/"},{"categories":null,"content":"1.1 使用内置命令 尽可能利用内置的 Shell 命令，而不是外部可执行文件。内置命令执行更快，因为它们不需要加载外部进程。例如，在条件语句中使用 [[ ]] 而不是 [ ] 或 test 。 # 低效的写法 if [ \"$var\" -eq 1 ]; then echo \"等于 1\" fi # 高效的写法 if [[ \"$var\" -eq 1 ]]; then echo \"等于 1\" fi ","date":"2024-09-13","objectID":"/omid_dev_advanced-shell-scripting-techniques-automating-complex-tasks-with-bash/:1:1","tags":["bash","tip"],"title":"Advanced Shell Scripting Techniques: Automating Complex Tasks with Bash","uri":"/omid_dev_advanced-shell-scripting-techniques-automating-complex-tasks-with-bash/"},{"categories":null,"content":"1.2 减少子 shell 使用 子 shell 在性能方面可能很昂贵。尽量避免它们，可以使用内置命令或参数扩展。 # 低效的写法 output=$(cat file.txt) # 高效的写法 output=$(\u003cfile.txt) ","date":"2024-09-13","objectID":"/omid_dev_advanced-shell-scripting-techniques-automating-complex-tasks-with-bash/:1:2","tags":["bash","tip"],"title":"Advanced Shell Scripting Techniques: Automating Complex Tasks with Bash","uri":"/omid_dev_advanced-shell-scripting-techniques-automating-complex-tasks-with-bash/"},{"categories":null,"content":"1.3 使用数组处理大量数据# 处理大量数据时，数组可能比多个变量更高效且更易管理。 # 低效的写法 item1=\"苹果\" item2=\"香蕉\" item3=\"樱桃\" # 高效的写法 items=(\"苹果\" \"香蕉\" \"樱桃\") for item in \"${items[@]}\"; do echo \"$item\" done ","date":"2024-09-13","objectID":"/omid_dev_advanced-shell-scripting-techniques-automating-complex-tasks-with-bash/:1:3","tags":["bash","tip"],"title":"Advanced Shell Scripting Techniques: Automating Complex Tasks with Bash","uri":"/omid_dev_advanced-shell-scripting-techniques-automating-complex-tasks-with-bash/"},{"categories":null,"content":"1.4 Enable Noclobber# 为防止意外覆写文件，请使用 noclobber 选项。这在生成临时文件的脚本中尤为有用。 set -o noclobber noclobber 选项可用于避免使用重定向输出时覆盖现有文件（/请参阅内置命令::）。’\u003e|‘重定向操作符可用于覆盖 noclobber 。 ","date":"2024-09-13","objectID":"/omid_dev_advanced-shell-scripting-techniques-automating-complex-tasks-with-bash/:1:4","tags":["bash","tip"],"title":"Advanced Shell Scripting Techniques: Automating Complex Tasks with Bash","uri":"/omid_dev_advanced-shell-scripting-techniques-automating-complex-tasks-with-bash/"},{"categories":null,"content":"1.5 使用函数# 函数允许您封装和重用代码，使脚本更加清晰，减少冗余。 function greet() { local name=$1 echo \"Hello, $name\" } greet \"Alice\" greet \"Bob\" ","date":"2024-09-13","objectID":"/omid_dev_advanced-shell-scripting-techniques-automating-complex-tasks-with-bash/:1:5","tags":["bash","tip"],"title":"Advanced Shell Scripting Techniques: Automating Complex Tasks with Bash","uri":"/omid_dev_advanced-shell-scripting-techniques-automating-complex-tasks-with-bash/"},{"categories":null,"content":"1.6 高效的文件操作# 在进行文件操作时，请使用高效的技术以最小化资源使用。 # 低效的方式 while read -r line; do echo \"$line\" done \u003c file.txt # 高效的方式 while IFS= read -r line; do echo \"$line\" done \u003c file.txt ","date":"2024-09-13","objectID":"/omid_dev_advanced-shell-scripting-techniques-automating-complex-tasks-with-bash/:1:6","tags":["bash","tip"],"title":"Advanced Shell Scripting Techniques: Automating Complex Tasks with Bash","uri":"/omid_dev_advanced-shell-scripting-techniques-automating-complex-tasks-with-bash/"},{"categories":null,"content":"1.7 并行处理# 对于可以并行执行的任务，考虑使用并行处理来加速脚本。像 xargs 和 GNU parallel 这样的工具非常有用。 # 使用 xargs 进行并行处理 cat urls.txt | xargs -n 1 -P 4 curl -O ","date":"2024-09-13","objectID":"/omid_dev_advanced-shell-scripting-techniques-automating-complex-tasks-with-bash/:1:7","tags":["bash","tip"],"title":"Advanced Shell Scripting Techniques: Automating Complex Tasks with Bash","uri":"/omid_dev_advanced-shell-scripting-techniques-automating-complex-tasks-with-bash/"},{"categories":null,"content":"2 错误处理# 健壮的错误处理对于创建可靠且易维护的脚本至关重要。以下是一些增强 Bash 脚本错误处理的技巧。 ","date":"2024-09-13","objectID":"/omid_dev_advanced-shell-scripting-techniques-automating-complex-tasks-with-bash/:2:0","tags":["bash","tip"],"title":"Advanced Shell Scripting Techniques: Automating Complex Tasks with Bash","uri":"/omid_dev_advanced-shell-scripting-techniques-automating-complex-tasks-with-bash/"},{"categories":null,"content":"2.1 当发生错误时立即退出# 使用 set -e 确保如果任何命令失败，脚本会立即退出，防止出现级联错误。 set -e ","date":"2024-09-13","objectID":"/omid_dev_advanced-shell-scripting-techniques-automating-complex-tasks-with-bash/:2:1","tags":["bash","tip"],"title":"Advanced Shell Scripting Techniques: Automating Complex Tasks with Bash","uri":"/omid_dev_advanced-shell-scripting-techniques-automating-complex-tasks-with-bash/"},{"categories":null,"content":"2.2 自定义错误消息# 实现自定义错误消息以在出现问题时提供更多上下文信息。 command1 || { echo \"command1 failed\"; exit 1; } ","date":"2024-09-13","objectID":"/omid_dev_advanced-shell-scripting-techniques-automating-complex-tasks-with-bash/:2:2","tags":["bash","tip"],"title":"Advanced Shell Scripting Techniques: Automating Complex Tasks with Bash","uri":"/omid_dev_advanced-shell-scripting-techniques-automating-complex-tasks-with-bash/"},{"categories":null,"content":"2.3 捕获信号# 使用 trap 命令来捕获和优雅地处理信号和错误。 trap 'echo \"Error occurred\"; cleanup; exit 1' ERR function cleanup() { # 清理代码 } ","date":"2024-09-13","objectID":"/omid_dev_advanced-shell-scripting-techniques-automating-complex-tasks-with-bash/:2:3","tags":["bash","tip"],"title":"Advanced Shell Scripting Techniques: Automating Complex Tasks with Bash","uri":"/omid_dev_advanced-shell-scripting-techniques-automating-complex-tasks-with-bash/"},{"categories":null,"content":"2.4 验证输入# 始终验证用户的输入和脚本参数，以防止意外行为。 if [[ -z \"$1\" ]]; then echo \"用法: $0 \u003c参数\u003e\" exit 1 fi ","date":"2024-09-13","objectID":"/omid_dev_advanced-shell-scripting-techniques-automating-complex-tasks-with-bash/:2:4","tags":["bash","tip"],"title":"Advanced Shell Scripting Techniques: Automating Complex Tasks with Bash","uri":"/omid_dev_advanced-shell-scripting-techniques-automating-complex-tasks-with-bash/"},{"categories":null,"content":"2.5 记录日志# 实现日志记录以跟踪脚本执行并诊断问题。 logfile=\"script.log\" exec \u003e \u003e(tee -i $logfile) exec 2\u003e\u00261 echo \"脚本已启动\" ","date":"2024-09-13","objectID":"/omid_dev_advanced-shell-scripting-techniques-automating-complex-tasks-with-bash/:2:5","tags":["bash","tip"],"title":"Advanced Shell Scripting Techniques: Automating Complex Tasks with Bash","uri":"/omid_dev_advanced-shell-scripting-techniques-automating-complex-tasks-with-bash/"},{"categories":null,"content":" Table of Contents 1 Introduction 2 I/O Models 3 AIO System Calls 3.1 ABI Interface 本文为摘录(或转载)，侵删，原文为： https://oxnz.github.io/2016/10/13/linux-aio/ ","date":"2024-06-20","objectID":"/oxnz_github_io_linux-aio/:0:0","tags":null,"title":"Linux Asynchronous I/O","uri":"/oxnz_github_io_linux-aio/"},{"categories":null,"content":"1 Introduction 异步 I/O（AIO）是一种执行 I/O 操作的方法，使得发出 I/O 请求的进程在操作完成之前不被阻塞。相反，在提交 I/O 请求后，该进程继续执行其代码，并可以随后检查所提交请求的状态。 在 Linux 中实现异步 I/O 有几种方式： 内核系统调用 用户空间库的实现并在内部使用系统调用（libaio） 在用户空间完全模拟 AIO 而不依赖任何内核支持（目前为止，使用 librt，属于 libc 的一部分） ","date":"2024-06-20","objectID":"/oxnz_github_io_linux-aio/:1:0","tags":null,"title":"Linux Asynchronous I/O","uri":"/oxnz_github_io_linux-aio/"},{"categories":null,"content":"2 I/O Models Mode Blocking Non-blocking Synchronous read/write read/write (O_NONBLOCK) Asynchronous I/O (select/poll/epoll) multiplexing AIO ","date":"2024-06-20","objectID":"/oxnz_github_io_linux-aio/:2:0","tags":null,"title":"Linux Asynchronous I/O","uri":"/oxnz_github_io_linux-aio/"},{"categories":null,"content":"3 AIO System Calls ","date":"2024-06-20","objectID":"/oxnz_github_io_linux-aio/:3:0","tags":null,"title":"Linux Asynchronous I/O","uri":"/oxnz_github_io_linux-aio/"},{"categories":null,"content":"3.1 ABI Interface AIO 系统调用入口点位于内核源代码中的 fs/aio.c 文件中。导出到用户空间的类型和常数位于 /usr/include/linux/aio_abi.h 头文件中。 Linux 内核仅提供了 5 个用于执行异步 I/O 的系统调用。 #include \u003clinux/aio_abi.h\u003e int io_setup(unsigned nr_events, aio_context_t *ctxp); int io_destroy(aio_context_t ctx); int io_submit(aio_context_t ctx, long nr, struct iocb **iocbpp); int io_cancel(aio_context_t ctx, struct iocb *, struct io_event *result); int io_getevents(aio_context_t ctx, long min_nr, long nr, struct io_event *events, struct timespec *timeout); struct iocb: 每个提交到 AIO 上下文的 I/O 请求都由一个 I/O 控制块结构表示 - struct iocb io_submit() 接受 AIO 上下文 ID、数组的大小和数组本身作为参数。 需要注意的是，数组应包含指向 iocb 结构的指针，而不是结构本身。 io_submit() 的返回代码可以是以下值之一： ret = （已提交的 iocbs 数量） 理想情况，所有 iocbs 都被接受并正在处理。 0 \u003c ret \u003c （已提交的 iocbs 数量） io_submit() 系统调用会逐个处理传递数组中的 iocbs，从第一个条目开始。如果某个 iocb 的提交失败，系统会在这一点停止并返回失败的 iocb 的索引。无法知道具体的失败原因。然而，如果第一个 iocb 的提交失败，请参考点 C。 ret \u003c 0 出现这种情况有两个原因： 在 io_submit() 开始迭代数组中的 iocbs 之前，出现了某些错误（例如，AIO 上下文无效）。 第一个 iocb (cbx[0]) 的提交失败。 ","date":"2024-06-20","objectID":"/oxnz_github_io_linux-aio/:3:1","tags":null,"title":"Linux Asynchronous I/O","uri":"/oxnz_github_io_linux-aio/"},{"categories":null,"content":" Table of Contents 1 Single Page Recovery 本文为摘录(或转载)，侵删，原文为： http://mysql.taobao.org/monthly/2023/11/01/ 《数据库故障恢复机制的前世今生》一文中介绍过，由于磁盘的的顺序访问性能远好于随机访问，数据库设计中通常都会采用 WAL 的方式，将随机访问的数据库请求转换为顺序的日志 IO，并通过 Buffer Pool 尽量的合并并推迟真正的数据修改落盘。如果发生故障，可以通过日志的重放恢复故障发生前未刷盘的修改信息。也就是说 Log 中包含数据库恢复所需要的全部信息。 现代数据库为了追求更高的事务并发度，会： 显式地区分用户可见的逻辑内容和维护内部的物理结构， 在并发控制上支持了 Lock 和 Latch 的分层， 同时也在故障恢复上区分了 User Transaction 和 System Transaction。 在这种设计下， 保证数据库 D（Durable）的 Redo Log 需要能在 Crash Recovery 的过程中，在完全不感知用户事务的情况下，恢复未提交的 System Transaction。因此，Redo Log 的设计上天然就是 Page Oriented 的，也就是说每条 Redo Log 都被限制在单个 Page 中，其重放过程不需要感知用户事务的存在，也不需要关心其他的 Page。 在《B+树数据库故障恢复概述》中详细的讨论过这个过程，也提到这样做的好处使得在 Crash Recovery 的过程中 Page 的恢复过程可以实现充分的并发。到这里我们就可以引出本文想要讨论的主要内容： 已知： 特性 1（完备）：Log 中包含数据库恢复所需要的全部信息； 特性 2（Page Oriented）：Page 通过 Log 的恢复过程只需要关心当前的 Page 本身； 那么，通过这两个特性，数据库设计能实现哪些实用和有趣的功能呢？ ","date":"2024-06-13","objectID":"/mysql_taobao_org_01/:0:0","tags":null,"title":"聊聊日志即数据库","uri":"/mysql_taobao_org_01/"},{"categories":null,"content":"1 Single Page Recovery ","date":"2024-06-13","objectID":"/mysql_taobao_org_01/:1:0","tags":null,"title":"聊聊日志即数据库","uri":"/mysql_taobao_org_01/"},{"categories":null,"content":" Table of Contents 1 Citus 简介 2 四种典型的应用场景及其需求 2.1 多租户 2.2 实时分析 2.3 高性能增删改查 2.4 数据仓库 3 Citus 架构 4 Citus 是如何修改 PG 本身的行为的 5 Citus 的整体架构 6 Citus 的表类型 7 数据再平衡 8 分布式查询计划器 9 分布式查询执行器 10 分布式事务 11 其他场景的分布式处理 12 高可用和备份 12.1 高可用 12.2 备份 13 性能测试 14 应用案例 15 相关工作 本文为摘录(或转载)，侵删，原文为： https://zhuanlan.zhihu.com/p/667067679 ","date":"2024-05-13","objectID":"/zhuanlan.zhihu/:0:0","tags":null,"title":"Citus: Distributed PostgreSQL for Data-Intensive Applications","uri":"/zhuanlan.zhihu/"},{"categories":null,"content":"1 Citus 简介 作为非常著名的开源数据库，PostgreSQL 在许多商业场景得到应用，促使将其扩展为多机器的分布式数据库。Citus 基于 PostgreSQL 的插件接口，构建了分片层、分布式查询计划生成器、执行器和分布式事务，保留了 PG 的各种功能。文章基于 Citus 应用，总结了四种需要扩展 PG 的场景和对分布式数据库的功能需求。接着，介绍了 Citus 如何基于 PG 的扩展接口构建分布式数据库系统，并解决各类应用场景的需求。 ","date":"2024-05-13","objectID":"/zhuanlan.zhihu/:1:0","tags":null,"title":"Citus: Distributed PostgreSQL for Data-Intensive Applications","uri":"/zhuanlan.zhihu/"},{"categories":null,"content":"2 四种典型的应用场景及其需求 扩展 PG 的四种应用场景： 多租户、 实时分析、 高性能增删改查、 数据仓库。 ","date":"2024-05-13","objectID":"/zhuanlan.zhihu/:2:0","tags":null,"title":"Citus: Distributed PostgreSQL for Data-Intensive Applications","uri":"/zhuanlan.zhihu/"},{"categories":null,"content":"2.1 多租户 多租户的场景是一个很典型的需要多数据进行分片的场景， 最传统的方式是对租户的数据进行手动分片，将不同租户的数据放到不同的分片下，以实现资源的隔离。（我们的数据库就是这种方式）。 还有一种方式是通过 tenant ID 列来对数据进行分片，Citus 采用的就是这种方式， 这种方式下，往往需要不同租户采用相同的数据表模式，但事实上用户会希望针对不同租户设置特定的数据表模式。 针对这一需求，作者简易可以使用 JSONB 数据类型累进行扩展。同时，客户也需要能够控制租户数据的位置，这样可以在监控到热点的时候对数据进行迁移。 ","date":"2024-05-13","objectID":"/zhuanlan.zhihu/:2:1","tags":null,"title":"Citus: Distributed PostgreSQL for Data-Intensive Applications","uri":"/zhuanlan.zhihu/"},{"categories":null,"content":"2.2 实时分析 实时分析的目的是实时处理大规模流数据，主要涉及 event 数据和时间序列数据，用于系统监控和异常检测等。 数据库需要高写吞吐和每秒数百个读请求处理能力，在这种场景下，查询通常基于索引、物化视图和数据转换请求，需高效地更新数据。 PG 通过 COPY 语句快速实现数据导入，MVCC 支持同时写入和服务读请求，也支持复杂数据类型，但单机存储限制是其缺点。 为解决单机存储限制，数据库系统需要数据分发到不同机器，并支持并行批量加载数据。Citus 可实现分库分表，分发写入的数据，后续将介绍 Citus 如何支持高效查询，包括跨节点 join 等操作。 ","date":"2024-05-13","objectID":"/zhuanlan.zhihu/:2:2","tags":null,"title":"Citus: Distributed PostgreSQL for Data-Intensive Applications","uri":"/zhuanlan.zhihu/"},{"categories":null,"content":"2.3 高性能增删改查 高性能的 CRUD （创建、读取、更新、删除） 操作对于处理大量相对独立的对象或文档至关重要。 应用程序通常会简单地执行 CRUD 操作，但也可能需要进行复杂的查询, 这些对象通常采用类似 JSON 的非结构化数据格式。 PostgreSQL 支持针对 JSON 的查询，一台大型的 PostgreSQL 服务器可以处理每秒数十万次的写入操作和数百万次的读取操作。 然而，PostgreSQL 的 MVCC（多版本并发控制）模型需要写入新副本，并通过自动清理来回收空间。 如果自动清理不能及时跟上，则会影响性能。 此外，由于 PostgreSQL 采用每个连接一个进程的架构，以及进程的相对高内存开销，它只能处理有限数量的空闲连接。 ","date":"2024-05-13","objectID":"/zhuanlan.zhihu/:2:3","tags":null,"title":"Citus: Distributed PostgreSQL for Data-Intensive Applications","uri":"/zhuanlan.zhihu/"},{"categories":null,"content":"2.4 数据仓库 数据仓库将不同来源的数据合并到单个数据库系统，生成即时分析报告。 该应用通常不需要低延迟或高吞吐量，但查询可能需要扫描大量数据。 数据库需支持快速扫描，为手写 SQL 找到高效的查询计划。 PostgreSQL 在执行大扫描时存在扫描性能和并行性方面的限制，但其性能特性和全面的 SQL 支持使其成为分析吸引人的选择。 为扩展数据仓库应用，可通过并行、分布式 SELECT 和列式存储加速扫描。应选择分布列以增加共同分布连接数量，同时支持非共同分布连接。查询优化器需最小化网络流量的连接顺序。 ","date":"2024-05-13","objectID":"/zhuanlan.zhihu/:2:4","tags":null,"title":"Citus: Distributed PostgreSQL for Data-Intensive Applications","uri":"/zhuanlan.zhihu/"},{"categories":null,"content":"3 Citus 架构 在 Citus 集群中，所有服务器都运行带有 Citus 扩展以及任意数量其他扩展的 PG 实例。Citus 使用 PG 扩展 API 来以两种方式改变数据库的行为： 首先，Citus 将数据库对象（如自定义类型和函数）复制到所有服务器。 其次，Citus 添加了两种新的表类型来利用外部服务器。 ","date":"2024-05-13","objectID":"/zhuanlan.zhihu/:3:0","tags":null,"title":"Citus: Distributed PostgreSQL for Data-Intensive Applications","uri":"/zhuanlan.zhihu/"},{"categories":null,"content":"4 Citus 是如何修改 PG 本身的行为的 PG 本身提供大量的编程接口，我们可以在扩展插件中编写自己的方法来调整数据库的行为。 Citus 主要使用了以下几个接口： User-defined functions (UDFs) 可以在 SQL 查询时作为事务一部分被调用，主要用于操作 Citus 元数据以及执行 RPC。 查询计划器和执行器的 hook 本身是一组全局函数指针，允许扩展提供替代的查询计划和执行方法。在 PG 解析查询后，Citus 会检查查询是否涉及 Citus 表。如果是的话，Citus 会生成一个包含 CustomScan 节点的计划树，该节点封装了分布式查询计划。 CustomScan 是 PG 查询计划中的执行节点，它保存自定义状态并通过自定义函数指针返回元组。Citus CustomScan 调用分布式查询执行器，该执行器将查询发送到其他服务器，并在将结果返回给 PG 执行器之前收集这些结果。 Transaction callbacks 在事务的生命周期中的关键点（例如预提交、后提交、中止）被调用。Citus 使用这些回调来实现分布式事务。 Utility hook 在解析不经过常规查询计划器的任何命令后被调用。Citus 用这些 hook 来执行 Citus 表相关的 DDL 和 COPY 命令。 Background workers 在单独的进程中运行用户提供的代码。Citus 使用此 API 运行维护守护进程。该守护进程执行分布式死锁检测、两阶段提交准备事务恢复和清理。 通过这些钩子，Citus 可以拦截客户端和涉及 Citus 表的 PG 引擎之间的任何交互，并替换或增强 PG 的行为。 ","date":"2024-05-13","objectID":"/zhuanlan.zhihu/:4:0","tags":null,"title":"Citus: Distributed PostgreSQL for Data-Intensive Applications","uri":"/zhuanlan.zhihu/"},{"categories":null,"content":"5 Citus 的整体架构 Citus 部署通常包括一个 coordinator 和多个 worker. coordinator 保存表的元数据，用于客户端连接使用。 当用户通过 Citus UDF 添加工作节点时，PG 服务器隐式成为协调器。 worker 存储数据分片。 集群规模小时，协调器也可用作工作节点，最小 Citus 集群是单服务器。 单个 coordinator 作为入口点好处是 PG 库和工具可与 Citus 集群交互，就好像它是一个普通的 PG 服务器。由于分布式查询的开销与查询执行相比较小，一个大型协调器节点可以处理每秒数十万次的事务或通过 PG 的 COPY 命令每秒摄入数百万行的数据。 coordinator 节点可能成为系统瓶颈，Citus 通过元数据分发到 worker 节点解决，降低 coordinator 查询压力。 coordinator 只负 DDL 执行，减少压力。但这种方案可能导致 client 连接集群创建更多连接，可能带来另一个瓶颈。 ","date":"2024-05-13","objectID":"/zhuanlan.zhihu/:5:0","tags":null,"title":"Citus: Distributed PostgreSQL for Data-Intensive Applications","uri":"/zhuanlan.zhihu/"},{"categories":null,"content":"6 Citus 的表类型 Citus 有两种表， 分布表 和 引用表 。 在创建本地表后，通过执行 Citus 方法可将其转换为 Citus 表，并由 Citus 接管所有相关操作。 Citus 利用真分区键进行哈希，将数据均匀分布到 worker 节点上。 Citus 可以保证，相同哈希值的数据在相同节点，避免跨节点通信。分布表数据哈希分片到 worker 节点，引用表所有节点复制同步。在 join 时，worker 只需对本地分片执行。 ","date":"2024-05-13","objectID":"/zhuanlan.zhihu/:6:0","tags":null,"title":"Citus: Distributed PostgreSQL for Data-Intensive Applications","uri":"/zhuanlan.zhihu/"},{"categories":null,"content":"7 数据再平衡 当单个 worker 节点的数据达到负载极限时，我们需要将数据移动到新的节点，从而实现整体的负载均衡。 Citus 提供一个 rebalancer 来执行移动数据的操作，在执行 rebalance 操作时，rebalancer 会选取一个分片和与之相关的其他数据，通过 PG 的逻辑复制进行移动，这时，分片依然可以接收读写请求。 在完成所有存量和增量的复制后，Citus 会对分片加上写锁来等待所有复制完成，并执行分布表的元数据更改。这时一般会有几秒的写宕机。 ","date":"2024-05-13","objectID":"/zhuanlan.zhihu/:7:0","tags":null,"title":"Citus: Distributed PostgreSQL for Data-Intensive Applications","uri":"/zhuanlan.zhihu/"},{"categories":null,"content":"8 分布式查询计划器 在客户端请求查询 Citus 相关的数据表时，Citus 会生成一个包含有分布式查询计划的 Custom-Scan 节点，Citus 有不同的查询计划器，以应对不同场景下的查询请求。如下图所示： （A）： Fast path planner 快速路径规划器处理的是针对单个表的简单 CRUD 查询，并且该表只有一个分布列的取值。 它直接从查询中的过滤条件中提取分布列的值， 并确定与该值匹配的分片。 然后，规划器将表名重写为分片名，以构建在工作节点上运行的查询，这可以在 CPU 开销极小的情况下完成。 因此，快速路径规划器支持高吞吐量的 CRUD 工作负载。 （B）： Router planner 路由规划器处理的是可以限定在一组共同分布的分片上的任意复杂查询。 路由规划器会检查或推断所有分布表是否具有相同的分布列过滤条件。 如果是这样，查询中的表名将被重写为与分布列值匹配的共同分布分片的名称。 路由规划器隐式支持 PostgreSQL 支持的所有 SQL 特性，因为它会将完整的查询委托给另一个 PostgreSQL 服务器。 因此，路由规划器使多租户 SaaS 应用能够在最小开销下使用所有 SQL 特性。 （C）： Logical planner 逻辑规划器通过构建多关系代数树来处理跨分片的查询。 多关系代数形式化了两个在 PostgreSQL 中不可用的分布式执行原语，用于收集和重新分区数据。 这种差异影响了路由规划器和逻辑规划器之间的分离。 逻辑规划器的目标是在结果在 coordinator 上合并之前，将尽可能多的计算推送到工作节点。 这里有两种不同的逻辑规划策略： 逻辑下推规划器： 检测连接树是否可以完全下推。 这要求所有分布表之间具有共同分布的连接，并且子查询不需要全局合并步骤（例如，GROUP BY 必须包含分布列）。 如果是这样，规划器可以基本上不关心连接树中使用的 SQL 构造，因为它们完全委托给工作节点，分布式查询计划变得非常容易并行化。 逻辑连接顺序规划器： 确定涉及非共同分布连接的连接树的最佳执行顺序。 它使用共同分布连接、广播连接和重新分区连接来评估分布表和子查询之间所有可能的连接顺序，并选择最小化网络流量的顺序。 广播连接和重新分区连接会导致带有过滤器和投影的子计划被推送到子计划中。 对于每个查询，Citus 会按照最低到最高开销的顺序遍历这四个规划器。如果某个特定规划器可以为查询生成计划，Citus 就会使用它。在特定场景下，相比执行而言，查询计划的生成在时间开销上很低。 ","date":"2024-05-13","objectID":"/zhuanlan.zhihu/:8:0","tags":null,"title":"Citus: Distributed PostgreSQL for Data-Intensive Applications","uri":"/zhuanlan.zhihu/"},{"categories":null,"content":"9 分布式查询执行器 PG 的查询计划是一个由多个执行节点组成的执行树，每个节点都有一个返回一个元组的函数。 Citus 生成的 CustomScan 就是其中的一个节点。 PG 的执行器进入 CustomScan 函数后，Citus 会执行各个子计划，然后把执行移交给 adaptive executor 自适应执行器。自适应执行器可以通过单工作节点多路连接的方式并行执行查询任务。这种多路实现的方式需要管理过程中建立连接，以及并行处理过程中的额外开销。 自适应执行器需要权衡并行执行的延迟与各类开销。这里提出了一个“ slow start ”慢启动的方案。查询开始时，执行器对每个工作节点只建立一个连接，接下来，每 10ms，执行器会给每个工作节点的连接数（n）加 1。如果有 t 个等待交给某个工作节点执行的任务没有被分配到可用的连接， 那么执行器就会为这个工作节点创建 min(n, t) 个连接，并放入连接池中。 这种方案的原因在于，一个简单的内存中基于索引的查询往往只需要不到 1ms 的时间，所以一般来说节点上的所有任务会在执行器尝试打开连接之前完成。此外，分析型任务往往需要数百毫秒，尽管连接建立有一定的延迟，但是在整体的时间开销里几乎可以忽略。当然，这种方案下，执行器仍然需要管理与各个节点的连接数。 在执行连接上的任务分配时，由于每个连接到分片上执行查询时访问的是不同的数据，并在多语句事务的情况下保持未提交的写入和锁定。因此，对于每个连接，Citus 会跟踪已访问的分片，以确保相同的连接将在同一事务中对同一组共同分布的分片进行任何后续访问。在开始执行语句时，如果在事务中已经访问了分片，则将任务分配给对应的连接，否则将其分配给工作节点的通用池。当连接准备就绪时，执行器首先从其队列中获取一个已分配的任务，否则从通用池中获取任务。 通过结合慢启动、共享连接限制和任务分配算法，自适应执行器可以处理各种工作负载模式，即使它们在单个数据库集群上并发运行，并支持复杂的交互式事务块而不损失并行性。 ","date":"2024-05-13","objectID":"/zhuanlan.zhihu/:9:0","tags":null,"title":"Citus: Distributed PostgreSQL for Data-Intensive Applications","uri":"/zhuanlan.zhihu/"},{"categories":null,"content":"10 分布式事务 Citus 中的事务主要分两种，一种是在 coordinator 上的事务，一种是在工作节点上的事务。 对于仅仅涉及单个工作节点的事务，工作节点全权负责整个事务； 对于涉及多个节点的事务则通过 两阶段提交 来保证原子性。 单节点事务其实比较简单，我们主要看看多节点的事务如何基于两阶段提交来实现。 对于涉及多个节点的写事务，执行器在工作节点上开启事务块，并在提交时对它们执行两阶段提交（2PC）。 PostgreSQL 实现了准备事务状态的命令，以一种保留锁并在重新启动和恢复时保留状态的方式。这使得稍后可以提交或中止已准备好的事务。Citus 使用这些命令来实现完整的 2PC 协议。 当协调器上的事务即将提交时，预提交回调通过所有与开启事务块的工作节点的连接发送“准备事务”命令。 如果成功，协调器为每个已准备好的事务在 Citus 元数据中写入一个提交记录，然后本地事务提交，确保提交记录被耐久存储。 在提交后和中止回调中，已准备好的事务将尽力提交或中止。 当一个或多个已准备好的事务无法提交或中止时，将使用 Citus 元数据中的提交记录确定事务的结果。 后台守护进程定期比较每个工作节点上待处理的准备好的事务列表和本地的提交记录。 如果存在已准备好的事务的提交记录（即：可见），则协调器已经提交，因此已准备好的事务也必须提交。 当存在多个协调器时，每个协调器为其启动的事务执行 2PC 恢复。 反之，如果一个已结束的事务没有记录存在，那么已准备好的事务必须中止。 由于提交记录和已准备好的事务都存储在预写式日志中，这种方法对涉及的任何节点的故障是强大的。 另一个关键点在于 如何处理分布式死锁 ，特别是在多语句事务之间。为了解决这个问题，可以使用死锁预防或死锁检测方法。死锁预防技术（例如 Wound-Wait）需要一定百分比的事务重新启动。 PostgreSQL 具有交互式协议，这意味着在重新启动发生之前可能将结果返回给客户端，而且不希望客户端重试事务。因此，Wound-Wait 对于 Citus 来说不太适用。为了保持与 PostgreSQL 的兼容性， Citus 实现了分布式死锁检测 ，当事务陷入实际死锁时，会中止事务。 PostgreSQL 已经在单节点上提供了死锁检测。Citus 通过在协调器节点上运行的后台守护程序扩展了这一逻辑。该守护程序: 每 2 秒轮询所有工作节点，以获取其锁图中的边缘（进程 a 等待进程 b）， 然后合并在同一分布式事务中参与的图中的所有进程。 如果生成的图包含一个环路，那么将向属于环路中最年轻的分布式事务的进程发送取消命令，以中止事务。 除非存在实际死锁，否则在典型的（分布式）数据库工作负载中，只有少数事务会在等待锁。因此，分布式死锁检测的开销很小。当分布式死锁经常发生时，建议用户更改其事务中语句的顺序。 Citus 中的多节点事务提供了原子性、一致性和持久性的保证，但 不提供分布式快照隔离的保证 。并发的多节点查询可能在一个节点上提交之前获取本地 MVCC 快照，而在另一个节点上提交之后获取快照。解决这个问题需要对 PostgreSQL 进行更改，使快照管理器可扩展。在实践中，我们在这四种工作负载模式中并没有发现对分布式快照隔离的强烈需求，客户目前也没有表达对此的需求。在多租户和 CRUD 应用程序中，大多数事务范围仅限于单个节点，这意味着它们在该节点上获得了隔离保证。分析应用程序之间的事务没有强依赖关系，因此对宽松的保证更具宽容性。 在某些混合场景中，分布式快照隔离可能很重要。然而，现有的分布式快照隔离技术由于需要额外的网络往返或等待时钟而具有显著的性能成本，这会增加响应时间并降低可实现的吞吐量。在同步的 PostgreSQL 协议的背景下，吞吐量最终受到#连接数/响应时间的限制。由于从应用程序的角度来看，建立大量的数据库连接通常是不切实际的，因此低响应时间是实现高吞吐量的唯一途径。因此，如果将来实施分布式快照隔离，我们可能会将其作为可选项。 ","date":"2024-05-13","objectID":"/zhuanlan.zhihu/:10:0","tags":null,"title":"Citus: Distributed PostgreSQL for Data-Intensive Applications","uri":"/zhuanlan.zhihu/"},{"categories":null,"content":"11 其他场景的分布式处理 除了简单的 SELECT 语句和其他 DML 命令外，Citus 还提供其他语句的支持。 DDL 命令 在 PG 里面是在线处理的具有事务性的操作， Citus 同样通过加锁来保持相同的特性，并通过执行器将命令发送到 worker 节点 COPY 命令 在 PG 里面可以被用来导入 CSV 格式的数据，这个过程在 PG 里面是单线程的实现，并需要更新索引、检查各类约束条件。 在 citus 里面，coordinator 会在每一个分片和数据流上异步开启 COPY 命令，这样写操作也可以并行执行。 跨分布表的 INSERT…SELECT 命令往往采用以下三种步骤之一去执行： 如果 SELECT 操作在协调器上需要执行合并步骤，则该命令在内部作为分布式 SELECT 执行，然后将结果 COPY 到目标表中。 如果没有合并步骤，但源表和目标表不是共位的，则 INSERT..SELECT 在将 SELECT 结果插入目标表之前执行分布式重新分区。 如果源表和目标表是共位的，则 INSERT..SELECT 直接在并行的共位分片上执行。 在 Citus 中，存储过程可以基于分布参数和一个共位的分布表被委托给工作节点，以避免协调器和工作节点之间的网络往返。 工作节点可以在不进行网络往返的情况下在本地执行大多数操作，但在必要时也可以在工作节点之间执行分布式事务。这种方法有助于在分布式环境中优化存储过程的性能。 ","date":"2024-05-13","objectID":"/zhuanlan.zhihu/:11:0","tags":null,"title":"Citus: Distributed PostgreSQL for Data-Intensive Applications","uri":"/zhuanlan.zhihu/"},{"categories":null,"content":"12 高可用和备份 ","date":"2024-05-13","objectID":"/zhuanlan.zhihu/:12:0","tags":null,"title":"Citus: Distributed PostgreSQL for Data-Intensive Applications","uri":"/zhuanlan.zhihu/"},{"categories":null,"content":"12.1 高可用 在 Citus 中，HA 主要在服务器层使用现有的 PostgreSQL 复制进行处理。 在 HA 设置中，集群中的每个节点都有一个或多个热备份节点，并使用同步、异步或 quorum 来复制其写前日志（WAL）。 当一个节点失败时，集群协调器会提升一个备用节点，并更新 Citus 元数据、DNS 记录或虚拟 IP。 整个故障切换过程需要 20-30 秒，在此期间涉及该节点的分布式事务会回滚。 Coordinator 通常是托管服务中的控制面的一部分，但本地用户可以使用 pg_auto_failover 扩展来执行相同的功能。 ","date":"2024-05-13","objectID":"/zhuanlan.zhihu/:12:1","tags":null,"title":"Citus: Distributed PostgreSQL for Data-Intensive Applications","uri":"/zhuanlan.zhihu/"},{"categories":null,"content":"12.2 备份 备份也主要在服务器级别进行，通过创建周期性的磁盘快照或数据库目录的副本，并在每个服务器中将 WAL 持续存档到远程存储来实现。 Citus 支持定期创建一致的还原点，即每个节点的 WAL 记录。 还原点是在将写操作阻塞到 coordinator 上的提交记录表时创建的，这可以防止在创建还原点时进行中的两阶段提交。 将所有服务器还原到相同的还原点可以保证在恢复的集群中，所有多节点事务要么完全提交要么中止，或者可以通过协调器在启动时执行 2PC 恢复来完成。 ","date":"2024-05-13","objectID":"/zhuanlan.zhihu/:12:2","tags":null,"title":"Citus: Distributed PostgreSQL for Data-Intensive Applications","uri":"/zhuanlan.zhihu/"},{"categories":null,"content":"13 性能测试 Benchmark 部分，作者的实验基本围绕着不同场景下 PG 单机和 Citus 不同部署模型下的性能差距，包括 latency 、 QPS 、 TPS 等等。 ","date":"2024-05-13","objectID":"/zhuanlan.zhihu/:13:0","tags":null,"title":"Citus: Distributed PostgreSQL for Data-Intensive Applications","uri":"/zhuanlan.zhihu/"},{"categories":null,"content":"14 应用案例 这部分介绍了 Citus 在微软内部的使用，这一场景主要是一个数据分析场景，数据来自全球数亿台 windows 设备，指标显示在一个名为“Release Quality View”（RQV）的实时分析仪表板上，该仪表板帮助 Windows 工程团队评估每个 Windows 版本的客户体验质量。 RQV 的底层数据存储，代号为 VeniceDB，由两个在 Microsoft Azure 上运行的超过 1000 核心的 Citus 集群提供支持，存储了超过一 PB 的数据。虽然对于 VeniceDB 评估了许多不同的分布式数据库和数据处理系统，但只有 Citus 能够满足与 PB 级 VeniceDB 工作负载相关的特定要求，包括： 对于每天超过 6 百万次查询，p95 下的小于一秒的响应时间 每天约 10TB 的新数据 在 RQV 中显示新的数据需要在 20 分钟内完成 具有高基数 group by 的嵌套子查询 高级二级索引（例如部分索引、GiST 索引）以高效查找沿各个维度的报告 高级数据类型（例如数组、HyperLogLog）以在 SQL 中实现复杂的分析算法 通过增量聚合减少行数 在节点间进行原子更新以清理错误数据 在 Citus 集群中，原始数据存储在名为 measures 的表中，该表按设备 ID 进行分布，并使用 PostgreSQL 中内置的分区功能按时间进行磁盘分区。使用 COPY 命令来并行化将传入的 JSON 数据导入分布式表。使用分布式 INSERT..SELECT 命令来执行设备级别的对传入数据进行预聚合，并将其放入几个具有不同索引的 reports 表中。reports 表也按设备 ID 进行分布，并与 measures 表共位，以便 Citus 可以完全并行化 INSERT..SELECT。 这里给出了一个典型的查询语句： SELECT ..., avg(device_avg) FROM ( SELECT deviceid, ..., avg(metric) as device_avg FROM reports WHERE ... GROUP BY deviceid, \u003ctime period\u003e , \u003cother dimensions\u003e ) AS subq GROUP BY \u003ctime period\u003e, \u003cother dimensions\u003e; 这些查询通过多个维度进行过滤（例如测量、时间范围、Windows 版本），以找到数据的重要子集。嵌套的子查询首先通过设备 ID 对报告进行聚合，这对于按设备而不是按报告数量来衡量整体平均值是必要的。每个查询可能涉及数千万台设备，这使得按 deviceid 进行 GROUP BY 的计算变得具有挑战性。由于子查询按照分布列进行分组，Citus 中的逻辑推送计划器认识到它可以将整个子查询推送到所有工作节点以进行并行化。然后，工作节点使用仅索引扫描按设备 ID 顺序读取数据，并最小化 GROUP BY 的磁盘 I/O 和内存占用。最后， Citus 通过在工作节点上计算部分聚合并在协调器上合并这些部分聚合来分发外部聚合步骤，以生成最终结果。 ","date":"2024-05-13","objectID":"/zhuanlan.zhihu/:14:0","tags":null,"title":"Citus: Distributed PostgreSQL for Data-Intensive Applications","uri":"/zhuanlan.zhihu/"},{"categories":null,"content":"15 相关工作 这部分大体介绍了当前市面上常见的分布式数据库解决方案： 针对 MySQL 的类似于 Citus 的方案 Vitess，采取了和 Citus 相似的实现方案 - 基于 PG 的解决方案 Greenplum and Redshift，相比 Citus 而言对分析场景具有更好的支持，比如采用列存来实现快速 scan，通过数据 shuffle 来优化 join 性能等 Aurora 同样也对 PG 进行了支持，通过分布式存储的实现，Aurora 采用了存算分离、共享存储的方案，这种方案的好处在于调用端不需 要做许多分布式场景下的决策，可以直接把 Aurora 当做单机 DB 来使用。 Citus 则需要调用方对分布方案有足够的理解和干预。 Spanner ，CockroachDB 和 Yugabyte 主要面向需要分布式事务支持的场景。CockroachDB 和 Yugabyte 也部分支持 PostgreSQL 协议。 与 Citus 相比，这些系统的一个显著的架构差异在于它们提供了分布式快照隔离，并使用了\"等待-等待\"（wound-wait）而不是死锁检测。分布式快照隔离的一个优点是它避免了数据建模的约束。Citus 用户需要使用邻近数据存储和引用表，以将事务范围限制到单个节点，以获得完整的 ACID 保证。另一方面，这些技术还能实现高效的连接和外键，因此它们对于扩展复杂的关系数据库工作负载是至关重要的。 TimescaleDB 是一个为时间序列数据优化的 PostgreSQL 扩展。它使用与 Citus 相似的钩子来引入“超级表”（hypertable）的概念，该 表会根据时间自动进行分区。按时间对表进行分区对于限制索引大小以保持时间序列工作负载的高写入性能，以及通过时间范围进行分区修剪以加速查询是有用的。由于对 PostgreSQL 钩子的冲突使用，目前 Citus 和 TimescaleDB 不兼容，但 Citus 可以与 pg_partman 一起使用，后者是一个更简单的时间分区扩展。许多使用 Citus 的实时分析应用程序也会在分布式表的基础上使用 pg_partman，在这种情况下，各个分片会被本地分区，以获得分布式表和时间分区的双重优势。 整体而言，Citus 的分布式解决方案需要用户直接介入数据切片、数据同步、数据存储等多个过程，对于使用者而言需要一定背景知识。这一实现方案的好处在于 Citus 可以快速发布支持最新版本 PG 的新版本。 ","date":"2024-05-13","objectID":"/zhuanlan.zhihu/:15:0","tags":null,"title":"Citus: Distributed PostgreSQL for Data-Intensive Applications","uri":"/zhuanlan.zhihu/"},{"categories":null,"content":"本文为摘录(或转载)，侵删，原文为： attachments/org-fold-core.el ","date":"2024-05-13","objectID":"/org-fold-core/:0:0","tags":null,"title":"org-fold-core","uri":"/org-fold-core/"},{"categories":null,"content":" Table of Contents 1 节点 1.1 Coordinator 与 Worker 2 分布式数据 2.1 表类型 2.2 Shards 3 查询执行 本文为摘录(或转载)，侵删，原文为： https://www.51cto.com/article/703272.html ","date":"2024-05-13","objectID":"/www.51cto.com_article_703272/:0:0","tags":["transaction","pg","citus"],"title":"分布式 PostgreSQL之Citus 架构-postgresql 分布式","uri":"/www.51cto.com_article_703272/"},{"categories":null,"content":"1 节点 Citus 是一种 PostgreSQL 扩展，它允许数据库服务器(称为节点)在“无共享(shared nothing)”架构中相互协调。这些节点形成一个集群，允许 PostgreSQL 保存比单台计算机上更多的数据和使用更多的 CPU 内核。这种架构还允许通过简单地向集群添加更多节点来扩容数据库。 ","date":"2024-05-13","objectID":"/www.51cto.com_article_703272/:1:0","tags":["transaction","pg","citus"],"title":"分布式 PostgreSQL之Citus 架构-postgresql 分布式","uri":"/www.51cto.com_article_703272/"},{"categories":null,"content":"1.1 Coordinator 与 Worker 每个 cluster 都有一个称为 coordinator (协调器) 的特殊节点(其他节点称为 worker 节点)。 应用程序将它们的查询发送到 coordinator 节点， coordinator 节点将其转发给相关的 worker 并累积结果。 对于每个查询，coordinator 根据所需数据是位于单个节点上还是多个节点上： 要么将其路由到单个 worker 节点， 要么将其并行化到多个节点， coordinator 通过查阅其 元数据表 知道如何做到这一点 这些 Citus 特定表跟踪 worker 节点的 DNS 名称和运行状况， 以及跨节点数据的分布情况。 ","date":"2024-05-13","objectID":"/www.51cto.com_article_703272/:1:1","tags":["transaction","pg","citus"],"title":"分布式 PostgreSQL之Citus 架构-postgresql 分布式","uri":"/www.51cto.com_article_703272/"},{"categories":null,"content":"2 分布式数据 ","date":"2024-05-13","objectID":"/www.51cto.com_article_703272/:2:0","tags":["transaction","pg","citus"],"title":"分布式 PostgreSQL之Citus 架构-postgresql 分布式","uri":"/www.51cto.com_article_703272/"},{"categories":null,"content":"2.1 表类型 Citus 集群中有三种类型的表，每种表都以不同方式存储在节点中，并且用于不同的目的： 分布表 引用表 本地表 2.1.1 类型 1：分布式表 第一种类型，也是最常见的，是分布式表。对于 SQL 语句而言，它们看似是普通的表，但在 worker 节点之间 水平分区 。 这里 table 的行存储在 worker 的表 table_1001 、 table_1002 等中。组件 worker 表称为分片(shards)。 2.1.1.1 分布列 Citus 使用使用分片算法将行分配到分片。基于表列(称为 分布列 (distribution column))的值执行分配，此分配具有确定性。集群管理员在分布表时必须指定此列。做出正确的选择，这一点对于性能和功能有重要影响。 2.1.2 类型 2：引用表 （复制表） 引用表 是一种分布式表，其全部内容都集中到单个分片中，并在每个 worker 上复制。 对任何 worker 的查询都可以在本地访问引用信息，无需从另一个节点请求行，因此也不会产生此类网络开销。 引用表没有分布列，因为无需区分每行的各个分片。 引用表通常很小，用于存储与在任何工作节点上运行的查询相关的数据。 例如，订单状态或产品类别等枚举值。 当与 引用表 交互时，我们会自动对事务执行两阶段提交 (2PC)。这意味着 Citus 确保您的数据始终处于一致状态，无论您是在写入、修改还是删除它。 2PC https://en.wikipedia.org/wiki/Two-phase_commit_protocol 2.1.3 类型 3：本地表 当您使用 Citus 时，您连接并与之交互的 coordinator 节点是安装了 Citus 扩展的常规 PostgreSQL 数据库。因此，您可以创建普通表并选择不对其进行分片。这对于不参与连接查询的小型管理表很有用。一个示例是用于应用程序登录和身份验证的用户表。 创建标准 PostgreSQL 表很容易，因为它是默认值。这是你运行 CREATE TABLE 时得到的。在几乎每个 Citus 部署中，我们都会看到标准 PostgreSQL 表与 distributed 和 reference 表共存。事实上，如前所述，Citus 本身使用本地表来保存集群元数据。 ","date":"2024-05-13","objectID":"/www.51cto.com_article_703272/:2:1","tags":["transaction","pg","citus"],"title":"分布式 PostgreSQL之Citus 架构-postgresql 分布式","uri":"/www.51cto.com_article_703272/"},{"categories":null,"content":"2.2 Shards 上一节将分片描述为在 worker 节点内的较小表中包含分布式表的行的子集。本节详细介绍了技术细节。 协调器上的 pg_dist_shard 元数据表包含系统中每个分布式表的每个分片的行。该行与分片 ID 相匹配，分片 ID 的范围是一组哈希整数 (shardminvalue, shardmaxvalue) 。 SELECT * from pg_dist_shard; logicalrelid | shardid | shardstorage | shardminvalue | shardmaxvalue ---------------+---------+--------------+---------------+--------------- github_events | 102026 | t | 268435456 | 402653183 github_events | 102027 | t | 402653184 | 536870911 github_events | 102028 | t | 536870912 | 671088639 github_events | 102029 | t | 671088640 | 805306367 (4 rows) 如果 coordinator 节点要确定哪个分片包含 github_events 行，它将对行中分布列的值执行哈希算法。然后此节点检查哪个分片的范围包含此哈希值。定义范围后，哈希函数的 image(图像) 就是两者的并查。 2.2.0.1 分片放置 假设分片 102027 与相应的行关联。在某个 worker 中的 github_events_102027 表中读取或写入此行。是哪个 worker?这完全由元数据表确定。分片映射到 worker 的过程称为分片放置(shard placement)。 coordinator 节点将查询重写为引用特定表(例如 github_events_102027)的片段，并对相应 worker 运行这些片段。下面的查询示例在后台运行，旨在查找分片 ID 为 102027 的节点。 SELECT shardid, node.nodename, node.nodeport FROM pg_dist_placement placement JOIN pg_dist_node node ON placement.groupid = node.groupid AND node.noderole = 'primary'::noderole WHERE shardid = 102027; ┌─────────┬───────────┬──────────┐ │ shardid │ nodename │ nodeport │ ├─────────┼───────────┼──────────┤ │ 102027 │ localhost │ 5433 │ └─────────┴───────────┴──────────┘ 在 github_events 示例中，有四个分片。每个表的分片数量在其在集群中分布时是可配置的。 最后请注意，Citus 允许复制分片以防止数据丢失。有两种复制“模式”：Citus 复制和流复制。前者创建额外的备份分片放置并针对所有更新它们的所有它们运行查询。后者效率更高，利用 PostgreSQL 的流式复制将每个节点的整个数据库备份到一个 follower 数据库。这是透明的，不需要 Citus 元数据表的参与。 2.2.0.2 共置 由于可以根据需要将分片及其副本放置在节点上，因此将包含相关表的相关行的分片放在同一节点上是有意义的。这样，它们之间的连接查询可以避免通过网络发送尽可能多的信息，并且可以在单个 Citus 节点内执行。 一个示例是包含商店、产品和购买的数据库。如果所有三个表都包含 - 并且由 - store_id 列分布，那么限制在单个存储中的所有查询都可以在单个工作节点上高效运行。即使查询涉及这些表的任意组合也是如此。 2.2.0.3 并行性 跨多台机器分散查询允许一次运行更多查询，并允许通过向集群添加新机器来扩展处理速度。此外，如上一节所述，将单个查询拆分为片段可以提高专用于它的处理能力。后一种情况实现了最大的并行性，这意味着 CPU 内核的利用率。 读取或影响均匀分布在多个节点上的分片的查询能够以“实时”速度运行。请注意，查询的结果仍然需要通过协调器节点传回，因此当最终结果紧凑时(例如计数和描述性统计等聚合函数)，加速效果最为明显。 ","date":"2024-05-13","objectID":"/www.51cto.com_article_703272/:2:2","tags":["transaction","pg","citus"],"title":"分布式 PostgreSQL之Citus 架构-postgresql 分布式","uri":"/www.51cto.com_article_703272/"},{"categories":null,"content":"3 查询执行 在执行多分片查询时，Citus 必须平衡并行性的收益与数据库连接的开销(网络延迟和工作节点资源使用)。要配置 Citus 的查询执行以获得最佳的数据库工作负载结果，它有助于了解 Citus 如何管理和保存协调节点和工作节点之间的数据库连接。 Citus 将每个传入的多分片查询会话转换为称为任务的每个分片查询。它将任务排队，并在能够获得与相关工作节点的连接时运行它们。对于分布式表 foo 和 bar 的查询，下面是连接管理图： coordinator 节点为每个会话都有一个连接池。每个查询(例如图中的 SELECT * FROM foo)仅限于为每个 worker 的任务打开最多 citus.max_adaptive_executor_pool_size(整数)个同时连接。该设置可在会话级别进行配置，以进行优先级管理。 在同一连接上按顺序执行短任务比为它们并行建立新连接更快。另一方面，长时间运行的任务受益于更直接的并行性。 为了平衡短任务和长任务的需求，Citus 使用 citus.executor_slow_start_interval(整数)。该设置指定多分片查询中任务的连接尝试之间的延迟。当查询首先对任务进行排队时，这些任务只能获取一个连接。在每个有待处理连接的时间间隔结束时，Citus 会增加它将打开的同时连接数。通过将 GUC 设置为 0，可以完全禁用慢启动行为。 当任务完成使用连接时，会话池将保持连接打开以供以后使用。缓存连接避免了 coordinator 和 worker 之间重新建立连接的开销。但是，每个池一次打开的空闲连接不超过 citus.max_cached_conns_per_worker(整数)个，以限制 worker 中空闲连接资源的使用。 最后，设置 citus.max_shared_pool_size (integer) 充当故障保险。它限制了所有任务之间每个 worker 的总连接数。 ","date":"2024-05-13","objectID":"/www.51cto.com_article_703272/:3:0","tags":["transaction","pg","citus"],"title":"分布式 PostgreSQL之Citus 架构-postgresql 分布式","uri":"/www.51cto.com_article_703272/"},{"categories":null,"content":" Table of Contents 1 Q 2 A 2.1 Basic authentication 2.2 Using personal access tokens 本文为摘录(或转载)，侵删，原文为： https://stackoverflow.com/questions/33655700/github-api-fetch-issues-with-exceeds-rate-limit-prematurely ","date":"2024-05-11","objectID":"/stackoverflow.com_33655700_github-api-fetch-issues-with-exceeds-rate-limit-prematurely/:0:0","tags":["gh"],"title":"Github API: Fetch issues with exceeds rate limit prematurely","uri":"/stackoverflow.com_33655700_github-api-fetch-issues-with-exceeds-rate-limit-prematurely/"},{"categories":null,"content":"1 Q I am building an app that fetches the issues and pull requests of over 1K github repos, like this. $ curl -i \"https://api.github.com/repos/user/repo/issues?state=closed\" My problem is that, after the initial 60 iterations I get a rate limit error: { \"message\": \"API rate limit exceeded for xxx.xxx.xxx.xxx. (But here's the good news: Authenticated requests get a higher rate limit. Check out the documentation for more details.)\", \"documentation_url\": \"https://developer.github.com/v3/#rate-limiting\" } The document says I can make upto 5000 requests using Authentication Which I registered an oauth for and obtained Client ID and Client Secret tokens https://api.github.com/repos/%7Brepo.name%7D/issues?client_id=...\u0026client_secret=… Still the rate limit shows up only after about 60 requests. ","date":"2024-05-11","objectID":"/stackoverflow.com_33655700_github-api-fetch-issues-with-exceeds-rate-limit-prematurely/:1:0","tags":["gh"],"title":"Github API: Fetch issues with exceeds rate limit prematurely","uri":"/stackoverflow.com_33655700_github-api-fetch-issues-with-exceeds-rate-limit-prematurely/"},{"categories":null,"content":"2 A The public GitHub API requests are limited to 60 / hour / ip, like you observed. That’s why you need authentication. There are multiple ways to get authenticated when you use the GitHub APIs. ","date":"2024-05-11","objectID":"/stackoverflow.com_33655700_github-api-fetch-issues-with-exceeds-rate-limit-prematurely/:2:0","tags":["gh"],"title":"Github API: Fetch issues with exceeds rate limit prematurely","uri":"/stackoverflow.com_33655700_github-api-fetch-issues-with-exceeds-rate-limit-prematurely/"},{"categories":null,"content":"2.1 Basic authentication Basically, you provide the username and the password. curl -u your-username \"https://api.github.com/repos/user/repo/issues?state=closed\" This will prompt you for entering the password. If you dont want to use the password, you can use a personal token: curl -u username:token \"https://api.github.com/repos/user/repo/issues?state=closed\" ","date":"2024-05-11","objectID":"/stackoverflow.com_33655700_github-api-fetch-issues-with-exceeds-rate-limit-prematurely/:2:1","tags":["gh"],"title":"Github API: Fetch issues with exceeds rate limit prematurely","uri":"/stackoverflow.com_33655700_github-api-fetch-issues-with-exceeds-rate-limit-prematurely/"},{"categories":null,"content":"2.2 Using personal access tokens This is my favorite, but make sure you don’t share the token code with others. To generate a new token, open this page, and you will create the token. Then you can use it like this: curl \"https://api.github.com/repos/user/repo/issues?state=closed\u0026access_token=token\" (replace the token snippet at the end of the url with your token code) ◎ OAuth If you want to implement authentication for other users, you should use OAuth. The docs are good in this direction. ","date":"2024-05-11","objectID":"/stackoverflow.com_33655700_github-api-fetch-issues-with-exceeds-rate-limit-prematurely/:2:2","tags":["gh"],"title":"Github API: Fetch issues with exceeds rate limit prematurely","uri":"/stackoverflow.com_33655700_github-api-fetch-issues-with-exceeds-rate-limit-prematurely/"},{"categories":null,"content":" Table of Contents 1 prelog 2 Configurable parameters 3 SICleanupQueue 3.1 重置后的处理 3.2 信号的处理 本文为摘录(或转载)，侵删，原文为： https://github.com/postgres/postgres/blob/master/src/backend/storage/ipc/sinval.c ","date":"2024-04-25","objectID":"/sinvaladt/:0:0","tags":["pg","cache","inval","msg","postgres"],"title":"shared cache invalidation","uri":"/sinvaladt/"},{"categories":null,"content":"1 prelog 共享缓存失效消息在一个无限数组中存储，maxMsgNum 是下一个数组下标来存储提交的消息， minMsgNum 是最小的数组下标，包含尚未被所有后端读取的消息，始终满足 maxMsgNum \u003e= minMsgNum。每个活跃后端都有一个 nextMsgNum 指针，指示下一个需要读取的消息；对每个后端都有 maxMsgNum \u003e= nextMsgNum \u003e= minMsgNum。 消息实际上存储在一个 MAXNUMMESSAGES 条目的循环缓冲区中。我们将 MsgNum 值转换为循环缓冲区索引，通过计算 MsgNum % MAXNUMMESSAGES。只要 maxMsgNum 不比 minMsgNum 多出超过 MAXNUMMESSAGES，缓冲区就足够大。如果缓冲区溢出，我们通过为每个已经太落后的后端设置 “reset” 标志来恢复。 为降低需要重置的概率，我们向任何看起来严重滞后的后端发送“catchup” 中断。当一个后端完成处理 catchup 中断后，它执行 SICleanupQueue，这将在需要时向滞后最远的后端发送信号。这避免了多个后端同时尝试赶上导致的不必要争用。然而，最落后的后端可能被困在无法赶上的状态。最终，它会被重置，因此不会再给其他任何人带来问题。 对共享 sinval 数组访问受两个锁的保护，SInvalReadLock 和 SInvalWriteLock。读者以共享模式获取 SInvalReadLock；这允许它们修改自己的 ProcState，但不能修改或查看其他读者的。写者总是以独占模式获取 SInvalWriteLock，以串行化向列队添加消息。最多一个这样的中断正在飞行，当一个后端完成处理 catchup 中断后，它执行 SICleanupQueue，如果需要，则将信号传递给下一个最落后的后端。 /* 共享失效结构状态， 存在于每个后端中 */ typedef struct ProcState { /* 如果 ProcState 数组条目处于非活动状态，procPid 为零。 */ pid_t procPid; // 后端的 PID，用于信号传递 */ /* 如果 procPid == 0 或 resetState 为真，则 nextMsgNum 没有意义。 */ int nextMsgNum; /* 下一个要读取的消息号 */ bool resetState; /* 后端需要重置其状态 */ bool signaled; // 后端已发送“追赶”信号 */ bool hasMessages; // 后端有未读消息 */ /* */ * 后端只发送失效信息，不接收失效信息。只有在恢复期间的启动进程才有意义， * 因为它不维护 relcache，但会发送失效消息以让查询后端看到模式更改。 */ bool sendOnly; // 后端只发送，不接收 */ /* * 每个空闲后端槽使用的下一个LocalTransactionId。 我们将其保存在这里是因为它由ProcNumber索引， * 并且在设置MyProcNumber时将值从本地内存复制到其中非常方便。在活动ProcState条目中没有意义。 */ LocalTransactionId nextLXID; } ProcState; /* 共享缓存失效内存段, 存在于共享内存中 */ typedef struct SISeg { /* 通用状态信息 */ int minMsgNum; /* 最早仍然需要的消息 */ int maxMsgNum; // 下一个要分配的消息数字 */ int nextThreshold; /* 调用 SICleanupQueue 的消息数量 */ slock_t msgnumLock; // 保护 maxMsgNum 的自旋锁 */ /* 保存共享失效消息的循环缓冲区 */ SharedInvalidationMessage buffer[MAXNUMMESSAGES]; /* * 每个后端失效状态信息 * * 'procState' 有 NumProcStateSlots 个条目，并且由 pgprocno 进行索引。 * 'numProcs' 是当前使用的插槽数，'pgprocnos' 是它们索引的稠密数组，以加快扫描所有正在使用的插槽的速度。 * * 'pgprocnos' 在很大程度上与 ProcArrayStruct-\u003epgprocnos 重复，但有了我们单独的副本，避免了 * ProcArrayLock 上的争用，并允许我们仅跟踪参与共享缓存失效的进程。 */ int numProcs; int *pgprocnos; ProcState procState[FLEXIBLE_ARRAY_MEMBER]; } SISeg; ","date":"2024-04-25","objectID":"/sinvaladt/:1:0","tags":["pg","cache","inval","msg","postgres"],"title":"shared cache invalidation","uri":"/sinvaladt/"},{"categories":null,"content":"2 Configurable parameters MAXNUMMESSAGES 我们可以缓冲的共享失效消息的最大数量。为了提高速度，必须是 2 的幂次方。 MSGNUMWRAPAROUND 多久将 MsgNum 变量减小一次以避免溢出。必须是 MAXNUMMESSAGES 的倍数。应该足够大。 CLEANUP_MIN 在我们打扰调用 SICleanupQueue 之前必须在缓冲区中存在的消息的最小数目。 CLEANUP_QUANTUM 一旦超过 CLEANUP_MIN ，调用 SICleanupQueue 的频率（以消息数计）。为了提高速度，应为 2 的幂次方。 SIG_THRESHOLD 后端必须落后多少个消息才会发送 PROCSIG_CATCHUP_INTERRUPT 的最小消息数量。 WRITE_QUANTUM 在 SIInsertDataEntries 的每次迭代中将推送到缓冲区的最大消息数。非关键，但应该小于 CLEANUP_QUANTUM ，因为我们每次迭代只考虑调用 SICleanupQueue 一次。 ","date":"2024-04-25","objectID":"/sinvaladt/:2:0","tags":["pg","cache","inval","msg","postgres"],"title":"shared cache invalidation","uri":"/sinvaladt/"},{"categories":null,"content":"3 SICleanupQueue 删除已被所有活跃后端进程消费的消息 如果调用者持有 SInvalWriteLock，则 callerHasWriteLock 为 true。 minFree 是要释放的最小消息槽数量。 落后太多的会被重置 (stateP-\u003eresetState = true) 严重落后但不至于重置的，会被发送信号 PROCSIG_CATCHUP_INTERRUPT 一次最多对一个后端进行信号处理。 注意：由于我们在信号其他后端进程时瞬时释放写锁，退出时不保证仍有 minFree 个空闲消息槽。调用者必须重新检查并可能重试。 ","date":"2024-04-25","objectID":"/sinvaladt/:3:0","tags":["pg","cache","inval","msg","postgres"],"title":"shared cache invalidation","uri":"/sinvaladt/"},{"categories":null,"content":"3.1 重置后的处理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 void AcceptInvalidationMessages(void) { ReceiveSharedInvalidMessages(LocalExecuteInvalidationMessage, InvalidateSystemCaches); // ... skipped ... } void ReceiveSharedInvalidMessages(void (*invalFunction) (SharedInvalidationMessage *msg), void (*resetFunction) (void)) { // ... skipped ... getResult = SIGetDataEntries(messages, MAXINVALMSGS); if (getResult \u003c 0) { /* got a reset message */ elog(DEBUG4, \"cache state reset\"); SharedInvalidMessageCounter++; resetFunction(); break; /* nothing more to do */ } // ... skipped ... } int SIGetDataEntries(SharedInvalidationMessage *data, int datasize) { // ... skipped ... if (stateP-\u003eresetState) { /* * Force reset. We can say we have dealt with any messages added * since the reset, as well; and that means we should clear the * signaled flag, too. */ stateP-\u003enextMsgNum = max; stateP-\u003eresetState = false; stateP-\u003esignaled = false; LWLockRelease(SInvalReadLock); return -1; } // ... skipped ... } ReceiveSharedInvalidMessages() 中调用 SIGetDataEntries() 来取得未处理的消息 SIGetDataEntries() 发现被重置后，返回 -1 ReceiveSharedInvalidMessages() 检查到返回值小于 0 ，则调用传入的回调函数 InvalidateSystemCaches() 来进行清理缓存 ","date":"2024-04-25","objectID":"/sinvaladt/:3:1","tags":["pg","cache","inval","msg","postgres"],"title":"shared cache invalidation","uri":"/sinvaladt/"},{"categories":null,"content":"3.2 信号的处理 信号处理最终会调到函数 ProcessCatchupInterrupt() ： /* * ProcessCatchupInterrupt * * 处理追赶中断的部分，运行在信号处理程序之外，使其能够实际处理待处理的失效消息。 */ void ProcessCatchupInterrupt(void) { while (catchupInterruptPending) { /* * 在这里我们需要让 ReceiveSharedInvalidMessages() 函数运行，它将进行必要的处理并重置 * catchupInterruptPending 标志。如果我们正在事务中，可以直接调用 AcceptInvalidationMessages() * 来执行这个操作。如果不是，在这里启动并立即结束一个事务；AcceptInvalidationMessages() 的调用 * 发生在事务启动内部。 * * 很诱人地，我们可以尝试只调用 AcceptInvalidationMessages()，而不执行事务启动/停止的其他操作， * 我认为在正常情况下这样做是可行的；但是如果出现错误，我不确定处理会不会很顺利。 */ if (IsTransactionOrTransactionBlock()) { elog(DEBUG4, \"ProcessCatchupEvent inside transaction\"); AcceptInvalidationMessages(); } else { elog(DEBUG4, \"ProcessCatchupEvent outside transaction\"); StartTransactionCommand(); CommitTransactionCommand(); } } } AcceptInvalidationMessages() 见 2 。 ","date":"2024-04-25","objectID":"/sinvaladt/:3:2","tags":["pg","cache","inval","msg","postgres"],"title":"shared cache invalidation","uri":"/sinvaladt/"},{"categories":null,"content":" Table of Contents 1 解决 calibre 导入书籍和传输书籍不是中文名称问题 2 我的解决方法 2.1 追加 本文为摘录(或转载)，侵删，原文为： https://mp.weixin.qq.com/s?__biz=MzA5MTgxNzM0Nw==\u0026mid=2653286264\u0026idx=1\u0026sn=78ffdd914a3863f0b3927485e669bd98\u0026chksm=8ba7db94bcd05282c10916297526edefb001f4b88ef18434c85e20d44a784893a1b91b80df37\u0026mpshare=1\u0026scene=1\u0026srcid=0410rJQbgLUkbG2wSAoTpbln\u0026sharer_shareinfo=6d065c71e8d859f972c14e5e0361382b\u0026sharer_shareinfo_first=6d065c71e8d859f972c14e5e0361382b#rd ","date":"2024-04-10","objectID":"/%E8%A7%A3%E5%86%B3calibre%E5%AF%BC%E5%85%A5%E4%B9%A6%E7%B1%8D%E5%92%8C%E4%BC%A0%E8%BE%93%E4%B9%A6%E7%B1%8D%E4%B8%8D%E6%98%AF%E4%B8%AD%E6%96%87%E5%90%8D%E7%A7%B0%E9%97%AE%E9%A2%98/:0:0","tags":null,"title":"解决calibre导入书籍和传输书籍不是中文名称问题","uri":"/%E8%A7%A3%E5%86%B3calibre%E5%AF%BC%E5%85%A5%E4%B9%A6%E7%B1%8D%E5%92%8C%E4%BC%A0%E8%BE%93%E4%B9%A6%E7%B1%8D%E4%B8%8D%E6%98%AF%E4%B8%AD%E6%96%87%E5%90%8D%E7%A7%B0%E9%97%AE%E9%A2%98/"},{"categories":null,"content":"1 解决 calibre 导入书籍和传输书籍不是中文名称问题 去官网下载最新版本软件，安装 下载源码 git clone https://github.com/kovidgoyal/calibre.git check out 相应安装版本，根据需求修改源代码。 gco v5.43.0(gco = git checkout) 修改 backend.py 文件，删掉 ascii_filename(）方法，解决导入书籍生成不是中文名称的问题。 修改 smart_device_app 包下的 driver.py 文件，解决传输后书籍不是中文名称的问题。修改内容如下： 创建快捷方式 vim /usr/local/bin/calibre-develop 写入内容 #!/bin/sh export CALIBRE_DEVELOP_FROM=\"/Users/kovid/work/calibre/src\" calibre-debug -g 授予权限 chmod +x /usr/local/bin/calibre-develop 配置环境变量 #calibre export CALIBRE=/Applications/calibre.app/Contents/MacOS export PATH=$PATH:$CALIBRE 启动程序 calibre-develop ","date":"2024-04-10","objectID":"/%E8%A7%A3%E5%86%B3calibre%E5%AF%BC%E5%85%A5%E4%B9%A6%E7%B1%8D%E5%92%8C%E4%BC%A0%E8%BE%93%E4%B9%A6%E7%B1%8D%E4%B8%8D%E6%98%AF%E4%B8%AD%E6%96%87%E5%90%8D%E7%A7%B0%E9%97%AE%E9%A2%98/:1:0","tags":null,"title":"解决calibre导入书籍和传输书籍不是中文名称问题","uri":"/%E8%A7%A3%E5%86%B3calibre%E5%AF%BC%E5%85%A5%E4%B9%A6%E7%B1%8D%E5%92%8C%E4%BC%A0%E8%BE%93%E4%B9%A6%E7%B1%8D%E4%B8%8D%E6%98%AF%E4%B8%AD%E6%96%87%E5%90%8D%E7%A7%B0%E9%97%AE%E9%A2%98/"},{"categories":null,"content":"2 我的解决方法 按照上面的方法搞了一遍，发现没起作用，没再去研究为什么，就直接修改了系统的 calibre 。。。 为了后续更新方便，把修改过程写在了 emacs 里面： (defun yc/fix-calibre () \"Fix calibre.\" (interactive) (let ((file (pcase system-type ('gnu/linux \"/usr/lib64/calibre/calibre/utils/filenames.py\") (_ (error \"Platform %s not support\" system-type))))) (if (yc/file-exists-p file) (with-current-buffer (yc/find-file-as-root file nil t) (goto-char (point-min)) (unless (re-search-forward \"# 替换为下划线\" nil t) (goto-char (point-min)) (search-forward \"def ascii_filename(\") (replace-match \" import re def ascii_filename(\") (goto-char (pos-eol)) (insert \" return re.sub(r'[\\/\\\\\\:\\*\\?\\\"\\\u003c\\\u003e\\|]', substitute, orig) # 替换为下划线 \") (save-buffer)) (kill-buffer (current-buffer))) (error \"Can't open file: %s\" file)))) ","date":"2024-04-10","objectID":"/%E8%A7%A3%E5%86%B3calibre%E5%AF%BC%E5%85%A5%E4%B9%A6%E7%B1%8D%E5%92%8C%E4%BC%A0%E8%BE%93%E4%B9%A6%E7%B1%8D%E4%B8%8D%E6%98%AF%E4%B8%AD%E6%96%87%E5%90%8D%E7%A7%B0%E9%97%AE%E9%A2%98/:2:0","tags":null,"title":"解决calibre导入书籍和传输书籍不是中文名称问题","uri":"/%E8%A7%A3%E5%86%B3calibre%E5%AF%BC%E5%85%A5%E4%B9%A6%E7%B1%8D%E5%92%8C%E4%BC%A0%E8%BE%93%E4%B9%A6%E7%B1%8D%E4%B8%8D%E6%98%AF%E4%B8%AD%E6%96%87%E5%90%8D%E7%A7%B0%E9%97%AE%E9%A2%98/"},{"categories":null,"content":"2.1 追加 gentoo 里面提供的 binpkg 使用 解决 calibre 导入书籍和传输书籍不是中文名称问题 里提到的方法不起作用，但是如果 calibre 是从官网下载的二进制版本，则可以。。。 ","date":"2024-04-10","objectID":"/%E8%A7%A3%E5%86%B3calibre%E5%AF%BC%E5%85%A5%E4%B9%A6%E7%B1%8D%E5%92%8C%E4%BC%A0%E8%BE%93%E4%B9%A6%E7%B1%8D%E4%B8%8D%E6%98%AF%E4%B8%AD%E6%96%87%E5%90%8D%E7%A7%B0%E9%97%AE%E9%A2%98/:2:1","tags":null,"title":"解决calibre导入书籍和传输书籍不是中文名称问题","uri":"/%E8%A7%A3%E5%86%B3calibre%E5%AF%BC%E5%85%A5%E4%B9%A6%E7%B1%8D%E5%92%8C%E4%BC%A0%E8%BE%93%E4%B9%A6%E7%B1%8D%E4%B8%8D%E6%98%AF%E4%B8%AD%E6%96%87%E5%90%8D%E7%A7%B0%E9%97%AE%E9%A2%98/"},{"categories":null,"content":"本文为摘录(或转载)，侵删，原文为： https://gist.github.com/alesk/3826552 将 CSV 转换为 org 表格 将文本导入文件，标记文本，然后按下 C-c | 。它会将该区域转换为表格。 要导出 请使用 M-x org-table-export。 参考资料： http://stackoverflow.com/questions/1241581/emacs-import-a-csv-into-org-mode ","date":"2024-04-07","objectID":"/gist.github.com_alesk_3826552/:0:0","tags":["org","csv","table"],"title":"Emacs org mode hints – convert between csv \u0026 org table","uri":"/gist.github.com_alesk_3826552/"},{"categories":null,"content":" Table of Contents 1 背景 2 消息收发架构 2.1 消息发送架构 2.2 消息接收架构 2.3 小结 3 消息防丢失机制 3.1 sequence 机制 3.2 消息收取 sequnece 确认机制 本文为摘录(或转载)，侵删，原文为： https://mp.weixin.qq.com/s/dD-aPhnynOqSC3MUYLjeAA 2023 年，微信及 WeChat 的 DAU（月活用户）达到 13.4 亿，微信已经是很多人工作、生活中不可或缺的一个环节。从 2011 年 1 月 21 日上线至今，微信已经走过了 13 个年头，其背后的技术基座与架构也发生了巨大的变化。 这些变化背后，所折射的也正是中国互联网高速发展的黄金年代。腾讯云开发者社区特别策划了「十年前的技术」系列，带大家回顾那些明星项目背后最初的技术架构。好的架构是生长出来的，却也少不了良好的设计，愿各位读者都能从中获得启发，找到力量。 ","date":"2024-03-29","objectID":"/mp.weixin.qq.com_s_dd-aphnynoqsc3muyljeaa/:0:0","tags":["wechat","weixin"],"title":"十年前的微信消息收发架构长啥样","uri":"/mp.weixin.qq.com_s_dd-aphnynoqsc3muyljeaa/"},{"categories":null,"content":"1 背景 微信诞生于 QQMail 团队，初始的整个微信后台架构都带着浓重的邮箱气息，消息收发架构作为微信最为核心的部分，同样是基于邮箱的存储转发机制演变而来。微信定位为即时通讯软件，对消息的收发有 2 个基本的要求： 消息尽可能的实时送达。 不丢消息。 在邮箱的存储转发机制上做了改良后，微信的消息收发实现了以上 2 个基本要求。 ","date":"2024-03-29","objectID":"/mp.weixin.qq.com_s_dd-aphnynoqsc3muyljeaa/:1:0","tags":["wechat","weixin"],"title":"十年前的微信消息收发架构长啥样","uri":"/mp.weixin.qq.com_s_dd-aphnynoqsc3muyljeaa/"},{"categories":null,"content":"2 消息收发架构 ","date":"2024-03-29","objectID":"/mp.weixin.qq.com_s_dd-aphnynoqsc3muyljeaa/:2:0","tags":["wechat","weixin"],"title":"十年前的微信消息收发架构长啥样","uri":"/mp.weixin.qq.com_s_dd-aphnynoqsc3muyljeaa/"},{"categories":null,"content":"2.1 消息发送架构 首先通过手机 A 给手机 B 发送一条微信消息来看消息发送的整体架构是怎样的, 如图 1 所示： 微信消息发送在整体架构上可以分为 2 个部分： 手机 A 发送消息到服务器（图 1 中 1，2，3 部分） 手机 A 发送发消息请求到接入层 ConnnectSvr； 接入层收到请求后，将请求转到逻辑层 SendSvr 进行处理； 逻辑层处理完各种逻辑（如反垃圾，黑名单等等）之后，将消息存入存储层 MsgStore。 服务器发送通知到手机 B（图 1 中 4，5.1，5.2，6，7 部分） 4. 逻辑层 SendSvr 将给手机 B 的新消息到达通知发送到通知处理服务器 PushSvr； 5. 5.1：PushSvr 查询手机 B 在接入层所在长连接的 ConnectSvr， 并将通知发给该 ConnectSvr； 5.2：PushSvr 发送一个 Push tips 给手机操作系统自建的第三方 Push 系统（如苹果的 ApnsPush，微软的 WPPush，黑莓的 BBPush 等）。像苹果的 IOS 系统，在 APP 退出到后台 10 分钟后就会释放掉该 APP 所持有的所有资源（如 CPU，网络，内存等），导致之前建立的长连接通道也会一并断掉，此时通过 5.1 的方式进行通知是不可达的，所以还需要依赖与苹果自身的 apns 通道来达到实时通知的目的； 6. 接入层 ConnnectSvr 通过手机 B 建立的长连接通道将新消息达到通知发送给手机 B； 7. 第三方 Push 服务器通过自建的 Push 通过发送 Push tips 到手机 B。 ","date":"2024-03-29","objectID":"/mp.weixin.qq.com_s_dd-aphnynoqsc3muyljeaa/:2:1","tags":["wechat","weixin"],"title":"十年前的微信消息收发架构长啥样","uri":"/mp.weixin.qq.com_s_dd-aphnynoqsc3muyljeaa/"},{"categories":null,"content":"2.2 消息接收架构 手机 B 在收到新消息到达通知后进行消息收取的整体架构如图 2 所示： 消息收取的流程主要分为 3 个步骤： 手机 B 发起收取消息的请求到接入层服务器 ConnnectSvr； 接入层服务器 ConnnectSvr 接到请求后转给逻辑层服务器 ReceiveSvr 进行处理； ReceiveSvr 从存储层 MsgStore 中获取到需要下发的消息。 ","date":"2024-03-29","objectID":"/mp.weixin.qq.com_s_dd-aphnynoqsc3muyljeaa/:2:2","tags":["wechat","weixin"],"title":"十年前的微信消息收发架构长啥样","uri":"/mp.weixin.qq.com_s_dd-aphnynoqsc3muyljeaa/"},{"categories":null,"content":"2.3 小结 以上消息收发架构可以保证手机 A 在发出消息 100ms 级别内让手机 B 收取到该条消息。当然 对于退出后台的苹果 IOS 用户，在苹果的 apns 服务器正常的情况下，也可以保证在秒级别内通知到手机 B 点开 APP 进入前台来收取消息。 ","date":"2024-03-29","objectID":"/mp.weixin.qq.com_s_dd-aphnynoqsc3muyljeaa/:2:3","tags":["wechat","weixin"],"title":"十年前的微信消息收发架构长啥样","uri":"/mp.weixin.qq.com_s_dd-aphnynoqsc3muyljeaa/"},{"categories":null,"content":"3 消息防丢失机制 消息收发架构保证了消息收发双方能够及时收发消息，但该架构不能保证消息在传输过程中不发生丢弃。当然为了达到任意一条消息都不丢的状态，最简单的方案是手机端对收到的每条消息都给服务器进行一次 ack 确认，但该方案在手机端和服务器之间的交互过多，并且也会遇到在弱网络情况下 ack 丢失等问题。为了完美的做到消息不丢，微信消息系统对消息收发引入了 sequence 机制。 ","date":"2024-03-29","objectID":"/mp.weixin.qq.com_s_dd-aphnynoqsc3muyljeaa/:3:0","tags":["wechat","weixin"],"title":"十年前的微信消息收发架构长啥样","uri":"/mp.weixin.qq.com_s_dd-aphnynoqsc3muyljeaa/"},{"categories":null,"content":"3.1 sequence 机制 每个用户都有 42 亿的 sequence 空间（从 1 到 UINT_MAX），从小到大连续分配； 每个用户的每条消息都需要分配一个 sequence； 服务器存储有每个用户已经分配到的最大 sequence； 手机端存储有已收取消息的最大 sequence。 ","date":"2024-03-29","objectID":"/mp.weixin.qq.com_s_dd-aphnynoqsc3muyljeaa/:3:1","tags":["wechat","weixin"],"title":"十年前的微信消息收发架构长啥样","uri":"/mp.weixin.qq.com_s_dd-aphnynoqsc3muyljeaa/"},{"categories":null,"content":"3.2 消息收取 sequnece 确认机制 当服务器和手机端都拥有了一个 sequence 之后，服务器和手机端之间就可以根据两者 sequence 的差异来收取消息，同时保证手机端未收取下去的消息最终能够收取下去。具体流程如图 3 表示： 根据服务器和手机端之间 sequence 的差异，可以很轻松的实现增量下发手机端未收取下去的消息。 对于在弱网络环境差的情况，丢包情况发生概率是比较高的，此时经常会出现服务器的回包不能到达手机端的现象。由于手机端只会在确切的收取到消息后才会更新本地的 sequence，所以即使服务器的回包丢了，手机端等待超时后重新拿旧的 sequence 上服务器收取消息，同样是可以正确的收取未下发的消息。 由于手机端存储的 sequence 是确认收到消息的最大 sequence，所以对于手机端每次到服务器来收取消息也可以认为是对上一次收取消息的确认。一个帐号在多个手机端轮流登录的情况下，只要服务器存储手机端已确认的 sequence，那就可以简单的实现已确认下发的消息不会重复下发，不同手机端之间轮流登录不会收到其他手机端已经收取到的消息。 * 如图 4 所示，假如手机 A 拿 Seq_cli = 100 上服务器收取消息，此时服务器的 Seq_svr = 150，那手机 A 可以将 sequence 为[101 - 150]的消息收取下去，同时手机 A 会将本地的 Seq_cli 置为 150。 * 如图 5 所示，手机 A 在下一次再次上来服务器收取消息，此时 Seq_cli = 150，服务器的 Seq_svr = 200，那手机 A 可以将 sequence 为 [151 - 200]的消息收取下去。 * 如图 6 所示，假如原手机 A 用户换到手机 B 登录，并使用 Seq_cli = 120 上服务器收取消息，由于服务器已经确认 sequence \u003c= 150 的消息已经被手机收取下去了，故不会再返回 sequence 为[121 - 150]的消息给手机 B，而是将 sequence 为[151 - 200]的消息下发给手机 B。这里虽然 sequence 为[151 - 200]的消息有可能是被手机 A 和手机 B 都收取到，但由于手机 A 在收到 sequence 为[151 - 200]的消息时并没有给服务器进行确认或者这些消息手机 A 压根就没有收取到，所以为了防止消息丢失，sequence 为[151 - 200]的消息也是需要下发给手机 B 的。 ● 04 总结 以上简单的描述了微信消息收发的架构，该架构实现了即时通讯软件对消息收发所需的两个基本要求： 消息尽可能的实时送达 。 不丢消息。 以上，是 2014 年微信古早时期的消息收发架构的基本介绍，时过境迁，微信的消息收发架构已经发生了巨大的变化，但我们还是可以从中看到技术演变的价值与力量。 程序员最大的成就与幸福，或许就是自己的代码跑在千万人的设备上，默默支撑着海量的需求。 ","date":"2024-03-29","objectID":"/mp.weixin.qq.com_s_dd-aphnynoqsc3muyljeaa/:3:2","tags":["wechat","weixin"],"title":"十年前的微信消息收发架构长啥样","uri":"/mp.weixin.qq.com_s_dd-aphnynoqsc3muyljeaa/"},{"categories":null,"content":" Table of Contents 1 Q 2 A: 3 Further more 本文为摘录(或转载)，侵删，原文为： https://superuser.com/questions/77504/how-to-strip-audio-streams-from-an-mkv-file ","date":"2024-03-27","objectID":"/superuser.com_77504_how-to-strip-audio-streams-from-an-mkv-file/:0:0","tags":null,"title":"video - How to strip audio streams from an MKV file? - Super User","uri":"/superuser.com_77504_how-to-strip-audio-streams-from-an-mkv-file/"},{"categories":null,"content":"1 Q 我一直在尝试从一个 MKV（Matroska）文件中删除不需要的音频流。我这样做的原因是为了避免在 Windows Media Player 中手动选择所需的流。 输入文件提供了以下的 ffmpeg 信息： 流 #0.0: 视频: mpeg4, yuv420p, 704x396 [PAR 1:1 DAR 16:9], 29.98 tbr, 1k tbn, 29.98 tbc 流 #0.1(eng): 音频: aac，24000 Hz，5.1，s16 流 #0.2(jpn): 音频: aac，24000 Hz，5.1，s16 流 #0.3(eng): 字幕: 0x0000 流 #0.4(eng): 字幕: 0x0000 流 #0.5: 附件: 0x0000 流 #0.6: 附件: 0x0000 由于我想要的流是 0，1 和 3（sub），我的 ffmpeg 命令如下： ffmpeg -i input.mkv -map 0:0 -map 0:1 -map 0:3 -vcodec copy -acodec libmp3lame -newsubtitle test.mkv 但是却奇怪地出现了错误： 至少必须指定一个输出文件 如果要删除字幕： ffmpeg -i input.mkv -map 0:0 -map 0:1 -vcodec copy -acodec libmp3lame test.mkv 则会出现： 流映射数量必须与输出流的数量相匹配 我似乎不太理解“map”选项的工作原理。有人能帮我弄清楚吗？ ","date":"2024-03-27","objectID":"/superuser.com_77504_how-to-strip-audio-streams-from-an-mkv-file/:1:0","tags":null,"title":"video - How to strip audio streams from an MKV file? - Super User","uri":"/superuser.com_77504_how-to-strip-audio-streams-from-an-mkv-file/"},{"categories":null,"content":"2 A: 如果你只想删除一个流而不重新编码，你可能希望使用 MKVtoolnix 包来完成（请参阅 videohelp.com 的页面）。 有一些图形用户界面可能会帮助你（在 videohelp 链接中查找）。我不确定确切的 mkvmerge 命令行可能是什么，但我认为类似这样的内容会起作用： # 首先，获取音频轨道信息，这样我们知道要保留哪个 mkvmerge -i input.mkv File 'input.mkv': container: Matroska Track ID 1: video (V_MPEG4/ISO/AVC) Track ID 2: audio (A_AAC) Track ID 3: audio (A_AAC) \u003c----------- 例如，我们保留这个 Track ID 4: audio (A_AAC) mkvmerge -o output.mkv --audio-tracks 3 input.mkv 这样应该就可以了（很抱歉，我没有可用于测试的文件）。–audio-tracks 选项告诉 mkvmerge 仅将列出的音轨复制到新文件中。如果你想保留第 2 和第 3 轨道，但不要第 4 轨道，可以使用–audio-tracks 2,3。 mkvmerge 还有很多其他选项，比如设置标题、为音频添加延迟以同步等等，所以请查看 manpage 以获取详细信息。 ","date":"2024-03-27","objectID":"/superuser.com_77504_how-to-strip-audio-streams-from-an-mkv-file/:2:0","tags":null,"title":"video - How to strip audio streams from an MKV file? - Super User","uri":"/superuser.com_77504_how-to-strip-audio-streams-from-an-mkv-file/"},{"categories":null,"content":"3 Further more For anyone needing to automate this, I’ve done this: find ./ -maxdepth 1 -type f \\ -exec mkvmerge -o ./output/\"{}\" \\ --audio-tracks 2 \\ --video-tracks 0 \\ --subtitle-tracks 5 \\ --default-track-flag 2 \\ --default-track-fla g 5 \\ --forced-display-flag 5 \"{}\" \\; This finds all files in current directory, include only audio track 2 video track 0, and subtitle track 5. Also makes track 5 default subtitle and forces it. Then save each file in ./output directoy. ","date":"2024-03-27","objectID":"/superuser.com_77504_how-to-strip-audio-streams-from-an-mkv-file/:3:0","tags":null,"title":"video - How to strip audio streams from an MKV file? - Super User","uri":"/superuser.com_77504_how-to-strip-audio-streams-from-an-mkv-file/"},{"categories":null,"content":" Table of Contents 1 Introduction 2 Where it all start 3 What happens behind pg_plan_query 4 set_base_rel_sizes() 5 set_base_rel_pathlist() 6 generate_gather_paths 7 get_cheapest_fractional_path and create_plan 8 Examine the Plan 本文为摘录(或转载)，侵删，原文为： https://postgr.es/p/6s9 ","date":"2024-03-25","objectID":"/postgr.es_p_6s9/:0:0","tags":["pg","planner"],"title":"cary huang:  PostgreSQL’s Planner – Simple Scan Paths vs Plans","uri":"/postgr.es_p_6s9/"},{"categories":null,"content":"1 Introduction 当你向 PostgreSQL 发送查询时，通常会经历查询处理的各个阶段，并在最后返回结果。这些阶段被称为： 解析（Parse） 分析（Analyze） 重写（Rewrite） 规划（Plan） 执行（Execute） 在这篇博客中，我们将只关注“规划”阶段或者“规划器”模块，因为这或许是最有趣或者最复杂的阶段。我将分享我对规划器模块的理解，探究其内部运作以处理一个简单的顺序扫描。这将基于 PostgreSQL 16。 虽然规划器的目标非常简单，即从一系列可选路径中识别最快的“路径”，并据此制订一个“方案”，以便“执行器”模块在下一个阶段执行。然而， 要识别最快的“路径”正是使规划器变得复杂的原因 。 ","date":"2024-03-25","objectID":"/postgr.es_p_6s9/:1:0","tags":["pg","planner"],"title":"cary huang:  PostgreSQL’s Planner – Simple Scan Paths vs Plans","uri":"/postgr.es_p_6s9/"},{"categories":null,"content":"2 Where it all start 在 postgres.c 中的 exec_simple_query() 函数是查询处理阶段发生的地方。我们将关注它落在 pg_plan_query() 之后发生了什么。我只会提到它将会落在的重要函数。 ","date":"2024-03-25","objectID":"/postgr.es_p_6s9/:2:0","tags":["pg","planner"],"title":"cary huang:  PostgreSQL’s Planner – Simple Scan Paths vs Plans","uri":"/postgr.es_p_6s9/"},{"categories":null,"content":"3 What happens behind pg_plan_query 实际上会发生很多事情，比如： 标识子查询、分区表、外键表、连接等等 借助表访问方法估计所有涉及表的大小 确定完成查询的所有可能路径 顺序扫描、索引扫描、TID 扫描、并行工作线程等 在所有路径中找到最佳路径，通常是成本最低的 制定一个执行计划。 对于单个表的简单 SELECT 查询，不涉及任何连接或子查询，pg_plan_query 下的近似调用栈如下可视化描述： 这个甘特图被极大地简化，但展示了规划模块的若干关键要素。如果字太小，你可能需要下载图片以得到更好的视觉效果。接下来将详细解释带有蓝色星标记的区块。 ","date":"2024-03-25","objectID":"/postgr.es_p_6s9/:3:0","tags":["pg","planner"],"title":"cary huang:  PostgreSQL’s Planner – Simple Scan Paths vs Plans","uri":"/postgr.es_p_6s9/"},{"categories":null,"content":"4 set_base_rel_sizes() :NOTER_DOCUMENT: https://postgr.es/p/6s9 :NOTER_OPEN: eww :NOTER_PAGE: 2076 :END: 正如其名称所示，这是用于估算与所有关系（表、视图、索引等）有关的大小的主要入口点。 大小包括预估的行数（元组）和列数。 这些信息通常必须从“堆访问方法”中获取，其中它将可以访问“缓冲区管理器”和“存储管理器”以提供大小的估算。 总大小将是所有涉及表的大小之和。 这对后续的“成本估算”阶段非常重要。 ","date":"2024-03-25","objectID":"/postgr.es_p_6s9/:4:0","tags":["pg","planner"],"title":"cary huang:  PostgreSQL’s Planner – Simple Scan Paths vs Plans","uri":"/postgr.es_p_6s9/"},{"categories":null,"content":"5 set_base_rel_pathlist() 对于简单表的简单顺序扫描，程序会最终到达这里。其他更复杂的查询将使用不同的路径构建技术。有关其他路径构建技术，请参考 allpaths.c 中的“set_rel_pathlist()”。 目前，默认添加了 4 个扫描路径： 顺序扫描 逐个顺序扫描所有内容 部分顺序扫描 这是以“部分”添加的，因为它将由“gather”节点聚合，该节点在下一阶段考虑。这本质上意味着是一个并行顺序扫描 仅当关系或查询是并行安全时才添加 索引扫描 如果表有索引，可以考虑作为潜在路径 tid 扫描 如果查询包含范围限制子句（WHERE ctid \u003e ‘(1,30)’ AND ctid \u003c ‘(30,5)’），则 tid 扫描可能是一个选项 所有这些都需要一些成本，这些成本是由元组或页面的数量以及每个元组/页面的成本因素来估算的，如下配置: # - Planner Cost Constants - seq_page_cost = 1.0 # measured on an arbitrary scale random_page_cost = 4.0 # same scale as above cpu_tuple_cost = 0.01 # same scale as above cpu_index_tuple_cost = 0.005 # same scale as above cpu_operator_cost = 0.0025 # same scale as above parallel_setup_cost = 1000.0 # same scale as above parallel_tuple_cost = 0.1 # same scale as above 不同的路径方法具有不同的成本计算，它们会调用以下方法来计算“启动成本”和“运行成本”： cost_seqscan() cost_indexscan() cost_tidscan() 你可以在选择最理想路径制定计划时从根本上影响规划者的决策。例如，如果你希望规划者更频繁地使用并行扫描，你可以考虑降低每个并行扫描元组的成本，通过调小\"parallel_tuple_cost\"，比如设为 0.001。 “add_path” 函数被调用以将路径添加到潜在路径列表中，但请记住规划器的路径构建机制确实有一种排出机制。这意味着如果我们打算添加一条明显优于已添加的其他路径的路径，它可能会删除所有现有路径并接受新路径。同样，如果要添加的路径明显更差，则根本不会被添加。 如果规划程序认为并行顺序扫描是安全的，则会调用“add_partial_path”。这种顺序扫描是“partial”（部分的），因为需要对其进行收集和聚合，以形成最终结果，从而导致额外的成本，因此并行性可能并不总是理想的。以下是一个经验法则： 如果 PostgreSQL 需要扫描大量数据，但我们只需要其中的少量数据，则并行性可以帮助 如果 PostgreSQL 需要扫描大量数据，而其中大部分是我们需要的数据，则并行性可能会更慢。 ","date":"2024-03-25","objectID":"/postgr.es_p_6s9/:5:0","tags":["pg","planner"],"title":"cary huang:  PostgreSQL’s Planner – Simple Scan Paths vs Plans","uri":"/postgr.es_p_6s9/"},{"categories":null,"content":"6 generate_gather_paths 如果已经添加了一些部分路径，通常是顺序扫描子路径，则调用此例程。这个例程添加了一个名为“gather”的新路径类型，其中包含一个名为“顺序扫描”的子路径。gather 路径必须考虑每个子路径的成本，以及从并行工作程序获取元组和在最终形式中对数据进行聚合的成本。 ","date":"2024-03-25","objectID":"/postgr.es_p_6s9/:6:0","tags":["pg","planner"],"title":"cary huang:  PostgreSQL’s Planner – Simple Scan Paths vs Plans","uri":"/postgr.es_p_6s9/"},{"categories":null,"content":"7 get_cheapest_fractional_path and create_plan 一旦所有可能的路径候选项都被添加完毕，将调用此函数来选择最便宜的路径，即总成本最低的路径。然后选择的路径将被输入到“create_plan”中，其中路径（以及子路径（如果有））将会递归地创建，并制定成执行器能理解和执行的最终计划结构。 ","date":"2024-03-25","objectID":"/postgr.es_p_6s9/:7:0","tags":["pg","planner"],"title":"cary huang:  PostgreSQL’s Planner – Simple Scan Paths vs Plans","uri":"/postgr.es_p_6s9/"},{"categories":null,"content":"8 Examine the Plan 我们可以在查询之前使用 EXPLAIN ANALYZE 来检查规划器选择的最便宜的计划及其成本细节。以下示例是一个包含 1 个名为“gather”的主计划及 1 个局部计划“sequential scan”的查询计划，该计划有 2 个 worker。您可以通过箭头（-\u003e）来判断它代表一个子路径。 postgres=# explain analyze select * from test where a \u003e 500000 and a \u003c600000; QUERY PLAN ------------------------------------------------------------ Gather (cost=1000.00..329718.40 rows=112390 width=36) (actual time=62.362..5106.295 rows=99999 loops=1) Workers Planned: 2 Workers Launched: 2 -\u003e Parallel Seq Scan on test (cost=0.00..317479.40 rows=46829 width=36) (actual time=58.020..3416.544 rows=33333 loops=3) Filter: ((a \u003e 500000) AND (a \u003c 600000)) Rows Removed by Filter: 13300000 Planning Time: 0.489 ms Execution Time: 5110.030 ms (8 rows) 如果规划器选择了顺序扫描主路径而没有选择任何子路径，查询计划会如下所示： postgres=# explain analyze select * from test where a \u003e 500000; QUERY PLAN ------------------------------------------------------------ Seq Scan on test (cost=0.00..676994.40 rows=39571047 width=6) (actual time=0.011..7852.896 rows=39500000 loops=1) Filter: (a \u003e 500000) Rows Removed by Filter: 500000 Planning Time: 0.115 ms Execution Time: 9318.773 ms (5 rows) ","date":"2024-03-25","objectID":"/postgr.es_p_6s9/:8:0","tags":["pg","planner"],"title":"cary huang:  PostgreSQL’s Planner – Simple Scan Paths vs Plans","uri":"/postgr.es_p_6s9/"},{"categories":null,"content":" Table of Contents 1 What is Random Page Cost? 2 Diving Deeper 3 Seeing is Believing: Before and After Examples 3.1 Before (RPC = 4.0): 3.2 After (RPC = 1.1): 4 can perform it on a per query/connection basis 本文为摘录(或转载)，侵删，原文为： https://postgr.es/p/6oe 最近我在 Postgres 中处理一些查询，发现它要么选择不使用索引执行顺序扫描，要么选择使用复合部分索引的替代索引。这让我感到困惑，尤其是知道系统中有可以更快执行这些查询的索引时。 为什么会这样呢？ 经过一些研究，我偶然发现了 random_page_cost 参数。 ","date":"2024-02-26","objectID":"/postgr.es_p_6oe/:0:0","tags":null,"title":"100x Faster Query in Aurora Postgres with a lower random_page_cost","uri":"/postgr.es_p_6oe/"},{"categories":null,"content":"1 What is Random Page Cost? 想象在图书馆里寻找一本特定的书。按顺序阅读书籍就像数据库中的顺序扫描，而直接跳转到所需书籍就像随机访问。random_page_cost 反映了数据库中随机访问相对于顺序访问的成本。当 random_page_cost 较高时，Postgres 认为随机获取数据很昂贵，因此决定按顺序阅读所有内容（检查每一本书架上的书）代替。这个设置还会影响它是否决定使用完整索引还是部分或复合索引。我们将在下文中详细了解更多内容。 ","date":"2024-02-26","objectID":"/postgr.es_p_6oe/:1:0","tags":null,"title":"100x Faster Query in Aurora Postgres with a lower random_page_cost","uri":"/postgr.es_p_6oe/"},{"categories":null,"content":"2 Diving Deeper 魔法在于 PG 如何使用这个值。较高的 RPC（random_page_cost）会抑制索引的使用，更倾向于顺序扫描。在 Aurora Postgres 14.11 中，默认的 random_page_cost 目前为 4.0。然而，使用现代存储技术，随机访问的成本远低于传统旋转硬盘。通过根据这个实际情况调整 RPC，我们可以促使引擎更有效地利用索引，可能导致查询速度显著提高。 ","date":"2024-02-26","objectID":"/postgr.es_p_6oe/:2:0","tags":null,"title":"100x Faster Query in Aurora Postgres with a lower random_page_cost","uri":"/postgr.es_p_6oe/"},{"categories":null,"content":"3 Seeing is Believing: Before and After Examples 让我们通过一个具体但匿名化的例子来说明降低 RPC 的影响。在这里，我将使用 EXPLAIN ANALYZE 命令来比较在相同查询上调整 RPC 前后的查询计划。这个 LATERAL JOIN 查询旨在找到与名为 table_1 的表关联的有限数量的行，按其 ID 排序，同时排除已完成的条目，其 completed_at 具有值 /非空值。 现在，有两个索引存在 - 一个是标准索引 table_2_pkey，它是在 table_2 的主键上的索引。第二个是一个在 table_2 上的复合部分索引，其中索引在 table_1_id、id 上，并且在 (completed_at IS NULL) 条件下。 ","date":"2024-02-26","objectID":"/postgr.es_p_6oe/:3:0","tags":null,"title":"100x Faster Query in Aurora Postgres with a lower random_page_cost","uri":"/postgr.es_p_6oe/"},{"categories":null,"content":"3.1 Before (RPC = 4.0): 使用默认的 RPC，查询的执行时间大约为~11 秒。显然，这个时间非常长，对我们来说不可扩展。执行计划如下所示： Nested Loop (cost=0.42..95.02 rows=1000 width=117) (actual time=0.115..11286.991 rows=1000 loops=1) Buffers: shared hit=88534 -\u003e Seq Scan on table_1 (cost=0.00..5.20 rows=2 width=8) (actual time=0.017..0.023 rows=2 loops=1) Filter: (id = ANY ('{150,250}'::bigint[])) Rows Removed by Filter: 14 Buffers: shared hit=5 -\u003e Limit (cost=0.42..34.91 rows=500 width=117) (actual time=5149.715..5643.379 rows=500 loops=2) Buffers: shared hit=88529 -\u003e Index Scan using table_2_pkey on table_2 (cost=0.42..20413.13 rows=295949 width=117) (actual time=5149.713..5643.321 rows=500 loops=2) Filter: ((completed_at IS NULL) AND (table_1_id = table_1.id)) Rows Removed by Filter: 146339 Buffers: shared hit=88529 Planning: Buffers: shared hit=1 Planning Time: 0.204 ms Execution Time: 11287.091 ms 这里，PG 在 table_1 表上执行了顺序扫描，然后使用完整索引在 table_2 表上执行索引扫描。这是因为 PG 确定了使用默认 RPC 值 4.0 时，复合索引的成本更高，如上所述。 ","date":"2024-02-26","objectID":"/postgr.es_p_6oe/:3:1","tags":null,"title":"100x Faster Query in Aurora Postgres with a lower random_page_cost","uri":"/postgr.es_p_6oe/"},{"categories":null,"content":"3.2 After (RPC = 1.1): 现在，通过降低 RPC 以更好地反映存储系统的能力，PG 选择使用复合索引，因为它认为这样更轻松。 现在 PG 能够在不到 2 毫秒的时间内执行相同的查询（!!） Nested Loop (cost=0.56..57.04 rows=1000 width=117) (actual time=0.063..1.401 rows=1000 loops=1) Buffers: shared hit=344 -\u003e Index Only Scan using table_1_pkey on table_1 (cost=0.14..1.67 rows=2 width=8) (actual time=0.013..0.017 rows=2 loops=1) Index Cond: (id = ANY ('{150,250}'::bigint[])) Heap Fetches: 2 Buffers: shared hit=3 -\u003e Limit (cost=0.42..17.69 rows=500 width=117) (actual time=0.032..0.585 rows=500 loops=2) Buffers: shared hit=341 -\u003e Index Scan using idx_complete_table_2_on_table_1_id_id_where_completed_at_is_nul on table_2 (cost=0.42..10022.74 rows=290287 width=117) (actual time=0.030..0.531 rows=500 loops=2) Index Cond: (table_1_id = table_1.id) Buffers: shared hit=341 Planning: Buffers: shared hit=127 Planning Time: 0.647 ms Execution Time: 1.496 ms ","date":"2024-02-26","objectID":"/postgr.es_p_6oe/:3:2","tags":null,"title":"100x Faster Query in Aurora Postgres with a lower random_page_cost","uri":"/postgr.es_p_6oe/"},{"categories":null,"content":"4 can perform it on a per query/connection basis class ApplicationRecord \u003c ActiveRecord::Base # ... def with_minimized_page_cost(\u0026block) ActiveRecord::Base.connection.exec_query(\"SET random_page_cost=1.1\") yield ensure ActiveRecord::Base.connection.exec_query(\"RESET random_page_cost;\") end # ... end .. ApplicationRecord.with_minimized_page_cost do # Perform your queries here end ","date":"2024-02-26","objectID":"/postgr.es_p_6oe/:4:0","tags":null,"title":"100x Faster Query in Aurora Postgres with a lower random_page_cost","uri":"/postgr.es_p_6oe/"},{"categories":null,"content":" Table of Contents 1 Failed to login as normal user ","date":"2024-02-20","objectID":"/gentoo-tips/:0:0","tags":null,"title":"Gentoo Tips","uri":"/gentoo-tips/"},{"categories":null,"content":"1 Failed to login as normal user passwd 中，用户使用的 shell ， 必需是包含在 /etc/shells 里面的，否则会无法登录，哪怕密码没有问题。 ","date":"2024-02-20","objectID":"/gentoo-tips/:1:0","tags":null,"title":"Gentoo Tips","uri":"/gentoo-tips/"},{"categories":null,"content":" Table of Contents 1 Abort HashData 2 设计理念 3 架构介绍 3.1 管理模块 3.2 用户模块 4 产品特性 4.1 数据仓库服务 4.2 灵活高效的业务支持 4.3 多维度弹性 4.4 高可用和低成本 4.5 接近零停机时间 4.6 优化的硬件配置 4.7 兼容开源 4.8 完善的数据库能力 本文为摘录(或转载)，侵删，原文为： https://docs.hashdata.xyz/docs/20-product-guide/ ","date":"2024-01-12","objectID":"/20-product-guide/:0:0","tags":["hashta","pg"],"title":"HashData|产品介绍","uri":"/20-product-guide/"},{"categories":null,"content":"1 Abort HashData HashData was founded in 2016 by the guys who built Apache HAWQ, one of the most advanced SQL on Hadoop solutions. As the flagship product of the company, HashData Warehousing is a data warehouse service built for the cloud. While 100% compatible with the analytics interfaces of the open source MPP database Greenplum，HashData’s unique architecture delivers proven breakthroughs in performance, concurrency, elasticity and simplicity. HashData 成立于 2016 年，由构建 Apache HAWQ 的团队创立，后者是最先进的 SQL on Hadoop 解决方案之一。作为公司的旗舰产品，HashData Warehousing 是一种为云构建的数据仓库服务。虽然与开源 MPP 数据库 Greenplum 的分析接口 100%兼容，但 HashData 的独特架构在性能、并发性、弹性和简单性方面取得了明显突破。 ","date":"2024-01-12","objectID":"/20-product-guide/:1:0","tags":["hashta","pg"],"title":"HashData|产品介绍","uri":"/20-product-guide/"},{"categories":null,"content":"2 设计理念 HashData 云数仓是专 为云原生基础架构平台设计研发的分析性数据库 。 其核心设计理念是通过重构数据库处理核心，充分适配云原生基础架构，发挥云基础设施的资源弹性、运维管理和利用效率优势。这大幅提高了数据库服务在云原生架构下的配置效率，实现了 计算和存储的弹性扩展以及按需分配 的优势，从而为客户带来超高的投入产出比。 HashData 云数仓具有 近乎无限可扩展的数据容量、并发性和分析性能 。 它能够帮助企业整合内部的数据孤岛，轻松共享受监管的数据，并执行各种数据分析负载。同时，它能够无缝地跨越多个公共云和私有云，提供一致的数据分析体验。作为企业数据分析的核心引擎， HashData 为数据仓库、数据湖、数据工程、数据科学、数据应用程序开发和数据共享提供整体的解决方案。 HashData 的愿景是 让加载数据、分析数据、挖掘价值等任务变得更简单 : 打造一个让更多人能够更轻松地挖掘数据价值的平台， 消除企业规划、购买和运维基础设施带来的负担， 让企业专注于核心业务。 ","date":"2024-01-12","objectID":"/20-product-guide/:2:0","tags":["hashta","pg"],"title":"HashData|产品介绍","uri":"/20-product-guide/"},{"categories":null,"content":"3 架构介绍 HashData 云数仓的技术架构如下图所示： HashData 的云数仓分为管理模块和用户模块两大模块。其中： 管理模块包括管理控制台 用户模块包括租户集群，包含元数据服务、计算集服务和数据存储服务。 ","date":"2024-01-12","objectID":"/20-product-guide/:3:0","tags":["hashta","pg"],"title":"HashData|产品介绍","uri":"/20-product-guide/"},{"categories":null,"content":"3.1 管理模块 管理模块是云数仓的关键组成部分，用于管理控制平台（Cloudmanager）。其主要职责是 管理元数据集群和计算集群 ，包括创建、启停、资源管理以及监控告警等功能。 作为云数仓的重要组件，管理控制台能够统一管理各类云平台资源，并整合数据库集群的监控、运维和管理功能，建立统一的数字化管理和运维平台。通过实现图形化和自动化操作，管理模块实现了“所见即所得”的效果，大大降低了数据仓库集群的运维管理成本，使企业用户能够高效便捷地管理上万节点的数据仓库集群。 用户可以在管理控制台中进行: 创建／删除、启动／停止、扩容／缩容、升级集群等操作； 管理底层的对象存储、基础设施（节点生命周期等）； 查询和管理数据仓库自身的元数据，如用户、数据库、表、锁等； 配置管理 ETL 任务，编辑、保存 SQL 文本等。 ","date":"2024-01-12","objectID":"/20-product-guide/:3:1","tags":["hashta","pg"],"title":"HashData|产品介绍","uri":"/20-product-guide/"},{"categories":null,"content":"3.2 用户模块 HashData 云数仓的用户模块主要分为三个层次：元数据服务层、计算层和数据存储层。这三个层次之间是完全解耦的。 元数据服务层负责管理整个集群的元数据和事务，保证数据的一致性和完整性。 计算层主要负责接收用户查询请求、协调查询、优化查询和执行计算任务。 数据存储层提供持久化数据服务，所有计算集群节点都可以访问数据存储层，确保数据的可靠性和高可用性。 3.2.1 元数据服务层 元数据服务层包括：调度层、服务层、元数据持久层，架构和各层功能如下： 调度层 提供服务发现： 新建计算集群后，由调度层分配服务节点与计算集群的主节点进行连接，进行后续的元数据访问； 如果计算集群与服务节点的连接断开，需要重新建立连接时，由调度层决定该计算集群应该访问哪个服务节点； 调度层能够监控服务层和计算层的服务状态，当有节点宕机、服务进程宕或不可用等情况下，调度层将信息反馈给管理组件； 提供负载均衡： 调度层集群中的每个节点都存有等量数据,客户端连接时将自动进行节点分配，保证节点负载均衡（多活架构）； 调度层作为计算层与元数据层之间的桥梁,统筹协调对主节点与服务层之间的连接，保证连接的负载均衡； 服务层 服务层由一组服务节点组成， 每个服务节点其实是无状态的服务进程 负责接收计算集群发送过来的元数据请求。 元数据持久层 提供元数据存储服务； 提供元数据多副本及高可用服务。 3.2.1.1 元数据服务层的部署架构 元数据服务层是计算集群与数据库元数据交互的入口，而调度层主要用于服务发现，采用默认的 etcd 集群配置以保证高可用性。服务节点是无状态的进程，可以在任意空闲的物理服务器上启动。元数据持久层通过 FoundationDB 实现。 在系统中，调度层决定每个计算集群应该访问哪个元数据服务节点， 所有系统持久化状态信息都保存在元数据存储层中。 元数据服务层用于缓存热点元数据信息在内存中，并维护一些临时状态。 当元数据服务节点失败时，保存在内存的信息会丢失，但不会影响系统信息的一致性。系统会启动一个全新的元数据服务节点来替换失败的节点，并重新加载需要的状态信息。系统通过调度层实现元数据的负载均衡。 3.2.1.2 元数据服务的高可用机制 该架构遵循物理上解耦、逻辑上集成的原则。 整个元数据服务分为三层： 调度层、 调度层采用 etcd 集群来保证高可用性， 元数据服务层 元数据服务层无状态，因此即使节点失败，只需启动一个新的节点即可恢复； 元数据持久层 元数据持久层采用 FoundationDB 集群来保证高可用性。 整个元数据服务的高可用性取决于每个层级本身的高可用性。管理组件负责监控每一层的节点故障，并在保证各层高可用性的前提下将新的空闲节点替换失败的节点，以确保处理能力不下降。每一层根据需要提供的安全系数来调整部署方式和规模。 整体而言，该架构设计思想以高可用性、分布式数据库技术和根据需要调整规模为核心，确保元数据服务的稳定运行和可靠性。 3.2.2 计算层 计算层会包含多个独立的计算集群，这些集群共享存储服务和元数据服务，可以从共享服务中加载和查询数据，每个集群的资源和操作都是独立的，从而实现高度的敏捷性。 每个计算集群包含两种逻辑角色：主节点（Master）和计算节点（Segment），并由一个主节点和多个计算节点组成。 在这个逻辑结构中: 主节点负责管理和协调计算集群的操作 充当 QD 角色： 负责接受用户连接 进行认证授权 SQL 解析， 生成查询计划， 分发查询计划给计算节点， 汇总查询结构并返回给用户 主节点的本地磁盘只用做元数据的缓存使用： 所有元数据都存放在元数据持久层 所有的元数据请求及持久化操作都需要与元数据服务进行交互 计算节点则执行具体的计算任务。 充当 QE 的角色，是及集群中的计算单元 根据主节点分发的执行计划进行 SQL 运算 将执行结果反馈给主节点 计算节点不做应用数据持久化存储 根据需求从对象存储缓存所需数据 用户可以选择在物理服务器、虚拟服务器或容器上部署层，可以通过管理控制台配置每个物理服务器的 Segment 实例数量、操作系统参数和数据库参数。用户可以根据需求启动、暂停或扩容集群，新提交的查询会自动在调整后的新集群运行。在同一个共享存储的不同计算集群上可以独立运行不同的任务，实现基于同一份数据的并行大吞吐量工作负载，满足用户对低延迟和快速响应的需求。此外，它还支持在批量加载数据的表上进行数据科学操作，并为用户的仪表盘提供亚秒级的响应时间。最后，由于存在多个集群，可以在不停机或者对性能无影响的情况下，对单个集群进行扩缩容操作，提供了真正的弹性，计算节点数可以在 2 个和 1024 个之间任意伸缩。 3.2.2.1 数据分布式算法 HashData 云数仓采用的 基于一致性哈希算法 的数据分布策略, 其基本原理如下图所示： 一致性哈希算法通过将每条记录的内容计算出 Hash 值，然后映射到一个环上的一点，再将环分成若干连续的区间，每个区间对应一个计算节点，从而实现数据分布。新增节点时只需转移少量数据，是其最大优点。 与传统 MPP 架构的数据库相比，尽管一些产品采用了一致性哈希的数据分布策略，但在经典的完全无共享架构下，增删节点仍需迁移部分数据，虽然数据量减少。但 HashData 云数仓采用共享存储架构，在增加节点后，数据无需迁移，新的查询可实现秒级扩容。 在上图所示的例子中 （3，4），开始的时候集群包含两个计算节点，并将数据分成了六个切片。节点 1 负责数据切片 1、2、3，节点 2 负责数据切片 4、5、6。增加一个新的节点 3 之后，数据并不需要发生任何迁移。节点添加完成后，新的查询执行的时候，节点 1 负责数据切片 1、2，节点 2 负责数据切片 4、5，新增的节点 3 负责数据切片 3、6，但数据切片 3、6 不需要从节点 1、2 的缓存中抓取，而是直接从对象存储访问，然后在节点 3 本地缓存，从而做到秒级扩容。 3.2.2.2 计算集群高可用 该段文字主要描述了在计算集群中一台物理机发生故障后，管理组件能够感知并执行不同的故障恢复策略， 替换发生故障的物理节点 选择一个空闲的物理节点加入到计算集群，替换发生故障的物理节点 由于计算节点是没有状态的，整个替换过程非常迅速 当计算节点失败时，在底层的 IaaS 资源是充足的情况下，系统会通过底层的 IaaS 提供的 API 按照提前做好的镜像启动一个新的虚拟机，替换发生故障的计算节点。 从而确保一个计算节点发生故障的时候，系统能够及时启动新的虚拟机接替故障节点。而虚拟机所在的物理机发生故障的情况，IaaS 层会自动处理，上层的 HashData 云数仓是无感知的。 剔除发生故障的物理节点 当没有空闲的物理节点的情况下，计算集群执行一个类似缩容的操作将发生故障的物理节点踢出可用计算节点列表中， 这样新来的查询就按照新的可用计算节点列表来生成查询计划。 在生成查询计划的过程中，每个计算节点负责的数据块（包括后续的计算分析）将会按照一致性哈希的策略重新计算，等价于原来由发生故障节点负责的任务均匀打散分配给其它剩余正常工作的计算节点。 在节点发生故障后会导致每个计算节点负责的数据块（包括后续的计算分析）按照一致性哈希的策略重新映射（哪个正常工作的节点负责哪个数据块）的过程完全是按需的，只针对当前准备要执行的 SQL 语句，而不是全量的数据。所以每台物理服务器本地的磁盘容量大小对发生故障后恢复的效率没有任何影响。 后续发生故障的节点恢复了，只需要执行一个扩容的操作就可以将修复后的计算节点加入到可用计算节点列表中，这样新的查询就可以用上这个添加回来的节点。 3.2.2.3 计算集群数据缓存 对象存储服务理论上提供了无限的存储空间，但性能低于云盘或物理硬盘。为了提高计算集群的效率， HashData 云数仓使用本地硬盘作为对象存储服务的缓存，存储热点数据，减少直接访问对象存储的延迟和 API 调用开销，从而提升整体 IO 性能。该数据缓存方案跨集群、跨数据中心以及跨云中心实现数据访问，并保证数据的强一致性，用户可灵活合理地规划数据部署和使用。 通常情况下，缓存占热数据的 50% 左右和全量数据的 5%～10% 左右，系统性能将接近完全使用本地盘的水平。本地缓存的容量取决于本地磁盘的容量。 本地缓存主要有两种级别的策略： 最底层的是经典的 LRU 算法，在缓存空间不足时，会踢掉老数据； 上层的策略是根据数据库当前执行的 SQL 语句操作决定。 比如，ANALYZE 语句需要访问的数据不会被缓存，因为其只是为了更新统计信息，并不知道下次访问这张表的数据是何时。 INSERT INTO SELECT FROM 这类语句访问到的数据也不会被缓存，因为后续访问的数据通常是 INTO 的目标表，而不是 FROM 的源表。 通过估算热点数据来确定本地缓存系统的大小，以实现更高的查询性能。 3.2.3 数据存储层 数据存储层采用对象存储实现，提供统一的用户数据持久化，并以其架构优势实现数据访问安全和高可用功能。HashData 采用标准的对象存储访问协议，可与各类对象存储产品对接。 HashData 云数据仓库是基于对象存储和抽象服务构建的，支持多种对象存储方式。 在公有云场景下，对象存储与云虚拟块存储服务有显著差别：对象存储根据实际使用量按需收费，且单位容量的存储成本远低于类似 EBS 的云盘。这种按需付费和低存储成本让基于对象存储的云端数据仓库使用成本大幅降低。 在私有云环境中，对象存储集群的单位建设成本远低于块存储集群，对服务器和磁盘的要求也较低。此外，对象存储集群自身支持","date":"2024-01-12","objectID":"/20-product-guide/:3:2","tags":["hashta","pg"],"title":"HashData|产品介绍","uri":"/20-product-guide/"},{"categories":null,"content":"4 产品特性 ","date":"2024-01-12","objectID":"/20-product-guide/:4:0","tags":["hashta","pg"],"title":"HashData|产品介绍","uri":"/20-product-guide/"},{"categories":null,"content":"4.1 数据仓库服务 HashData 云数仓提供了企业用户快速启动数据仓库集群的能力，加载数据后可以立即进行数据分析任务。该数据库还承担了集群资源配置、数据备份、监控审计、错误恢复、高可用和升级等繁杂的运维工作，让用户专注于业务分析。 ","date":"2024-01-12","objectID":"/20-product-guide/:4:1","tags":["hashta","pg"],"title":"HashData|产品介绍","uri":"/20-product-guide/"},{"categories":null,"content":"4.2 灵活高效的业务支持 这段文字主要讲述了共享存储的优势，它可以让不同的计算集群独立运行不同的任务，实现基于同一份数据的并行运行大吞吐量工作负载。这样可以满足用户对低延迟、快速响应的需求。另外，用户还可以在批量加载数据的表上进行数据科学操作，并为用户仪表盘提供亚秒级的数据支持。 ","date":"2024-01-12","objectID":"/20-product-guide/:4:2","tags":["hashta","pg"],"title":"HashData|产品介绍","uri":"/20-product-guide/"},{"categories":null,"content":"4.3 多维度弹性 HashData 云数仓支持独立的扩展计算和存储，可以根据需求灵活增减吞吐量。 云原生架构可通过扩展存储应对不断增长的数据量， 增加计算集群数量以适应用户增加， 还可增加计算节点以提高响应速度，实现吞吐量、数据容量和响应时间的完全弹性。 ","date":"2024-01-12","objectID":"/20-product-guide/:4:3","tags":["hashta","pg"],"title":"HashData|产品介绍","uri":"/20-product-guide/"},{"categories":null,"content":"4.4 高可用和低成本 HashData 云数仓的整体架构设计思想包括物理上解耦、逻辑上集成，以及实现无单点故障设计。该架构涵盖管理控制台、元数据服务层、计算层和数据存储层，所有功能组件均实现了无单点故障和自动故障恢复，确保整个数据库服务能够实现高可用和高容错。云数仓可以部署在主流公有云和私有云环境，无论部署方式如何，都可实现故障自愈的高可用，并支持按需关闭或挂起暂时不用的数据库以控制成本。 ","date":"2024-01-12","objectID":"/20-product-guide/:4:4","tags":["hashta","pg"],"title":"HashData|产品介绍","uri":"/20-product-guide/"},{"categories":null,"content":"4.5 接近零停机时间 HashData 云数仓采用共享数据存储的架构设计，利用一致性 Hash 分布方案，能够实现在新建计算集群、对单个集群进行扩容或缩容操作时，无需进行数据迁移，避免集群维护操作需要停机，用户可以在此期间正常使用数据库。 ","date":"2024-01-12","objectID":"/20-product-guide/:4:5","tags":["hashta","pg"],"title":"HashData|产品介绍","uri":"/20-product-guide/"},{"categories":null,"content":"4.6 优化的硬件配置 HashData 云数仓提供灵活的计算和存储资源配置，可以根据业务需求选择合适的资源配置。这意味着可以利用小型计算集群处理 PB 级数据，也可以在较小的数据集上运行强大的计算集群。这种灵活性能更好地满足不同业务类型的数据处理需求，同时大幅提高了硬件资源利用效率。 ","date":"2024-01-12","objectID":"/20-product-guide/:4:6","tags":["hashta","pg"],"title":"HashData|产品介绍","uri":"/20-product-guide/"},{"categories":null,"content":"4.7 兼容开源 HashData 云数仓提供了与开源 PostgreSQL 和 Greenplum 完全兼容的查询接口和数据文件存储格式，并且支持相同的访问协议。这使得用户可以充分利用已有的 SQL 技能和在 BI 和 ETL 工具方面的投入，降低业务迁移成本。这种兼容性能够帮助用户轻松地迁移其现有的业务数据到 HashData 云数仓平台中，而无需担心数据格式或查询接口的变化。 ","date":"2024-01-12","objectID":"/20-product-guide/:4:7","tags":["hashta","pg"],"title":"HashData|产品介绍","uri":"/20-product-guide/"},{"categories":null,"content":"4.8 完善的数据库能力 该系统完全支持 UTF-8、GBK 等编码格式，支持多租户管理，关系数据模型和标准 SQL 语法。它还支持行、列两种存储引擎，并且支持单表和多表并发的插入、更新、删除操作，以及行级锁。此外，该系统满足事务数据强一致性，支持表数据并发增删改，支持主流的数据类型，以及常用数据库对象的创建、修改和删除操作，包括数据库、表、索引、视图、存储过程和自定义函数。它还支持数据库用户的创建、删除操作，以及用户权限的分配与回收。最后，该系统还支持完善的分区管理功能，以及主流的 JDBC、ODBC 等接口。 ","date":"2024-01-12","objectID":"/20-product-guide/:4:8","tags":["hashta","pg"],"title":"HashData|产品介绍","uri":"/20-product-guide/"},{"categories":null,"content":" Table of Contents 1 Question 2 Answer 2.1 For the Linux 2.6 kernel: 2.2 For the Linux 2.4 kernel: 本文为摘录(或转载)，侵删，原文为： https://www.broadcom.com/support/knowledgebase/1211161453667/how-can-3ware-and-megaraid-performance-be-increased-in-linux ","date":"2023-12-28","objectID":"/1211161453667_how-can-3ware-and-megaraid-performance-be-increased-in-linux/:0:0","tags":null,"title":"How can 3ware and MegaRAID performance be increased in Linux?","uri":"/1211161453667_how-can-3ware-and-megaraid-performance-be-increased-in-linux/"},{"categories":null,"content":"1 Question How can LSI 3ware and LSI MegaRAID performance be increased in Linux? ","date":"2023-12-28","objectID":"/1211161453667_how-can-3ware-and-megaraid-performance-be-increased-in-linux/:1:0","tags":null,"title":"How can 3ware and MegaRAID performance be increased in Linux?","uri":"/1211161453667_how-can-3ware-and-megaraid-performance-be-increased-in-linux/"},{"categories":null,"content":"2 Answer ","date":"2023-12-28","objectID":"/1211161453667_how-can-3ware-and-megaraid-performance-be-increased-in-linux/:2:0","tags":null,"title":"How can 3ware and MegaRAID performance be increased in Linux?","uri":"/1211161453667_how-can-3ware-and-megaraid-performance-be-increased-in-linux/"},{"categories":null,"content":"2.1 For the Linux 2.6 kernel: See KB article A004958 Article ID 1211161457978 See also: Article ID 1211161479669 Third party software such as SarCheck http://www.sarcheck.com can also be used. 2.1.1 For Hard Disk Drives (HDDs): echo \"deadline\" \u003e /sys/block/sda/queue/scheduler (Turn on deadline I/O scheduler) 2.1.2 For Solid State Drives (SSDs): In addition to echo \"deadline\" \u003e /sys/block/sda/queue/scheduler (Turn on deadline I/O scheduler) these will increase performance with SSDs: echo \"0\" \u003e /sys/block/sda/queue/rotational (Turn off seek reordering) echo \"975\" \u003e /sys/block/sda/queue/nr_requests (Turn up block layer queue depth for sda to 975) echo \"975\" \u003e /sys/block/sda/device/queue_depth (Turn up driver queue depth for sda to 975) kernel OS is 2.6.18 which limits the MegaRAID controller’s ability to use smp_affinity when used with motherboards with multiple processors (kernel 2.6.32 allows smp_affinity) ","date":"2023-12-28","objectID":"/1211161453667_how-can-3ware-and-megaraid-performance-be-increased-in-linux/:2:1","tags":null,"title":"How can 3ware and MegaRAID performance be increased in Linux?","uri":"/1211161453667_how-can-3ware-and-megaraid-performance-be-increased-in-linux/"},{"categories":null,"content":"2.2 For the Linux 2.4 kernel: Tuning Linux VM parameters may help to increase the read performance, depending your RAID type, application, and other factors. You can try this setting and see if it helps increase performance in your situation. The settings are: To make the change without having to reboot (change will not survive after a reboot), type the following from a command prompt: echo \"2048\" \u003e/proc/sys/vm/min-readahead echo \"2048\" \u003e/proc/sys/vm/max-readahead To make the change permanent, modify /etc/sysctl.conf and add the following lines: vm.max-readahead=2048 vm.min-readahead=2048 In addition, you can modify the bdflush parameter: sysctl -w \"vm.bdflush=10 500 0 0 500 3000 0 20 0\" Other information on Linux system tuning is available from: http://people.redhat.com/alikins/system_tuning.html There are no other 3ware specific tuning parameters for Linux for read performance. ","date":"2023-12-28","objectID":"/1211161453667_how-can-3ware-and-megaraid-performance-be-increased-in-linux/:2:2","tags":null,"title":"How can 3ware and MegaRAID performance be increased in Linux?","uri":"/1211161453667_how-can-3ware-and-megaraid-performance-be-increased-in-linux/"},{"categories":null,"content":" Table of Contents 1 pin_lock 概述 2 相关数据结构 2.1 struct spinlock 2.2 struct qnode 3 相关函数 3.1 初始化函数 3.2 上锁函数 3.3 解锁函数 3.4 尝试获取锁函数 3.5 判断上锁状态 3.6 还可以直接使用 raw_spinlock_t 和与其配套的一组 raw_spin_xxx() 4 锁代码分析 4.1 spin_lock() 4.2 spin_lock 持锁慢速路径 queued_spin_lock_slowpath(): 5 解锁代码分析 5.1 spin_unlock() 函数 6 总结 7 补充 本文为摘录(或转载)，侵删，原文为： https://www.cnblogs.com/hellokitty2/p/16368024.html ","date":"2023-12-28","objectID":"/p_16368024/:0:0","tags":null,"title":"Linux内核机制—spin_lock (转载)","uri":"/p_16368024/"},{"categories":null,"content":"1 pin_lock 概述 spin lock 是一种不可休眠锁，可用于原子上下文。当获取不到锁的时候会 spin 等待，此时是 running 状态。 spin lock 的发展到现在经历了四个阶段 (1) CAS 锁只有一个原子变量，执行单个 compare-and-swap 指令来获取锁。问题是没有公平可言，无法让等待最长的那个任务优先拿到锁，为了解决这个问题引入了 ticket spinlock。 (2) ticket spinlock 类似排队叫号，只有任务手中事先领取的号和被叫到的号相等时才能持锁进入临界区。这解决了不公平的问题。但是出现叫号时，所有等待的任务所在的 cpu 都要读取内存，刷新对应的 cache line，而只有获取锁的那个任务所在的 cpu 对 cache line 的刷新才是有意义的，锁争抢的越激烈，无谓的开销也就越大。 (3) MCS Lock 在 ticket spinlock 的基础上做一定的修改，让多个 CPU 不再等待同一个 spinlock 变量，而是基于各自的 per-CPU 的变量进行等待，那么每个 CPU 平时只需要查询自己对应的这个变量所在的本地 cache line，仅在这个变量发生变化的时候，才需要读取内存和刷新这条 cache line，这样就可以解决上述问题。要实现类似这样的 spinlock 的分身，其中的一种方法就是使用 MCS lock。试图获取一个 spinlock 的每个 CPU，都有一份自己的 MCS lock。 (4) qspinlock 相比起 Linux 中只占 4 个字节的 ticket spinlock，MCS lock 多了一个指针，要多占 4（或者 8）个字节，消耗的存储空间是原来的 2-3 倍。 qspinlock 的首要目标就是改进原生的 MCS lock 结构体，尽量将原生 MCS lock 要包含的内容塞进 4 字节的空间里。 如果只有 1 个或 2 个 CPU 试图获取锁，那么只需要一个 4 字节的 qspinlock 就可以了，其所占内存的大小和 ticket spinlock 一样。当有 3 个以上的 CPU 试图获取锁，需要一个 qspinlock 加上(N-2)个 MCS node。 qspinlock 中加入”pending”位域，如果是两个 CPU 试图获取锁，那么第二个 CPU 只需要简单地设置”pending”为 1，而不用另起炉灶创建一个 MCS node。 试图加锁的 CPU 数目超过 3 个是小概率事件，但一旦发生，使用 ticket spinlock 机制就会造成多个 CPU 的 cache line 无谓刷新的问题，而 qspinlock 可以利用 MCS node 队列来解决这个问题。 可见，使用 qspinlock 机制来实现 spinlock，具有很好的可扩展性，也就是无论当前锁的争抢程度如何，性能都可以得到保证。 ","date":"2023-12-28","objectID":"/p_16368024/:1:0","tags":null,"title":"Linux内核机制—spin_lock (转载)","uri":"/p_16368024/"},{"categories":null,"content":"2 相关数据结构 ","date":"2023-12-28","objectID":"/p_16368024/:2:0","tags":null,"title":"Linux内核机制—spin_lock (转载)","uri":"/p_16368024/"},{"categories":null,"content":"2.1 struct spinlock 除去使能 deug 才会有的相关成员，结构如下： typedef struct spinlock { //include/linux/spinlock_types.h struct raw_spinlock rlock; } spinlock_t; typedef struct raw_spinlock { //include/linux/spinlock_types.h arch_spinlock_t raw_lock; } raw_spinlock_t; typedef struct qspinlock { //include/asm-generic/qspinlock_types.h union { /* * \"val\"作为一个 32 位的变量，包含了三个部分：\"locked byte\", * \"pending\"和\"tail\"，\"tail\"又细分为\"tail index\"和\"tail cpu\" * * bit0-7: locked byte * bit8: pending * bit9-15: not used(实际上算在 pending 上了，只不过只使用了 bit8) * bit16-17: tail index * bit18-31: tail cpu(+1) * * 为了方便演示和说明，下面将\"tail\"表示为 x, \"pending\"表示为 y, * \"locked byte\"表示为 z, 组成一个三元组(x,y,z) */ atomic_t val; struct { u16 tail; u16 locked_pending; }; struct { u8 reserved[2]; u8 pending; u8 locked; }; }; } arch_spinlock_t; 其实 arch_spinlock_t 结构中只是一个 val 变量，分成多个位段使用，但是为了使用方便，不用进行位于/位或的操作，将其定义成了联合体，每个变量表示 val 中的一个位段。 spinlock 结构中只有一个类型为 raw_spinlock 的 rlock 成员。而 raw_spinlock 结构中只有一个类型为 qspinlock 的 raw_lock 成员。 qspinlock 结构中维护的是一个联合体。 val：为 0 表示没有人持锁，然后对其赋值为 _Q_LOCKED_VAL(1)表示持有了该锁。 ","date":"2023-12-28","objectID":"/p_16368024/:2:1","tags":null,"title":"Linux内核机制—spin_lock (转载)","uri":"/p_16368024/"},{"categories":null,"content":"2.2 struct qnode struct qnode { //kernel/locking/qspinlock.c struct mcs_spinlock mcs; #ifdef CONFIG_PARAVIRT_SPINLOCKS //默认不使能，没有下面成员 long reserved[2]; #endif }; struct mcs_spinlock { //kernel/locking/mcs_spinlock.h struct mcs_spinlock *next; /* 组成单链表 */ int locked; /* 1 if lock acquired */ int count; /* nesting count, see qspinlock.c */ }; static DEFINE_PER_CPU_ALIGNED(struct qnode, qnodes[MAX_NODES]); //MAX_NODES=4 MAX_NODES=4, 因为 CPU 只能处于 4 种上下文(thread、soft irq、irq、nmi)，因此一个 CPU 最多只能同时持有 4 个 spin_lock，嵌套 4 层。本次使用哪个 qnode 结构是由 lock-\u003eval 的 tail_cpu 和 tail idx 决定。 ","date":"2023-12-28","objectID":"/p_16368024/:2:2","tags":null,"title":"Linux内核机制—spin_lock (转载)","uri":"/p_16368024/"},{"categories":null,"content":"3 相关函数 ","date":"2023-12-28","objectID":"/p_16368024/:3:0","tags":null,"title":"Linux内核机制—spin_lock (转载)","uri":"/p_16368024/"},{"categories":null,"content":"3.1 初始化函数 //定义并初始化为 unlock 状态的，名为 x 的 spin_lock 变量。 DEFINE_SPINLOCK(x); //初始化为非持锁状态 spin_lock_init(_lock) //include/linux/spinlock.h 宏 ","date":"2023-12-28","objectID":"/p_16368024/:3:1","tags":null,"title":"Linux内核机制—spin_lock (转载)","uri":"/p_16368024/"},{"categories":null,"content":"3.2 上锁函数 //里面直接调用的是 raw_spin_lock(\u0026lock-\u003erlock) static __always_inline void spin_lock(spinlock_t *lock) //include/linux/spinlock.h //里面直接调用的是 raw_spin_lock_bh(\u0026lock-\u003erlock) static __always_inline void spin_lock_bh(spinlock_t *lock) //include/linux/spinlock.h //里面直接调用的是 raw_spin_lock_irq(\u0026lock-\u003erlock) static __always_inline void spin_lock_irq(spinlock_t *lock) //include/linux/spinlock.h //宏，等效于 raw_spin_lock_irqsave(spinlock_check(lock), flags) spin_lock_irqsave(lock, flags) //include/linux/spinlock.h 宏 ","date":"2023-12-28","objectID":"/p_16368024/:3:2","tags":null,"title":"Linux内核机制—spin_lock (转载)","uri":"/p_16368024/"},{"categories":null,"content":"3.3 解锁函数 //里面直接调用的是 raw_spin_unlock(\u0026lock-\u003erlock) static __always_inline void spin_unlock(spinlock_t *lock) //include/linux/spinlock.h //里面直接调用的是 raw_spin_unlock_bh(\u0026lock-\u003erlock) static __always_inline void spin_unlock_bh(spinlock_t *lock) //include/linux/spinlock.h //里面直接调用的是 raw_spin_unlock_irq(\u0026lock-\u003erlock) static __always_inline void spin_unlock_irq(spinlock_t *lock) //include/linux/spinlock.h //里面直接调用的是 raw_spin_unlock_irqrestore(\u0026lock-\u003erlock, flags) static __always_inline void spin_unlock_irqrestore(spinlock_t *lock, unsigned long flags) //include/linux/spinlock.h ","date":"2023-12-28","objectID":"/p_16368024/:3:3","tags":null,"title":"Linux内核机制—spin_lock (转载)","uri":"/p_16368024/"},{"categories":null,"content":"3.4 尝试获取锁函数 //里面直接调用的是 raw_spin_trylock(\u0026lock-\u003erlock) static __always_inline int spin_trylock(spinlock_t *lock) //include/linux/spinlock.h //里面直接调用的是 raw_spin_trylock_bh(\u0026lock-\u003erlock) static __always_inline int spin_trylock_bh(spinlock_t *lock) //include/linux/spinlock.h //里面直接调用的是 raw_spin_trylock_irq(\u0026lock-\u003erlock) static __always_inline int spin_trylock_irq(spinlock_t *lock) //include/linux/spinlock.h //宏，里面直接调用的是 raw_spin_trylock_irqsave(spinlock_check(lock), flags); spin_trylock_irqsave(lock, flags) //include/linux/spinlock.h 宏 ","date":"2023-12-28","objectID":"/p_16368024/:3:4","tags":null,"title":"Linux内核机制—spin_lock (转载)","uri":"/p_16368024/"},{"categories":null,"content":"3.5 判断上锁状态 //直接调用的是 raw_spin_is_locked(\u0026lock-\u003erlock), 直接返回的是 lock-\u003eval，非 0 表示 locked 的状态，0表示非 locked 状态 static __always_inline int spin_is_locked(spinlock_t *lock) //include/linux/spinlock.h //直接调用的是 raw_spin_is_contended(\u0026lock-\u003erlock), 判断锁是否处于被竞争状态，也即是否有任务在等待获取锁，为真表示锁处于竞争状态 static __always_inline int spin_is_contended(spinlock_t *lock) //include/linux/spinlock.h //判断上锁状态，等效于调用 BUG_ON(!raw_spin_is_locked(\u0026lock-\u003erlock)) assert_spin_locked(lock) //include/linux/spinlock.h 宏 raw_XXX() 函数是直接对 lock-\u003erlock 操作，一般使用不会直接使用。 可以看到，spin lock 的使用是需要区分是何种上下文的。spin_lock() 在持锁前先关抢占，通过在 current-\u003ethread_info.preempt.count 的\"preempt bit\"位段上加 1 来实现。spin_lock_bh() 持锁前先关底半部，通过在\"software interrupt count\" bit 位段上加 2 和在\"preempt bit\"位段上加 1 实现的。spin_lock_irq() 持锁之前先关本地中断，再关抢占(这里关中断是没有直接操作 preempt.count 的位段)。spin_lock_irqsave() 持锁之前先关中断再关抢占，同时保存中断标志位。 ","date":"2023-12-28","objectID":"/p_16368024/:3:5","tags":null,"title":"Linux内核机制—spin_lock (转载)","uri":"/p_16368024/"},{"categories":null,"content":"3.6 还可以直接使用 raw_spinlock_t 和与其配套的一组 raw_spin_xxx() #define DEFINE_RAW_SPINLOCK(x) //include/linux/spinlock_types.h raw_spin_lock_irqsave(lock, flags) //include/linux/spinlock.h raw_spin_unlock_irqrestore(lock, flags) //include/linux/spinlock.h ... ","date":"2023-12-28","objectID":"/p_16368024/:3:6","tags":null,"title":"Linux内核机制—spin_lock (转载)","uri":"/p_16368024/"},{"categories":null,"content":"4 锁代码分析 ","date":"2023-12-28","objectID":"/p_16368024/:4:0","tags":null,"title":"Linux内核机制—spin_lock (转载)","uri":"/p_16368024/"},{"categories":null,"content":"4.1 spin_lock() static __always_inline void spin_lock(spinlock_t *lock) //include/linux/spinlock.h { raw_spin_lock(\u0026lock-\u003erlock); } #define raw_spin_lock(lock) _raw_spin_lock(lock) //include/linux/spinlock.h void __lockfunc _raw_spin_lock(raw_spinlock_t *lock) //kernel/locking/spinlock.c { __raw_spin_lock(lock); } static inline void __raw_spin_lock(raw_spinlock_t *lock) //include/linux/spinlock_api_smp.h { /* 关抢占 */ preempt_disable(); /* 默认不使能 CONFIG_LOCKDEP，是个空函数 */ spin_acquire(\u0026lock-\u003edep_map, 0, 0, _RET_IP_); /* 默认不使能 CONFIG_LOCK_STAT, 等效于 do_raw_spin_lock(lock) */ LOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock); } static inline void do_raw_spin_lock(raw_spinlock_t *lock) __acquires(lock) //include/linux/spinlock.h { /* 静态代码检查相关，忽略之 */ __acquire(lock); arch_spin_lock(\u0026lock-\u003eraw_lock); mmiowb_spin_lock(); } #define arch_spin_lock(l) queued_spin_lock(l) //include/asm-generic/qspinlock.h /** * queued_spin_lock - acquire a queued spinlock * @lock: Pointer to queued spinlock structure, that is arch_spinlock_t. */ static __always_inline void queued_spin_lock(struct qspinlock *lock) //include/asm-generic/qspinlock.h { u32 val = 0; /* * 参数(*v, *old, new): * if (*v == *old) {*v = new; return true;} * if (*v != *old) {*old = *v; return false;} * * 如果 lock-\u003eval == 0, lock-\u003eval = _Q_LOCKED_VAL; return true; * 也就是说 lock-\u003eval 为 0 表示没有人持锁，此时赋值为 1 表示持有了该锁 */ if (likely(atomic_try_cmpxchg_acquire(\u0026lock-\u003eval, \u0026val, _Q_LOCKED_VAL))) return; /* 若是上面持锁失败，进入持锁慢速路径，上面进行了赋值，传参 val=lock-\u003eval */ queued_spin_lock_slowpath(lock, val); } ","date":"2023-12-28","objectID":"/p_16368024/:4:1","tags":null,"title":"Linux内核机制—spin_lock (转载)","uri":"/p_16368024/"},{"categories":null,"content":"4.2 spin_lock 持锁慢速路径 queued_spin_lock_slowpath(): /** * queued_spin_lock_slowpath - acquire the queued spinlock * @lock: Pointer to queued spinlock structure * @val: Current value of the queued spinlock 32-bit word * * val: (queue tail(bit16-31 x), pending bit(bit8 y), lock value(bit0-7 z)) * * fast : slow : unlock * : : * uncontended (0,0,0) -:--\u003e (0,0,1) ------------------------------:--\u003e (*,*,0) * : | ^--------.------. / : * : v \\ \\ | : * pending : (0,1,1) +--\u003e (0,1,0) \\ | : * : | ^--' | | : * : v | | : * uncontended : (n,x,y) +--\u003e (n,0,0) --' | : * queue : | ^--' | : * : v | : * contended : (*,x,y) +--\u003e (*,0,0) ---\u003e (*,0,1) -' : * queue : ^--' : */ /* queued_spin_lock 传参(lock, lock-\u003eval) */ void queued_spin_lock_slowpath(struct qspinlock *lock, u32 val) { struct mcs_spinlock *prev, *next, *node; u32 old, tail; int idx; /* 32 \u003e= 1\u003c\u003c14 恒不成立 */ BUILD_BUG_ON(CONFIG_NR_CPUS \u003e= (1U \u003c\u003c _Q_TAIL_CPU_BITS)); /* 默认为 false，恒不执行 */ if (pv_enabled()) goto pv_queue; /* 默认为 false，恒不执行 */ if (virt_spin_lock(lock)) return; /* * Wait for in-progress pending-\u003elocked hand-overs with a bounded * number of spins so that we guarantee forward progress. 0,1,0 -\u003e 0,0,1 */ /* * 进入慢速路径时有任务在等待 spin lock，执行这段代码时间内它可能已经获取到 spin lock 了， * 这里更新下从 lock-\u003eval 读取到的值. */ if (val == _Q_PENDING_VAL) { //1\u003c\u003c8 int cnt = _Q_PENDING_LOOPS; //1 /* * 函数作用：死循环读取 lock-\u003eval 的值，直到 arg2 为真才返回读取的结果。 * VAL 为读取的 lock-\u003eval 的值. * 含义为死循环读取 lock-\u003eval 的值，直到 lock-\u003eval != _Q_PENDING_VAL(即 1\u003c\u003c8), * 或尝试读取的次数达到 cnt 次，这里 cnt 初始化为 1，其实就只是读取一次。 */ val = atomic_cond_read_relaxed(\u0026lock-\u003eval, (VAL != _Q_PENDING_VAL) || !cnt--); } /* * If we observe any contention; queue. * * 除了 lock value(即 z)之外，还有其它位段不为 0，说明已经有任务处于 pending 等锁的状态了， * 那么就直接 queue，在自己的 mcs 锁上自旋，不要在 lock-\u003eval 上自旋了。 */ if (val \u0026 ~_Q_LOCKED_MASK) // val \u0026 ~0xff goto queue; /* * trylock || pending * 0,0,* -\u003e 0,1,* -\u003e 0,0,1 pending, trylock * * 代码走到这里，说明没有任务处于 pending 状态，那么设置锁的 pending 标志，标识本任务 * 要 pending 了。 * 函数等效于 ret = lock-\u003eval; lock-\u003eval |= _Q_PENDING_VAL(1\u003c\u003c8); val = ret; */ val = queued_fetch_set_pending_acquire(lock); /* * If we observe contention, there is a concurrent locker. * * Undo and queue; our setting of PENDING might have made the * n,0,0 -\u003e 0,0,0 transition fail and it will now be waiting * on @next to become !NULL. * * 在执行这段代码期间，若是有任务进入了 pending 状态(设置了 pending 标识或 * 在 msc lock 上 spin 了)，那么也是要直接 queue 的，在自己的 msc lock 上 spin， * 不要在 lock-\u003eval 上 spin 了。 * 若情况是其它任务在 mcs lock 上自旋了，就清除自己或上的 pending 标志。 */ if (unlikely(val \u0026 ~_Q_LOCKED_MASK)) { //~0xff /* Undo PENDING if we set it. */ if (!(val \u0026 _Q_PENDING_MASK)) //_Q_PENDING_MASK = 0xff\u003c\u003c8 /* 直接 lock-\u003epending=0, 将 pending 位段清 0，看来 pending 位段只使用了 bit8 */ clear_pending(lock); goto queue; } /* * We're pending, wait for the owner to go away. * * 0,1,1 -\u003e 0,1,0 * * this wait loop must be a load-acquire such that we match the * store-release that clears the locked bit and create lock * sequentiality; this is because not all * clear_pending_set_locked() implementations imply full * barriers. * * 代码走到这里，说明目前只有一个任务正持有锁(也可能已经释放了)，且没有任务等待。 * 那么就在 lock-\u003eval 上自旋等待，只有锁的 owner 退出临界区。 * 上面的这个 pending 位段为 1 还是上面本任务设置的。 */ if (val \u0026 _Q_LOCKED_MASK) //0xff atomic_cond_read_acquire(\u0026lock-\u003eval, !(VAL \u0026 _Q_LOCKED_MASK)); //【1. 在 lock-\u003eval 上 spin】 /* * take ownership and clear the pending bit. * 0,1,0 -\u003e 0,0,1 * * owner 退出临界区释放锁了，我们就获取锁，清除我们设置的 pending 标志位。 * 通过将 bit0-15 设置为 1 来实现的。 */ clear_pending_set_locked(lock); /* 默认不使能 CONFIG_LOCK_EVENT_COUNTS，为空 */ lockevent_inc(lock_pending); /* 这个路径下，我们就是锁的第一继承人，获取到锁后就退出了 */ return; /* * End of pending bit optimistic spinning and beginning of MCS queuing. * * 下面就是非第一位继承人，要在自己的 msc node 节点上自旋了。 */ queue: /* 原生有记录进入执行慢速路径的次数 */ lockevent_inc(lock_slowpath); pv_queue: /* 获取当前 cpu 的 spin lock 嵌套深度 */ node = this_cpu_ptr(\u0026qnodes[0].mcs); idx = node-\u003ecount++; //先赋值，再嵌套计数加 1 //对 tail(即 x)的 tail cpu 和 tail idx 位段进行编码 tail = encode_tail(smp_processor_id(), idx); /* * 4 nodes are allocated based on the assumption that there will * not be nested NMIs taking s","date":"2023-12-28","objectID":"/p_16368024/:4:2","tags":null,"title":"Linux内核机制—spin_lock (转载)","uri":"/p_16368024/"},{"categories":null,"content":"5 解锁代码分析 ","date":"2023-12-28","objectID":"/p_16368024/:5:0","tags":null,"title":"Linux内核机制—spin_lock (转载)","uri":"/p_16368024/"},{"categories":null,"content":"5.1 spin_unlock() 函数 static __always_inline void spin_unlock(spinlock_t *lock) //include/linux/spinlock.h { raw_spin_unlock(\u0026lock-\u003erlock); } #define raw_spin_unlock(lock) _raw_spin_unlock(lock) //include/linux/spinlock.h void __lockfunc _raw_spin_unlock(raw_spinlock_t *lock) //kernel/locking/spinlock.c { __raw_spin_unlock(lock); } EXPORT_SYMBOL(_raw_spin_unlock); static inline void __raw_spin_unlock(raw_spinlock_t *lock) //include/linux/spinlock_api_smp.h { spin_release(\u0026lock-\u003edep_map, _RET_IP_); do_raw_spin_unlock(lock); /* unlock 后开抢占 */ preempt_enable(); } static inline void do_raw_spin_unlock(raw_spinlock_t *lock) __releases(lock) //include/linux/spinlock.h { /* 没使能 CONFIG_MMIOWB，是个空函数 */ mmiowb_spin_unlock(); arch_spin_unlock(\u0026lock-\u003eraw_lock); __release(lock); } #define arch_spin_unlock(l) queued_spin_unlock(l) //include/asm-generic/qspinlock.h static __always_inline void queued_spin_unlock(struct qspinlock *lock) { /* * unlock() needs release semantics: * 直接将 lock-\u003elocked 赋值为 0，也即只是将 lock-\u003eval 的 bit0-8 设置为 0 */ smp_store_release(\u0026lock-\u003elocked, 0); } ","date":"2023-12-28","objectID":"/p_16368024/:5:1","tags":null,"title":"Linux内核机制—spin_lock (转载)","uri":"/p_16368024/"},{"categories":null,"content":"6 总结 spin lock 是不休眠锁，不像其它锁一样，没有 owner 成员保存当前持锁任务。其持锁之前是抢占的，使用需要区分是在哪个上下文中使用，来用对应的函数。 spin lock 实现机制中考虑了中断嵌套，由于只有 4 种上下文，为每个 cpu 分配了 4 个 mcs node。 当一个 spin lock 在不同 cpu 上存在竞争时，各个 cpu 的 mcs node 构成一个单链表， lock-\u003etail 字段\"指向\"最后尝试获取锁的任务所在 cpu 对应的 mcs node 节点。第一顺位继承人在 lock-\u003eval 上进行自旋，非第一顺位继承人在自己的 msc node 的 locked 成员上自旋，这样就做了释放锁时只有一个 cpu 需要更新其 cache line。 ","date":"2023-12-28","objectID":"/p_16368024/:6:0","tags":null,"title":"Linux内核机制—spin_lock (转载)","uri":"/p_16368024/"},{"categories":null,"content":"7 补充 内核中为了 debug spin_lock 方便，对函数原型进行了 inline 和 unline 的封装 //kernel/locking/spinlock.c #ifndef CONFIG_INLINE_SPIN_LOCK //默认不使能 void __lockfunc _raw_spin_lock(raw_spinlock_t *lock) { __raw_spin_lock(lock); } EXPORT_SYMBOL(_raw_spin_lock); #endif #ifdef CONFIG_UNINLINE_SPIN_UNLOCK //默认使能 void __lockfunc _raw_spin_unlock(raw_spinlock_t *lock) { __raw_spin_unlock(lock); } EXPORT_SYMBOL(_raw_spin_unlock); #endif //include/linux/spinlock_api_smp.h #ifndef CONFIG_UNINLINE_SPIN_UNLOCK #define _raw_spin_unlock(lock) __raw_spin_unlock(lock) #endif #ifdef CONFIG_INLINE_SPIN_LOCK #define _raw_spin_lock(lock) __raw_spin_lock(lock) #endif kernel/locking/spinlock.c 中还有 CONFIG_INLINE_READ_LOCK_IRQ、CONFIG_INLINE_SPIN_UNLOCK_BH 等。 linux-5.15.41 中新增: 若使能 CONFIG_PREEMPT_RT(Linux RT patch 默认不使能)，则将 spin_lock 的实现改为基于 rt_mutex 的可 休眠 spin_lock 实现了。 /* include\\linux\\spinlock_types.h */ #include \u003clinux/rtmutex.h\u003e typedef struct spinlock { struct rt_mutex_base lock; //5.10 的内核还是 struct raw_spinlock rlock; } spinlock_t; 因此有实现以下两套 lock 和 raw lock 接口： //raw spinlock: raw_spinlock_t lock; raw_spin_lock_init(\u0026lock) raw_spin_lock(\u0026lock); raw_spin_unlock(\u0026lock); //spinlock: spinlock_t lock; spin_lock_init(\u0026lock) spin_lock(\u0026lock); spin_unlock(\u0026lock); 在没有配置 CONFIG_PREEMPT_RT 的情况下两者实现是一样的，但是在使能了 CONFIG_PREEMPT_RT(默认不使能) 的 RT 内核中，spinlock 会被实现为基于 rtmutex 的可休眠锁，raw spinlock 保持和之前一致的逻辑。 内核工匠中有一篇类似博客：https://blog.csdn.net/feelabclihu/article/details/125454456 ","date":"2023-12-28","objectID":"/p_16368024/:7:0","tags":null,"title":"Linux内核机制—spin_lock (转载)","uri":"/p_16368024/"},{"categories":null,"content":"本文为摘录(或转载)，侵删，原文为： https://blog.regehr.org/archives/2173 自旋锁 (spinlock) 是多处理器操作系统提供的最基本的互斥原语。自旋锁需要保护当前 CPU 免受抢占（通常通过禁用中断，但我们会在本文中忽略这个方面），并且还需要防止其他核心同时访问临界区（通过使用原子内存操作）。正如其名称所示，尝试获取已锁定的自旋锁会简单地自旋：它们会消耗 CPU 时间： 我们不希望长时间持有自旋锁， 当持有自旋锁时，我们当然也不希望被抢占。 很多年前，人们提出了基于标准内存操作（加载和存储）的自旋锁实现方式。Eisenberg＆McGuire 和 Lamport Bakery 是其中的例子。具有弱内存模型（包括 x86 和 x86-64）的现代多核处理器破坏了这些算法的朴素实现，尽管可以通过添加内存屏障来修复，但由此产生的代码效率不如使用硬件支持的原子内存操作来得高，这些操作比加载和存储更为强大，例如 test-and-set, compare-and-swap, and load-linked / store-conditional 自旋锁并不需要太复杂，我们可以使用 GCC 的原子内置函数编写一个相当通用的用户态自旋锁。 struct spin_lock_t { int lock; }; void spin_lock(struct spin_lock_t *s) { while (1) { int zero = 0; int one = 1; if (__atomic_compare_exchange(\u0026s-\u003elock, \u0026zero, \u0026one, 0, __ATOMIC_SEQ_CST, __ATOMIC_SEQ_CST)) return; } } void spin_unlock(struct spin_lock_t *s) { int zero = 0; __atomic_store(\u0026s-\u003elock, \u0026zero, __ATOMIC_SEQ_CST); } 这里的想法是， lock 字段在锁空闲时保存 0 ，在锁被持有时保存 1 。要获取锁，我们使用比较和交换（compare-and-swap）操作，尝试将 lock 字段中的 0 更改为 1 -— 关键是*比较和交换的执行是原子的* 。 __ATOMIC_SEQ_CST 指定我们希望从这些原子操作获得最强的同步行为。此锁的这一和的其他方面可能会被优化，但此实现可行。 这种自旋锁的一个问题是在竞争情况下可能导致不公平：如果多个核心试图进入临界区，实际上是处理器的内存子系统在选择谁可以进入。在我拥有的一台随机的 AMD 机器上，很容易看到在竞争激烈时，一些核心访问临界区的次数远远多于其他核心。为了使对临界区的访问更公平，我们可以创建强制 FIFO 访问的自旋锁。这是实现这一点的简单方法： struct ticket_lock_t { unsigned front; unsigned back; }; void ticket_lock(struct ticket_lock_t *s) { unsigned ticket = __atomic_add_fetch(\u0026s-\u003eback, 1, __ATOMIC_SEQ_CST) - 1; while (1) { unsigned front; __atomic_load(\u0026s-\u003efront, \u0026front, __ATOMIC_SEQ_CST); if (front == ticket) return; } } void ticket_unlock(struct ticket_lock_t *s) { __atomic_add_fetch(\u0026s-\u003efront, 1, __ATOMIC_SEQ_CST); } 在这里，当 front = back= 时，锁是自由的，而等待进入临界区的线程数是 =front - back - 1=。这个比喻与 Lamport 面包店的情况相同：线程在请求进入临界区时会得到递增的票号，它们按照票号递增的顺序获得进入权限。通过在一个大型多核处理器上进行一些实验，发现这种自旋锁在高争用情况下也非常公平。 On most platforms, the Linux kernel currently uses a “queued spinlock” that has a pretty complicated implementation. It is spread across several files but the bulk of the logic is here. The rest of this post will ignore that code, however, and rather focus on Linux’s spinlock for 32-bit ARM platforms, which has a lot going on that’s fun to dissect. Here’s the code for acquiring a lock; I’ll refer to it by line number in the rest of this post. But first, here’s the data structure for this spinlock, the code is a bit messy but basically it’s just saying that we can look at the spinlock data either as a 32-bit int or else as a pair of 16-bit ints; these are going to work in the same way as front and back in the ticket spinlock above. Of course this spinlock will fail if anyone manages to create a machine containing enough 32-bit ARM cores that more than 65535 of them end up contending for the same spinlock. Seems safe enough. The prefetchw() call at line 62 turns into a pldw instruction. I don’t have any idea why it is advantageous to prefetch a value so close to where it is actually needed. [UPDATE: Luke Wren and Paul Khuong pointed out on Twitter that this is to reserve the cache line for writing right off the bat, instead of reserving it for reading and then a bit later reserving it for writing.] The inline assembly block at lines 64-71 is for grabbing a ticket number; it is functionally equivalent to the _ _atomic_add_fetch() in the ticket lock above. GCC inline assembly is never super easy so let’s dig in. Line 69 specifies the outputs of the inline assembly block: it is going to write values into three variables, lockval, newval, and tmp, and these are going to be referred to respectively as %0, %1, and %2 in the assembly code. These are “virtual registers” that the compiler will map to physical registers as it sees fit. Line 70 specifies the inputs to the inline assembly block: the address of the lock struct will be virtual register %3 and the constant 1\u003c\u003c16 will be stored in virtual register %4. Finally, line 71 specifies the “clobbers” for this inline assembly block: machine state not mentioned anywhere else that is going to be overwritten by the assembly. “cc” tells the compiler that it ma","date":"2023-12-27","objectID":"/2173/:0:0","tags":["spinlock"],"title":"A Close Look at a Spinlock – Embedded in Academia","uri":"/2173/"},{"categories":null,"content":" Table of Contents 1 Interprocedural optimization 2 GCC function suffixes 本文为摘录(或转载)，侵删，原文为： https://people.redhat.com/~jolawren/klp-compiler-notes/livepatch/compiler-considerations.html ","date":"2023-12-27","objectID":"/compiler-considerations/:0:0","tags":null,"title":"Compiler considerations — The Linux Kernel 5.7.0+ documentation","uri":"/compiler-considerations/"},{"categories":null,"content":"1 Interprocedural optimization 函数内联可能是影响动态修补最常见的编译器优化。在一个简单的例子中，内联将原始代码转换为： foo() { ... [ foo implementation ] ... } bar() { ... foo() ... } 变为： bar() { ... [ foo implementation ] ... } 内联类似于宏展开，然而编译器可能会内联它认为值得的情况（同时保留其他情况下的原始调用/返回语义），甚至部分内联函数的部分（见下文“GCC 函数后缀”中的冷函数）。 要安全地对上述示例中的 foo()进行动态修补，需要考虑到所有调用它的地方。对于那些编译器已经内联了 foo()的调用者，动态修补应该包含一个调用新的被修补内联函数版本的调用函数的新版本，使得它： 调用内联函数的新的被修补版本，或者 提供调用者的更新版本，其中包含其自己的内联并更新的内联函数版本 ","date":"2023-12-27","objectID":"/compiler-considerations/:1:0","tags":null,"title":"Compiler considerations — The Linux Kernel 5.7.0+ documentation","uri":"/compiler-considerations/"},{"categories":null,"content":"2 GCC function suffixes GCC 可能会根据应用的优化将原始、复制和克隆函数进行重命名。以下是编译器可能应用于内核函数的名称后缀的部分列表： 冷子函数(Cold subfunctions) ： .code 或者 .cold.\u003cN\u003e ： 由属性或优化确定不太可能执行的函数（子函数）的部分。 例如， irq_do_set_affinity() 的不太可能执行的部分可能移出到子函数 irq_do_set_affinity.cold.49() 。从 GCC 9 开始，编号后缀已被移除。因此，在上一个例子中，冷子函数简单地为 irq_do_set_affinity.cold() 。 部分内:联 .part.\u003cN\u003e ： 从原始函数主体中分离出来的函数部分，在整体内联决策上有所改进。 函数 cdev_put() 提供了一个有趣的部分克隆的例子。GCC 会将源函数： void cdev_put(struct cdev *p) { if (p) { struct module *owner = p-\u003eowner; kobject_put(\u0026p-\u003ekobj); module_put(owner); } } 拆成两个函数： cdev_put.part.0() 为部分内联， cdev_put 会调用 cdev_put.part.0() 将 cdev_put() 中的条件测试和 cdev_put.part.0() 中的 kobject_put() 和 module_put() 调用分成两个函数： \u003ccdev_put\u003e: e8 bb 60 73 00 callq ffffffff81a01a10 \u003c__fentry__\u003e 48 85 ff test %rdi,%rdi 74 05 je ffffffff812cb95f \u003ccdev_put+0xf\u003e e9 a1 fc ff ff jmpq ffffffff812cb600 \u003ccdev_put.part.0\u003e c3 retq \u003ccdev_put.part.0\u003e: e8 0b 64 73 00 callq ffffffff81a01a10 \u003c__fentry__\u003e 53 push %rbx 48 8b 5f 60 mov 0x60(%rdi),%rbx e8 a1 54 5a 00 callq ffffffff81870ab0 \u003ckobject_put\u003e 48 89 df mov %rbx,%rdi 5b pop %rbx e9 b8 5c e8 ff jmpq ffffffff811512d0 \u003cmodule_put\u003e 0f 1f 84 00 00 00 00 nopl 0x0(%rax,%rax,1) 00 常量传播 (Constant propagation) : .constprop.\u003cN\u003e : function copies to enable constant propagation when conflicting arguments exist. For example, consider cpumask_weight() and its copies for cpumask_weight(cpu_possible_mask) and cpumask_weight (__cpu_online_mask). Note how the .constprop copies implicitly assign the function parameter: \u003ccpumask_weight\u003e: 8b 35 1e 7d 3e 01 mov 0x13e7d1e(%rip),%esi e9 55 6e 3f 00 jmpq ffffffff8141d2b0 \u003c__bitmap_weight\u003e \u003ccpumask_weight.constprop.28\u003e: 8b 35 79 cf 1c 01 mov 0x11ccf79(%rip),%esi 48 c7 c7 80 db 40 82 mov $0xffffffff8240db80,%rdi R_X86_64_32S __cpu_possible_mask e9 a9 c0 1d 00 jmpq ffffffff8141d2b0 \u003c__bitmap_weight\u003e \u003ccpumask_weight.constprop.108\u003e: 8b 35 de 69 32 01 mov 0x13269de(%rip),%esi 48 c7 c7 80 d7 40 82 mov $0xffffffff8240d780,%rdi R_X86_64_32S __cpu_online_mask e9 0e 5b 33 00 jmpq ffffffff8141d2b0 \u003c__bitmap_weight\u003e IPA-SRA : .isra.0 : TODO ","date":"2023-12-27","objectID":"/compiler-considerations/:2:0","tags":null,"title":"Compiler considerations — The Linux Kernel 5.7.0+ documentation","uri":"/compiler-considerations/"},{"categories":null,"content":" Table of Contents 1 Concepts 本文为摘录(或转载)，侵删，原文为： https://github.com/postgres/postgres/blob/master/doc/src/sgml/nls.sgml#L52 ","date":"2023-12-18","objectID":"/note-about-po-file/:0:0","tags":["nls","po"],"title":"Note about PO file in PostgreSQL","uri":"/note-about-po-file/"},{"categories":null,"content":"1 Concepts The pairs of original (English) messages and their (possibly) translated equivalents are kept in message catalogs , one for each program (although related programs can share a message catalog) and for each target language. There are two file formats for message catalogs: The first is the PO file (for Portable Object), which is a plain text file with special syntax that translators edit. The second is the MO file (for Machine Object), which is a binary file generated from the respective PO file and is used while the internationalized program is run. Translators do not deal with MO files; in fact hardly anyone does. 原始（英语）消息与它们的（可能的）翻译对应关系保存在 消息目录 中，每个程序都有一个（尽管相关的程序可以共享一个消息目录），对于每种目标语言也是如此。消息目录有两种文件格式： 第一种是 PO 文件（Portable Object） 这是一个特殊语法的纯文本文件， 由翻译人员编辑 第二种是 MO 文件（Machine Object） 它是从相应的 PO 文件生成的二进制文件 在国际化程序运行时使用。 翻译人员不需要处理 MO 文件；事实上，几乎没有人会处理。 The extension of the message catalog file is to no surprise either .po or .mo. The base name is either the name of the program it accompanies, or the language the file is for, depending on the situation. This is a bit confusing. Examples are psql.po (PO file for psql) or fr.mo (MO file in French). 消息目录文件的扩展名也不足为奇，要么是 .po 要么是 .mo 。基本名称则根据情况是程序的名称或者文件所对应的语言。这有点让人困惑。例如， psql.po （psql 的 PO 文件）或 fr.mo （法语的 MO 文件）。 The file format of the PO files is illustrated here: PO 文件的文件格式如下所示： # comment msgid \"original string\" msgstr \"translated string\" msgid \"more original\" msgstr \"another translated\" \"string can be broken up like this\" ... The msgid lines are extracted from the program source. (They need not be, but this is the most common way.) The msgstr lines are initially empty and are filled in with useful strings by the translator. The strings can contain C-style escape characters and can be continued across lines as illustrated. (The next line must start at the beginning of the line.) msgid 行是从程序源代码中提取的。（虽然不一定非得这样做，但这是最常见的方式。） msgid 行之后的 msgstr 行最初是空的，会由翻译人员填入有用的字符串。 这些字符串可以包含 C 风格的转义字符，并且可以跨行续写，就像这样。（下一行必须从行的开头开始。） The # character introduces a comment. If whitespace immediately follows the # character, then this is a comment maintained by the translator. There can also be automatic comments, which have a non-whitespace character immediately following the #. These are maintained by the various tools that operate on the PO files and are intended to aid the translator. # 字符引入一个注释。 如果 # 字符后面紧跟着 空格 ，则这是译者维护的注释。 如果 # 字符后面紧跟着 非空格 ， 则为自动注释，他们由操作 PO 文件的各种工具维护，并旨在帮助翻译者。 #. automatic comment #: filename.c:1023 #, flags, flags The #. style comments are extracted from the source file where the message is used. Possibly the programmer has inserted information for the translator, such as about expected alignment. The #: comments indicate the exact locations where the message is used in the source. The translator need not look at the program source, but can if there is doubt about the correct translation. The #, comments contain flags that describe the message in some way. There are currently two flags: fuzzy is set if the message has possibly been outdated because of changes in the program source. The translator can then verify this and possibly remove the fuzzy flag. Note that fuzzy messages are not made available to the end user. The other flag is c-format, which indicates that the message is a \u003cfunction\u003eprintf\u003c/function\u003e-style format template. This means that the translation should also be a format string with the same number and type of placeholders. There are tools that can verify this, which key off the c-format flag. #. ： 的内容是从使用消息的源文件中提取的。 可能程序员已经为翻译者插入了关于期望对齐方式等信息。 # : 指出了消息在源文件中的确切位置。翻译者无需查看程序源文件，但如果对正确翻译存在疑问，可以查看源文件。 #， ： 注释包含描述消息的标志。目前有两个标志： fuzzy ： 如果消息可能因程序源文件的更改而过时，则会设置 fuzzy 标志。 翻译者可以验证这一点，并可能移除 fuzzy 标志。请注意，模糊消息不向最终用户提供。 c-format : 表示消息是 printf 格式的模板。 这意味着翻译也应该是具有相同数量和类型占位符的格式字符串。 有一些工具可以验证这一点，这些工具会基于 c-format 标志进行匹配。 ","date":"2023-12-18","objectID":"/note-about-po-file/:1:0","tags":["nls","po"],"title":"Note about PO file in PostgreSQL","uri":"/note-about-po-file/"},{"categories":null,"content":" Table of Contents 1 mlockall() 2 how to do this after program started and program does not call mlockall() ? 3 内核实现 3.1 mlockall() 3.2 内存区域标记 4 Swap 4.1 Swap info 4.2 Locks 4.3 fork 时候复制 swap… 4.4 进程退出时候清理 swap 。。。 5 RLIMIT_MEMLOCK 本文为摘录(或转载)，侵删，原文为： https://stackoverflow.com/questions/12520499/linux-how-to-lock-the-pages-of-a-process-in-memory ","date":"2023-12-16","objectID":"/how-to-avoid-memory-being-swapped/:0:0","tags":["memory","mlock","swap","lock","mlockall"],"title":"how to avoid memory being swapped (locking memory pages)","uri":"/how-to-avoid-memory-being-swapped/"},{"categories":null,"content":"1 mlockall() from manpage: mlockall() and munlockall() mlockall() locks all pages mapped into the address space of the calling process. This in‐ cludes the pages of the code, data, and stack segment, as well as shared libraries, user space kernel data, shared memory, and memory-mapped files. All mapped pages are guaranteed to be resident in RAM when the call returns successfully; the pages are guaranteed to stay in RAM until later unlocked. The flags argument is constructed as the bitwise OR of one or more of the following constants: MCL_CURRENT Lock all pages which are currently mapped into the address space of the process. MCL_FUTURE Lock all pages which will become mapped into the address space of the process in the future. These could be, for instance, new pages required by a growing heap and stack as well as new memory-mapped files or shared memory regions. MCL_ONFAULT (since Linux 4.4) Used together with MCL_CURRENT, MCL_FUTURE, or both. Mark all current (with MCL_CUR‐ RENT) or future (with MCL_FUTURE) mappings to lock pages when they are faulted in. When used with MCL_CURRENT, all present pages are locked, but mlockall() will not fault in non-present pages. When used with MCL_FUTURE, all future mappings will be marked to lock pages when they are faulted in, but they will not be populated by the lock when the mapping is created. MCL_ONFAULT must be used with either MCL_CURRENT or MCL_FUTURE or both. If MCL_FUTURE has been specified, then a later system call (e.g., mmap(2), sbrk(2), mal‐ loc(3)), may fail if it would cause the number of locked bytes to exceed the permitted maximum (see below). In the same circumstances, stack growth may likewise fail: the kernel will deny stack expansion and deliver a SIGSEGV signal to the process. munlockall() unlocks all pages mapped into the address space of the calling process. ","date":"2023-12-16","objectID":"/how-to-avoid-memory-being-swapped/:1:0","tags":["memory","mlock","swap","lock","mlockall"],"title":"how to avoid memory being swapped (locking memory pages)","uri":"/how-to-avoid-memory-being-swapped/"},{"categories":null,"content":"2 how to do this after program started and program does not call mlockall() ? Make a GDB command file that contains something like this: call mlockall(3) detach Then on the command line, find the PID of the process you want to mlock. Type: gdb --pid [PID] --batch -x [command file] If you get fancy with pgrep that could be: gdb --pid $(pgrep sshd) --batch -x [command file] ","date":"2023-12-16","objectID":"/how-to-avoid-memory-being-swapped/:2:0","tags":["memory","mlock","swap","lock","mlockall"],"title":"how to avoid memory being swapped (locking memory pages)","uri":"/how-to-avoid-memory-being-swapped/"},{"categories":null,"content":"3 内核实现 ","date":"2023-12-16","objectID":"/how-to-avoid-memory-being-swapped/:3:0","tags":["memory","mlock","swap","lock","mlockall"],"title":"how to avoid memory being swapped (locking memory pages)","uri":"/how-to-avoid-memory-being-swapped/"},{"categories":null,"content":"3.1 mlockall() SYSCALL_DEFINE1(mlockall, int, flags) { unsigned long lock_limit; int ret; if (!flags || (flags \u0026 ~(MCL_CURRENT | MCL_FUTURE | MCL_ONFAULT)) || flags == MCL_ONFAULT) return -EINVAL; if (!can_do_mlock()) return -EPERM; lock_limit = rlimit(RLIMIT_MEMLOCK); lock_limit \u003e\u003e= PAGE_SHIFT; if (mmap_write_lock_killable(current-\u003emm)) return -EINTR; ret = -ENOMEM; if (!(flags \u0026 MCL_CURRENT) || (current-\u003emm-\u003etotal_vm \u003c= lock_limit) || capable(CAP_IPC_LOCK)) ret = apply_mlockall_flags(flags); mmap_write_unlock(current-\u003emm); if (!ret \u0026\u0026 (flags \u0026 MCL_CURRENT)) mm_populate(0, TASK_SIZE); return ret; } 3.1.1 EPERM 的情况 当可执行程序拥有 CAP_IPC_LOCK 时候，可以有权限执行 mlock, 否则的话，下列情况会返回 EPERM: RLIMIT_MEMLOCK 为 0 时候： bool can_do_mlock(void) { if (rlimit(RLIMIT_MEMLOCK) != 0) return true; if (capable(CAP_IPC_LOCK)) return true; return false; } MCL_CURRENT 被设置，并且当前进程已使用的内存超过了 RLIMIT_MEMLOCK . ","date":"2023-12-16","objectID":"/how-to-avoid-memory-being-swapped/:3:1","tags":["memory","mlock","swap","lock","mlockall"],"title":"how to avoid memory being swapped (locking memory pages)","uri":"/how-to-avoid-memory-being-swapped/"},{"categories":null,"content":"3.2 内存区域标记 ","date":"2023-12-16","objectID":"/how-to-avoid-memory-being-swapped/:3:2","tags":["memory","mlock","swap","lock","mlockall"],"title":"how to avoid memory being swapped (locking memory pages)","uri":"/how-to-avoid-memory-being-swapped/"},{"categories":null,"content":"4 Swap ","date":"2023-12-16","objectID":"/how-to-avoid-memory-being-swapped/:4:0","tags":["memory","mlock","swap","lock","mlockall"],"title":"how to avoid memory being swapped (locking memory pages)","uri":"/how-to-avoid-memory-being-swapped/"},{"categories":null,"content":"4.1 Swap info class swap_info_struct { + unsigned flags + short prio + struct list + struct avail_lists + signed type + unsigned max + unsigned swap_map + struct cluster_info + struct free_clusters + unsigned lowest_bit + unsigned highest_bit + unsigned pages + unsigned inuse_pages + unsigned cluster_next + unsigned cluster_nr + struct percpu_cluster + struct curr_swap_extent + struct first_swap_extent + struct bdev + struct swap_file + unsigned old_block_size + spinlock_t lock + spinlock_t cont_lock + struct discard_work + struct discard_clusters } class swap_cluster_info { + spinlock_t lock + unsigned data + unsigned flags } swap_info_struct *-- swap_cluster_info class swap_cluster_list { + struct head + struct tail } swap_info_struct *-- swap_cluster_list class swap_extent { + struct list + unsigned start_page + unsigned nr_pages + sector_t start_block } swap_info_struct *-- swap_extent note left of swap_extent 一个交换区范围 (swap extent range) 将交换文件的 PAGE_SIZE 大小的页的范围映射到磁盘块的范围上。 交换区范围列表映射整个交换文件。 end note class block_device { + dev_t bd_dev + int bd_openers + struct bd_inode + struct bd_super + struct bd_mutex + void bd_claiming + void bd_holder + int bd_holders + bool bd_write_holder + struct bd_holder_disks + struct bd_contains + unsigned bd_block_size + u8 bd_partno + struct bd_part + unsigned bd_part_count + int bd_invalidated + struct bd_disk + struct bd_queue + struct bd_bdi + struct bd_list + unsigned bd_private + int bd_fsfreeze_count + struct bd_fsfreeze_mutex } swap_info_struct *-- block_device class file { + union f_u + struct f_path + struct f_inode + const f_op + spinlock_t f_lock + enum f_write_hint + atomic_long_t f_count + unsigned f_flags + fmode_t f_mode + struct f_pos_lock + loff_t f_pos + struct f_owner + const f_cred + struct f_ra + u64 f_version + void f_security + void private_data + struct f_ep_links + struct f_tfile_llink + struct f_mapping + errseq_t f_wb_err } swap_info_struct *-- file class address_space { + struct host + struct i_pages + atomic_t i_mmap_writable + struct i_mmap + struct i_mmap_rwsem + unsigned nrpages + unsigned nrexceptional + unsigned writeback_index + const a_ops + unsigned flags + spinlock_t private_lock + gfp_t gfp_mask + struct private_list + void private_data + errseq_t wb_err } file *-- address_space class inode { + umode_t i_mode + unsigned i_opflags + kuid_t i_uid + kgid_t i_gid + unsigned i_flags + struct i_acl + struct i_default_acl + const i_op + struct i_sb + struct i_mapping + void i_security + unsigned i_ino + dev_t i_rdev + loff_t i_size + struct i_atime + void i_private } address_space *-- inode /* * MAX_SWAPFILES defines the maximum number of swaptypes: things which can * be swapped to. The swap type and the offset into that swap type are * encoded into pte's and into pgoff_t's in the swapcache. Using five bits * for the type means that the maximum number of swapcache pages is 27 bits * on 32-bit-pgoff_t architectures. And that assumes that the architecture packs * the type/offset into the pte as 5/27 as well. */ /* * MAX_SWAPFILES 定义了最大的swaptypes数量：可以被交换到的东西。交换类型和交换类型中的偏移量都被编码到 * pte和swapcache中的pgoff_t中。对于类型使用五位意味着在32位pgoff_t架构上，swapcache页面的最大数量为27 * 位。并且这假设架构也将类型/偏移量打包到pte中，比例为5/27。 */ #define MAX_SWAPFILES \\ ((1 \u003c\u003c MAX_SWAPFILES_SHIFT) - SWP_DEVICE_NUM - \\ SWP_MIGRATION_NUM - SWP_HWPOISON_NUM) struct swap_info_struct *swap_info[MAX_SWAPFILES]; 最多 MAX_SWAPFILES 个 swap 设备。 ","date":"2023-12-16","objectID":"/how-to-avoid-memory-being-swapped/:4:1","tags":["memory","mlock","swap","lock","mlockall"],"title":"how to avoid memory being swapped (locking memory pages)","uri":"/how-to-avoid-memory-being-swapped/"},{"categories":null,"content":"4.2 Locks 4.2.1 全局锁 DEFINE_SPINLOCK(swap_lock); 4.2.2 粗粒度锁 4.2.3 细粒度锁 ","date":"2023-12-16","objectID":"/how-to-avoid-memory-being-swapped/:4:2","tags":["memory","mlock","swap","lock","mlockall"],"title":"how to avoid memory being swapped (locking memory pages)","uri":"/how-to-avoid-memory-being-swapped/"},{"categories":null,"content":"4.3 fork 时候复制 swap… 14.74% 0.00% xxxxsql [kernel.kallsyms] [k] entry_SYSCALL_64_after_hwframe | ---entry_SYSCALL_64_after_hwframe do_syscall_64 | |--7.61%--__x64_sys_exit_group | do_group_exit | | | --7.61%--do_exit | | | --7.46%--mmput | | | --7.45%--exit_mmap | | | --6.37%--unmap_vmas | | | --6.33%--unmap_page_range | | | |--0.98%--free_swap_and_cache | | | --0.76%--tlb_flush_mmu | |--3.40%--_do_fork | | | --3.38%--copy_process | | | --3.15%--dup_mm | | | --2.42%--copy_page_range | | | --2.35%--copy_pte_range.isra.97 | | | --0.98%--swap_duplicate | | | --0.83%--__swap_duplicate 4.3.1 swap_duplicate 将 swap entry 的引用计数增加 1。 返回 0 : 表示成功 返回 -ENOMEM 如果需要 swap_count_continuation 但无法原子地分配， 如果 __swap_duplicate() 因其他原因失败（ -EINVAL 或 -ENOENT ），如页表条目损坏，则返回 0，就像它成功一样。 /* * Increase reference count of swap entry by 1. * Returns 0 for success, or -ENOMEM if a swap_count_continuation is required * but could not be atomically allocated. Returns 0, just as if it succeeded, * if __swap_duplicate() fails for another reason (-EINVAL or -ENOENT), which * might occur if a page table entry has got corrupted. */ int swap_duplicate(swp_entry_t entry) { int err = 0; while (!err \u0026\u0026 __swap_duplicate(entry, 1) == -ENOMEM) err = add_swap_count_continuation(entry, GFP_ATOMIC); return err; } ","date":"2023-12-16","objectID":"/how-to-avoid-memory-being-swapped/:4:3","tags":["memory","mlock","swap","lock","mlockall"],"title":"how to avoid memory being swapped (locking memory pages)","uri":"/how-to-avoid-memory-being-swapped/"},{"categories":null,"content":"4.4 进程退出时候清理 swap 。。。 ","date":"2023-12-16","objectID":"/how-to-avoid-memory-being-swapped/:4:4","tags":["memory","mlock","swap","lock","mlockall"],"title":"how to avoid memory being swapped (locking memory pages)","uri":"/how-to-avoid-memory-being-swapped/"},{"categories":null,"content":"5 RLIMIT_MEMLOCK ","date":"2023-12-16","objectID":"/how-to-avoid-memory-being-swapped/:5:0","tags":["memory","mlock","swap","lock","mlockall"],"title":"how to avoid memory being swapped (locking memory pages)","uri":"/how-to-avoid-memory-being-swapped/"},{"categories":null,"content":" Table of Contents 1 背景介绍 2 RO 内存同步架构 3 WAL Meta 4 LogIndex 4.1 内存数据结构 4.2 磁盘数据结构 5 日志回放 5.1 延迟回放 5.2 Mini Transaction 6 总结 本文为摘录(或转载)，侵删，原文为： https://apsaradb.github.io/PolarDB-for-PostgreSQL/zh/theory/logindex.html ","date":"2023-12-11","objectID":"/logindex/:0:0","tags":["polardb","logindex"],"title":"LogIndex | PolarDB for PostgreSQL","uri":"/logindex/"},{"categories":null,"content":"1 背景介绍 PolarDB 采用了共享存储一写多读架构，读写节点 RW 和多个只读节点 RO 共享同一份存储，读写节点可以读写共享存储中的数据；只读节点仅能各自通过回放日志，从共享存储中读取数据，而不能写入，只读节点 RO 通过内存同步来维护数据的一致性。此外，只读节点可同时对外提供服务用于实现读写分离与负载均衡，在读写节点异常 crash 时，可将只读节点提升为读写节点，保证集群的高可用。基本架构图如下所示： 传统 share nothing 的架构下，只读节点 RO 有自己的内存及存储，只需要接收 RW 节点的 WAL 日志进行回放即可。如下图所示，如果需要回放的数据页不在 Buffer Pool 中，需将其从存储文件中读至 Buffer Pool 中进行回放，从而带来 CacheMiss 的成本，且持续性的回放会带来较频繁的 Buffer Pool 淘汰问题。 此外，RW 节点多个事务之间可并行执行，RO 节点则需依照 WAL 日志的顺序依次进行串行回放，导致 RO 回放速度较慢，与 RW 节点的延迟逐步增大。 与传统 share nothing 架构不同，共享存储一写多读架构下 RO 节点可直接从共享存储上获取需要回放的 WAL 日志。若共享存储上的数据页是最新的，那么 RO 可直接读取数据页而不需要再进行回放操作。基于此，PolarDB 设计了 LogIndex 来加速 RO 节点的日志回放。 ","date":"2023-12-11","objectID":"/logindex/:1:0","tags":["polardb","logindex"],"title":"LogIndex | PolarDB for PostgreSQL","uri":"/logindex/"},{"categories":null,"content":"2 RO 内存同步架构 LogIndex 中保存了数据页与修改该数据页的所有 LSN 的映射关系，基于 LogIndex 可快速获取到修改某个数据页的所有 LSN，从而可将该数据页对应日志的回放操作延迟到真正访问该数据页的时刻进行。LogIndex 机制下 RO 内存同步的架构如下图所示。 RW / RO 的相关流程相较传统 share nothing 架构下有如下区别： 读写节点 RW 与只读节点 RO 之间不再传输完整的 WAL 日志，仅传输 WAL meta，减少网络数据传输量，降低了 RO 与 RW 节点的延迟； 读写节点 RW 依据 WAL meta 生成 LogIndex 写入 LogIndex Memory Table 中，LogIndex Memory Table 写满之后落盘，保存至共享存储的 LogIndex Table 中，已落盘的 LogIndex Memory Table 可以被复用； 读写节点 RW 通过 LogIndex Meta 文件保证 LogIndex Memory Table I/O 操作的原子性， LogIndex Memory Table 落盘后会更新 LogIndex Meta 文件，落盘的同时还会生成 Bloom Data，通过 Bloom Data 可快速检索特定 Page 是否存在于某 LogIndex Table 中，从而忽略不必扫描的 LogIndex Table 提升效率； 只读节点 RO 接收 RW 所发送的 WAL Meta，并基于 WAL Meta 在内存中生成相应的 LogIndex，同样写入其内存的 LogIndex Memory Table 中，同时将 WAL Meta 对应已存在于 Buffer Pool 中的页面标记为 Outdate，该阶段 RO 节点并不进行真正的日志回放，无数据 I/O 操作，可去除 cache miss 的成本； 只读节点 RO 基于 WAL Meta 生成 LogIndex 后即可推进回放位点，日志回放操作被交由背景进程及真正访问该页面的 backend 进程执行，由此 RO 节点也可实现日志的并行回放； 只读节点 RO 生成的 LogIndex Memory Table 不会落盘，其基于 LogIndex Meta 文件判断已满的 LogIndex Memory Table 是否在 RW 节点已落盘，已落盘的 LogIndex Memory Table 可被复用，当 RW 节点判断存储上的 LogIndex Table 不再使用时可将相应的 LogIndex Table Truncate。 PolarDB 通过仅传输 WAL Meta 降低 RW 与 RO 之间的延迟，通过 LogIndex 实现 WAL 日志的延迟回放 + 并行回放以加速 RO 的回放速度，以下则对这两点进行详细介绍。 ","date":"2023-12-11","objectID":"/logindex/:2:0","tags":["polardb","logindex"],"title":"LogIndex | PolarDB for PostgreSQL","uri":"/logindex/"},{"categories":null,"content":"3 WAL Meta WAL 日志又称为 XLOG Record，如下图，每个 XLOG Record 由两部分组成： 通用的首部部分 general header portion：该部分即为 XLogRecord 结构体，固定长度。主要用于存放该条 XLOG Record 的通用信息，如 XLOG Record 的长度、生成该条 XLOG Record 的事务 ID、该条 XLOG Record 对应的资源管理器类型等; 数据部分 data portion：该部分又可以划分为首部和数据两个部分，其中首部部分 header part 包含 0 ～ N 个 XLogRecordBlockHeader 结构体及 0 ～ 1 个 XLogRecordDataHeader [Short|Long] 结构体。数据部分 data part 则包含 block data 及 main data。每一个 XLogRecordBlockHeader 对应数据部分的一个 Block data，XLogRecordDataHeader [Short|Long] 则与数据部分的 main data 对应。 共享存储模式下，读写节点 RW 与只读节点 RO 之间无需传输完整的 WAL 日志，仅传输 WAL Meta 数据，WAL Meta 即为上图中的 general header portion + header part + main data，RO 节点可基于 WAL Meta 从共享存储上读取完整的 WAL 日志内容。该机制下，RW 与 RO 之间传输 WAL Meta 的流程如下： 当 RW 节点中的事务对其数据进行修改时，会生成对应的 WAL 日志并将其写入 WAL Buffer，同时拷贝对应的 WAL meta 数据至内存中的 WAL Meta queue 中； 同步流复制模式下，事务提交时会先将 WAL Buffer 中对应的 WAL 日志 flush 到磁盘，此后会唤醒 WalSender 进程； WalSender 进程发现有新的日志可以发送，则从 WAL Meta queue 中读取对应的 WAL Meta，通过已建立的流复制连接发送到对端的 RO； RO 的 WalReceiver 进程接收到新的日志数据之后，将其 push 到内存的 WAL Meta queue 中，同时通知 Startup 进程有新的日志到达； Startup 从 WAL Meta queue 中读取对应的 meta 数据，解析生成对应的 LogIndex memtable 即可。 RW 与 RO 节点的流复制不传输具体的 payload 数据，减少了网络数据传输量；此外，RW 节点的 WalSender 进程从内存中的 WAL Meta queue 中获取 WAL Meta 信息，RO 节点的 WalReceiver 进程接收到 WAL Meta 后也同样将其保存至内存的 WAL Meta queue 中，相较于传统主备模式减少了日志发送及接收的磁盘 I/O 过程，从而提升传输速度，降低 RW 与 RO 之间的延迟。 ","date":"2023-12-11","objectID":"/logindex/:3:0","tags":["polardb","logindex"],"title":"LogIndex | PolarDB for PostgreSQL","uri":"/logindex/"},{"categories":null,"content":"4 LogIndex ","date":"2023-12-11","objectID":"/logindex/:4:0","tags":["polardb","logindex"],"title":"LogIndex | PolarDB for PostgreSQL","uri":"/logindex/"},{"categories":null,"content":"4.1 内存数据结构 LogIndex 实质为一个 HashTable 结构，其 key 为 PageTag，可标识一个具体数据页，其 value 即为修改该 page 的所有 LSN。LogIndex 的内存数据结构如下图所示，除了 Memtable ID、 Memtable 保存的最大 LSN、最小 LSN 等信息，LogIndex Memtable 中还包含了三个数组，分别为： HashTable：HashTable 数组记录了某个 Page 与修改该 Page 的 LSN List 的映射关系， HashTable 数组的每一个成员指向 Segment 数组中一个具体的 LogIndex Item； Segment：Segment 数组中的每个成员为一个 LogIndex Item，LogIndex Item 有两种结构，即下图中的 Item Head 和 Item Seg，Item Head 为某个 Page 对应的 LSN 链表的头部，Item Seg 则为该 LSN 链表的后续节点。Item Head 中的 Page TAG 用于记录单个 Page 的元信息，其 Next Seg 和 Tail Seg 则分别指向后续节点和尾节点，Item Seg 存储着指向上一节点 Prev Seg 和后续节点 Next Seg 的指针。Item Head 和 Item Seg 中保存的 Suffix LSN 与 LogIndex Memtable 中保存的 Prefix LSN 可构成一个完整的 LSN，避免了重复存储 Prefix LSN 带来的空间浪费。当不同 Page TAG 计算到 HashTable 的同一位置时，通过 Item Head 中的 Next Item 指向下一个具有相同 hash 值的 Page，以此解决哈希冲突； Index Order：Index Order 数组记录了 LogIndex 添加到 LogIndex Memtable 的顺序，该数组中的每个成员占据 2 个字节。每个成员的后 12bit 对应 Segment 数组的一个下标，指向一个具体的 LogIndex Item，前 4bit 则对应 LogIndex Item 中 Suffix LSN 数组的一个下标，指向一个具体的 Suffix LSN，通过 Index Order 可方便地获取插入到该 LogIndex Memtable 的所有 LSN 及某个 LSN 与其对应修改的全部 Page 的映射关系。 内存中保存的 LogIndex Memtable 又可分为 Active LogIndex Memtable 和 Inactive LogIndex Memtable。如下图所示，基于 WAL Meta 数据生成的 LogIndex 记录会写入 Active LogIndex Memtable，Active LogIndex Memtable 写满后会转为 Inactive LogIndex Memtable，并重新申请一个新的 Active LogIndex Memtable，Inactive LogIndex Memtable 可直接落盘，落盘后的 Inactive LogIndex Memtable 可再次转为 Active LogIndex Memtable。 ","date":"2023-12-11","objectID":"/logindex/:4:1","tags":["polardb","logindex"],"title":"LogIndex | PolarDB for PostgreSQL","uri":"/logindex/"},{"categories":null,"content":"4.2 磁盘数据结构 磁盘上保存了若干个 LogIndex Table，LogIndex Table 与 LogIndex Memtable 结构类似，一个 LogIndex Table 可包含 64 个 LogIndex Memtable，Inactive LogIndex Memtable 落盘的同时会生成其对应的 Bloom Filter。如下图所示，单个 Bloom Filter 的大小为 4096 字节，Bloom Filter 记录了该 Inactive LogIndex Memtable 的相关信息，如保存的最小 LSN、最大 LSN、该 Memtable 中所有 Page 在 bloom filter bit array 中的映射值等。通过 Bloom Filter 可快速判断某个 Page 是否存在于对应的 LogIndex Table 中，从而可忽略无需扫描的 LogIndex Table 以加速检索。 当 Inactive LogIndex MemTable 成功落盘后，LogIndex Meta 文件也被更新，该文件可保证 LogIndex Memtable 文件 I/O 操作的原子性。如下，LogIndex Meta 文件保存了当前磁盘上最小 LogIndex Table 及最大 LogIndex Memtable 的相关信息，其 Start LSN 记录了当前已落盘的所有 LogIndex MemTable 中最大的 LSN。若 Flush LogIndex MemTable 时发生部分写，系统会从 LogIndex Meta 记录的 Start LSN 开始解析日志，如此部分写舍弃的 LogIndex 记录也会重新生成，保证了其 I/O 操作的原子性。 由 Buffer 管理 可知，一致性位点之前的所有 WAL 日志修改的数据页均已持久化到共享存储中， RO 节点无需回放该位点之前的 WAL 日志，故 LogIndex Table 中小于一致性位点的 LSN 均可清除。 RW 据此 Truncate 掉存储上不再使用的 LogIndex Table，在加速 RO 回放效率的同时还可减少 LogIndex Table 占用的空间。 ","date":"2023-12-11","objectID":"/logindex/:4:2","tags":["polardb","logindex"],"title":"LogIndex | PolarDB for PostgreSQL","uri":"/logindex/"},{"categories":null,"content":"5 日志回放 ","date":"2023-12-11","objectID":"/logindex/:5:0","tags":["polardb","logindex"],"title":"LogIndex | PolarDB for PostgreSQL","uri":"/logindex/"},{"categories":null,"content":"5.1 延迟回放 LogIndex 机制下，RO 节点的 Startup 进程基于接收到的 WAL Meta 生成 LogIndex，同时将该 WAL Meta 对应的已存在于 Buffer Pool 中的页面标记为 Outdate 后即可推进回放位点，Startup 进程本身并不对日志进行回放，日志的回放操作交由背景回放进程及真正访问该页面的 Backend 进程进行，回放过程如下图所示，其中： 背景回放进程按照 WAL 顺序依次进行日志回放操作，根据要回放的 LSN 检索 LogIndex Memtable 及 LogIndex Table，获取该 LSN 修改的 Page List，若某个 Page 存在于 Buffer Pool 中则对其进行回放，否则直接跳过。背景回放进程按照 LSN 的顺序逐步推进 Buffer Pool 中的页面位点，避免单个 Page 需要回放的 LSN 数量堆积太多； Backend 进程则仅对其实际需要访问的 Page 进行回放，当 Backend 进程需要访问一个 Page 时，如果该 Page 在 Buffer Pool 中不存在，则将该 Page 读到 Buffer Pool 后进行回放；如果该 Page 已经在 Buffer Pool 中且标记为 outdate，则将该 Page 回放到最新。Backend 进程依据 Page TAG 对 LogIndex Memtable 及 LogIndex Table 进行检索，按序生成与该 Page 相关的 LSN List，基于 LSN List 从共享存储中读取完整的 WAL 日志来对该 Page 进行回放。 为降低回放时读取磁盘 WAL 日志带来的性能损耗，同时添加了 XLOG Buffer 用于缓存读取的 WAL 日志。如下图所示，原始方式下直接从磁盘上的 WAL Segment File 中读取 WAL 日志，添加 XLog Page Buffer 后，会先从 XLog Buffer 中读取，若所需 WAL 日志不在 XLog Buffer 中，则从磁盘上读取对应的 WAL Page 到 Buffer 中，然后再将其拷贝至 XLogReaderState 的 readBuf 中；若已在 Buffer 中，则直接将其拷贝至 XLogReaderState 的 readBuf 中，以此减少回放 WAL 日志时的 I/O 次数，从而进一步加速日志回放的速度。 ","date":"2023-12-11","objectID":"/logindex/:5:1","tags":["polardb","logindex"],"title":"LogIndex | PolarDB for PostgreSQL","uri":"/logindex/"},{"categories":null,"content":"5.2 Mini Transaction 与传统 share nothing 架构下的日志回放不同，LogIndex 机制下，Startup 进程解析 WAL Meta 生成 LogIndex 与 Backend 进程基于 LogIndex 对 Page 进行回放的操作是并行的，且各个 Backend 进程仅对其需要访问的 Page 进行回放。由于一条 XLog Record 可能会对多个 Page 进行修改，以索引分裂为例，其涉及对 Page_0、Page_1 的修改，且其对 Page_0 及 Page_1 的修改为一个原子操作，即修改要么全部可见，要么全部不可见。针对此，设计了 mini transaction 锁机制以保证 Backend 进程回放过程中内存数据结构的一致性。 如下图所示，无 mini transaction lock 时，Startup 进程对 WAL Meta 进行解析并按序将当前 LSN 插入到各个 Page 对应的 LSN List 中。若 Startup 进程完成对 Page_0 LSN List 的更新，但尚未完成对 Page_1 LSN List 的更新时，Backend_0 和 Backend_1 分别对 Page_0 及 Page_1 进行访问，Backend_0 和 Backend_1 分别基于 Page 对应的 LSN List 进行回放操作，Page_0 被回放至 LSN_N + 1 处，Page_1 被回放至 LSN_N 处，可见此时 Buffer Pool 中两个 Page 对应的版本并不一致，从而导致相应内存数据结构的不一致。 Mini transaction 锁机制下，对 Page_0 及 Page_1 LSN List 的更新被视为一个 mini transaction。Startup 进程更新 Page 对应的 LSN List 时，需先获取该 Page 的 mini transaction lock，如下先获取 Page_0 对应的 mtr lock，获取 Page mtr lock 的顺序与回放时的顺序保持一致，更新完 Page_0 及 Page_1 LSN List 后再释放 Page_0 对应的 mtr lock。 Backend 进程基于 LogIndex 对特定 Page 进行回放时，若该 Page 对应在 Startup 进程仍处于一个 mini transaction 中，则同样需先获取该 Page 对应的 mtr lock 后再进行回放操作。故若 Startup 进程完成对 Page_0 LSN List 的更新，但尚未完成对 Page_1 LSN List 的更新时， Backend_0 和 Backend_1 分别对 Page_0 及 Page_1 进行访问，此时 Backend_0 需等待 LSN List 更新完毕并释放 Page_0 mtr lock 之后才可进行回放操作，而释放 Page_0 mtr lock 时 Page_1 的 LSN List 已完成更新，从而实现了内存数据结构的原子修改。 ","date":"2023-12-11","objectID":"/logindex/:5:2","tags":["polardb","logindex"],"title":"LogIndex | PolarDB for PostgreSQL","uri":"/logindex/"},{"categories":null,"content":"6 总结 PolarDB 基于 RW 节点与 RO 节点共享存储这一特性，设计了 LogIndex 机制来加速 RO 节点的内存同步，降低 RO 节点与 RW 节点之间的延迟，确保了 RO 节点的一致性与可用性。本文对 LogIndex 的设计背景、基于 LogIndex 的 RO 内存同步架构及具体细节进行了分析。除了实现 RO 节点的内存同步，基于 LogIndex 机制还可实现 RO 节点的 Online Promote，可加速 RW 节点异常崩溃时，RO 节点提升为 RW 节点的速度，从而构建计算节点的高可用，实现服务的快速恢复。 ","date":"2023-12-11","objectID":"/logindex/:6:0","tags":["polardb","logindex"],"title":"LogIndex | PolarDB for PostgreSQL","uri":"/logindex/"},{"categories":null,"content":" Table of Contents 1 传统数据库的问题 2 PolarDB PostgreSQL 版云原生数据库的优势 3 PolarDB PostgreSQL 版整体架构概述 3.1 存储计算分离架构概述 3.2 HTAP 架构概述 本文为摘录(或转载)，侵删，原文为： https://help.aliyun.com/zh/polardb/polardb-for-postgresql/polardb-for-postgresql-architecture/?spm=a2c4g.11186623.0.0.2e3b5fb1p0L9je PolarDB PostgreSQL 版是一款阿里云自主研发的企业级数据库产品，采用计算存储分离架构，兼容 PostgreSQL 与 Oracle。PolarDB PostgreSQL 版的存储与计算能力均可横向扩展，具有高可靠、高可用、弹性扩展等企业级数据库特性。同时，PolarDB PostgreSQL 版具有大规模并行计算能力，可以应对 OLTP 与 OLAP 混合负载。还具有时空、向量、搜索、图谱等多模创新特性，可以满足企业对数据处理日新月异的新需求。 PolarDB PostgreSQL 版支持多种部署形态：存储计算分离部署、X-Paxos 三节点部署以及本地盘部署。 ","date":"2023-12-11","objectID":"/polardb-for-postgresql%E6%9E%B6%E6%9E%84%E4%BB%8B%E7%BB%8D/:0:0","tags":["polardb"],"title":"PolarDB for PostgreSQL架构介绍","uri":"/polardb-for-postgresql%E6%9E%B6%E6%9E%84%E4%BB%8B%E7%BB%8D/"},{"categories":null,"content":"1 传统数据库的问题 随着用户业务数据量越来越大，业务越来越复杂，传统数据库系统面临巨大挑战，例如： 存储空间无法超过单机上限。 通过只读实例进行读扩展，每个只读实例独享一份存储，成本增加。 随着数据量增加，创建只读实例的耗时增加。 主备延迟高。 ","date":"2023-12-11","objectID":"/polardb-for-postgresql%E6%9E%B6%E6%9E%84%E4%BB%8B%E7%BB%8D/:1:0","tags":["polardb"],"title":"PolarDB for PostgreSQL架构介绍","uri":"/polardb-for-postgresql%E6%9E%B6%E6%9E%84%E4%BB%8B%E7%BB%8D/"},{"categories":null,"content":"2 PolarDB PostgreSQL 版云原生数据库的优势 针对上述传统数据库的问题，阿里云研发了 PolarDB PostgreSQL 版云原生数据库。采用了自主研发的计算集群和存储集群分离的架构。具备如下优势： 扩展性：存储计算分离，极致弹性。 成本：共享一份数据，存储成本低。 易用性：一写多读，透明读写分离。 可靠性：三副本、秒级备份。 ","date":"2023-12-11","objectID":"/polardb-for-postgresql%E6%9E%B6%E6%9E%84%E4%BB%8B%E7%BB%8D/:2:0","tags":["polardb"],"title":"PolarDB for PostgreSQL架构介绍","uri":"/polardb-for-postgresql%E6%9E%B6%E6%9E%84%E4%BB%8B%E7%BB%8D/"},{"categories":null,"content":"3 PolarDB PostgreSQL 版整体架构概述 ","date":"2023-12-11","objectID":"/polardb-for-postgresql%E6%9E%B6%E6%9E%84%E4%BB%8B%E7%BB%8D/:3:0","tags":["polardb"],"title":"PolarDB for PostgreSQL架构介绍","uri":"/polardb-for-postgresql%E6%9E%B6%E6%9E%84%E4%BB%8B%E7%BB%8D/"},{"categories":null,"content":"3.1 存储计算分离架构概述 PolarDB PostgreSQL 版是存储计算分离的设计，存储集群和计算集群可以分别独立扩展： 当计算能力不够时，可以单独扩展计算集群。 当存储容量不够时，可以单独扩展存储集群。 基于 Shared-Storage，主节点和多个只读节点共享一份存储数据，主节点刷脏不能再按照传统的刷脏方式，否则会导致以下问题： 只读节点在存储中读取的页面，可能是比较老的版本，不符合当前的状态。 只读节点读取到的页面比自身内存中想要的数据要超前。 主节点切换到只读节点时，只读节点接管数据更新时，存储中的页面可能是旧的，需要读取日志重新对脏页的恢复。 对于第一个问题，我们需要有页面多版本能力；对于第二个问题，我们需要主库控制脏页的刷脏速度。 ","date":"2023-12-11","objectID":"/polardb-for-postgresql%E6%9E%B6%E6%9E%84%E4%BB%8B%E7%BB%8D/:3:1","tags":["polardb"],"title":"PolarDB for PostgreSQL架构介绍","uri":"/polardb-for-postgresql%E6%9E%B6%E6%9E%84%E4%BB%8B%E7%BB%8D/"},{"categories":null,"content":"3.2 HTAP 架构概述 读写分离后，单个计算节点无法发挥出存储侧大 IO 带宽的优势，也无法通过增加计算资源来加速大的查询。PolarDB PostgreSQL 版推出了基于 Shared-Storage 的 MPP 分布式并行执行，来加速在 OLTP 场景下 OLAP 查询。 PolarDB PostgreSQL 版支持一套 OLTP 场景型的数据在以下两种计算引擎中使用： 单机执行引擎：处理高并发的 OLTP 型负载。 分布式执行引擎：处理大查询的 OLAP 型负载。 在使用相同的硬件资源时性能达到了传统 MPP 数仓的 90%，同时具备了 SQL 级别的弹性：在计算能力不足时，可随时增加参与 OLAP 分析查询的 CPU，而数据无需重分布。 ","date":"2023-12-11","objectID":"/polardb-for-postgresql%E6%9E%B6%E6%9E%84%E4%BB%8B%E7%BB%8D/:3:2","tags":["polardb"],"title":"PolarDB for PostgreSQL架构介绍","uri":"/polardb-for-postgresql%E6%9E%B6%E6%9E%84%E4%BB%8B%E7%BB%8D/"},{"categories":null,"content":" Table of Contents 1 HTAP 架构原理 2 分布式优化器 3 算子并行化 4 消除数据倾斜问题 5 SQL 级别弹性扩展 6 事务一致性 7 TPC-H 性能：加速比 8 TPC-H 性能：和传统 MPP 数仓对比 9 分布式执行加速索引创建 10 分布式并行执行加速多模：时空数据库 本文为摘录(或转载)，侵删，原文为： https://help.aliyun.com/zh/polardb/polardb-for-postgresql/polardb-for-postgresql-architecture/?spm=a2c4g.11186623.0.0.2e3b5fb1p0L9je PolarDB PostgreSQL 版读写分离后，由于底层是存储池，理论上 IO 吞吐是无限大的。而大查询只能在单个计算节点上执行，单个计算节点的 CPU/MEM/IO 是有限的，因此单个计算节点无法发挥出存储侧的大 IO 带宽的优势，也无法通过增加计算资源来加速大的查询。PolarDB PostgreSQL 版推出了基于 Shared-Storage 的 MPP 分布式并行执行，来加速在 OLTP 场景下 OLAP 查询。 ","date":"2023-12-11","objectID":"/polardb-pg-htap%E6%9E%B6%E6%9E%84%E8%AF%A6%E8%A7%A3/:0:0","tags":null,"title":"polardb pg HTAP架构详解","uri":"/polardb-pg-htap%E6%9E%B6%E6%9E%84%E8%AF%A6%E8%A7%A3/"},{"categories":null,"content":"1 HTAP 架构原理 PolarDB PostgreSQL 版底层存储在不同节点上是共享的，因此不能直接像传统 MPP 一样去扫描表。 PolarDB PostgreSQL 版在原来单机执行引擎上支持了 MPP 分布式并行执行，同时对 Shared-Storage 进行了优化。 基于 Shared-Storage 的 MPP 是业界首创。原理如下： Shuffle 算子屏蔽数据分布。 ParallelScan 算子屏蔽共享存储。 如图所示： 表 A 和表 B 做 join，并做聚合。 共享存储中的表仍然是单张表，并没有做物理上的分区。 重新设计 4 类扫描算子，使之在扫描共享存储上的表时能够分片扫描，形成 virtual partition。 ","date":"2023-12-11","objectID":"/polardb-pg-htap%E6%9E%B6%E6%9E%84%E8%AF%A6%E8%A7%A3/:1:0","tags":null,"title":"polardb pg HTAP架构详解","uri":"/polardb-pg-htap%E6%9E%B6%E6%9E%84%E8%AF%A6%E8%A7%A3/"},{"categories":null,"content":"2 分布式优化器 基于社区的 GPORCA 优化器扩展了能感知共享存储特性的 Transformation Rules。使得能够探索共享存储下特有的 Plan 空间。例如，对于一个表在 PolarDB PostgreSQL 版中既可以全量的扫描，也可以分区域扫描，这个是和传统 MPP 的本质区别。如下图所示，上面灰色部分是 PolarDB PostgreSQL 版内核与 GPORCA 优化器的适配部分。下半部分是 ORCA 内核，灰色模块是在 ORCA 内核中对共享存储特性所做的扩展。 ","date":"2023-12-11","objectID":"/polardb-pg-htap%E6%9E%B6%E6%9E%84%E8%AF%A6%E8%A7%A3/:2:0","tags":null,"title":"polardb pg HTAP架构详解","uri":"/polardb-pg-htap%E6%9E%B6%E6%9E%84%E8%AF%A6%E8%A7%A3/"},{"categories":null,"content":"3 算子并行化 PolarDB PostgreSQL 版中有 4 类算子需要并行化，以下介绍一个具有代表性的 Seqscan 的算子的并行化。 为了最大限度的利用存储的大 IO 带宽，在顺序扫描时，按照 4 MB 为单位做逻辑切分，将 IO 尽量打散到不同的盘上，达到所有的盘同时提供读服务的效果。这样做还有一个优势，就是每个只读节点只扫描部分表文件，则最终能缓存的表大小是所有只读节点的 BufferPool 总和。 下面的图表中： 增加只读节点，扫描性能线性提升 30 倍。 打开 Buffer 时，扫描从 37 分钟降到 3.75 秒。 ","date":"2023-12-11","objectID":"/polardb-pg-htap%E6%9E%B6%E6%9E%84%E8%AF%A6%E8%A7%A3/:3:0","tags":null,"title":"polardb pg HTAP架构详解","uri":"/polardb-pg-htap%E6%9E%B6%E6%9E%84%E8%AF%A6%E8%A7%A3/"},{"categories":null,"content":"4 消除数据倾斜问题 倾斜是传统 MPP 固有的问题： 在 PolarDB PostgreSQL 版中，大对象的是通过 heap 表关联 TOAST​表，无论对哪个表切分都无法达到均衡。 另外，不同只读节点的事务、Buffer、网络、IO 负载抖动。 以上两点会导致分布执行时存在长尾进程。 协调节点内部分成 DataThread 和 ControlThread。 DataThread 负责收集汇总元组。 ControlThread 负责控制每个扫描算子的扫描进度。 扫描快的工作进程能多扫描逻辑的数据切片。 过程中需要考虑 Buffer 的亲和性。 说明 尽管是动态分配，尽量维护 Buffer 的亲和性。另外，每个算子的上下文存储在 worker 的私有内存中， Coordinator 不存储具体表的信息。 下面表格中，当出现大对象时，静态切分出现数据倾斜，而动态扫描仍然能够线性提升。 ","date":"2023-12-11","objectID":"/polardb-pg-htap%E6%9E%B6%E6%9E%84%E8%AF%A6%E8%A7%A3/:4:0","tags":null,"title":"polardb pg HTAP架构详解","uri":"/polardb-pg-htap%E6%9E%B6%E6%9E%84%E8%AF%A6%E8%A7%A3/"},{"categories":null,"content":"5 SQL 级别弹性扩展 利用数据共享的特点，还可以支持云原生下极致弹性的要求。将 Coordinator 全链路上各个模块所需要的外部依赖存在共享存储上，同时 worker 全链路上需要的运行时参数通过控制链路从 Coordinator 同步过来，使 Coordinator 和 worker 无状态化。 因此： SQL 连接的任意只读节点都可以成为 Coordinator 节点，这解决了 Coordinator 单点问题。 支持不同的 SQL 使用不同的 CPU 数目执行，灵活的配置不同业务 SQL 配置不同的 CPU 核心数。 ","date":"2023-12-11","objectID":"/polardb-pg-htap%E6%9E%B6%E6%9E%84%E8%AF%A6%E8%A7%A3/:5:0","tags":null,"title":"polardb pg HTAP架构详解","uri":"/polardb-pg-htap%E6%9E%B6%E6%9E%84%E8%AF%A6%E8%A7%A3/"},{"categories":null,"content":"6 事务一致性 多个计算节点数据一致性通过等待回放和 globalsnapshot 机制来完成。等待回放保证所有 worker 能看到所需要的数据版本，而 globalsnapshot 保证了选出一个统一的版本。 ","date":"2023-12-11","objectID":"/polardb-pg-htap%E6%9E%B6%E6%9E%84%E8%AF%A6%E8%A7%A3/:6:0","tags":null,"title":"polardb pg HTAP架构详解","uri":"/polardb-pg-htap%E6%9E%B6%E6%9E%84%E8%AF%A6%E8%A7%A3/"},{"categories":null,"content":"7 TPC-H 性能：加速比 使用 1 TB 的 TPC-H 进行了测试，首先对比了 PolarDB PostgreSQL 版新的分布式并行和单机并行的性能，有 3 条 SQL 提速 60 倍，19 条 SQL 提速 10 倍以上。 此外，使用分布式执行引擎测试，增加 CPU 时的性能，可以看到，从 16 核和 128 核时性能线性提升。单看 22 条 SQL，通过增加 CPU，每条 SQL 性能线性提升。 ","date":"2023-12-11","objectID":"/polardb-pg-htap%E6%9E%B6%E6%9E%84%E8%AF%A6%E8%A7%A3/:7:0","tags":null,"title":"polardb pg HTAP架构详解","uri":"/polardb-pg-htap%E6%9E%B6%E6%9E%84%E8%AF%A6%E8%A7%A3/"},{"categories":null,"content":"8 TPC-H 性能：和传统 MPP 数仓对比 和传统 MPP 数仓对比，同样使用 16 个节点，PolarDB PostgreSQL 版的性能是传统 MPP 数仓的 90%。 前面讲到给 PolarDB PostgreSQL 版的分布式引擎做到了弹性扩展，数据不需要充分重分布，当 dop=8 时，性能是传统 MPP 数仓的 5.6 倍。 ","date":"2023-12-11","objectID":"/polardb-pg-htap%E6%9E%B6%E6%9E%84%E8%AF%A6%E8%A7%A3/:8:0","tags":null,"title":"polardb pg HTAP架构详解","uri":"/polardb-pg-htap%E6%9E%B6%E6%9E%84%E8%AF%A6%E8%A7%A3/"},{"categories":null,"content":"9 分布式执行加速索引创建 OLTP 业务中会建大量的索引，经分析建索引过程中，80%是在排序和构建索引页，20%在写索引页。通过使用分布式并行来加速排序过程，同时流水化批量写入。 上述优化能够使得创建索引有 4~5 倍的提升。 ","date":"2023-12-11","objectID":"/polardb-pg-htap%E6%9E%B6%E6%9E%84%E8%AF%A6%E8%A7%A3/:9:0","tags":null,"title":"polardb pg HTAP架构详解","uri":"/polardb-pg-htap%E6%9E%B6%E6%9E%84%E8%AF%A6%E8%A7%A3/"},{"categories":null,"content":"10 分布式并行执行加速多模：时空数据库 PolarDB PostgreSQL 版是对多模数据库，支持时空数据。时空数据库是计算密集型和 IO 密集型，可以借助分布式执行来加速。PolarDB PostgreSQL 版针对共享存储退出了扫描共享 RTREE 索引的功能。 数据量：40000 万，500 GB。 规格：5个只读节点，每个节点规格为 16 核 CPU、128 GB 内存。 性能： 随 CPU 数目线性提升。 80 核 CPU 时，提升 71 倍。 ","date":"2023-12-11","objectID":"/polardb-pg-htap%E6%9E%B6%E6%9E%84%E8%AF%A6%E8%A7%A3/:10:0","tags":null,"title":"polardb pg HTAP架构详解","uri":"/polardb-pg-htap%E6%9E%B6%E6%9E%84%E8%AF%A6%E8%A7%A3/"},{"categories":null,"content":" Table of Contents 1 Shared-Storage 带来的挑战 2 架构原理 3 数据一致性 3.1 传统数据库的内存状态同步 3.2 基于 Shared-Storage 的内存状态同步 3.3 基于 Shared-Storage 的过去页面 3.4 过去页面的解法 3.5 基于 Shared-Storage 的未来页面 3.6 未来页面的解法 4 低延迟复制 4.1 传统流复制的问题 4.2 优化 1：只复制 Meta 4.3 优化 2：页面回放优化 4.4 优化 3：DDL 锁回放优化 5 Recovery 优化 5.1 背景 5.2 Lazy Recovery 5.3 Persistent BufferPool 本文为摘录(或转载)，侵删，原文为： https://help.aliyun.com/zh/polardb/polardb-for-postgresql/polardb-for-postgresql-architecture/?spm=a2c4g.11186623.0.0.2e3b5fb1p0L9je ","date":"2023-12-11","objectID":"/polardb-pg-%E5%AD%98%E5%82%A8%E8%AE%A1%E7%AE%97%E5%88%86%E7%A6%BB%E6%9E%B6%E6%9E%84%E8%AF%A6%E8%A7%A3/:0:0","tags":["sharedata"],"title":"PolarDB PostgreSQL 版：存储计算分离架构详解","uri":"/polardb-pg-%E5%AD%98%E5%82%A8%E8%AE%A1%E7%AE%97%E5%88%86%E7%A6%BB%E6%9E%B6%E6%9E%84%E8%AF%A6%E8%A7%A3/"},{"categories":null,"content":"1 Shared-Storage 带来的挑战 基于 Shared-Storage，数据库由传统的 share nothing，转变成了 Shared-Storage 架构。需要解决以下问题： 数据一致性：由原来的 N 份计算+N 份存储，转变成了 N 份计算+1 份存储。 读写分离：如何基于新架构做到低延迟的复制。 高可用：如何 Recovery 和 Failover。 IO 模型：如何从 Buffer-IO 向 Direct-IO 优化。 ","date":"2023-12-11","objectID":"/polardb-pg-%E5%AD%98%E5%82%A8%E8%AE%A1%E7%AE%97%E5%88%86%E7%A6%BB%E6%9E%B6%E6%9E%84%E8%AF%A6%E8%A7%A3/:1:0","tags":["sharedata"],"title":"PolarDB PostgreSQL 版：存储计算分离架构详解","uri":"/polardb-pg-%E5%AD%98%E5%82%A8%E8%AE%A1%E7%AE%97%E5%88%86%E7%A6%BB%E6%9E%B6%E6%9E%84%E8%AF%A6%E8%A7%A3/"},{"categories":null,"content":"2 架构原理 基于 Shared-Storage 的 PolarDB PostgreSQL 版的架构原理如下： 主节点为可读可写节点（RW），只读节点为只读（RO）。 Shared-Storage 层，只有主节点能写入，因此主节点和只读节点能看到一致的落盘的数据。 只读节点的内存状态是通过回放 WAL 保持和主节点同步的。 主节点的 WAL 日志写到 Shared-Storage，仅复制 WAL 的 meta 给只读节点。 只读节点从 Shared-Storage 上读取 WAL 并回放。 ","date":"2023-12-11","objectID":"/polardb-pg-%E5%AD%98%E5%82%A8%E8%AE%A1%E7%AE%97%E5%88%86%E7%A6%BB%E6%9E%B6%E6%9E%84%E8%AF%A6%E8%A7%A3/:2:0","tags":["sharedata"],"title":"PolarDB PostgreSQL 版：存储计算分离架构详解","uri":"/polardb-pg-%E5%AD%98%E5%82%A8%E8%AE%A1%E7%AE%97%E5%88%86%E7%A6%BB%E6%9E%B6%E6%9E%84%E8%AF%A6%E8%A7%A3/"},{"categories":null,"content":"3 数据一致性 ","date":"2023-12-11","objectID":"/polardb-pg-%E5%AD%98%E5%82%A8%E8%AE%A1%E7%AE%97%E5%88%86%E7%A6%BB%E6%9E%B6%E6%9E%84%E8%AF%A6%E8%A7%A3/:3:0","tags":["sharedata"],"title":"PolarDB PostgreSQL 版：存储计算分离架构详解","uri":"/polardb-pg-%E5%AD%98%E5%82%A8%E8%AE%A1%E7%AE%97%E5%88%86%E7%A6%BB%E6%9E%B6%E6%9E%84%E8%AF%A6%E8%A7%A3/"},{"categories":null,"content":"3.1 传统数据库的内存状态同步 传统 share nothing 的数据库，主节点和只读节点都有各自的内存和存储，只需要从主节点复制 WAL 日志到只读节点，并在只读节点上依次回放日志即可，这也是复制状态机的基本原理。 ","date":"2023-12-11","objectID":"/polardb-pg-%E5%AD%98%E5%82%A8%E8%AE%A1%E7%AE%97%E5%88%86%E7%A6%BB%E6%9E%B6%E6%9E%84%E8%AF%A6%E8%A7%A3/:3:1","tags":["sharedata"],"title":"PolarDB PostgreSQL 版：存储计算分离架构详解","uri":"/polardb-pg-%E5%AD%98%E5%82%A8%E8%AE%A1%E7%AE%97%E5%88%86%E7%A6%BB%E6%9E%B6%E6%9E%84%E8%AF%A6%E8%A7%A3/"},{"categories":null,"content":"3.2 基于 Shared-Storage 的内存状态同步 存储计算分离后，Shared-Storage 上读取到的页面是一致的，内存状态是通过从 Shared-Storage 上读取最新的 WAL 并回放得来，如下图所示： 主节点通过刷脏将版本 200 写入到 Shared-Storage。 只读节点基于版本 100，并回放日志得到 200。 ","date":"2023-12-11","objectID":"/polardb-pg-%E5%AD%98%E5%82%A8%E8%AE%A1%E7%AE%97%E5%88%86%E7%A6%BB%E6%9E%B6%E6%9E%84%E8%AF%A6%E8%A7%A3/:3:2","tags":["sharedata"],"title":"PolarDB PostgreSQL 版：存储计算分离架构详解","uri":"/polardb-pg-%E5%AD%98%E5%82%A8%E8%AE%A1%E7%AE%97%E5%88%86%E7%A6%BB%E6%9E%B6%E6%9E%84%E8%AF%A6%E8%A7%A3/"},{"categories":null,"content":"3.3 基于 Shared-Storage 的过去页面 上述流程中，只读节点中基于日志回放出来的页面会被淘汰掉，此后需要再次从存储上读取页面，会出现读取的页面是之前的老页面，称为过去页面。如下图所示： T1 时刻，主节点在 T1 时刻写入日志 LSN=200，把页面 P1 的内容从 500 更新到 600。 只读节点此时页面 P1 的内容是 500。 T2 时刻，主节点将日志 200 的 meta 信息发送给只读节点，只读节点得知存在新的日志。 T3 时刻，此时在只读节点上读取页面 P1，需要读取页面 P1 和 LSN=200 的日志，进行一次回放，得到 P1 的最新内容为 600。 T4 时刻，只读节点上由于 BufferPool 不足，将回放出来的最新页面 P1 淘汰掉。 主节点没有将最新的页面 P1 为 600 的最新内容刷脏到 Shared-Storage 上。 T5 时刻，再次从只读节点上发起读取 P1 操作，由于内存中已经将 P1 淘汰掉了，因此从 Shared-Storage 上读取，此时读取到了过去页面的内容。 ","date":"2023-12-11","objectID":"/polardb-pg-%E5%AD%98%E5%82%A8%E8%AE%A1%E7%AE%97%E5%88%86%E7%A6%BB%E6%9E%B6%E6%9E%84%E8%AF%A6%E8%A7%A3/:3:3","tags":["sharedata"],"title":"PolarDB PostgreSQL 版：存储计算分离架构详解","uri":"/polardb-pg-%E5%AD%98%E5%82%A8%E8%AE%A1%E7%AE%97%E5%88%86%E7%A6%BB%E6%9E%B6%E6%9E%84%E8%AF%A6%E8%A7%A3/"},{"categories":null,"content":"3.4 过去页面的解法 只读节点在任意时刻读取页面时，需要找到对应的 Base 页面和对应起点的日志，依次回放。如下图所示： 在只读节点内存中维护每个 Page 对应的日志 meta。 在读取时一个 Page 时，按需逐个应用日志直到期望的 Page 版本。 应用日志时，通过日志的 meta 从 Shared-Storage 上读取。 通过上述分析，需要维护每个 Page 到日志的倒排索引，而只读节点的内存是有限的，因此这个 Page 到日志的索引需要持久化，PolarDB PostgreSQL 版设计了一个可持久化的索引结构-LogIndex。 LogIndex 本质是一个可持久化的 hash 数据结构。 只读节点通过 WAL receiver 接收从主节点过来的 WAL meta 信息。 WAL meta 记录该条日志修改了哪些 Page。 将该条 WAL meta 插入到 LogIndex 中。其中，key 是 Page ID，value 是 LSN。 一条 WAL 日志可能更新了多个 Page（索引分裂），在 LogIndex 中有多条记录。 同时在 BufferPool 中给该 Page 打上 outdate 标记，以便下次读取的时候从 LogIndex 重回放对应的日志。 当内存达到一定阈值时，LogIndex 异步将内存中的 hash 刷到盘上。 通过 LogIndex 解决了刷脏依赖过去页面的问题，也是将只读节点的回放转变成了 Lazy 的回放：只需要回放日志的 meta 信息即可。 ","date":"2023-12-11","objectID":"/polardb-pg-%E5%AD%98%E5%82%A8%E8%AE%A1%E7%AE%97%E5%88%86%E7%A6%BB%E6%9E%B6%E6%9E%84%E8%AF%A6%E8%A7%A3/:3:4","tags":["sharedata"],"title":"PolarDB PostgreSQL 版：存储计算分离架构详解","uri":"/polardb-pg-%E5%AD%98%E5%82%A8%E8%AE%A1%E7%AE%97%E5%88%86%E7%A6%BB%E6%9E%B6%E6%9E%84%E8%AF%A6%E8%A7%A3/"},{"categories":null,"content":"3.5 基于 Shared-Storage 的未来页面 在存储计算分离后，刷脏依赖还存在未来页面的问题。如下图所示： T1 时刻，主节点对 P1 更新了 2 次，产生了 2 条日志，此时主节点和只读节点上页面 P1 的内容都是 500。 T2 时刻， 发送日志 LSN=200 给只读节点。 T3 时刻，只读节点回放 LSN=200 的日志，得到 P1 的内容为 600，此时只读节点日志回放到了 200，后面的 LSN=300 的日志对其来说还不存在。 T4 时刻，主节点刷脏，将 P1 最新的内容 700 刷到了 Shared-Storage 上，同时只读节点上 BufferPool 淘汰掉了页面 P1。 T5 时刻，只读节点再次读取页面 P1，由于 BufferPool 中不存在 P1，因此从共享内存上读取了最新的 P1，但是只读节点并没有回放 LSN=300 的日志，读取到了一个对其来说超前的未来页面。 未来页面的问题是：部分页面是未来页面，部分页面是正常的页面，会导致数据不一致。例如，索引分裂成 2 个 Page 后，一个读取到了正常的 Page，另一个读取到了未来页面，B+Tree 的索引结构会被破坏。 ","date":"2023-12-11","objectID":"/polardb-pg-%E5%AD%98%E5%82%A8%E8%AE%A1%E7%AE%97%E5%88%86%E7%A6%BB%E6%9E%B6%E6%9E%84%E8%AF%A6%E8%A7%A3/:3:5","tags":["sharedata"],"title":"PolarDB PostgreSQL 版：存储计算分离架构详解","uri":"/polardb-pg-%E5%AD%98%E5%82%A8%E8%AE%A1%E7%AE%97%E5%88%86%E7%A6%BB%E6%9E%B6%E6%9E%84%E8%AF%A6%E8%A7%A3/"},{"categories":null,"content":"3.6 未来页面的解法 未来页面的原因是主节点刷脏的速度超过了任一只读节点的回放速度（虽然只读节点的 Lazy 回放已经很快了）。因此，解法就是对主节点刷脏进度时做控制：不能超过最慢的只读节点的回放位点。如下图所示： 只读节点回放到 T4 位点。 主节点在刷脏时，对所有脏页按照 LSN 排序，仅刷在 T4 之前的脏页（包括 T4），之后的脏页不刷。 其中，T4 的 LSN 位点称为一致性位点。 ","date":"2023-12-11","objectID":"/polardb-pg-%E5%AD%98%E5%82%A8%E8%AE%A1%E7%AE%97%E5%88%86%E7%A6%BB%E6%9E%B6%E6%9E%84%E8%AF%A6%E8%A7%A3/:3:6","tags":["sharedata"],"title":"PolarDB PostgreSQL 版：存储计算分离架构详解","uri":"/polardb-pg-%E5%AD%98%E5%82%A8%E8%AE%A1%E7%AE%97%E5%88%86%E7%A6%BB%E6%9E%B6%E6%9E%84%E8%AF%A6%E8%A7%A3/"},{"categories":null,"content":"4 低延迟复制 ","date":"2023-12-11","objectID":"/polardb-pg-%E5%AD%98%E5%82%A8%E8%AE%A1%E7%AE%97%E5%88%86%E7%A6%BB%E6%9E%B6%E6%9E%84%E8%AF%A6%E8%A7%A3/:4:0","tags":["sharedata"],"title":"PolarDB PostgreSQL 版：存储计算分离架构详解","uri":"/polardb-pg-%E5%AD%98%E5%82%A8%E8%AE%A1%E7%AE%97%E5%88%86%E7%A6%BB%E6%9E%B6%E6%9E%84%E8%AF%A6%E8%A7%A3/"},{"categories":null,"content":"4.1 传统流复制的问题 同步链路：日志同步路径 IO 多，网络传输量大。 页面回放：读取和 Buffer 修改慢（IO 密集型+CPU 密集型）。 DDL 回放：修改文件时需要对修改的文件加锁，而加锁的过程容易被阻塞，导致 DDL 慢。 快照更新：RO 高并发引起事务快照更新慢。 流程如下： 主节点写入 WAL 日志到本地文件系统中。 WAL Sender 进程读取，并发送。 只读节点的 WAL Receiver 进程接收写入到本地文件系统中。 回放进程读取 WAL 日志，读取对应的 Page 到 BufferPool 中，并在内存中回放。 主节点刷脏页到 Shared Storage。 从上述流程可以看到，整个链路是很长的，只读节点延迟高，影响用户业务读写分离负载均衡。 ","date":"2023-12-11","objectID":"/polardb-pg-%E5%AD%98%E5%82%A8%E8%AE%A1%E7%AE%97%E5%88%86%E7%A6%BB%E6%9E%B6%E6%9E%84%E8%AF%A6%E8%A7%A3/:4:1","tags":["sharedata"],"title":"PolarDB PostgreSQL 版：存储计算分离架构详解","uri":"/polardb-pg-%E5%AD%98%E5%82%A8%E8%AE%A1%E7%AE%97%E5%88%86%E7%A6%BB%E6%9E%B6%E6%9E%84%E8%AF%A6%E8%A7%A3/"},{"categories":null,"content":"4.2 优化 1：只复制 Meta 因为底层是 Shared-Storage，只读节点可直接从 Shared-Storage 上读取所需要的 WAL 数据。因此主节点只把 WAL 日志的元数据（去掉 Payload）复制到只读节点，这样网络传输量小，减少关键路径上的 IO。如下图所示： 优化流程如下： WAL Record 是由：Header，PageID，Payload 组成。 由于只读节点可以直接读取 Shared-Storage 上的 WAL 文件，因此主节点只把 WAL 日志的元数据发送（复制）到只读节点，包括：Header，PageID。 在只读节点上，通过 WAL 的元数据直接读取 Shared-Storage 上完整的 WAL 文件。 通过上述优化，能显著减少主节点和只读节点间的网络传输量。从下图可以看到网络传输量减少了 98%。 ","date":"2023-12-11","objectID":"/polardb-pg-%E5%AD%98%E5%82%A8%E8%AE%A1%E7%AE%97%E5%88%86%E7%A6%BB%E6%9E%B6%E6%9E%84%E8%AF%A6%E8%A7%A3/:4:2","tags":["sharedata"],"title":"PolarDB PostgreSQL 版：存储计算分离架构详解","uri":"/polardb-pg-%E5%AD%98%E5%82%A8%E8%AE%A1%E7%AE%97%E5%88%86%E7%A6%BB%E6%9E%B6%E6%9E%84%E8%AF%A6%E8%A7%A3/"},{"categories":null,"content":"4.3 优化 2：页面回放优化 在传统数据库中日志回放的过程中会读取大量的 Page 并逐个日志 Apply，然后落盘。该流程在用户读 IO 的关键路径上，借助存储计算分离可以做到：如果只读节点上 Page 不在 BufferPool 中，不产生任何 IO，仅仅记录 LogIndex 即可。 可以将回放进程中的以下 IO 操作 offload 到 session 进程中： 数据页 IO 开销。 日志 apply 开销。 基于 LogIndex 页面的多版本回放。 如下图所示，在只读节点上的回放进程中，在 Apply 一条 WAL 的 meta 时： 如果对应 Page 不在内存中，仅仅记录 LogIndex。 如果对应的 Page 在内存中，则标记为 Outdate，并记录 LogIndex，回放过程完成。 用户 session 进程在读取 Page 时，读取正确的 Page 到 BufferPool 中，并通过 LogIndex 来回放相应的日志。 可以看到，主要的 IO 操作由原来的单个回放进程 offload 到了多个用户进程。 通过上述优化，能显著减少回放的延迟，比其他云原生数据库快 30 倍。 ","date":"2023-12-11","objectID":"/polardb-pg-%E5%AD%98%E5%82%A8%E8%AE%A1%E7%AE%97%E5%88%86%E7%A6%BB%E6%9E%B6%E6%9E%84%E8%AF%A6%E8%A7%A3/:4:3","tags":["sharedata"],"title":"PolarDB PostgreSQL 版：存储计算分离架构详解","uri":"/polardb-pg-%E5%AD%98%E5%82%A8%E8%AE%A1%E7%AE%97%E5%88%86%E7%A6%BB%E6%9E%B6%E6%9E%84%E8%AF%A6%E8%A7%A3/"},{"categories":null,"content":"4.4 优化 3：DDL 锁回放优化 在主节点执行 DDL 时（例如，drop table），需要在所有节点上都对表上排他锁，这样能保证表文件不会在只读节点上读取时被主节点删除掉了（因为文件在 Shared-Storage 上只有一份）。在所有只读节点上对表上排他锁是通过 WAL 复制到所有的只读节点，只读节点回放 DDL 锁来完成。而回放进程在回放 DDL 锁时，对表上锁可能会阻塞很久，因此可以通过把 DDL 锁 offload 到其他进程上来优化回放进程的关键路径。 通过上述优化，能够保证回放进程一直处于平滑的状态，不会因为去等 DDL 而阻塞了回放的关键路径。 上述 3 个优化之后，极大的降低了复制延迟，能够带来如下优势： 读写分离：负载均衡，更接近 Oracle RAC 使用体验。 高可用：加速 HA 流程。 稳定性：最小化未来页的数量，可以写更少或者无需写页面快照。 ","date":"2023-12-11","objectID":"/polardb-pg-%E5%AD%98%E5%82%A8%E8%AE%A1%E7%AE%97%E5%88%86%E7%A6%BB%E6%9E%B6%E6%9E%84%E8%AF%A6%E8%A7%A3/:4:4","tags":["sharedata"],"title":"PolarDB PostgreSQL 版：存储计算分离架构详解","uri":"/polardb-pg-%E5%AD%98%E5%82%A8%E8%AE%A1%E7%AE%97%E5%88%86%E7%A6%BB%E6%9E%B6%E6%9E%84%E8%AF%A6%E8%A7%A3/"},{"categories":null,"content":"5 Recovery 优化 ","date":"2023-12-11","objectID":"/polardb-pg-%E5%AD%98%E5%82%A8%E8%AE%A1%E7%AE%97%E5%88%86%E7%A6%BB%E6%9E%B6%E6%9E%84%E8%AF%A6%E8%A7%A3/:5:0","tags":["sharedata"],"title":"PolarDB PostgreSQL 版：存储计算分离架构详解","uri":"/polardb-pg-%E5%AD%98%E5%82%A8%E8%AE%A1%E7%AE%97%E5%88%86%E7%A6%BB%E6%9E%B6%E6%9E%84%E8%AF%A6%E8%A7%A3/"},{"categories":null,"content":"5.1 背景 数据库 OOM、Crash 等场景恢复时间长，本质上是日志回放慢，在共享存储 Direct-IO 模型下问题更加突出。 ","date":"2023-12-11","objectID":"/polardb-pg-%E5%AD%98%E5%82%A8%E8%AE%A1%E7%AE%97%E5%88%86%E7%A6%BB%E6%9E%B6%E6%9E%84%E8%AF%A6%E8%A7%A3/:5:1","tags":["sharedata"],"title":"PolarDB PostgreSQL 版：存储计算分离架构详解","uri":"/polardb-pg-%E5%AD%98%E5%82%A8%E8%AE%A1%E7%AE%97%E5%88%86%E7%A6%BB%E6%9E%B6%E6%9E%84%E8%AF%A6%E8%A7%A3/"},{"categories":null,"content":"5.2 Lazy Recovery 上述内容介绍通过 LogIndex 在只读节点上做到了 Lazy 的回放，在主节点重启后的 recovery 过程中，本质也是在回放日志，因此，可以借助 Lazy 回放来加速 recovery 的过程： 从 checkpoint 点开始逐条去读 WAL 日志。 回放完 LogIndex 日志后，即认为回放完成。 recovery 完成，开始提供服务。 真正的回放被 offload 到了重启之后进来的 session 进程中。 优化之后（回放 500 MB 日志量），如下图所示： ","date":"2023-12-11","objectID":"/polardb-pg-%E5%AD%98%E5%82%A8%E8%AE%A1%E7%AE%97%E5%88%86%E7%A6%BB%E6%9E%B6%E6%9E%84%E8%AF%A6%E8%A7%A3/:5:2","tags":["sharedata"],"title":"PolarDB PostgreSQL 版：存储计算分离架构详解","uri":"/polardb-pg-%E5%AD%98%E5%82%A8%E8%AE%A1%E7%AE%97%E5%88%86%E7%A6%BB%E6%9E%B6%E6%9E%84%E8%AF%A6%E8%A7%A3/"},{"categories":null,"content":"5.3 Persistent BufferPool 上述方案优化了在 recovery 的重启速度，但是在重启之后，session 进程通过读取 WAL 日志来回放想要的 page。表示为在 recovery 之后会有短暂的响应慢的问题。优化的办法为在数据库重启时 BufferPool 并不销毁，如下图所示：crash 和 restart 期间 BufferPool 不销毁。 内核中的共享内存分成 2 部分： 全局结构，ProcArray 等。 BufferPool 结构；其中 BufferPool 通过具名共享内存来分配，在进程重启后仍然有效。而全局结构在进程重启后需要重新初始化。 而 BufferPool 中并不是所有的 Page 都是可以复用的。例如：在重启前，某进程对 Page 上 X 锁，随后 crash 了，该 X 锁就没有进程来释放了。因此，在 crash 和 restart 之后需要把所有的 BufferPool 遍历一遍，剔除掉不能被复用的 Page。另外，BufferPool 的回收依赖 kubernetes。该优化之后，使得重启前后性能平稳。 ","date":"2023-12-11","objectID":"/polardb-pg-%E5%AD%98%E5%82%A8%E8%AE%A1%E7%AE%97%E5%88%86%E7%A6%BB%E6%9E%B6%E6%9E%84%E8%AF%A6%E8%A7%A3/:5:3","tags":["sharedata"],"title":"PolarDB PostgreSQL 版：存储计算分离架构详解","uri":"/polardb-pg-%E5%AD%98%E5%82%A8%E8%AE%A1%E7%AE%97%E5%88%86%E7%A6%BB%E6%9E%B6%E6%9E%84%E8%AF%A6%E8%A7%A3/"},{"categories":null,"content":" Table of Contents 1 为什么 OCI Database for PostgreSQL 脱颖而出 2 Vanilla PostgreSQL 的问题 3 OCI Database with PostgreSQL – 高级架构 3.1 数据库优化存储 (DbOS) 的优点 3.2 进一步的存储优化 3.3 结论 本文为摘录(或转载)，侵删，原文为： https://mp.weixin.qq.com/s?__biz=MzI3OTM3MDkyNg==\u0026mid=2247497316\u0026idx=1\u0026sn=d08b84d63ab2e4b69949af9170762189\u0026chksm=eb4a7ba5dc3df2b3ca2b3721e5614ab5711be6e984ec44173035323953d193440240f8412591\u0026mpshare=1\u0026scene=1\u0026srcid=1208AtRH30qSa2LdMxzmf3sV\u0026sharer_shareinfo=9a0858a92025bbb0e8887abc9a5eee8a\u0026sharer_shareinfo_first=9a0858a92025bbb0e8887abc9a5eee8a#rd 对于希望在云中轻松扩展且无需更改应用程序的组织来说，OCI Database with PostgreSQL 数据库是理想的解决方案。它提供完全的 PostgreSQL 兼容性，同时让用户利用 OCI 灵活、高性能、高可用性的基础设施以及内置的安全性和简单的定价。此外，这种 OCI 实施还提供了卓越的可扩展性并减少了管理需求。 ","date":"2023-12-08","objectID":"/oci-database-with-postgresql-%E5%AE%8C%E5%96%84oci%E7%9A%84%E4%BA%91%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A5%97%E4%BB%B6%E4%BB%A5%E6%BB%A1%E8%B6%B3%E5%90%84%E7%A7%8D%E9%9C%80%E6%B1%82/:0:0","tags":["pg"],"title":"OCI Database with PostgreSQL: 完善OCI的云数据库套件以满足各种需求","uri":"/oci-database-with-postgresql-%E5%AE%8C%E5%96%84oci%E7%9A%84%E4%BA%91%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A5%97%E4%BB%B6%E4%BB%A5%E6%BB%A1%E8%B6%B3%E5%90%84%E7%A7%8D%E9%9C%80%E6%B1%82/"},{"categories":null,"content":"1 为什么 OCI Database for PostgreSQL 脱颖而出 性能提升高达 3 倍 数据库优化存储 将 SQL 事务处理引擎与存储层解耦 成本不到友商的一半 我们将开源 PostgreSQL 称为“Vanilla PostgreSQL”。 ","date":"2023-12-08","objectID":"/oci-database-with-postgresql-%E5%AE%8C%E5%96%84oci%E7%9A%84%E4%BA%91%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A5%97%E4%BB%B6%E4%BB%A5%E6%BB%A1%E8%B6%B3%E5%90%84%E7%A7%8D%E9%9C%80%E6%B1%82/:1:0","tags":["pg"],"title":"OCI Database with PostgreSQL: 完善OCI的云数据库套件以满足各种需求","uri":"/oci-database-with-postgresql-%E5%AE%8C%E5%96%84oci%E7%9A%84%E4%BA%91%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A5%97%E4%BB%B6%E4%BB%A5%E6%BB%A1%E8%B6%B3%E5%90%84%E7%A7%8D%E9%9C%80%E6%B1%82/"},{"categories":null,"content":"2 Vanilla PostgreSQL 的问题 主要故障转移期间的数据丢失 - 非零 RPO 如图 2 所示，客户通常跨可用性域复制数据库实例。 此复制是从 AD1 中的主数据库异步执行到 AD2 中的“副本”的。 副本数据库可能落后于主数据库。 如果主数据库发生故障并且副本被提升为新的主数据库，则可能会因滞后而丢失一些数据。 数据丢失量取决于升级的副本与旧主副本的落后程度。 vanilla PostgreSQL 中解决此问题的一个解决方案是同步复制功能，但由于性能开销巨大，因此不太受欢迎。 手动升级和可管理性的复杂性： 尽管您可以在不同的可用性域中设置副本以实现高可用性，但将备用副本升级为主副本是一个手动且复杂的过程。必须谨慎选择要升级的新候选节点，从而有效减少数据丢失，同样，将旧主节点重新添加回集群需要更多手动步骤。例如，旧的主数据库可能有本地提交的多余事务，需要首先使用 pg_rewind 等工具清除这些事务，然后才能重新加入集群。 创建只读副本既昂贵又缓慢： 使用普通 PostgreSQL，创建新副本需要在主数据库上拍摄数据快照并赶上主数据库。对于可能达到 TB 级的大型数据库，这是一项昂贵且缓慢的操作。为了能够处理应用程序的突发读取需求，客户必须过度配置数据库资源。由于每个副本必须具有数据库的完整副本，因此运行多个副本的存储成本可能会变得昂贵。 ","date":"2023-12-08","objectID":"/oci-database-with-postgresql-%E5%AE%8C%E5%96%84oci%E7%9A%84%E4%BA%91%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A5%97%E4%BB%B6%E4%BB%A5%E6%BB%A1%E8%B6%B3%E5%90%84%E7%A7%8D%E9%9C%80%E6%B1%82/:2:0","tags":["pg"],"title":"OCI Database with PostgreSQL: 完善OCI的云数据库套件以满足各种需求","uri":"/oci-database-with-postgresql-%E5%AE%8C%E5%96%84oci%E7%9A%84%E4%BA%91%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A5%97%E4%BB%B6%E4%BB%A5%E6%BB%A1%E8%B6%B3%E5%90%84%E7%A7%8D%E9%9C%80%E6%B1%82/"},{"categories":null,"content":"3 OCI Database with PostgreSQL – 高级架构 在 OCI Database with PostgreSQL 数据库中，Oracle 将 复制和持久性问题推到了新的数据库优化存储(DbOS) 层: 该层是专门为实现高规模、高可用性和高性能数据库服务而构建的。DbOS 提供高度耐用的网络附加存储， 其中数据块在三个可用性域区域中的多个可用性域之间复制。 在单 AD 区域中，数据跨多个故障域复制。集群中的所有 PostgreSQL 节点都访问相同的网络附加存储。每个备用副本不再需要维护自己的数据库副本。主实例写入共享存储，而备用副本实例从同一共享存储读取并服务用户查询。 ","date":"2023-12-08","objectID":"/oci-database-with-postgresql-%E5%AE%8C%E5%96%84oci%E7%9A%84%E4%BA%91%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A5%97%E4%BB%B6%E4%BB%A5%E6%BB%A1%E8%B6%B3%E5%90%84%E7%A7%8D%E9%9C%80%E6%B1%82/:3:0","tags":["pg"],"title":"OCI Database with PostgreSQL: 完善OCI的云数据库套件以满足各种需求","uri":"/oci-database-with-postgresql-%E5%AE%8C%E5%96%84oci%E7%9A%84%E4%BA%91%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A5%97%E4%BB%B6%E4%BB%A5%E6%BB%A1%E8%B6%B3%E5%90%84%E7%A7%8D%E9%9C%80%E6%B1%82/"},{"categories":null,"content":"3.1 数据库优化存储 (DbOS) 的优点 持久性（零 RPO）： DbOS 在多可用性域区域中跨多个可用性域复制数据，并且可以在整个可用性域丢失的情况下幸存下来。 DbOS 使用基于仲裁的复制在幕后复制数据块。 如果主节点发生故障，数据库可以故障转移到使用复制的 DbOS 的其他数据库节点，并且这个新升级的主 PostgreSQL 实例可以接管而不会丢失数据。之前在旧主数据库上提交的所有事务都存在于新主数据库中。 由于 DbOS 层执行复制，因此无需仅仅为了持久性而运行多个副本实例。 例如，可以在没有任何副本的情况下使用 PostgreSQL 实例运行单节点 OCI 数据库，但仍然不会牺牲耐用性。即使在这种单节点设置中，也保证您具有零 RPO。 高可用性 (99.99%)： 使用 OCI Database with PostgreSQL 数据库，您可以在几分钟内自动将主数据库故障转移到集群中的另一个副本。 主故障转移速度很快，并且对应用程序几乎是透明的，因为恢复时间目标只需要几分钟。 为了透明地启用故障转移，主端点被设置为浮动 IP 地址，该地址会自动移动到新的主端点。 故障转移后，应用程序会自动重新建立与新主数据库的数据库连接，无需对应用程序进行任何配置更改。 与普通 PostgreSQL 不同，您在启动主故障转移时无需担心复制滞后和数据丢失。 您无需手动选择特定副本来减少数据丢失。集群中的所有实例共享相同的存储，因此在故障转移时，新的主实例可以保证零数据丢失。 弹性： 由于数据库存储在所有节点之间共享，因此您可以快速创建或删除副本，以满足用户查询工作负载需求。 与普通 PostgreSQL 不同，您不需要在主节点上拍摄数据快照并将其复制到副本节点来启动新的备用 PostgreSQL 实例。 可以像使用 PostgreSQL 在 OCI 数据库中启动计算实例一样快速地创建备用副本。 只读副本的水平扩展： 由于副本节点与 PostgreSQL 共享 OCI 数据库中的数据库存储，因此无论数据库集群中的副本数量有多少，您只需要维护一份数据库副本。 与在云中运行普通 PostgreSQL 相比，带有 PostgreSQL 的 OCI 数据库可显着节省存储成本。 此外，OCI 的 PostgreSQL 服务提供按使用量付费的数据定价模型，并具有自动扩展功能，可降低您的成本。 低副本延迟： 复制延迟是普通 PostgreSQL 只读副本设置的一个主要挑战。 由于副本必须重播并保存主副本所做的所有更改，因此很容易落后，尤其是在网络分区的情况下。 通过共享存储，副本的工作量显着减少。它只需要将更改应用于其缓存中的页面，并且不必保留这些更改。 使用这种架构，复制延迟通常以毫秒为单位，这使得读取查询能够近乎实时地执行或完成。 高效复制： OCI Database with PostgreSQL 在存储层执行复制。 因此，主实例不需要将预写日志 (WAL) 记录物理传送到所有副本。 相反，它通知副本有新的更改，并且各个副本直接从共享存储读取 latest WAL 记录。 这可以减少主服务器上的负载，并且可以更有效地扩展到更多数量的副本。 在我们的实验中，具有内置跨 AD 复制功能的 OCI Database with PostgreSQL 数据库比普通 PostgreSQL 中的同步复制快两倍多。 ","date":"2023-12-08","objectID":"/oci-database-with-postgresql-%E5%AE%8C%E5%96%84oci%E7%9A%84%E4%BA%91%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A5%97%E4%BB%B6%E4%BB%A5%E6%BB%A1%E8%B6%B3%E5%90%84%E7%A7%8D%E9%9C%80%E6%B1%82/:3:1","tags":["pg"],"title":"OCI Database with PostgreSQL: 完善OCI的云数据库套件以满足各种需求","uri":"/oci-database-with-postgresql-%E5%AE%8C%E5%96%84oci%E7%9A%84%E4%BA%91%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A5%97%E4%BB%B6%E4%BB%A5%E6%BB%A1%E8%B6%B3%E5%90%84%E7%A7%8D%E9%9C%80%E6%B1%82/"},{"categories":null,"content":"3.2 进一步的存储优化 除了共享存储优化之外，OCI Database with PostgreSQL 还实施了以下优化以进一步提高性能。 原子写入： DbOS 针对已知的数据库性能风险实施优化，例如消除“撕裂写入”。 通常，大多数数据库需要某种针对“撕裂写入”的保护，当数据库使用的页面大小（PostgreSQL 使用 8 KB）与底层存储的“原子写入单元”大小（通常为 512B 或 4KB）。例如，如果这是自上一个检查点以来对页面的第一次修改，PostgreSQL 首先将整个 8KB 页面写入 WAL，然后将该页面刷新到磁盘。如果页面写入被破坏，那么 PostgreSQL 会回退到使用之前在 WAL 中写入的整页，并且不会造成任何损害。但这种保护是有代价的——它会导致 WAL 膨胀，并且频繁的检查点会加剧问题，而频繁的检查点需要减少计划外故障转移期间的恢复时间。 我们在 DbOS 中实现了对 PostgreSQL 页面的原子写入支持。 存储层永远不会覆盖现有页面。 相反，它使用日志结构化技术始终将页面写入磁盘上的新位置，并维护从逻辑文件偏移到磁盘位置的映射层。 旧版本的页面会定期被垃圾收集。这避免了双重写入。 优化的页面缓存： 带有 PostgreSQL 的 OCI 数据库使用专门构建的缓存层，这与依赖于通用 Linux 内核页面缓存的普通 PostgreSQL 不同。 OCI 的页面缓存实现有很多优化，例如： 专为 PostgreSQL 工作负载定制的自定义预取逻辑。 避免在 PostgreSQL 共享缓冲区和页面缓存中双重缓存页面 通过预取数据页加速 PostgreSQL 恢复 存储级备份： 在普通 Postgres 中，为了维护数据库备份，WAL 被复制到对象存储，并定期拍摄文件系统快照。此过程同时使用主节点上的网络和 CPU。OCI 数据库与 PostgreSQL 将备份委托给存储层，从而消除了备份的网络和 CPU 开销。 ","date":"2023-12-08","objectID":"/oci-database-with-postgresql-%E5%AE%8C%E5%96%84oci%E7%9A%84%E4%BA%91%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A5%97%E4%BB%B6%E4%BB%A5%E6%BB%A1%E8%B6%B3%E5%90%84%E7%A7%8D%E9%9C%80%E6%B1%82/:3:2","tags":["pg"],"title":"OCI Database with PostgreSQL: 完善OCI的云数据库套件以满足各种需求","uri":"/oci-database-with-postgresql-%E5%AE%8C%E5%96%84oci%E7%9A%84%E4%BA%91%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A5%97%E4%BB%B6%E4%BB%A5%E6%BB%A1%E8%B6%B3%E5%90%84%E7%A7%8D%E9%9C%80%E6%B1%82/"},{"categories":null,"content":"3.3 结论 正如前面详细介绍的，OCI Database with PostgreSQL 数据库在成本、性能、规模、可用性和持久性方面提供了显着的优势。实现大部分优势的关键是基于 DbOS 和 DbFS，它们是专门为优化 PostgreSQL 以在云规模上更有效地工作而构建的。 ","date":"2023-12-08","objectID":"/oci-database-with-postgresql-%E5%AE%8C%E5%96%84oci%E7%9A%84%E4%BA%91%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A5%97%E4%BB%B6%E4%BB%A5%E6%BB%A1%E8%B6%B3%E5%90%84%E7%A7%8D%E9%9C%80%E6%B1%82/:3:3","tags":["pg"],"title":"OCI Database with PostgreSQL: 完善OCI的云数据库套件以满足各种需求","uri":"/oci-database-with-postgresql-%E5%AE%8C%E5%96%84oci%E7%9A%84%E4%BA%91%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A5%97%E4%BB%B6%E4%BB%A5%E6%BB%A1%E8%B6%B3%E5%90%84%E7%A7%8D%E9%9C%80%E6%B1%82/"},{"categories":null,"content":" Table of Contents 1 What is the difference between elfutils and binutils 2 eu-stack vs gdb 3 eu-strip vs strip 4 eu-addr2line vs addr2line 本文为摘录(或转载)，侵删，原文为： https://lynxbee.com/what-is-the-difference-between-elfutils-and-binutils/#:~:text=Ulrich%20Drepper%20who%20authored%20elfutils%20has%20mentioned%20the,available%20in%20binutils%20which%20are%20in%20%28wide%29%20use ","date":"2023-11-14","objectID":"/what-is-the-difference-between-elfutils-and-binutils/:0:0","tags":["elf","eu-stack","eu-strip","objcopy"],"title":"What is the difference between elfutils and binutils","uri":"/what-is-the-difference-between-elfutils-and-binutils/"},{"categories":null,"content":"1 What is the difference between elfutils and binutils 根据维基百科的介绍，elfutils 被描述为“Ulrich Drepper 编写了 elfutils，以取代 GNU Binutils，专门为 Linux 开发，并仅支持 ELF 和 DWARF 格式”。 elfutils 是一个红帽项目。 elfutils（如 eu-addr2line、eu-elflint、eu-findtextrel、eu-nm、eu-readelf、eu-size、eu-strip 等）与 binutils（addr2line、nm、readelf、size、strip、objdump 等）有相当大的重叠。 elfutils 的作者 Ulrich Drepper 提到了以下差异， 与 binutils 相比，elfutils 工具 体积更小 速度更快（通常是数倍） 更少的错误 功能更丰富 一些 binutils 中没有的工具被广泛使用 还有一些工具使用了 elfutils 库（如 systemtap、frysk 等） ","date":"2023-11-14","objectID":"/what-is-the-difference-between-elfutils-and-binutils/:1:0","tags":["elf","eu-stack","eu-strip","objcopy"],"title":"What is the difference between elfutils and binutils","uri":"/what-is-the-difference-between-elfutils-and-binutils/"},{"categories":null,"content":"2 eu-stack vs gdb eu-stack 仅用作显示可执行文件或者 core 文件的堆栈，速度非常快。 gdb 是一个完整的调试器，速度相对慢。 ","date":"2023-11-14","objectID":"/what-is-the-difference-between-elfutils-and-binutils/:2:0","tags":["elf","eu-stack","eu-strip","objcopy"],"title":"What is the difference between elfutils and binutils","uri":"/what-is-the-difference-between-elfutils-and-binutils/"},{"categories":null,"content":"3 eu-strip vs strip eu-strip 比 strip 更灵活，可以将抽符号表与将符号表保存一步完成： eu-strip a.out -f a.debug 以上命令将 a.out 中的符号表段和调试信息段都移出到 a.debug 文件中。这样，a.out 的 size 会减小很多。而此时，a.out 中会多一个 .gnu_debuglink 段，它是用来保存符号表位置的。之后，再用 gdb 去打开并运行 a.out 时，gdb 还可以找到 a.debug 这样的符号表及调试信息文件。 使用 strip 也能完成同样的任务，但是需要配合名 objcopy 命令，需要多个步骤完成： # test.debug 将包含调试信息和符号表； 而test将只包含调试信息 objcopy --only-keep-debug test test.debug # 从test文件里剥离debug段 objcopy --strip-debug test # 更彻底地，上面这句可以换成下面这句以移除所有的debug信息和符号表 strip -s test # 在二进制文件 test 中添加 .gnu_debuglink 段以指向符号表和调试信息文件 objcopy --add-gnu-debuglink=test.debug test # objdump 命令可以查看指定的section objdump -s -j .gnu_debuglink test ","date":"2023-11-14","objectID":"/what-is-the-difference-between-elfutils-and-binutils/:3:0","tags":["elf","eu-stack","eu-strip","objcopy"],"title":"What is the difference between elfutils and binutils","uri":"/what-is-the-difference-between-elfutils-and-binutils/"},{"categories":null,"content":"4 eu-addr2line vs addr2line 前者速度飞快。。。 ","date":"2023-11-14","objectID":"/what-is-the-difference-between-elfutils-and-binutils/:4:0","tags":["elf","eu-stack","eu-strip","objcopy"],"title":"What is the difference between elfutils and binutils","uri":"/what-is-the-difference-between-elfutils-and-binutils/"},{"categories":null,"content":" Table of Contents 1 A Universal Method 2 Debian / Ubuntu 3 Fedora / Rocky Linux / AlmaLinux 4 Arch Linux 本文为摘录(或转载)，侵删，原文为： https://linuxiac.com/how-to-find-linux-os-installation-date/ ","date":"2023-11-03","objectID":"/how-to-find-linux-os-installation-date/:0:0","tags":null,"title":"Linux Installation Date: How to Discover Your System's Age","uri":"/how-to-find-linux-os-installation-date/"},{"categories":null,"content":"1 A Universal Method 首先，我们必须澄清一点，在 Linux 中没有专门的设置、变量、日志文件条目或类似的东西来明确存储系统安装的实际日期和时间的信息。 然而，通过确定根目录（“/”）文件系统的创建时间，可以很容易地检索到此信息。 可以借助 stat 命令来实现这一目标，该命令能够显示文件或目录的详细信息，包括创建、访问和修改时间戳、文件类型、权限等元数据。 因此，要找到您的 Linux 系统安装的确切日期和时间，请运行以下命令： LANG=C stat / | awk '/Birth: /{print $2 \" \" substr($3,1,5)}' 当我们逐步分解这个 awk 命令时： `/Birth: /`：这是 awk 在输入的每一行中搜索的模式。 `{print $2 \" \" substr($3,1,5)}`：这是 awk 在找到匹配模式的行时执行的操作。下面是每个部分的作用： `$2` 指代当前行的第二个字段（列），也就是日期。 `substr($3, 1, 5)` 从当前行的第三个字段（列）中提取一个子字符串，从第一个字符开始，长度为 5，也就是时间。 `\" “` 是字符串文字，用于连接日期和时间之间的空格。 因此，该命令会搜索包含\"Birth: “的行，并从相应的字段中打印出日期和时间。 ","date":"2023-11-03","objectID":"/how-to-find-linux-os-installation-date/:1:0","tags":null,"title":"Linux Installation Date: How to Discover Your System's Age","uri":"/how-to-find-linux-os-installation-date/"},{"categories":null,"content":"2 Debian / Ubuntu 在 Debian 和 Ubuntu 系统以及它们的所有衍生系统（如 Linux Mint 和其他系统），你可以通过显示安装程序 syslog 文件的第一行来查看它们被安装的确切日期和时间。 sudo head -n1 /var/log/installer/syslog ","date":"2023-11-03","objectID":"/how-to-find-linux-os-installation-date/:2:0","tags":null,"title":"Linux Installation Date: How to Discover Your System's Age","uri":"/how-to-find-linux-os-installation-date/"},{"categories":null,"content":"3 Fedora / Rocky Linux / AlmaLinux 在 Fedora、Red Hat Enterprise Linux 及其所有衍生版（如 Rocky Linux、AlmaLinux、Oracle Linux 等）中，我们可以通过检查“basesystem”软件包的安装日期，将其用作可靠的标记来确认操作系统的安装日期。 sudo rpm -qi basesystem | grep -i \"install date\" 请记住，然而，如果你正在进行原地升级，比如从 Fedora 38 升级到 Fedora 39，Rocky 9.1 升级到 Rocky 9.2 等等，在检索“basesystem”包信息时显示的日期将是升级时的时间。 在这种情况下，要获取最初安装的实际日期，使用文章开头提到的 stat 命令的前两种通用方法之一。 ","date":"2023-11-03","objectID":"/how-to-find-linux-os-installation-date/:3:0","tags":null,"title":"Linux Installation Date: How to Discover Your System's Age","uri":"/how-to-find-linux-os-installation-date/"},{"categories":null,"content":"4 Arch Linux 如果你正在使用 Arch Linux 或其衍生版如 Manjaro 或 EndeavourOS，那么“pacman.log”文件的第一行将告诉你你的 Linux 系统安装的时间。 head -n1 /var/log/pacman.log ","date":"2023-11-03","objectID":"/how-to-find-linux-os-installation-date/:4:0","tags":null,"title":"Linux Installation Date: How to Discover Your System's Age","uri":"/how-to-find-linux-os-installation-date/"},{"categories":null,"content":" Table of Contents 1 docker 1.1 how to convert container to image? 1.2 how to export image to tar ? 1.3 how to import image into docker 如何将图像导入到 Docker 1.4 how to rename an image in docker 如何在 Docker 中重命名镜像 2 Debian 2.1 I’m running a debian docker, and I can’t find ip addr command 2.2 how to get sshd in debian docker 2.3 how to search packages in debian 答案由 ChatGPT 生成。 ","date":"2023-10-31","objectID":"/silly-questions-related-to-docker--debian/:0:0","tags":["image","container","ssh"],"title":"silly questions related to docker \u0026 debian","uri":"/silly-questions-related-to-docker--debian/"},{"categories":null,"content":"1 docker ","date":"2023-10-31","objectID":"/silly-questions-related-to-docker--debian/:1:0","tags":["image","container","ssh"],"title":"silly questions related to docker \u0026 debian","uri":"/silly-questions-related-to-docker--debian/"},{"categories":null,"content":"1.1 how to convert container to image? Commit the changes made to the container and create a new image: docker commit CONTAINER_ID new_image_name Replace CONTAINER_ID with the ID of the running container, and new_image_name with the desired name for the new image. ","date":"2023-10-31","objectID":"/silly-questions-related-to-docker--debian/:1:1","tags":["image","container","ssh"],"title":"silly questions related to docker \u0026 debian","uri":"/silly-questions-related-to-docker--debian/"},{"categories":null,"content":"1.2 how to export image to tar ? To export a Docker image to a TAR file, you can follow these steps: Open a terminal or command prompt on your system. Use the docker save command followed by the image name or ID to export the image: docker save -o imagefile.tar image_name Replace image_name with the name or ID of the Docker image you want to export. The command will save the image as a TAR archive file named imagefile.tar in the current directory. You can specify a different file location or name if desired. Once the export process is complete, the TAR file contains the Docker image along with its metadata. By following these steps, you can export a Docker image to a TAR file, which can then be shared or imported into another Docker environment using the docker load command. ","date":"2023-10-31","objectID":"/silly-questions-related-to-docker--debian/:1:2","tags":["image","container","ssh"],"title":"silly questions related to docker \u0026 debian","uri":"/silly-questions-related-to-docker--debian/"},{"categories":null,"content":"1.3 how to import image into docker 如何将图像导入到 Docker 要将图像导入到 Docker 中，可以按照以下步骤操作： 首先，确保已经安装了 Docker 引擎，并且正在运行。 在你的本地计算机上找到你想要导入的图像文件。 打开终端或命令提示符，进入到存放图像文件的目录。 运行以下命令来导入图像： docker load -i imagefile.tar 其中， imagefile.tar 是你想要导入的图像文件。 等待 Docker 加载图像文件。加载完成后，你将在终端中看到一系列的输出，显示导入的图像的详细信息。 现在，你可以使用 docker images 命令来查看已导入的图像列表。你应该能够看到刚才导入的图像。 现在，你可以使用已导入的图像来启动容器，进行开发或测试等相关工作。 通过按照上述步骤，你就可以将图像成功导入到 Docker 中，并开始使用它了。 ","date":"2023-10-31","objectID":"/silly-questions-related-to-docker--debian/:1:3","tags":["image","container","ssh"],"title":"silly questions related to docker \u0026 debian","uri":"/silly-questions-related-to-docker--debian/"},{"categories":null,"content":"1.4 how to rename an image in docker 如何在 Docker 中重命名镜像 要在 Docker 中重命名镜像，可以按照以下步骤操作： 首先，确保已经安装了 Docker 引擎，并且正在运行。 使用 docker images 命令查看当前可用的镜像列表。找到你想要重命名的镜像，并记下它的旧名称和标签。 打开终端或命令提示符，并使用以下命令来重命名镜像： docker tag old_image_name:old_tag new_image_name:new_tag 其中， old_image_name:old_tag 是当前镜像的旧名称和标签， new_image_name:new_tag 是你想要为镜像设定的新名称和标签。 运行以上命令后，Docker 将创建一个新的名称和标签的镜像副本，并保留原始镜像的副本。 使用 docker images 命令再次验证镜像列表。你应该能够看到已重命名的镜像。 如果你想彻底删除旧的镜像，可以使用 docker rmi old_image_name:old_tag 命令进行删除。 通过按照上述步骤，你可以在 Docker 中成功地为镜像进行重命名，并且可以继续使用新的名称和标签进行相关操作。 ","date":"2023-10-31","objectID":"/silly-questions-related-to-docker--debian/:1:4","tags":["image","container","ssh"],"title":"silly questions related to docker \u0026 debian","uri":"/silly-questions-related-to-docker--debian/"},{"categories":null,"content":"2 Debian ","date":"2023-10-31","objectID":"/silly-questions-related-to-docker--debian/:2:0","tags":["image","container","ssh"],"title":"silly questions related to docker \u0026 debian","uri":"/silly-questions-related-to-docker--debian/"},{"categories":null,"content":"2.1 I’m running a debian docker, and I can’t find ip addr command I’m sorry, but the ip addr command is not available by default in a minimal Debian Docker image. However, you can install the iproute2 package to get access to the ip command, which includes the ip addr functionality. Here’s how you can do it: Start your Debian Docker container: docker run -it debian Update the package repositories inside the container: apt update Install the iproute2 package: apt install -y iproute2 After the installation is complete, you should be able to use the ip command, including ip addr, to manage network addresses and interfaces within your Debian Docker container. Please note that you may need to have appropriate privileges (e.g., run the container with --privileged flag or as root) to install packages and execute network-related commands inside the Docker container. ","date":"2023-10-31","objectID":"/silly-questions-related-to-docker--debian/:2:1","tags":["image","container","ssh"],"title":"silly questions related to docker \u0026 debian","uri":"/silly-questions-related-to-docker--debian/"},{"categories":null,"content":"2.2 how to get sshd in debian docker To get SSH server (sshd) running inside a Debian Docker container, you can follow these steps: Start a new Debian Docker container and access the command prompt: docker run -it debian Update the package repositories and install the OpenSSH server package: apt update apt install -y openssh-server Once the installation is complete, start the SSH server: service ssh start By default, the SSH server will be configured to use port 22. If you want to use a different port, you need to modify the /etc/ssh/sshd_config file and change the Port directive accordingly. Now, you can exit the container by typing exit. Commit the changes made to the container and create a new image: docker commit CONTAINER_ID new_image_name Replace CONTAINER_ID with the ID of the running container, and new_image_name with the desired name for the new image. Now, you have an image with the SSH server installed. You can start a new container from this image, and SSH into it with the following command: docker run -d -p HOST_PORT:CONTAINER_PORT new_image_name Replace HOST_PORT with the port on your host machine to which you want to map the SSH port, and CONTAINER_PORT with the port to which the SSH server is listening inside the container (default is 22). You can now SSH into your container using the IP address or hostname of your host machine and the port you specified earlier: ssh username@host_ip -p HOST_PORT Replace username with your username, host_ip with the IP address or hostname of your host machine, and HOST_PORT with the port you chose in step 7. By following these steps, you can install and run SSH server inside a Debian Docker container, allowing remote access via SSH. ### how to search package with apt-get ","date":"2023-10-31","objectID":"/silly-questions-related-to-docker--debian/:2:2","tags":["image","container","ssh"],"title":"silly questions related to docker \u0026 debian","uri":"/silly-questions-related-to-docker--debian/"},{"categories":null,"content":"2.3 how to search packages in debian To search for a package using apt-get in a Debian-based distribution (such as Debian, Ubuntu, or Linux Mint), you can follow these steps: Open a terminal or command prompt on your system. Update the package repositories to ensure you have the latest package information: sudo apt-get update Use the apt-cache search command followed by the search term to search for packages. For example, to search for the text editor package, you can run: apt-cache search text editor The command will return a list of packages that match the search term, along with their descriptions. You can browse through the list to find the desired package. Once you have found the package you want to install, note down its exact name. To install the package, use the apt-get install command followed by the package name. For example, if you want to install the gedit text editor, you can run: sudo apt-get install gedit Replace gedit with the actual name of the package you want to install. Following these steps will allow you to search for and install packages using apt-get. It’s worth mentioning that you will need administrative privileges (sudo) to run apt-get commands. ","date":"2023-10-31","objectID":"/silly-questions-related-to-docker--debian/:2:3","tags":["image","container","ssh"],"title":"silly questions related to docker \u0026 debian","uri":"/silly-questions-related-to-docker--debian/"},{"categories":null,"content":" Table of Contents 1 Barriers: 协调进程的同步屏障 1.1 静态参与 2 TODO: Barriers API 3 TODO: how it is used in hash jon… 简单总结一下 PG 中进程同步用到的屏障： https://github.com/postgres/postgres/blob/master/src/backend/storage/ipc/barrier.c ","date":"2023-10-21","objectID":"/barriers-in-postgressql/:0:0","tags":["pg","ipc","barriers"],"title":"Barriers in PostgresSQL","uri":"/barriers-in-postgressql/"},{"categories":null,"content":"1 Barriers: 协调进程的同步屏障 来自维基百科[1]： “在并行计算中，屏障是一种同步方法。在源代码中，对于一组线程或进程而言，屏障意味着任何一个线程或进程必须在此处停止，并且在所有其他线程或进程到达该屏障之前无法继续进行。” 协调进程同步的屏障可以归纳为以下几点： 并发性：多个进程同时执行可能导致数据竞争和冲突，因此需要采取措施来确保数据的一致性和正确性。 同步需求不明确：不同的进程可能对同步的时间和顺序有不同的要求，导致难以找到一种通用的同步机制来满足所有进程的需求。 通信开销：在进程间进行同步需要进行通信，而通信本身会带来开销，包括延迟和带宽消耗。 死锁：在复杂的同步机制中，可能存在死锁的风险，即进程互相等待对方释放资源，从而导致系统无法继续执行。 跨平台兼容性：在跨平台开发中，不同操作系统或编程语言的同步机制可能不兼容，限制了进程间的同步和协作。 该屏障的实现允许静态参与和动态参与两种方式： 静态参与 参与者集合在一开始就确定（事先已知） 阶段号被内部使用，但是并不一定需要客户端代码访问它， 只有当声明的参与者数量达到屏障时，阶段才会前进， 客户端代码应始终能够确定计算的当前阶段。 动态参与 其中进程可以随时加入或离开 可以使用一个阶段号跟踪并行算法的进展情况， 当新参与者加入时，可能需要与多阶段算法的当前阶段同步 假设一个并行算法，它涉及到分开的计算阶段 A、B 和 C，每个阶段的输出在下一个阶段开始之前都是必需的。 ","date":"2023-10-21","objectID":"/barriers-in-postgressql/:1:0","tags":["pg","ipc","barriers"],"title":"Barriers in PostgresSQL","uri":"/barriers-in-postgressql/"},{"categories":null,"content":"1.1 静态参与 在初始化为 4 个参与者的静态屏障的情况下，每个参与者都在阶段 A 上工作，然后调用 BarrierArriveAndWait 进行等待，直到所有 4 个参与者到达该点。当 BarrierArriveAndWait 返回控制权时，每个参与者都可以在 B 上工作，以此类推。因为屏障知道要期望多少个参与者，所以计算的阶段不需要标签或数字，因为每个进程的程序计数器都暗示了当前阶段。即使某些进程开始运行阶段 A 较慢，其他参与者也在等待他们，并将耐心等待在屏障处。 代码可以写成如下形式： perform_a(); BarrierArriveAndWait(\u0026barrier, ...); perform_b(); BarrierArriveAndWait(\u0026barrier, ...); perform_c(); BarrierArriveAndWait(\u0026barrier, ...); If the number of participants is not known up front, then a dynamic barrier is needed and the number should be set to zero at initialization. New complications arise because the number necessarily changes over time as participants attach and detach, and therefore phases B, C or even the end of processing may be reached before any given participant has started running and attached. Therefore the client code must perform an initial test of the phase number after attaching, because it needs to find out which phase of the algorithm has been reached by any participants that are already attached in order to synchronize with that work. Once the program counter or some other representation of current progress is synchronized with the barrier’s phase, normal control flow can be used just as in the static case. Our example could be written using a switch statement with cases that fall-through, as follows: 如果事先不知道参与者的数量，那么就需要使用动态屏障，并在初始化时将数量设为零。由于参与者的附加和解除附加使数量随时间而变化，因此在某个给定的参与者开始运行和附加之前，可能会到达 B、C 阶段甚至处理结束。因此，客户端代码在附加后必须对阶段号进行初始测试，因为它需要找出已经附加的任何参与者所达到的算法阶段，以与该工作进行同步。一旦程序计数器或表示当前进度的其他表示与屏障的阶段进行了同步，就可以像静态情况下一样使用正常的控制流。我们的示例可以使用带有贯穿的 switch 语句来编写，如下所示： phase = BarrierAttach(\u0026barrier); switch (phase) { case PHASE_A: perform_a(); BarrierArriveAndWait(\u0026barrier, ...); case PHASE_B: perform_b(); BarrierArriveAndWait(\u0026barrier, ...); case PHASE_C: perform_c(); BarrierArriveAndWait(\u0026barrier, ...); } BarrierDetach(\u0026barrier); Static barriers behave similarly to POSIX’s pthread_barrier_t. Dynamic barriers behave similarly to Java’s java.util.concurrent.Phaser. 静态屏障的行为类似于 POSIX 的 pthread_barrier _t。动态屏障的行为类似于 Java 的 java.util.concurrent.Phaser 。 ","date":"2023-10-21","objectID":"/barriers-in-postgressql/:1:1","tags":["pg","ipc","barriers"],"title":"Barriers in PostgresSQL","uri":"/barriers-in-postgressql/"},{"categories":null,"content":"2 TODO: Barriers API ","date":"2023-10-21","objectID":"/barriers-in-postgressql/:2:0","tags":["pg","ipc","barriers"],"title":"Barriers in PostgresSQL","uri":"/barriers-in-postgressql/"},{"categories":null,"content":"3 TODO: how it is used in hash jon… ","date":"2023-10-21","objectID":"/barriers-in-postgressql/:3:0","tags":["pg","ipc","barriers"],"title":"Barriers in PostgresSQL","uri":"/barriers-in-postgressql/"},{"categories":null,"content":" Table of Contents 1 rm 不能安全擦除 2 shred 3 wipe 4 dd 本文为摘录(或转载)，侵删，原文为： https://mp.weixin.qq.com/s/w-pMU3_TD3dEPoW-XEde-A https://mp.weixin.qq.com/s/w-pMU3_TD3dEPoW-XEde-A ","date":"2023-10-20","objectID":"/w-pmu3_td3depow-xede-a/:0:0","tags":["disk","erase"],"title":"Linux 中如何安全地抹去磁盘数据","uri":"/w-pmu3_td3depow-xede-a/"},{"categories":null,"content":"1 rm 不能安全擦除 因为 rm 命令或者文件管理器删除文件只是删除指向文件系统的指针（inode），所以原始数据仍可以使用 在 Linux 中，文件由指针部分（inode）和数据部分（data）组成 文件被删除的时候，文件对应的 inode 就被删除掉了，而文件的数据部分在 inode 被清除掉之后，就会被覆盖并写入新的内容 ","date":"2023-10-20","objectID":"/w-pmu3_td3depow-xede-a/:1:0","tags":["disk","erase"],"title":"Linux 中如何安全地抹去磁盘数据","uri":"/w-pmu3_td3depow-xede-a/"},{"categories":null,"content":"2 shred shred 功能是重复覆盖文件，只能使用专门的硬件并且极其困难地恢复数据，所以它经常被用来安全地擦除数据 shred 是 Linux 软件包 coreutils 的一部分，所以一般情况下是默认安装的 默认情况下，shred 会执行三次，在执行的时候，它会将伪随机数据写入设备。 例如我们要擦除 dev/sdb 设备 前面我们说到，shred 会执行三次。但是执行三次所需的时间太长了，我们可以通过 -n 来设置执行次数 我们还可以添加更多选项来提高从磁盘删除数据的可靠性 –random-source=/dev/urandom ：表示指定使用随机生成的数据覆盖磁盘。Linux 的特殊文件 /dev/urandom 为内核的随机数生成器提供了一个接口 -z /dev/sdb：用 0 覆盖到目前为止的所有内容 ","date":"2023-10-20","objectID":"/w-pmu3_td3depow-xede-a/:2:0","tags":["disk","erase"],"title":"Linux 中如何安全地抹去磁盘数据","uri":"/w-pmu3_td3depow-xede-a/"},{"categories":null,"content":"3 wipe 看这个命令的名字就可以知道，这个命令用于擦除（wipe）磁盘中的数据 wipe 命令会重写磁盘扇区并刷新缓存，这使得想要恢复数据是一件极其困难或者说不可能的事 Linux 默认没有这个工具，我们需要先安装 这个命令很简单，后面只需加上磁盘路径即可 ps：现在 wipe 这个工具好像安装不了了（不知道是不是弃用了） ","date":"2023-10-20","objectID":"/w-pmu3_td3depow-xede-a/:3:0","tags":["disk","erase"],"title":"Linux 中如何安全地抹去磁盘数据","uri":"/w-pmu3_td3depow-xede-a/"},{"categories":null,"content":"4 dd dd 可从标准输入或文件中读取数据，根据指定的格式来转换数据，再输出到文件、设备或标准输出 dd 命令是 Linux 中另一种常用的擦除磁盘的方法，尽管该命令并不像 shred 和 wipe 那样明确地用于从磁盘中擦除数据，但它是 Linux 用户广泛使用的方法 例如下面的命令可以安全可靠地擦除 /dev/sdb 设备中的数据 if=/dev/urandom ：输入文件，我们用 /dev/urandom 生成随机数据 of=/dev/sdb ：输出文件，表示要擦除的磁盘 bs ：块大小（以字节为单位） 当显示 “No space left on device”时，表示擦除成功完成 或者我们用 zero 字符串对磁盘进行覆盖，而不是生成随机数据 参考文章：https://linuxiac.com/best-ways-to-securely-erase-disk-in-linux/ ","date":"2023-10-20","objectID":"/w-pmu3_td3depow-xede-a/:4:0","tags":["disk","erase"],"title":"Linux 中如何安全地抹去磁盘数据","uri":"/w-pmu3_td3depow-xede-a/"},{"categories":null,"content":" Table of Contents 1 语法 1.1 选项 1.2 注意事项 1.3 退出状态 2 示例 2.1 使用进程替换 (process substitution) 的 mapfile 3 Process substitution 本文为摘录(或转载)，侵删，原文为： https://www.computerhope.com/unix/bash/mapfile.htm ","date":"2023-10-19","objectID":"/mapfile/:0:0","tags":["bash","mapfile"],"title":"Bash Mapfile Builtin Command Help and Examples","uri":"/mapfile/"},{"categories":null,"content":"1 语法 mapfile [-n count] [-O origin] [-s count] [-t] [-u fd] [-C callback [-c quantum]] [array] ","date":"2023-10-19","objectID":"/mapfile/:1:0","tags":["bash","mapfile"],"title":"Bash Mapfile Builtin Command Help and Examples","uri":"/mapfile/"},{"categories":null,"content":"1.1 选项 mapfile 内建命令接受以下选项： -n count 读取最多 count 行。如果 count 为零，则复制所有可用的行。 -O origin 从索引号 origin 开始将行写入数组 array。默认值为零。 -s count 在写入数组之前丢弃 count 行。 -t 如果任何行以换行符结尾，则去除换行符。 -u fd 从文件描述符 fd 读取行，而不是标准输入。 -C callback 每次读取量子行时执行/评估一个函数/表达式 callback。默认量子值为 1，除非使用-c 另行指定。 -c quantum 指定函数/表达式 callback 在指定了-C 时执行/评估的行数量子。 array 要写入行的数组变量的名称。如果省略了 array，则默认变量 MAPFILE 是目标。 ","date":"2023-10-19","objectID":"/mapfile/:1:1","tags":["bash","mapfile"],"title":"Bash Mapfile Builtin Command Help and Examples","uri":"/mapfile/"},{"categories":null,"content":"1.2 注意事项 命令名称 readarray 可以作为命令名称 mapfile 的别名使用，其操作没有任何差异。 如果指定了-u 选项，mapfile 将从文件描述符 fd 而不是标准输入中读取。 如果未指定 array，则默认变量 MAPFILE 将用作目标数组变量。 mapfile 命令不是非常可移植的。也就是说，如果你希望确保脚本可以在多种系统上运行，不建议使用 mapfile。它主要提供方便。相同的功能可以使用 read 循环实现，尽管通常 mapfile 的性能更好。 read 还可以将一个字符串转换成数组： read -a ","date":"2023-10-19","objectID":"/mapfile/:1:2","tags":["bash","mapfile"],"title":"Bash Mapfile Builtin Command Help and Examples","uri":"/mapfile/"},{"categories":null,"content":"1.3 退出状态 mapfile 命令返回 0 表示成功，或者 1 表示出现任何问题，例如提供了无效选项，目标变量是只读的或不是数组。 ","date":"2023-10-19","objectID":"/mapfile/:1:3","tags":["bash","mapfile"],"title":"Bash Mapfile Builtin Command Help and Examples","uri":"/mapfile/"},{"categories":null,"content":"2 示例 mapfile 命令逐行读取输入，并将每行放入数组变量中。我们提供多行输入。 我们可以使用 printf 来实现。这是一种简单的打印带有换行符的文本的方法。 在 printf 的格式字符串中，我们可以包含\"\\n\"（后面紧跟小写字母 n 的反斜杠），以创建换行符。 (\"\\n\"是一个元字符，是表示另一个字符的字符序列，无法直接输入，例如回车键。有关完整的 bash 元字符列表，请参见 bash 引用。) 这个 printf 命令打印三行文本： printf \"Line 1\\nLine 2\\nLine 3\\n\" Line 1 Line 2 Line 3 我们想使用 mapfile 将每行放入数组的一个元素中。 默认情况下，mapfile 从标准输入读取数据，所以你可能会尝试像这样将 printf 的输出通过管道传递给 mapfile： printf \"Line 1\\nLine 2\\nLine 3\\n\" | mapfile 你期望默认的数组变量 MAPFILE 包含这些行的值。但是如果你检查 MAPFILE 的值： echo \"${MAPFILE[@]}\" [一个空行] 变量是空的。为什么呢？ 管道中的每个命令都在一个子 shell 中执行: 一个作为子进程执行的 bash 实例。每个子 shell 都有自己的环境和词法作用域 - 构成管道中每个子 shell 环境的变量不会传递到其他子 shell 中。换句话说，一个管道中的元素之间没有共享环境副作用。在上面的例子中，mapfile 正常工作，并设置了 MAPFILE 的值，但是当命令的子 shell 终止时，变量 MAPFILE 消失了。 你可以在一个包含 mapfile 命令的子 shell 中输出 MAPFILE 的值来验证这一点，方法是将两者都括在括号中： printf \"Line 1\\nLine 2\\nLine 3\\n\" | (mapfile; echo \"${MAPFILE[@]}\") Line 1 Line 2 Line 3 在上述命令中，echo 打印数组变量 MAPFILE 的所有元素，以空格分隔。由于数据中的换行符，空格出现在第 2 行和第 3 行的开头。我们用括号显式地创建了子 shell，以便保留 MAPFILE 的值足够长的时间，以便我们看到这些值。 我们可以通过使用 -t 来去除换行符来修复换行符： printf \"Line 1\\nLine 2\\nLine 3\\n\" | (mapfile -t; echo \"${MAPFILE[@]}\") Line 1 Line 2 Line 3 （如果我们使用 printf，我们可以在输出中恢复换行符 - 我们将在后续示例中这样做。） 所以，mapfile 是有效的，但是数组变量对于父 shell 不可访问。然而，通常情况下，你希望 MAPFILE 变量在后续的命令中持续存在。你可以通过进程替换来实现这一点。 ","date":"2023-10-19","objectID":"/mapfile/:2:0","tags":["bash","mapfile"],"title":"Bash Mapfile Builtin Command Help and Examples","uri":"/mapfile/"},{"categories":null,"content":"2.1 使用进程替换 (process substitution) 的 mapfile 通过进程替换，我们可以将输出重定向到 mapfile，而不使用管道。 mapfile -t \u003c \u003c(printf \"Line 1\\nLine 2\\nLine 3\") 让我们分别解释一下这个命令的各个部分： mapfile -t : Mapfile 从标准输入获取输入，并从每行的末尾删除换行符(-t)。这通常是你想要的：仅将行的文本存储在数组元素中，换行符被丢弃。 \u003c : 第一个\u003c是一个重定向字符。它期望后面跟着一个文件名或文件描述符。该文件的内容将被重定向到前一个命令的标准输入。 \u003c( ... ) : 这些字符表示进程替换，它返回一个文件描述符。括号内的命令被执行，它们的输出被分配给这个文件描述符。在任何 bash 命令中，你可以像文件名一样使用进程替换。 当你运行整个命令时，mapfile 会安静地读取我们的三行文本，并将每一行放入默认数组变量 MAPFILE 的单独元素中。 我们可以使用 printf 来打印数组的元素来验证这一点。 printf \"%s\" \"${MAPFILE[@]}\" 第一个参数\"%s\"是 printf 的格式字符串。第二个参数\"${MAPFILE[@]}“由 bash 展开。数组 MAPFILE 的所有元素(”@\")被展开为单独的参数。（有关更多信息，请参见：在 bash 中引用数组元素。） Line 1Line2Line 3 如你所见，我们的三行文本被连续打印出来。这是因为我们用-t 删除了换行符，并且 printf 默认不输出换行符。 要指定 printf 在每行之后打印一个换行符，可以在格式字符串中使用\\n： printf \"%s\\n\" \"${MAPFILE[@]}\" Line 1 Line 2 Line 3 要访问数组的单个元素，请用索引数字替换@。编号是从零开始的，所以 0 是第一个元素的索引，1是第二个元素的索引，依此类推： printf \"%s\\n\" \"${MAPFILE[0]}\" Line 1 printf \"%s\\n\" \"${MAPFILE[2]}\" Line 3 ","date":"2023-10-19","objectID":"/mapfile/:2:1","tags":["bash","mapfile"],"title":"Bash Mapfile Builtin Command Help and Examples","uri":"/mapfile/"},{"categories":null,"content":"3 Process substitution Process substitution is supported on systems that support named pipes (FIFOs) or the /dev/fd method of naming open files. It takes the form of \u003c(list) or \u003e(list). The process list is run with its input or output connected to a FIFO or some file in /dev/fd. The name of this file is passed as an argument to the current command as the result of the expansion. If the \u003e(list) form is used, writing to the file provides input for list. If the \u003c(list) form is used, the file passed as an argument should be read to obtain the output of list. When available, process substitution is performed simultaneously with parameter and variable expansion, command substitution, and arithmetic expansion. 进程替换在支持命名管道（FIFOs）或 /dev/fd 命名打开文件的系统上得到支持。 它具有 \u003c(list) 或 \u003e(list) 的形式。 进程列表与其输入或输出连接到 FIFO 或/dev/fd 中的某个文件，并作为扩展的结果将此文件的名称作为参数传递给当前命令。 如果使用了 \u003e(list) 形式，则写入该文件提供了 list 的输入。 如果使用了 \u003c(list) 形式，则应该读取作为参数传递的文件来获取 list 的输出。 如果可用，进程替换将与参数和变量扩展、命令替换和算术扩展同时进行。 ","date":"2023-10-19","objectID":"/mapfile/:3:0","tags":["bash","mapfile"],"title":"Bash Mapfile Builtin Command Help and Examples","uri":"/mapfile/"},{"categories":null,"content":" To list untracked files git ls-files --others --exclude-standard If you need to pipe the output to xargs, it is wise to mind white spaces using git ls-files -z and xargs -0: git ls-files -z -o --exclude-standard | xargs -0 git add Nice alias for adding untracked files: au = !git add $(git ls-files -o --exclude-standard) Delete untracked files: git clean -dfx ","date":"2023-10-19","objectID":"/git-tips/:0:0","tags":["clean","untracked"],"title":"git tips","uri":"/git-tips/"},{"categories":null,"content":" Table of Contents 1 String View (C++17) SVG Image 1.1 string_view vs const string \u0026 2 Span (C++20) 3 Range Views (C++20) 4 MD Span (C++23) 5 Comparing Spans to Range Views 6 Summary 本文为摘录(或转载)，侵删，原文为： https://www.cppstories.com/2023/four-views-in-cpp23/ 在本博客文章中，我们将探讨现代 C++中引入的几种不同的视图/引用类型。第一种是 C++17 中新增的 string_view 。 C++20 引入了 std::span 和 ranges 视图。最后新增的是来自 C++23 的 std::mdspan 。 ","date":"2023-10-10","objectID":"/four-views-in-cpp23/:0:0","tags":["views","cpp"],"title":"Spans, string_view, and Ranges - Four View types (C++17 to C++23) - C++ Stories","uri":"/four-views-in-cpp23/"},{"categories":null,"content":"1 String View (C++17) SVG Image std::string_view 是一个指向字符串的非拥有引用。 提供了一种面向对象的方式来表示字符串和子字符串， 不需要复制或分配 std::string 带来的开销。 特别适用于需要临时视图的场景，大大提高了字符串处理代码的性能和表达能力。 视图对象不允许修改原始字符串中的字符。 以下是一个基本的示例： #include \u003cformat\u003e #include \u003ciostream\u003e #include \u003cstring_view\u003e void find_word(std::string_view text, std::string_view word) { size_t pos = text.find(word); if (pos != std::string_view::npos) std::cout \u003c\u003c std::format(\"单词在位置{}处找到\\n\", pos); else std::cout \u003c\u003c \"单词未找到\\n\"; } int main() { std::string str = \"The quick brown fox jumps over the lazy dog\"; std::string_view sv = str; find_word(sv, \"quick\"); find_word(sv, \"lazy\"); find_word(sv, \"hello\"); } ","date":"2023-10-10","objectID":"/four-views-in-cpp23/:1:0","tags":["views","cpp"],"title":"Spans, string_view, and Ranges - Four View types (C++17 to C++23) - C++ Stories","uri":"/four-views-in-cpp23/"},{"categories":null,"content":"1.1 string_view vs const string \u0026 std::string const\u0026 requires the data to be in a std::string, and not a raw C array, a char const* returned by a C API, a std::vector\u003cchar\u003e produced by some deserialization engine, etc. The avoided format conversion avoids copying bytes, and (if the string is longer than the SBO¹ for the particular std::string implementation) avoids a memory allocation. std::string const\u0026 要求数据在 std::string 中，而不是在原始的 C 数组，由 C API 返回的 char const*=，由某些反序列化引擎产生的 =std::vector\u003cchar\u003e 等中。避免格式转换可以避免字节的复制，并且（如果字符串比特定的 std::string 实现的 SBO¹更长）还可以避免内存分配。 ","date":"2023-10-10","objectID":"/four-views-in-cpp23/:1:1","tags":["views","cpp"],"title":"Spans, string_view, and Ranges - Four View types (C++17 to C++23) - C++ Stories","uri":"/four-views-in-cpp23/"},{"categories":null,"content":"2 Span (C++20) C++20 将 string_view 进一步通过 std::span 类型实现更通用。它作为对一系列连续对象的非拥有、轻量级引用。它在需要处理数组或向量的一部分而无需拥有数据所有权的函数中特别有用。 #include \u003ciostream\u003e #include \u003cspan\u003e #include \u003cvector\u003e void print(std::span\u003cconst int\u003e sp) { for (int i : sp) std::cout \u003c\u003c i \u003c\u003c \" \"; std::cout \u003c\u003c '\\n'; } int main() { int arr[] = {1, 2, 3, 4, 5}; std::span sp(arr, 5); std::vector nums { 10, 11, 12, 13 }; print(sp); print(nums); } ","date":"2023-10-10","objectID":"/four-views-in-cpp23/:2:0","tags":["views","cpp"],"title":"Spans, string_view, and Ranges - Four View types (C++17 to C++23) - C++ Stories","uri":"/four-views-in-cpp23/"},{"categories":null,"content":"3 Range Views (C++20) C++20 中与 std::span 同时引入的 Range Views（区间视图）为处理数据范围提供了高级可组合的抽象。Range Views 实现了惰性求值 (lazy evaluation)，这允许操作（如过滤、转换或连接等）以可读、声明式的方式表示，而不会立即求值，通常会提高性能表现。 #include \u003ciostream\u003e #include \u003cranges\u003e #include \u003cvector\u003e int main() { std::vector nums = {1, 2, 3, 4, 5, 6}; auto even_nums = nums | std::views::filter([](int n) { return n % 2 == 0; }); for (int n : even_nums) std::cout \u003c\u003c n \u003c\u003c \" \"; } ","date":"2023-10-10","objectID":"/four-views-in-cpp23/:3:0","tags":["views","cpp"],"title":"Spans, string_view, and Ranges - Four View types (C++17 to C++23) - C++ Stories","uri":"/four-views-in-cpp23/"},{"categories":null,"content":"4 MD Span (C++23) C++23 中的 std::mdspan 类型是一个多维度的 span。它将 span 的概念扩展到多维数据，这在数值和科学计算中非常有价值。在这个 C++标准中，我们还对[]运算符进行了更改，我们可以编写 mat[i,j]来访问其元素（请参见多维子脚本运算符-P2128 中的更改）。 下面，您可以找到一个简单的 mdspan 示例，用于测试给定矩阵是否是方形和单位矩阵： #include \u003cvector\u003e #include \u003chttps://raw.githubusercontent.com/kokkos/mdspan/single-header/mdspan.hpp\u003e #include \u003calgorithm\u003e #include \u003ciostream\u003e int isIdentity(std::mdspan\u003cint, std::extents\u003cint, std::dynamic_extent, std::dynamic_extent\u003e\u003e matrix) { int rows = matrix.extent(0); int cols = matrix.extent(1); if (rows != cols) return false; for (int i = 0; i \u003c rows; ++i) if (matrix[i, i] != 1) return false; return true; } int main() { std::vector\u003cint\u003e matrix_data = {1, 0, 0, 0, 1, 0, 0, 0, 1}; std::mdspan matrix = std::mdspan(matrix_data.data(), 3, 3); std::cout \u003c\u003c isIdentity(matrix) \u003c\u003c '\\n'; std::mdspan matrix2 = std::mdspan(matrix_data.data(), 3, 2); std::cout \u003c\u003c isIdentity(matrix2) \u003c\u003c '\\n'; } ","date":"2023-10-10","objectID":"/four-views-in-cpp23/:4:0","tags":["views","cpp"],"title":"Spans, string_view, and Ranges - Four View types (C++17 to C++23) - C++ Stories","uri":"/four-views-in-cpp23/"},{"categories":null,"content":"5 Comparing Spans to Range Views 尽管 std::span 和 Range Views 都是用于操作序列的现代机制，但它们有着不同的目的。 std::span 旨在提供对连续对象序列的直接、有限和安全的访问。它简单而又强大，适用于需要访问数据块但不需要所有权语义的功能。 Range Views 旨在操作和组合序列。它们不要求数据是连续的，允许在范围上进行延迟、串联的操作，这可以导致更富有表现力的代码和潜在的更好性能。 实质上，std::span 是一种用于安全的、连续数据访问的简单工具，而 Range Views 则提供了一种更高级的、功能性的容器操作方法。 ","date":"2023-10-10","objectID":"/four-views-in-cpp23/:5:0","tags":["views","cpp"],"title":"Spans, string_view, and Ranges - Four View types (C++17 to C++23) - C++ Stories","uri":"/four-views-in-cpp23/"},{"categories":null,"content":"6 Summary 在这篇短文中，我们回顾了最近的 C++ 修订，并了解了视图类型背后的一些基础知识。在 C++ 中，我们有三种不同的引用/视图对象类型： C++17 引入了 string_view ，用于高效的字符串处理，只能进行只读访问， C++20 中的 std::span 允许处理数据序列并公开读或写访问权限， C++23 中的 std::mdspan 是 span 的多维版本。 此外，作为最后一种类型，我提到了范围视图，它是对集合的高级抽象。虽然其他三种需要连续序列，但范围视图更加灵活。 下面是一个简单的表格，总结了上述内容： (*) 尽管你可以通过视图进行写入，但这可能不是最佳方法。 (*) mdspan 还提供了一些关于内存布局的额外选项，并且还可以使用步长参数。 在这个文本中，我还展示了一些基本的示例，但请记住这只是冰山一角，并且请继续关注更多关于这些方便类型的文章。 https://www.cppstories.com/2023/four-views-in-cpp23/ ","date":"2023-10-10","objectID":"/four-views-in-cpp23/:6:0","tags":["views","cpp"],"title":"Spans, string_view, and Ranges - Four View types (C++17 to C++23) - C++ Stories","uri":"/four-views-in-cpp23/"},{"categories":null,"content":"十一哪里也去不了，躲在家里重新刷一遍权力的游戏 （Game of Throne, GOT），今天看了第一季。很久没有写过随笔之类的了，今天顺手写下点东西，发泄感慨和牢骚。 以前看剧，总是觉得离现实很远；看了再多的剧集，再多的书，都觉得脱离实际。而现在看剧，哪怕是是 GOT 这样的魔幻之作，都会深有感触。这，是两年煎熬时光带给我的、能让我更好、更深刻的感受这个世界。 在 Ned 被抓之后，八爪蜘蛛瓦里斯前往探望，对其说：我在剧院中长大，从小跟随到处表演；而今在朝堂之上，仍然是在表演。其实表演的不止是他，表演的舞台也不止是在高高的朝堂。朝堂之上的表演更加精妙，危险： in the game of throne, you win, or you die. 普通的表演危险度相对低一些，不至于输了就挂，但是表演依旧还是存在的，而且为数不少。 像我这样的、脑筋不怎么灵光、不会见人说人话、见鬼说鬼话的小人物，还是谨言慎行，尽量尝试远离是非吧 （只是这是非不见得会远离我。。。） 人这一生，难免遇到点什么事，这烂人烂事有时确实是躲不开，只能是但尽人事，各凭天命了。 ","date":"2023-10-01","objectID":"/%E9%9A%8F%E7%AC%94-got-s1/:0:0","tags":["GOT"],"title":"随笔： GOT S1","uri":"/%E9%9A%8F%E7%AC%94-got-s1/"},{"categories":null,"content":" Table of Contents 1 Syscall Table hijacking — The good old way, 系统调用表劫持 2 sys_close — The brute force method 3 VFS hooking 4 The ftrace helper method 本文为摘录(或转载)，侵删，原文为： https://foxtrot-sq.medium.com/linux-rootkits-multiple-ways-to-hook-syscall-s-7001cc02a1e6 我们所见到的大多数恶意软件攻击中使用的 rootkit 都是开源的，其行为几乎与在系统中运行的正常进程相同（隐藏和挂钩）。从行为上来看，它们与正常进程几乎没有任何区别。在本文中，我们将探讨一些现有的方法，根据不同的 Linux 内核版本来挂钩系统调用。 我们将使用多种方式进行研究： Syscall 表劫持 – 传统的方法 Sys_close —— 暴力方法 VFS 挂钩 ftrace 助手方法 ","date":"2023-09-21","objectID":"/linux-rootkits-multiple-ways-to-hook-syscall-s-7001cc02a1e6/:0:0","tags":["linux","syscall","","hook"],"title":"Linux Rootkits — Multiple ways to hook syscall(s)","uri":"/linux-rootkits-multiple-ways-to-hook-syscall-s-7001cc02a1e6/"},{"categories":null,"content":"1 Syscall Table hijacking — The good old way, 系统调用表劫持 我们将讨论的第一种 hook syscall 的方法是通过 syscall 表劫持。想要劫持 syscall 表并从中 hook syscall，需要对表具有写访问权限。 syscall table 是 syscall ID 和 其实现的内核地址 之间的映射。为了修改表格，我们必须从只读获得写入权限。 这可以通过处理器中的控制寄存器来实现，该控制寄存器决定 CPU 的行为。要修改 syscall 表， cr0 寄存器的 WP 位被设置为 0 ，我们只需将其更改为 1 即可。 现在，我们可以轻松修改系统调用表。在 Linux 系统中， /proc/kallsyms 中包含了内核系统调用表（或 sys_call_table）的映射。 为了通过代码找到表格，我们将使用 syscall kallsyms_lookup_name() ，该函数在 kallsyms.h 中定义，用于获取函数的地址。在 Linux 内核 4.4 版本中，kallsyms_lookup_name()调用被导出，我们可以使用它来定位 sys_call_table 的地址: 一旦系统调用表的地址被确定，我们可以像下图所示轻松修改表中的条目。 使用 kallsyms_lookup_name 来查找 sys_call_table(): Inside my_read function 让我们把 Rootkit 加载进系统： Rootkit 成功地被加载了。因为我们勾住了 read()函数，所以我们得到了大量的日志记录。 ","date":"2023-09-21","objectID":"/linux-rootkits-multiple-ways-to-hook-syscall-s-7001cc02a1e6/:1:0","tags":["linux","syscall","","hook"],"title":"Linux Rootkits — Multiple ways to hook syscall(s)","uri":"/linux-rootkits-multiple-ways-to-hook-syscall-s-7001cc02a1e6/"},{"categories":null,"content":"2 sys_close — The brute force method 该方法其实还是在获取 syscall_table sys_close() 系统调用在旧版本的内核中（我们这里使用的是 4.4 版本）被导出，我们可以通过它来扫描内核内存中的 sys_call_table() 的地址。这是一种通过导出的函数查找系统调用表地址的简单方法。下面的代码片段展示了我们尝试定位 sys_call_table 的扫描代码。 上面的代码片段非常简单。首先我们只是将 sys_close 的地址存储在 offset 变量中，然后我们只是扫描内存以匹配表中的//NR_close 条目与 sys_close()。一旦匹配，我们就返回 sys_call_table 的地址（即上面的 sct）。 现在，我们只需要用我们自己的调用替换原来的 read()系统调用。 这个钩子函数会打印出下面的信息: 编译完成后，我们加载了 rootkit，可以看到 hooking 成功了。 ","date":"2023-09-21","objectID":"/linux-rootkits-multiple-ways-to-hook-syscall-s-7001cc02a1e6/:2:0","tags":["linux","syscall","","hook"],"title":"Linux Rootkits — Multiple ways to hook syscall(s)","uri":"/linux-rootkits-multiple-ways-to-hook-syscall-s-7001cc02a1e6/"},{"categories":null,"content":"3 VFS hooking 我在阅读这篇报告时听说了这种技术。 Linux 中的虚拟文件系统（VFS）是一个抽象层，它类似于胶水，使诸如 open()、read() 和 write() 等系统调用无论文件系统或底层物理介质的差异都能正常工作。通过 VFS，一个内核可以挂载多种不同类型的文件系统。 VFS 包含 4 个主要对象： 超级块对象（存储在磁盘上的特殊扇区） inode 对象 dentry 对象 文件对象 下面的图片展示了 Linux 中 VFS 实现的高层概述： 每当一个进程在系统中启动时，它有各种打开文件的文件对象。每个文件对象结构都包含一个称为文件路径（类型为 struct path）的字段，其中包含 dentry。 可以将 dentry 简单地理解为像/var/www/html 这样的路径。在路径中，var、www、html 和/都是 dentry 对象。这些对象是由 VFS 动态创建的。 dentry 对象本身是一个结构体，其中包含了关联的 inode 信息（比如以上路径中的 var）。 inode 对象代表内核操作文件或目录所需的所有信息。 inode 操作结构（inode 对象结构内的字段）包含各种操作，如创建、symlink、mkdir 等。 我们感兴趣的字段是查找。我们将钩住这个字段/调用，下图显示了查找钩子和替换代码片段。我们从修改 cr0 寄存器开始，以便替换我们的值。我们选择的目标是/proc，所以如果任何进程通过 lookup()在/proc 中查找任何文件，我们的函数都会被调用。 在上面的图像中：- fp 是/proc 的文件对象。- fp 文件对象结构包含 f_path，该结构是一个 dentry 对象。- dentry 结构包含指向 fp 对象 inode 结构的 d_inode。- inode 结构内部的 i_op 是实际的操作结构，其中包含操作如创建、 symlink、mkdir、查找。内核使用这个结构来操作文件和目录。 ","date":"2023-09-21","objectID":"/linux-rootkits-multiple-ways-to-hook-syscall-s-7001cc02a1e6/:3:0","tags":["linux","syscall","","hook"],"title":"Linux Rootkits — Multiple ways to hook syscall(s)","uri":"/linux-rootkits-multiple-ways-to-hook-syscall-s-7001cc02a1e6/"},{"categories":null,"content":"4 The ftrace helper method 这是一种相当新的技术，适用于最新的内核（Linux 内核 \u003e=5.7）。我们知道，在较新的内核中不再导出 kallsyms_lookup_name。使用 kallsyms_lookup_name，我们在早期 rootkit 中定位了 sys_call_table()。 ftrace 帮助库使用 kprobe 通过 kallsyms_lookup_name 来解析符号地址。这样，我们就可以利用 ftrace 库来钩住 syscall。该技术在此处有更详细的解释。我们将只查看来自 ftrace 库的某些结构的代码片段和工作原理。 我们可以看到下面的示例，使用 kprobe 解决 kallsyms_lookup_name()的使用。 在上面的图像中，我们要挂钩（我们的情况中是 mkdir）的名称是 syscall，hook_mkdir 是我们的挂钩函数，而 orig_mkdir 是我们要保存 mkdir 的位置（供以后使用）。 使用 kallsysms_lookup_name 来解析 mkdir()地址。 解析完成 mkdir()之后，其地址被保存在 ftrace_hook 结构体的 address 字段中。ftrace_hook 结必要的修改。我们将在以后的博客中介绍监视功能。构体中另一个重要的字段是 ops 字段。在 ftrace_hook 结构体中，ops 结构体包含.func 字段，可以在我们的目标 syscall（sys_mkdir）被调用时将其分配给回调函数。因此，我们分配.func 与 fh_ftrace_thunk（我们的回调函数）如下所示： ftrace 是 Linux 中非常有用的工具，我们不仅可以钩取系统调用，还可以监视并阻止对我们文件进行某些不必要的修改。我们在以后的博客中将介绍其监视功能。 ","date":"2023-09-21","objectID":"/linux-rootkits-multiple-ways-to-hook-syscall-s-7001cc02a1e6/:4:0","tags":["linux","syscall","","hook"],"title":"Linux Rootkits — Multiple ways to hook syscall(s)","uri":"/linux-rootkits-multiple-ways-to-hook-syscall-s-7001cc02a1e6/"},{"categories":null,"content":" Table of Contents 1 Introduction 2 BACKGROUND 2.1 Related Work 2.2 Light-Weight Database Compression 本文为摘录(或转载)，侵删，原文为： attachments/pdf/6/willhalm-vldb2009.pdf 现代服务器上的巨大系统内存可用性引起了对主内存数据库引擎的热情。数据仓库系统中，高度压缩的列式数据结构很突出。 为了跟踪数据量和系统负载，许多系统采用高度分布式的无共享方式。所有系统的基本原则是对一个或多个压缩列进行全表扫描。最近的研究提出了不同的技术以加快表扫描速度，如智能压缩、使用额外的硬件如图形卡或 FPGA。 本文展示了利用标准超标量处理器中的嵌入式向量处理单元（VPUs）可以将主内存全表扫描性能提高数倍。 这一结果实现了不改变硬件架构，因此不增加额外功耗。此外，由于片上 VPUs 直接访问系统的 RAM，标准主内存数据库引擎在使用新的 SIMD-扫描方法时无需额外昂贵的拷贝操作。因此， 我们建议将该扫描方法用作列式主内存存储的标准扫描操作符 ","date":"2023-09-12","objectID":"/willhalm-vldb2009/:0:0","tags":["simd",""],"title":"SIMD-Scan: Ultra Fast in-Memory Table Scan using onChip Vector Processing Units","uri":"/willhalm-vldb2009/"},{"categories":null,"content":"1 Introduction 为了节省内存并提高访问速度，内存数据结构会被高度压缩。 这是通过使用不同变种的轻量级压缩（LWC）技术实现的，例如游程编码或多版本固定长度编码。 越来越复杂的压缩算法被使用，全表扫描操作从 I/O 限制转变为 CPU 限制。 Vectorized Value Decompression: introduce a fast SIMD decompression approach for LWC Numebr Compression (LWC-NC) Vectorized Predicate Handling We present a new concept and implementation of SIMD predicate search. ","date":"2023-09-12","objectID":"/willhalm-vldb2009/:1:0","tags":["simd",""],"title":"SIMD-Scan: Ultra Fast in-Memory Table Scan using onChip Vector Processing Units","uri":"/willhalm-vldb2009/"},{"categories":null,"content":"2 BACKGROUND ","date":"2023-09-12","objectID":"/willhalm-vldb2009/:2:0","tags":["simd",""],"title":"SIMD-Scan: Ultra Fast in-Memory Table Scan using onChip Vector Processing Units","uri":"/willhalm-vldb2009/"},{"categories":null,"content":"2.1 Related Work ","date":"2023-09-12","objectID":"/willhalm-vldb2009/:2:1","tags":["simd",""],"title":"SIMD-Scan: Ultra Fast in-Memory Table Scan using onChip Vector Processing Units","uri":"/willhalm-vldb2009/"},{"categories":null,"content":"2.2 Light-Weight Database Compression ","date":"2023-09-12","objectID":"/willhalm-vldb2009/:2:2","tags":["simd",""],"title":"SIMD-Scan: Ultra Fast in-Memory Table Scan using onChip Vector Processing Units","uri":"/willhalm-vldb2009/"},{"categories":null,"content":" Table of Contents 1 Linux 中的 TTY 和 PTS 是什么？ 2 如何在 Linux 中终止被卡住/不需要的用户会话 2.1 Terminate User Session by TTY 2.2 按进程 ID 终止用户会话 2.3 Conclusion 本文为摘录(或转载)，侵删，原文为： https://linuxiac.com/how-to-terminate-user-session-in-linux/ ","date":"2023-09-08","objectID":"/how-to-terminate-stuck-or-unwanted-user-sessions-in-linux/:0:0","tags":["linux","tty","pts","terminate"],"title":"How to Terminate Stuck or Unwanted User Sessions in Linux","uri":"/how-to-terminate-stuck-or-unwanted-user-sessions-in-linux/"},{"categories":null,"content":"1 Linux 中的 TTY 和 PTS 是什么？ 在 Linux 中，“PTS\"和\"TTY\"都指不同的终端设备，用于用户与操作系统之间的通信。它们作为输入命令和从系统接收输出的接口。 TTY (Teletype, 电传打字机) “TTY\"最初是指电传打字机，一种类似打字机的设备，用于计算机早期的输入和输出。 在现代 Linux 系统中，TTY 代表物理或虚拟控制台，用户可以直接与系统交互。 PTS（Pseudo-Terminal Slave, 伪终端从属） PTS 代表伪终端从属。 它是一种虚拟终端，模拟硬件终端， 但没有直接连接到任何物理设备 系统创建和管理它以支持终端复用、远程登录和各种交互应用程序。 例如，当您使用 终端仿真器应用程序 （如 GNOME 的终端或 KDE 的 Konsole）来获取对 Linux 系统的 Shell 访问权限时，通常会使用伪终端。 这些 仿真器 作为伪终端的“主”端，而终端内运行的 Shell 或进程则作为“从”端。 当您打开多个终端窗口或选项卡时，每个窗口或选项卡对应一个单独的 PTS。例如，如果您打开了三个终端窗口，则它们可能会被标识为 /dev/pts/0 、 /dev/pts/1 和 /dev/pts/2 。 总之，TTY 和 PTS 都是 Linux 中的终端设备，允许用户与操作系统交互。TTY 代表物理或虚拟控制台，而 PTS 用于终端仿真器，并提供终端复用和远程登录的附加功能。 ","date":"2023-09-08","objectID":"/how-to-terminate-stuck-or-unwanted-user-sessions-in-linux/:1:0","tags":["linux","tty","pts","terminate"],"title":"How to Terminate Stuck or Unwanted User Sessions in Linux","uri":"/how-to-terminate-stuck-or-unwanted-user-sessions-in-linux/"},{"categories":null,"content":"2 如何在 Linux 中终止被卡住/不需要的用户会话 你可以用两种方式来完成这个任务，我们将在下面分别介绍这两种方式。 ","date":"2023-09-08","objectID":"/how-to-terminate-stuck-or-unwanted-user-sessions-in-linux/:2:0","tags":["linux","tty","pts","terminate"],"title":"How to Terminate Stuck or Unwanted User Sessions in Linux","uri":"/how-to-terminate-stuck-or-unwanted-user-sessions-in-linux/"},{"categories":null,"content":"2.1 Terminate User Session by TTY 我们将使用 w 命令获取有关我们 Linux 系统上已登录用户的信息。它显示有关当前已登录用户及其活动的信息。 当你运行 w 命令时，它为每个用户提供以下细节的摘要： USER: 已登录用户的用户名。 TTY: 与用户会话关联的终端名称或设备（例如，/dev/tty1，pts/0）。 FROM: 用户登录的远程主机或 IP 地址。如果用户本地登录，则显示 TTY 的名称或“ - ”符号。 LOGIN@: 用户登录的日期和时间。 IDLE: 用户会话的非活动时间长度。如果用户主动使用终端，则会显示“旧”。 JCPU: 与用户会话相关的所有进程使用的总 CPU 时间。 PCPU: 用户当前进程使用的 CPU 时间。 WHAT: 由用户或终端关联进程执行的命令。 下面是 w 命令的输出示例： 从上面这个例子的输出中可以看到，有三个登录用户——两个本地用户和一个远程用户。 为了终止名为 “linuxiac” 远程登录用户的会话，我们将在 Linux 中使用 pkill 命令，并使用选项 “-KILL” ，该选项意味着 Linux 进程必须立即被终止（而不是优雅地关闭）。请使用 “-t” 标志指定 TTY 的名称。 pkill -KILL -t pts/1 就是这样。从使用 w 命令进行重新检查可以看到，用户在我们的系统上的会话已立即终止。 ","date":"2023-09-08","objectID":"/how-to-terminate-stuck-or-unwanted-user-sessions-in-linux/:2:1","tags":["linux","tty","pts","terminate"],"title":"How to Terminate Stuck or Unwanted User Sessions in Linux","uri":"/how-to-terminate-stuck-or-unwanted-user-sessions-in-linux/"},{"categories":null,"content":"2.2 按进程 ID 终止用户会话 我们将展示第二种方法，即使用进程 ID 终止用户会话。为此，再次执行 w 命令以获取已登录用户的列表以及它们关联的 TTY/PTS。然后，一旦我们确定了 TTY/PTS 会话，使用 \"ps\" 命令和 \"-ft\" 参数来查找它的 PID： ps -ft [TTY/PTS] 最后，使用 kill 命令和 -9 （无条件终止一个进程）开关，传递进程 ID。例如： kill -9 4374 因此，用户会话立即被终止。 ","date":"2023-09-08","objectID":"/how-to-terminate-stuck-or-unwanted-user-sessions-in-linux/:2:2","tags":["linux","tty","pts","terminate"],"title":"How to Terminate Stuck or Unwanted User Sessions in Linux","uri":"/how-to-terminate-stuck-or-unwanted-user-sessions-in-linux/"},{"categories":null,"content":"2.3 Conclusion 在 Linux 系统管理领域中，了解如何终止卡住或不需要的用户会话是至关重要的。在本文中，我们探讨了两种有效的方法来完成此任务：TTY / PTS 或进程 ID。 TTY / PTS 方法提供了一个简单的方式来终止用户会话。 通过进程 ID 终止会话提供了一种更精确和直接的方法；使用哪种方法完全取决于您自己的决定。 请记住，无论您选择 TTY / PTS 方法还是进程 ID 方法，行使谨慎是至关重要的。确保终止正确的用户会话或进程，以防止意外数据丢失或意外后果。 需要更多详细信息吗？请查阅“pkill”和“kill”命令的手册页面。 https://linuxiac.com/how-to-terminate-user-session-in-linux/ ","date":"2023-09-08","objectID":"/how-to-terminate-stuck-or-unwanted-user-sessions-in-linux/:2:3","tags":["linux","tty","pts","terminate"],"title":"How to Terminate Stuck or Unwanted User Sessions in Linux","uri":"/how-to-terminate-stuck-or-unwanted-user-sessions-in-linux/"},{"categories":null,"content":" Table of Contents 1 autotiling 2 swaynagmode 2.1 swaynag (sway-1.8) crash… 3 chrome 启动慢 用了一段时间的 hyprland, 其 UI 和易用性都很不错，但可能是因为还处于功能的积极开发中，稳定性还差点，在 session 退出， 或者断开、连接新显示器时候会经常宕机， coredumpctl 里面总是一票 coredump 。。昨天受不了了，还是换回了 sway 。这里记录几个换回来后发现的几个小问题（和增强）。 ","date":"2023-09-07","objectID":"/back-to-sway/:0:0","tags":["sway","hyprland","wayland"],"title":"Back to Sway","uri":"/back-to-sway/"},{"categories":null,"content":"1 autotiling Hyprland 可以在创建新窗口时候自动设置窗口分割方向，很方便。 sway 没有内置这个功能，但是可以通过 autotiling 来实现。 ","date":"2023-09-07","objectID":"/back-to-sway/:1:0","tags":["sway","hyprland","wayland"],"title":"Back to Sway","uri":"/back-to-sway/"},{"categories":null,"content":"2 swaynagmode Control swaynag via keyboard shortcuts ","date":"2023-09-07","objectID":"/back-to-sway/:2:0","tags":["sway","hyprland","wayland"],"title":"Back to Sway","uri":"/back-to-sway/"},{"categories":null,"content":"2.1 swaynag (sway-1.8) crash… 最新的主干有修复，合并过来即可： my overlay ","date":"2023-09-07","objectID":"/back-to-sway/:2:1","tags":["sway","hyprland","wayland"],"title":"Back to Sway","uri":"/back-to-sway/"},{"categories":null,"content":"3 chrome 启动慢 这个是困扰了好一阵的问题，应该是 chrome 启动时候某个进程在尝试从 dbus 中读取什么东西，然后一直等到超时退出。。。 export XDG_CURRENT_DESKTOP=sway # xdg-desktop-portal export XDG_SESSION_DESKTOP=Unity # systemd export XDG_SESSION_TYPE=wayland # xdg/systemd dbus-update-activation-environment XDG_CURRENT_DESKTOP XDG_SESSION_DESKTOP XDG_SESSION_TYPE systemctl --user import-environment XDG_CURRENT_DESKTOP XDG_SESSION_DESKTOP XDG_SESSION_TYPE dbus-run-session sway \u003e ~/tmp/wm.log 2\u003e\u00261 ","date":"2023-09-07","objectID":"/back-to-sway/:3:0","tags":["sway","hyprland","wayland"],"title":"Back to Sway","uri":"/back-to-sway/"},{"categories":null,"content":" Table of Contents 1 用 Org Mode + Hugo 写博客，并通过 Github Action 自动部署到 Github Pages 1.1 准备工作 1.2 写博客 1.3 部署篇 1.4 遇到的问题 2 使用 Emacs Script 自动将 org 文件导出为 Markdown 2.1 痛点 2.2 如何解决 2.3 存在的问题 2.4 遇到的问题 3 附录 3.1 我正在用的 github actions 3.2 当前用的脚本 参考这里： https://superbear.github.io/post/2021/11/use-org-mode-and-hugo-to-write-blog/ https://superbear.github.io/post/2021/12/batch-export-org-files-to-markdown-with-emacs-script-and-ox-hugo/ 搬运一下，放丢。。。 以下内容转自 superbear 的博客。 ","date":"2023-09-05","objectID":"/how-this-blog-is-generated/:0:0","tags":["hugo","blog"],"title":"这个博客是怎么生成的？","uri":"/how-this-blog-is-generated/"},{"categories":null,"content":"1 用 Org Mode + Hugo 写博客，并通过 Github Action 自动部署到 Github Pages ","date":"2023-09-05","objectID":"/how-this-blog-is-generated/:1:0","tags":["hugo","blog"],"title":"这个博客是怎么生成的？","uri":"/how-this-blog-is-generated/"},{"categories":null,"content":"1.1 准备工作 1.1.1 创建两个 Github 仓库 用来放 org 文件. markdown 文件及 Hugo 相关配置，可以设置成私有，如 blog。 Github Pages 仓库，用来放生成的静态文件。一般是{username}.github.io。 1.1.2 安装 Hugo a static site generator written in Go 1.1.3 安装 ox-hugo 将 org 文件翻译成 markdown 文件，written in Emacs Lisp。Hugo 支持 Org Mode，但据说支持得不是很好 1。毕竟 Emacs Lisp 处理 org 文件相关的包比 Go 多，就直接用 ox-hugo 转 markdown 的方案了。 不是 Emacs 用户？ 可跳过 Org Mode 相关内容 1.1.4 配置环境 各软件版本 Emacs 27.1 Org Mode 9.3 ox-hugo 20210916.1332 Hugo v0.89.4 配置 Hugo # 在 blog 仓库中新建 hugo site cd /path/to/blog \u0026\u0026 hugo new site hugo # 选个主题，并设置成子模块（后续升级/替换都比较方便） git submodule add https://github.com/olOwOlo/hugo-theme-even.git hugo/themes/even # 修改默认配置 开启本地实时预览 # 配置修改. markdown 文件改动都会被监控到 cd blog \u0026\u0026 hugo –source hugo server -D 配置 ox-hugo ;;; 在 init.el 里或其他文件里加以下代码 (with-eval-after-load 'ox (require 'ox-hugo)) ;;; 可选。全局配置，如导出目录等字段，也可以在 org 文件里进行配置 ;;; M-x customize-variable org-hugo ","date":"2023-09-05","objectID":"/how-this-blog-is-generated/:1:1","tags":["hugo","blog"],"title":"这个博客是怎么生成的？","uri":"/how-this-blog-is-generated/"},{"categories":null,"content":"1.2 写博客 新建 org 目录及文件 cd blog \u0026\u0026 mkdir -p org/2021/11 # 可选，可以不按年月日分拆分目录。拆分后方便管理，但如果用户直接访问某年的数据，页面就会 404 新建 org 文件，如 test.org #+OPTIONS: author:nil ^:{} # 告诉 ox-hugo 将导出的 markdown 文件放到哪里。注意：even 主题需要发布到 post 目录。 # see: https://ox-hugo.scripter.co/#before-you-export #+HUGO_BASE_DIR: ../../../hugo #+HUGO_SECTION: post/2021/11 #+HUGO_CUSTOM_FRONT_MATTER: :toc true #+HUGO_AUTO_SET_LASTMOD: t #+HUGO_DRAFT: false #+DATE: [2021-11-28 Sun 19:28] #+TITLE: 标题 #+HUGO_TAGS: tag1 tag2 #+HUGO_CATEGORIES: category1 category2 Hello，World 导出 org 到 markdown 文件 在 Emacs 里执行 C-c C-e H h（File to Md file）导出整个 org 文件到 markdown 文件，也可以导出 subtree，具体看个人喜好 访问http://127.0.0.1:1313/ 正常情况就会看到博客界面啦 提交 org 及 markdown 文件到 blog 仓库 使用 Yasnippet（推荐） 下次新建文件就不用 copy 一些元数据 # -*- mode: snippet -*- # name: hugo # key: hugo # -- #+OPTIONS: author:nil ^:{} #+HUGO_BASE_DIR: ../../../hugo #+HUGO_SECTION: post/`(format-time-string \"%Y/%m\")` #+HUGO_CUSTOM_FRONT_MATTER: :toc true #+HUGO_AUTO_SET_LASTMOD: t #+HUGO_DRAFT: false #+DATE: `(format-time-string \"[%Y-%m-%d %a %H:%M]\")` #+TITLE: $1 #+HUGO_TAGS: $2 #+HUGO_CATEGORIES: $3 $0 1.2.1 目录结构 \u003c!-- blog 仓库目录结构如下 --\u003e \u003c!-- tree -a -d -L 3 -I .git --\u003e . ├── .github │ └── workflows ├── hugo │ ├── archetypes │ ├── content │ │ └── post │ ├── data │ ├── layouts │ │ └── _internal │ ├── static │ └── themes │ └── even ├── org │ └── 2021 │ └── 11 └── scripts ","date":"2023-09-05","objectID":"/how-this-blog-is-generated/:1:2","tags":["hugo","blog"],"title":"这个博客是怎么生成的？","uri":"/how-this-blog-is-generated/"},{"categories":null,"content":"1.3 部署篇 1.3.1 配置 Github Action 在 blog 仓库下新增.github/workflows/main.yml 文件，内容如下： name: GitHub Pages on: push: branches: - main # Set a branch to deploy pull_request: jobs: deploy: runs-on: ubuntu-20.04 concurrency: group: ${{ github.workflow }}-${{ github.ref }} steps: # 修改时区 - name: Set Timezone run: sudo timedatectl set-timezone 'Asia/Shanghai' - uses: actions/checkout@v2 with: submodules: true # Fetch Hugo themes (true OR recursive) fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: # 建议和本地用的版本保持一致，从而获得一致的体验 hugo-version: '0.89.4' # extended: true - name: Build run: | hugo --source hugo --minify --buildFuture --buildExpired - name: Deploy uses: peaceiris/actions-gh-pages@v3 if: ${{ github.ref == 'refs/heads/main' }} with: # github_token: ${{ secrets.PERSONAL_ACCESS_TOKEN }} # publish_branch: gh-pages # publish_dir: hugo/public deploy_key: ${{ secrets.DEPLOY_KEY }} external_repository: superbear/superbear.github.io # 默认是 master 目录，github 上可修改 publish_branch: master publish_dir: hugo/public 1.3.2 配置 DEPLOY_KEY 生成 github deploy-keys 将公钥添加至{username}.github.io 仓的 Deploy keys（Settings -\u003e Deploy keys）中； 将私钥添加至 blog 仓库的 secrets（Settings -\u003e Secrets）中； 将本地 blog 目录的改动 push 到远程 blog 仓库 master 分支； 正常情况下，一段时间之后，可以在{username}.github.io 的 master 分支下看到 hugo 生成的静态文件； 没有的话，可以根据 blog 仓库的 Github Actions 日志排查下。 ","date":"2023-09-05","objectID":"/how-this-blog-is-generated/:1:3","tags":["hugo","blog"],"title":"这个博客是怎么生成的？","uri":"/how-this-blog-is-generated/"},{"categories":null,"content":"1.4 遇到的问题 部署完成却没有生成文件，就只有一个.nojekyll 文件 1 \u003c!– actions log –\u003e 2 cp: no such file or directory: /home/runner/work/blog/hugo/public/* 排查思路：排查 Github Actions 日志，以及写一些 shell 命令查看路径相关信息 Hugo 生成静态文件报错，报错信息如下： 1 - unmarshal failed: Near line 4 (last key parsed ’tags’): Array contains values of type ‘Integer’ and ‘String’, but arrays must be homogeneous. 原因：tags 的类型不一致，标签混用了数字和字符串解决方案：去掉数字类型的标签或升级至最新版本的 hugo ","date":"2023-09-05","objectID":"/how-this-blog-is-generated/:1:4","tags":["hugo","blog"],"title":"这个博客是怎么生成的？","uri":"/how-this-blog-is-generated/"},{"categories":null,"content":"2 使用 Emacs Script 自动将 org 文件导出为 Markdown 接上篇 用 Org Mode + Hugo 写博客，并通过 Github Action 自动部署到 Github Pages ","date":"2023-09-05","objectID":"/how-this-blog-is-generated/:2:0","tags":["hugo","blog"],"title":"这个博客是怎么生成的？","uri":"/how-this-blog-is-generated/"},{"categories":null,"content":"2.1 痛点 代码仓库里会同时保存 org 文件和 markdown 文件，markdown 文件其实是中间产物，不想保存。 ","date":"2023-09-05","objectID":"/how-this-blog-is-generated/:2:1","tags":["hugo","blog"],"title":"这个博客是怎么生成的？","uri":"/how-this-blog-is-generated/"},{"categories":null,"content":"2.2 如何解决 首先，Emacs 是可以执行 Emacs Script 的，写个脚本，然后在 Github Action 里执行即可。Emacs 环境哪里来？ purcell 大神已经准备好了。 废话不多说，直接上代码。 嵌入 Gist 1 #+BEGIN_EXPORT html 2 \u003cscript src=\"https://gist.github.com/superbear/28fb0dbbca505b5d7d83e10e35b822a4.js\"\u003e\u003c/script\u003e 3 #+END_EXPORT 等等，直接用 markdown 写是不是就没有这个痛点了？嗯😄。 ","date":"2023-09-05","objectID":"/how-this-blog-is-generated/:2:2","tags":["hugo","blog"],"title":"这个博客是怎么生成的？","uri":"/how-this-blog-is-generated/"},{"categories":null,"content":"2.3 存在的问题 目前是全量导出，找到指定目录下的全部 org 文件，然后转成 markdown 文件。 这样每提交一篇文章，就需要处理全部存量文章。另外，全部文章的更新时间都会跟着变，这个和 HUGO_AUTO_SET_LASTMOD 这个 property 设置有关。详见：ox-hugo last modified 。待改成增量导出。 ","date":"2023-09-05","objectID":"/how-this-blog-is-generated/:2:3","tags":["hugo","blog"],"title":"这个博客是怎么生成的？","uri":"/how-this-blog-is-generated/"},{"categories":null,"content":"2.4 遇到的问题 org 导出 markdown 文件了，但未生成静态文件 原因：时区问题。Github Action 是按 UTC 时间执行的，而文件的发布日期是东八区的，这样 Hugo 可能会看到发布日期还未到，就不处理了 1。解决方案：修改 Github Action job 的时区，可一并解决文件修改时间不对的问题；或修改 Hugo 运行时的配置，增加–buildFuture 参数。 ","date":"2023-09-05","objectID":"/how-this-blog-is-generated/:2:4","tags":["hugo","blog"],"title":"这个博客是怎么生成的？","uri":"/how-this-blog-is-generated/"},{"categories":null,"content":"3 附录 ","date":"2023-09-05","objectID":"/how-this-blog-is-generated/:3:0","tags":["hugo","blog"],"title":"这个博客是怎么生成的？","uri":"/how-this-blog-is-generated/"},{"categories":null,"content":"3.1 我正在用的 github actions # Sample workflow for building and deploying a Hugo site to GitHub Pages name: Deploy Hugo site to Pages on: # Runs on pushes targeting the default branch push: branches: [\"master\"] # Allows you to run this workflow manually from the Actions tab workflow_dispatch: # Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages permissions: contents: read pages: write id-token: write # Allow only one concurrent deployment, skipping runs queued between the run in-progress and latest queued. # However, do NOT cancel in-progress runs as we want to allow these production deployments to complete. concurrency: group: \"pages\" cancel-in-progress: false # Default to bash defaults: run: shell: bash jobs: build: runs-on: ubuntu-20.04 concurrency: group: ${{ github.workflow }}-${{ github.ref }} steps: - uses: actions/checkout@v2 with: submodules: true # Fetch Hugo themes (true OR recursive) fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: '0.115.0' extended: true - name: Setup Emacs uses: purcell/setup-emacs@master with: version: 29.1 - name: Export Markdown run: | # 将org文件导出成md文件 mkdir ~/.emacs.d cd script \u0026\u0026 sh batch-export-org-files-to-md-with-ox-hugo.el - name: Build run: | cd hugo \u0026\u0026 hugo --minify --buildFuture --buildExpired - name: Upload artifact uses: actions/upload-pages-artifact@v2 with: path: ./hugo/public - name: Deploy uses: peaceiris/actions-gh-pages@v3 # If you're changing the branch from main, # also change the `main` in `refs/heads/main` # below accordingly. if: github.ref == 'refs/heads/master' with: publish_branch: master publish_dir: hugo/public deploy_key: ${{ secrets.DEPLOY }} external_repository: yangyingchao/yangyingchao.github.io ","date":"2023-09-05","objectID":"/how-this-blog-is-generated/:3:1","tags":["hugo","blog"],"title":"这个博客是怎么生成的？","uri":"/how-this-blog-is-generated/"},{"categories":null,"content":"3.2 当前用的脚本 #!/usr/bin/env sh :; set -e # -*- mode: emacs-lisp; lexical-binding: t -*- :; emacs --no-site-file --script \"$0\" -- \"$@\" || __EXITCODE=$? :; exit 0 ;;; Code: (defvar bootstrap-version) (defvar straight-base-dir) (defvar straight-fix-org) (defvar straight-vc-git-default-clone-depth 1) (defvar publish--straight-repos-dir) (setq gc-cons-threshold 83886080 ; 80MiB straight-base-dir (expand-file-name \"../..\" (or load-file-name buffer-file-name)) straight-fix-org t straight-vc-git-default-clone-depth 1 publish--straight-repos-dir (expand-file-name \"straight/repos/\" straight-base-dir)) (let ((bootstrap-file (expand-file-name \"straight/repos/straight.el/bootstrap.el\" straight-base-dir)) (bootstrap-version 5)) (unless (file-exists-p bootstrap-file) (with-current-buffer (url-retrieve-synchronously \"https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el\" 'silent 'inhibit-cookies) (goto-char (point-max)) (eval-print-last-sexp))) (load bootstrap-file nil 'nomessage)) ;;; org \u0026\u0026 ox-hugo (straight-use-package '(org :type built-in)) (straight-use-package '(ox-hugo :type git :host github :repo \"kaushalmodi/ox-hugo\" :nonrecursive t)) (require 'ox-hugo) (defun yc/org-hugo--build-toc-a (content) \"Append my markers. These markers are used to identify original source of this note.\" (concat (or content \"\") (save-excursion (goto-char (point-min)) (if (re-search-forward (rx bol \":NOTER_DOCUMENT:\" (* space) (group (+ nonl)) eol)) (let ((orig (match-string 1))) (format \"\\n\\n本文为摘录，原文为： %s\\n\" orig)) \"\")))) (advice-add #'org-hugo--build-toc :filter-return #'yc/org-hugo--build-toc-a) (defun tnote/export-org-file-to-md (file) \"Export single FILE to markdown.\" (message \"Checking file %s\" file) (if (and (file-exists-p file) (string-equal (file-name-extension file) \"org\") (not (string-match-p (rx (or \"inbox\" \"gtd\")) file))) (with-current-buffer (find-file-noselect file) (message \" Processing file: %s\" file) (condition-case var (org-hugo-export-wim-to-md t) (error (message \"ERROR: %s\" var))) (message \" .... done\")) (message \" Skipping file: %s\" file))) (defun batch-export-all-org-files-to-md (dir) \"Export all org files in directory DIR to markdown. To perform a full export of all org files in the directory DIR to markdown format, use this command. It should be called when a full export is required, typically for the first time..\" (message \"DIR: %s\" dir) (mapc #'tnote/export-org-file-to-md (directory-files-recursively dir \"\\\\`[^.#].*\\\\.org\\\\'\"))) (defun batch-export-HEAD-files-to-md () \"Export the files in the HEAD branch to markdown format. This command should be called in an incremental manner to effectively export updated files..\" (dolist (it (cdr (string-lines (shell-command-to-string \"git show --oneline --name-only HEAD\")))) (tnote/export-org-file-to-md (expand-file-name it \"..\")))) ;;; export (setq org-hugo-base-dir (concat default-directory \"../hugo\")) (setq org-file-dir (concat default-directory \"../org/\")) (batch-export-all-org-files-to-md org-file-dir) ","date":"2023-09-05","objectID":"/how-this-blog-is-generated/:3:2","tags":["hugo","blog"],"title":"这个博客是怎么生成的？","uri":"/how-this-blog-is-generated/"},{"categories":null,"content":" Table of Contents 1 pos2usage 1.1 pod2usage 是作什么的 1.2 pod2usage 输出的文档，是在哪里定义的 1.3 代码中的 =head1 是什么意思？ 2 use 是什么意思 3 die hook 4 常量 5 变量 不懂 perl, 所以看代码时候问了 chatGPT 这些很基础的问题，简单整理记录一下。 ","date":"2023-09-04","objectID":"/perl-begginer-note/:0:0","tags":["perl","basic"],"title":"perl begginer note","uri":"/perl-begginer-note/"},{"categories":null,"content":"1 pos2usage ","date":"2023-09-04","objectID":"/perl-begginer-note/:1:0","tags":["perl","basic"],"title":"perl begginer note","uri":"/perl-begginer-note/"},{"categories":null,"content":"1.1 pod2usage 是作什么的 pod2usage 是 Perl 中的一个函数，用于将指定的 POD（Plain Old Documentation）文档转换为使用说明。POD 是 Perl 语言中的一种简单文本标记格式，用于编写源代码中的文档注释和使用说明文档。pod2usage 函数可以方便地将这些注释和说明文档输出到终端或文件。 在程序中，pod2usage 主要用于输出使用说明以及命令行帮助信息。它的常用参数如下： -verbose：设定输出详细程度，取值为 0、1 或 2，默认为 1； -exitval：设定函数的退出值，默认为 1； -output：输出的文件或句柄，默认为 \\*STDERR。 例如，在代码中调用 pod2usage() 函数输出使用说明的时候，它默认会输出到终端，同时产生退出状态码 1，可以让主程序退出。如果使用 -verbose =\u003e 2 参数，可以输出更详细的信息。 ","date":"2023-09-04","objectID":"/perl-begginer-note/:1:1","tags":["perl","basic"],"title":"perl begginer note","uri":"/perl-begginer-note/"},{"categories":null,"content":"1.2 pod2usage 输出的文档，是在哪里定义的 pod2usage 输出的文档通常是在 Perl 源代码文件中使用特殊的注释格式（即 POD 格式）定义的。在 Perl 中，使用 “=pod” 和 “=cut” 标记来定义这些注释段： =pod =head1 SYNOPSIS Usage: script.pl [options] [file ...] Options: -h --help Show this help screen -v --verbose Enable verbose output -d --debug Enable debugging messages -f --file Specify input file -o --output Specify output file =head1 DESCRIPTION This script does something useful. =cut 在这里，定义了一个简单的使用说明文档，包含了程序的使用方法，命令行选项和描述。pod2usage 函数会自动解析 Perl 源代码中的 POD 格式注释，将其转换为纯文本形式并输出到终端。我们可以通过对 POD 格式注释的编写和格式化，来使得使用说明文档更加完整、清晰易读。 ### #################################################################################################################################### # Usage #################################################################################################################################### =head1 SYNOPSIS pgaudit_analyze [options] \u003cpg-log-path\u003e Configuration Options: --daemon run as a daemon (consider running under upstart or systemctl) --port port that PostgreSQL is running on (defaults to 5432) --socket-path PostgreSQL host or socket directory (default to system default directory) --log-file location of the log file for pgaudit_analyze (defaults to /var/log/pgaudit_analyze.log) --user specify postgres user instead of using pgaudit_analyze invoker General Options: --help display usage and exit =cut 这段代码是一个命令行程序的使用说明。该程序名为 “pgaudit_analyze”，可以从命令行运行。可以使用以下选项来定制程序的配置： –daemon：将程序作为守护进程运行（建议在 upstart 或 systemctl 下运行）； –port：指定 PostgreSQL 运行的端口号，默认为 5432； –socket-path：指定 PostgreSQL 的主机或套接字路径（默认为系统默认目录）； –log-file：指定 pgaudit_analyze 的日志文件位置（默认为 /var/log/pgaudit_analyze.log）； –user：指定要使用的 postgres 用户，而不是使用 pgaudit_analyze 调用者。 此外，还有一个通用选项： –help：显示使用说明并退出。 ","date":"2023-09-04","objectID":"/perl-begginer-note/:1:2","tags":["perl","basic"],"title":"perl begginer note","uri":"/perl-begginer-note/"},{"categories":null,"content":"1.3 代码中的 =head1 是什么意思？ 在 Perl 编程语言中，=head1 表示一个文档的节（section），在这个节中，标题通常为粗体。而在 Perl 中，这种文档格式通常用来生成程序或模块的文档。在这里，这段代码使用 =head1 来标记一个章节，章节标题为 SYNOPSIS。SYNOPSIS 章节通常用于描述一个脚本或程序如何使用的示例和简要的指南。 ","date":"2023-09-04","objectID":"/perl-begginer-note/:1:3","tags":["perl","basic"],"title":"perl begginer note","uri":"/perl-begginer-note/"},{"categories":null,"content":"2 use 是什么意思 在 Perl 编程语言中，use 语句用于加载一个模块（也称为库）或启用一个 pragma（编译指令）。它的一般形式为： ``` use Module::Name; use Module::Name qw(imported_function1 imported_function2 …); use Pragma; ``` 其中，Module::Name 表示要加载的模块名称，而 Pragma 则表示要启用的编译器指令。在 Perl 中，模块通常是一组封装好的函数和数据结构，而 pragma 可以用来更改编译器或运行时的行为，例如开启严格模式（strict）、开启警告（warnings）等。 2.0.1 上面的 qw() 是做什么的 在 Perl 编程语言中，qw() 是一种快速创建字符串列表的语法糖，它被用于创建字符串数组。在 qw() 括号中，通过空格或制表符分割的字符串会被转换为数组的元素，而逗号则用来分隔不同的元素。与使用普通的双引号或单引号不同，使用 qw() 创建字符串数组不需要使用引号或逗号，这使得语法更加简洁。在上面的代码中，qw(all) 表示一个字符串数组，包含了一个元素 “all”。这里它的作用是告诉警告 pragma 把所有警告视为致命错误。 ### use DBI; use File::Basename qw(dirname); use Getopt::Long qw(GetOptions); use Pod::Usage; use POSIX qw(setsid); 这段代码与 Perl 编程语言有关，包含了五个 use 语句。它们的含义分别是： use DBI：加载 DBI 模块，这是 Perl 中用于操作数据库的标准接口。 use \u003c:Basename\u003e qw(dirname)：加载 \u003c:Basename\u003e 模块，并导入其中的 dirname 函数，该函数用于获取给定文件路径的目录名部分。 use Getopt::Long qw(GetOptions)：加载 Getopt::Long 模块，并导入其中的 GetOptions 函数，该函数用于解析命令行参数。 use Pod::Usage：加载 Pod::Usage 模块，它提供了把 Perl 脚本中的 POD（Plain Old Documentation）文档转换为使用说明的方法。 use POSIX qw(setsid)：加载 POSIX 模块，并导入其中的 setsid 函数，该函数用于创建一个新的会话并将调用进程设置为新会话的领导者。 需要注意的是，这些模块都需要使用 cpan 等工具进行安装。 ","date":"2023-09-04","objectID":"/perl-begginer-note/:2:0","tags":["perl","basic"],"title":"perl begginer note","uri":"/perl-begginer-note/"},{"categories":null,"content":"3 die hook ### #################################################################################################################################### # Handle die as a confess instead to get more detailed error information #################################################################################################################################### $SIG{__DIE__} = sub {Carp::confess @_}; 这段代码是将内置变量 $SIG{__DIE__} 重定义为一个新的匿名子过程，用于把程序的“die”行为改为 Carp::confess ，以便获取更详细的错误信息。当程序中调用 die 函数时，Perl 解释器会触发 __DIE__ 信号，并尝试执行 $SIG{__DIE__} 中的代码。在这里，使用 Carp::confess 来代替 die 函数，它可以生成一份类似于栈追踪的调试信息，并在错误发生时输出到输出流中。这种方式可以帮助开发者更快地定位和修复程序中的错误。 ","date":"2023-09-04","objectID":"/perl-begginer-note/:3:0","tags":["perl","basic"],"title":"perl begginer note","uri":"/perl-begginer-note/"},{"categories":null,"content":"4 常量 ### use constant { # Session unique fields LOG_FIELD_USER_NAME =\u003e 1, LOG_FIELD_DATABASE_NAME =\u003e 2, LOG_FIELD_PROCESS_ID =\u003e 3, LOG_FIELD_CONNECTION_FROM =\u003e 4, LOG_FIELD_SESSION_ID =\u003e 5, LOG_FIELD_SESSION_START_TIME =\u003e 8, # Log fields LOG_FIELD_LOG_TIME =\u003e 0, LOG_FIELD_SESSION_LINE_NUM =\u003e 6, LOG_FIELD_COMMAND_TAG =\u003e 7, LOG_FIELD_VIRTUAL_TRANSACTION_ID =\u003e 9, LOG_FIELD_TRANSACTION_ID =\u003e 10, LOG_FIELD_ERROR_SEVERITY =\u003e 11, LOG_FIELD_SQL_STATE_CODE =\u003e 12, LOG_FIELD_MESSAGE =\u003e 13, LOG_FIELD_DETAIL =\u003e 14, LOG_FIELD_HINT =\u003e 15, LOG_FIELD_INTERNAL_QUERY =\u003e 16, LOG_FIELD_INTERNAL_QUERY_POS =\u003e 17, LOG_FIELD_CONTEXT =\u003e 18, LOG_FIELD_QUERY =\u003e 19, LOG_FIELD_QUERY_POS =\u003e 20, LOG_FIELD_LOCATION =\u003e 21, LOG_FIELD_APPLICATION_NAME =\u003e 22 }; 这段代码使用了 Perl 中的常量（constant）。它定义了一个匿名哈希（hash），其中每个键（key）都是一个常量，对应了 Postgres 的日志格式。 代码中使用了大括号来表示一个哈希，并使用箭头（=\u003e）来分隔键和值。其中，键是常量名，值是对应的数值，代表 Postgres 日志中的某个字段。 在这里，这个常量哈希主要用于后续代码中访问 Postgres 日志时，将字段名称转化为常量名，这样可以避免使用魔法数字（magic numbers）并提高代码的可读性和可维护性。下面是一些示例： LOG_FIELD_USER_NAME 表示用户名字段在哈希中对应的键值，其值为 1； LOG_FIELD_TRANSACTION_ID 表示事务 ID 字段在哈希中对应的键值，其值为 10； LOG_FIELD_APPLICATION_NAME 表示应用程序名称字段在哈希中对应的键值，其值为 22。 可以通过这些常量来代替在代码中使用数字来访问 Postgres 日志字段，并且可以避免因 Postgres 日志格式更改而导致代码逻辑混乱。 ","date":"2023-09-04","objectID":"/perl-begginer-note/:4:0","tags":["perl","basic"],"title":"perl begginer note","uri":"/perl-begginer-note/"},{"categories":null,"content":"5 变量 ### my %oDbHash; my $strAuditUserName = 'pgaudit_etl'; my $strAuditSchemaName = 'pgaudit'; 这段代码定义了三个变量。 %oDbHash：这是一个哈希表，也称为关联数组（associative array），用于存储数据库连接的相关信息。在程序运行期间，我们可以使用这个哈希表来保存数据库连接、游标等对象，并在程序的其他部分中共享这些对象。 $strAuditUserName：这是一个字符串变量，保存了 Postgres 数据库的用户名，该用户名用于访问存储日志信息的 pgaudit 表。 $strAuditSchemaName：这也是一个字符串变量，保存了 Postgres 数据库中存储日志信息的 schema 名称，该 schema 中包含了所有与日志分析相关的表。 在程序中，这些变量的具体使用方式会参考实际情况，在后续的代码中进行定义和赋值。 5.0.1 my 是用来作什么的 在 Perl 编程语言中，my 关键字用于声明一个新的变量，并将其限定在当前代码块（block）或子程序（subroutine）中。如果我们没有使用 my 或其他类似的关键字来声明变量，那么 Perl 就会将其视为一个全局变量，并可以在程序的任何部分进行修改和访问。 例如，在这段代码中，使用了 my 关键字来声明三个变量，这意味着它们只能在当前代码块或子程序中使用，并且不能在其他代码块或子程序中访问或修改它们。这样可以避免因命名冲突而导致程序出错，也能让代码更加清晰明了。 ### sub databaseGet { my $strDatabaseName = shift; if (defined($oDbHash{$strDatabaseName})) { return false if (!$oDbHash{$strDatabaseName}{log}); return true; } 这段代码是一个名为 databaseGet 的子程序（subroutine），接收一个参数 $strDatabaseName，用于返回需要分析的 Postgres 数据库连接设置。 在实现中，首先，使用 my 关键字声明了一个新的局部变量 $strDatabaseName 用于存储子程序接收到的参数。然后，使用 defined 函数检查 $oDbHash 哈希表是否已经包含了这个数据库的信息。 如果存在，会有两种可能： 如果该数据库没有配置日志记录，则返回 false； 否则返回 true，代表允许记录日志。 而如果 $oDbHash 中没有这个数据库的信息，则子程序会返回 undef（或空值）。在程序的其他部分，我们可以使用这个子程序来完成数据库的连接和日志记录的设置。 5.0.2 上面的 shift 是做什么的 `shift` 是用来从参数列表中取出第一个参数的函数。在这个代码中，它取出了传递给 `databaseGet` 函数的唯一一个参数 `$strDatabaseName`，并将其赋值给变量 `$strDatabaseName`。 所以，这个函数的首行代码 `my $strDatabaseName = shift;` 的作用就是将传入的 `$strDatabaseName` 参数值取出来，并将其存储到 `$strDatabaseName` 变量中。 5.0.3 if (defined($oDbHash{$strDatabaseName})) 是什么意思 `if (defined($oDbHash{$strDatabaseName}))` 这行代码使用了一个 `defined` 函数来判断一个叫做 `%oDbHash` 的哈希表中是否存在 `$strDatabaseName` 这个键名。 具体地说，如果哈希表 `%oDbHash` 中存在 `$strDatabaseName` 这个键名，则 `defined` 函数会返回 true，否则返回 false。 因此，这行代码在判断当前的程序是否已经连接到名为 `$strDatabaseName` 的数据库。如果存在，则证明程序已经连接过这个数据库。否则，程序需要对这个数据库重新进行连接。 5.0.4 怎样访问 perl 的哈希列表？ 访问 Perl 哈希列表的方式是通过使用键名来获取或者设置对应的值。 例如，如果有一个叫做 `%hash` 的哈希列表，我们可以使用它的键名来获取或者设置特定的值，比如： ```perl my %hash = ( key1 =\u003e ‘value1’, key2 =\u003e ‘value2’, key3 =\u003e ‘value3’ ); my $value = $hash{‘key1’}; # $value 等于 ‘value1’ $hash{‘key2’} = ’new_value2’; ``` 需要注意的是，Perl 哈希列表中的键名和值都可以是任何标量类型，包括字符串、数字、引用等等。 ### $oDbHash{$strDatabaseName}{hDb} = DBI-\u003econnect( \"dbi:Pg:dbname=${strDatabaseName};port=${iPort};\" . (defined($strSocketPath) ? \"host=${strSocketPath}\" : ''), $strDbUser, undef, {AutoCommit =\u003e 0, RaiseError =\u003e 1}); 这段代码的作用是根据给定的数据库名称 `$strDatabaseName`，连接到一个 PostgreSQL 数据库，并将连接对象存储到一个名为 `$oDbHash` 的哈希列表中。 具体地说，它首先创建一个名为 `$oDbHash` 的哈希列表，然后将连接对象存储在 `$oDbHash{$strDatabaseName}{hDb}` 中，其中 `$strDatabaseName` 是数据库名称。这个哈希列表可以在程序的其他地方使用，以便后续操作该数据库时可以重复使用此连接。 代码中连接数据库的方式是使用 Perl 的 DBI 模块提供的 `connect()` 函数连接 PostgreSQL 数据库。`connect()` 函数的参数是一个字符串，包含要连接的数据库的名称、端口和其他一些数据库连接选项。具体来说，这个字符串的格式是 `“dbi:Pg:dbname=\\({strDatabaseName};port=\\){iPort};host=\\({strSocketPath}”`，其中 `\\){strDatabaseName}` 是数据库名称，`\\({iPort}` 是端口号，`\\){strSocketPath}` 是套接字路径（如果可用）。 值得注意的是，代码中设置了一些连接选项，包括 `{AutoCommit =\u003e 0}` 和 `{RaiseError =\u003e 1}`。`{AutoCommit =\u003e 0}` 表示关闭自动提交事务的选项，也即开启了事务处理；`{RaiseError =\u003e 1}` 表示设置了自动报错选项，也即当出现错误时，DBI 模块将自动抛出异常。 5.0.5 简单介绍一下 DBI 模块 DBI（Database Interface）是 Perl 语言中使用最广泛的数据库访问模块。它是一个规范，定义了一组指令和 API 函数，用于访问各种关系数据库。它的目标是为 Perl 提供一种数据库无关性的抽象接口，并且尽可能的对各大数据库使用相同的操作语言。 DBI 的优点： 简单易用，提供了可移植的接口，让用户无需关心底层数据库信息。 可扩展性好，支持了大量第三方连接模块（称之为 DBD，Database Drivers）来支持各大数据库。 DBI 的基本用法： 使用 DBI 模块中的 `connect()` 函数连接指定的数据库。 创建一个 `Database Statement Handle`（句柄），句柄是连接到数据库的关键对象。使用 `prepare()` 函数准备要执行的 SQL 语句。 执行 SQL 语句，获取返回结果。使用 `execute()` 或者 `fetch()` 函数执行 SQL 语句，并从结果集中获取数据。 完成查询操作后，使用 `disconnect()` 函数关闭对数据库的连接。 总的来说，DBI 是一个非常强大且使用广泛的数据库访问模块，通过它可以很方便地访问、操作各种类型的关系数据库。 5.0.6 上面的 hDb 是什么 `hDb` 是保存在 `$oDbHash` 哈希表中的一个键名。在这段代码中，`$oDbHash{$strDatabaseName}{hDb}` 是一个存储 `DBI` 数据库句柄（Database Handle）的哈希表元素，这个数据库句柄是后面对该数据库进行操作所必需的。也就是说，一旦成功连接到一个数据库，使用 DBI 连接返回的数据库句柄，您可以使用该句柄执行任意的 SQL 语句，进行相关的数据库操作。 可以通过使用 `$oDbHash{$strDatabaseName}{hDb}` 来访问保存在哈希表中的数据库句柄，以便在程序的其他部分使用它来执行数据库操作。 ### # Check for the audit schema to determine whether or not to log this database my $hSqlSchemaSelect = $oDbHash{$strDatabaseName}{hDb}-\u003epr","date":"2023-09-04","objectID":"/perl-begginer-note/:5:0","tags":["perl","basic"],"title":"perl begginer note","uri":"/perl-begginer-note/"},{"categories":null,"content":" Table of Contents 1 When everything else fails, talk with the Kernel using SysReq 本文为摘录(或转载)，侵删，原文为： https://linuxhandbook.com/frozen-linux-system/ ","date":"2023-08-28","objectID":"/frozen-linux-system/:0:0","tags":["process","linux","dead","sysrq"],"title":"Ways to Deal With a Frozen Linux System","uri":"/frozen-linux-system/"},{"categories":null,"content":"1 When everything else fails, talk with the Kernel using SysReq 有时，甚至切换到 TTY 也无法正常工作。整个系统都死了。但是不要放弃，很可能是一种假象。Linux 在这种情况下提供了一种更多的功能。 如果在内核中编译并在文件中启用，Linux 可以为您提供直接向内核发送预设请求的方式。这在整个用户堆栈死亡的情况下非常有用。它被称为 Magic SysRq 键。在大多数发行版中默认情况下编译并启用，只有 Kernel Panic 才能阻止其工作。 要确认内核编译时已设置该选项，可以尝试在 /boot 中查找当前内核的配置文件。查找 CONFIG_MAGIC_SYSRQ 选项。如先前所述，它在大多数发行版中已编译并启用。要确认它已启用，请运行以下操作： sysctl kernel.sysrq 在较旧的系统中，有两个选项：0和 1。它要么是关闭的，要么是打开的。在新的系统中，可以更精细地控制哪些命令已启用。 任何大于 1 的值都意味着某些命令已启用。更多详细信息可以在此处找到。 要临时设置不同的值，请运行以下命令： sudo sysctl -w kernel.sysrq=value 要永久更改此值，请编辑 /etc/sysctl.conf 。搜索 kernel.sysrq，并设置所需的值。 测试这个功能最简单的方法就是去试。我也建议在系统稳定时学习一组按键操作并进行测试。当你执行 SysRq 命令时，内核将尝试响应。此响应只能在虚拟控制台 1 到 6 中看到。如果焦点无法从 X 移开，您将看不到响应。这并不意味着它不起作用。 可以发送许多命令。完整列表可以在这里看到。我建议记住以下内容： 键 描述 Alt + SysRq + r 退出原始模式，将控制权从 X 中移除 Alt + SysRq + e 向所有进程发送 SigTerm 指令，让它们有机会安全退出 Alt + SysRq + i 向所有进程发送 SigKill 指令 Alt + SysRq + k 关闭当前虚拟控制台中的所有进程 Alt + SysRq + s 同步所有已装载的文件系统，将所有数据刷新到磁盘上 Alt + SysRq + u 将所有文件系统重新挂载为只读 Alt + SysRq + b 立即重新启动系统，不同步或卸载 Alt + SysRq + o 关闭系统 这个简短的命令列表为您在处理不稳定的系统时提供了一个强大的新工具。在发送请求时，如果无法看到内核的响应，请在命令之间间隔几秒钟。当请求 HDD 操作时，请注意硬盘灯。 有两个值得记住的序列。 Alt + SysRq + r e k 这个序列可以用来重新启动没有响应的 X 服务器。 首先， 使用 Alt + SysRq + r 将键盘从原始模式退出。 然后， 使用 Alt + SysRq + e 请求向所有进程发送 SIGTERM 信号。 如果 X 服务器可以通过此请求重新启动，那么您就已经成功挽救了系统。如果 X 服务器仍然没有响应，则请使用第三个请求， Alt + SysRq + k 向当前虚拟控制台中的所有进程发送 SIGKILL 信号。 如果你的系统在上述操作后仍无响应，你应该继续进行以下操作序列。 Alt + SysRq + r e i s u b 这个命令将启动紧急重启。 – r ：退出 RAW 模式– e ：向所有进程发送 SIGTERM 信号– i ：向所有进程发送 SIGKILL 信号– s ：同步所有已挂载的文件系统– u ：应急重新挂载为只读– b ：立即重启系统 ","date":"2023-08-28","objectID":"/frozen-linux-system/:1:0","tags":["process","linux","dead","sysrq"],"title":"Ways to Deal With a Frozen Linux System","uri":"/frozen-linux-system/"},{"categories":null,"content":" Table of Contents 1 ABSTRACT 2 INTRODUCTION 2.1 AQP 2.2 现有 AQP 的采样对实时处理不太适用 2.3 Aggregated Btree Index 本文为摘录(或转载)，侵删，原文为： ../../attachments/pdf/d/p1835-zhao.pdf ","date":"2023-08-25","objectID":"/p1835-zhao/:0:0","tags":["aqp","近似估计"],"title":"AB-tree: Index for Concurrent Random Sampling and Updates","uri":"/p1835-zhao/"},{"categories":null,"content":"1 ABSTRACT 本文介绍了一种名为 AB-tree 的索引结构，用于高并发随机抽样和更新操作。 实时数据分析需求日益日益增长 近似查询处理（Approximate Query Processing, AQP） 适合用作实时数据分析： 使用随机抽样 通过降低查询延迟，换取一定的准确度。 然而，现有的 AQP 系统: 要么依赖于基于扫描的抽样算法来绘制样本（这仍然可能会产生相当高的表扫描成本）， 要么在预处理阶段中创建数据库样本，这些样本很难更新。 另一种方法是使用聚合 B 树索引来支持数据库中的随机抽样和更新，以对数时间完成。然而，要实现高并发操作，正确且高效地维护聚合权重非常困难，因此目前还未有自然而然的聚合 B 树设计支持高并发随机抽样和更新。 本文通过分析和识别实现高并发的关键挑战，提出了一种支持高并发随机抽样和更新操作的索引结构 AB-tree，并通过广泛的实验展示了其效率和功效。 ","date":"2023-08-25","objectID":"/p1835-zhao/:1:0","tags":["aqp","近似估计"],"title":"AB-tree: Index for Concurrent Random Sampling and Updates","uri":"/p1835-zhao/"},{"categories":null,"content":"2 INTRODUCTION ","date":"2023-08-25","objectID":"/p1835-zhao/:2:0","tags":["aqp","近似估计"],"title":"AB-tree: Index for Concurrent Random Sampling and Updates","uri":"/p1835-zhao/"},{"categories":null,"content":"2.1 AQP 数据量非常大的数据库的实时数据分析中，使用近似查询处理（AQP）变得非常有吸引力，因为遍历整个表或使用索引范围扫描太慢了。AQP 提供了在分析查询中结果准确性和查询延迟之间独特的折衷方案。 AQP 的一个主要方法是在从数据库中抽取的随机样本上估算查询结果。已经有很多工作使用不同的随机分布来为聚合查询提供准确的近似答案，以及设计从多表连接的结果中抽取随机样本的算法。实际上，相对于数据大小，人们可以在次线性甚至恒定的时间内用理论保证逼近简单的聚合查询。 ","date":"2023-08-25","objectID":"/p1835-zhao/:2:1","tags":["aqp","近似估计"],"title":"AB-tree: Index for Concurrent Random Sampling and Updates","uri":"/p1835-zhao/"},{"categories":null,"content":"2.2 现有 AQP 的采样对实时处理不太适用 AQP 技术通常会将样本抽取机制视作黑匣子认为可以通过 SQL 实现或对现有 DBMS 进行小的修改来高效实现。 但如果针对 实时数据 分析进行 AQP，则存在并发数据更新的情况： TABLESAMPLE 操作需要进行线性扫描或使用松弛的统计保证，这对 AQP 来说是不能接受的，特别是对于错误保证无效的系统或块采样。 其他采样技术如分层采样、宇宙采样和不同采样都需要对基表进行全表或索引范围扫描，这会减少 AQP 的好处，特别是当数据存储在外部存储器中时，扫描成为查询成本的主要因素。因此，许多 AQP 系统选择离线抽样，并仅在一段时间后更新它们，使实时分析成为不可行。 ","date":"2023-08-25","objectID":"/p1835-zhao/:2:2","tags":["aqp","近似估计"],"title":"AB-tree: Index for Concurrent Random Sampling and Updates","uri":"/p1835-zhao/"},{"categories":null,"content":"2.3 Aggregated Btree Index 为了支持 AQP 实时数据分析，我们需要在线绘制随机样本的能力，而不需要扫描基础表。 “聚合 B 树”可以在数据规模相对较小的情况下以对数时间在线绘制随机样本。 聚合 B 树是一种带有“子树聚合权重”的 B 树索引，可以用于在线绘制随机样本。 但是，目前还没有已知的方法可以在不锁定整个结构的情况下正确而高效地进行聚合 B 树的并发更新。 这意味着，使用聚合 B 树的 AQP 系统可能： 在很少更新数据的情况下表现良好，但 随着数据更新的增加，其性能会迅速下降。 这个问题的核心是: 每个数据的更新都会涉及到整个树路径上所有内部节点的汇总权值的修改， 这会导致根节点等高层节点的竞争非常激烈。 除此之外，它可能会向并发读者展示不一致的权值视图，导致采样偏差。第二个问题可以通过强制按路径顺序进行权值更新来减轻，但在结构修改操作（SMO，即页面分裂/合并）和采样操作交替进行时，可能仍会严重影响并发性能。不幸的是，现有高性能并发 B 树的设计,（其中大多数争用发生在叶子层，SMO 可以实现为几个原子步骤，可以与其他操作交错）已经不再适用，因为它们的假设完全相反。此外，实际上，现代 DBMS 通常使用的多版本并发控制（MVCC）可以对并发更新下聚合 B 树的随机采样效率产生负面影响，原因是由不可见版本引起的采样拒绝。 ","date":"2023-08-25","objectID":"/p1835-zhao/:2:3","tags":["aqp","近似估计"],"title":"AB-tree: Index for Concurrent Random Sampling and Updates","uri":"/p1835-zhao/"},{"categories":null,"content":"本文为摘录(或转载)，侵删，原文为： attachments/pdf/6/p2134-kim.pdf 本文介绍了一种称为 ABC（Attributed Bipartite Co-clustering 双向联合集聚归因算法）的问题， 它对于一个具有属性的二分图进行聚类。对于二分图的聚类问题是一个重要的基础问题。ABC 将两个重点内容结合起来：（一）二分图模块化优化；（二）属性的内聚性。本文证明了 ABC 是 NP 难的，并且不在 APX 类中，除非 P = NP。本文提出了三种算法：（1）自上而下的算法；（2）自下而上的算法；（3）分组匹配算法。在真实世界的带属性二分图上进行了广泛的实验结果表明，我们的算法具有高效性和有效性。本文的例子包括推荐和反欺诈等实际应用，另外 IEEE PVLDB Vol. 15, No. 10 ISSN 2150-8097， doi：10.14778/3547305.3547318 也被引用。 双向联合集聚归因算法 ","date":"2023-08-25","objectID":"/p2134-kim/:0:0","tags":null,"title":"ABC: Attributed Bipartite Co-clustering 双向联合集聚归因算法","uri":"/p2134-kim/"},{"categories":null,"content":" Table of Contents 1 Historical Context 2 Licensing and Distribution 3 Kernel and System Architecture 4 Community and Development 5 Customization and Flexibility 6 User Interface 7 Market Share and Industry Application 8 Security and Stability 9 Conclusion 本文为摘录(或转载)，侵删，原文为： https://www.linuxjournal.com/content/unix-vs-linux-what-is-the-difference 在复杂多变的操作系统领域里，UNIX 和 Linux 这两个显赫的巨头已经塑造了数字领域数十年。尽管这两个系统乍一看起来很相似，但深入分析后会发现它们存在根本性的区别，这些区别对开发人员、管理员和用户都有着重要的影响。在本文中，我们将踏上一段旅程，揭示 UNIX 和 Linux 之间的微妙差异，阐明它们的历史起源、许可模式、系统架构、社区、用户界面、市场应用、安全范式等方面的情况。 ","date":"2023-08-23","objectID":"/unix-vs-linux-what-is-the-difference/:0:0","tags":["unix","linux","compare"],"title":"UNIX vs Linux: What's the Difference?","uri":"/unix-vs-linux-what-is-the-difference/"},{"categories":null,"content":"1 Historical Context UNIX 是一个操作系统世界的先驱，于上世纪六十年代末在 AT\u0026T Bell 实验室诞生。由 Ken Thompson 和 Dennis Ritchie 领导的团队开发了 UNIX，最初是为研究目的创建的多任务、多用户平台。在随后的几十年中，商业化的努力促使各种专有 UNIX 版本兴起，每个版本都针对特定的硬件平台和行业而调整。 在九十年代初，一位名为 Linus Torvalds 的芬兰计算机科学学生通过开发 Linux 内核引发了开源革命。与主要由供应商控制的 UNIX 不同，Linux 利用协作开发的力量。Linux 的开源性质吸引了来自全球程序员的贡献，引领了快速的创新和多样化版本的创建，每个版本都具有独特的功能和目的。 ","date":"2023-08-23","objectID":"/unix-vs-linux-what-is-the-difference/:1:0","tags":["unix","linux","compare"],"title":"UNIX vs Linux: What's the Difference?","uri":"/unix-vs-linux-what-is-the-difference/"},{"categories":null,"content":"2 Licensing and Distribution UNIX 和 Linux 之间最显著的区别之一在于它们的许可模型。UNIX 是专有的，通常需要许可证来使用和定制。这限制了用户修改和分发系统的范围。 相反，Linux 采用开源许可证，最著名的是 GNU 通用公共许可证（GPL）。这种许可模型赋予用户自由地研究、修改和分发源代码的权力。结果是有大量的 Linux 发行版，满足各种需要，例如方便用户使用的 Ubuntu、注重稳定性的 CentOS 和社区驱动的 Debian。 ","date":"2023-08-23","objectID":"/unix-vs-linux-what-is-the-difference/:2:0","tags":["unix","linux","compare"],"title":"UNIX vs Linux: What's the Difference?","uri":"/unix-vs-linux-what-is-the-difference/"},{"categories":null,"content":"3 Kernel and System Architecture 内核的架构——操作系统的核心——在定义其行为和能力方面起着至关重要的作用。 Unix 系统通常采用单内核架构，这意味着必需的功能，如内存管理、进程调度和硬件驱动程序是紧密集成的。 Linux 也利用单内核架构，但通过可装载内核模块引入了模块化。这使得内核功能可以动态扩展而不需要完全系统重启。此外，Linux 开发的合作性质确保更广泛的硬件支持和适应不断发展变化的技术格局。 ","date":"2023-08-23","objectID":"/unix-vs-linux-what-is-the-difference/:3:0","tags":["unix","linux","compare"],"title":"UNIX vs Linux: What's the Difference?","uri":"/unix-vs-linux-what-is-the-difference/"},{"categories":null,"content":"4 Community and Development 一种成功的操作系统通常具有充满活力的社区。 由于 UNIX 的专有性质，历史上其社区参与有限。开发和更新主要由个别供应商控制，导致对新技术的适应速度较慢。 相比之下，Linux 社区通过开放的协作而繁荣发展。开发人员、爱好者和组织贡献他们的专业知识以增强系统的性能、安全性和可用性。这种合作精神确保 Linux 快速发展，新功能和更新以令人印象深刻的速度推出。 ","date":"2023-08-23","objectID":"/unix-vs-linux-what-is-the-difference/:4:0","tags":["unix","linux","compare"],"title":"UNIX vs Linux: What's the Difference?","uri":"/unix-vs-linux-what-is-the-difference/"},{"categories":null,"content":"5 Customization and Flexibility 操作系统提供的定制级别可以在不同环境下显着影响其可用性。 由于 UNIX 系统的专有实现，通常很少为用户提供定制选项。然而，供应商偶尔会为特定行业量身定制 UNIX 解决方案，例如 IBM 的用于高性能计算的主机。 Linux 的开源性使用户有能力进行广泛的系统定制。这种灵活性对各种应用程序都是一大福音，从在数据中心中运行服务器到为 IoT 设备中的嵌入式系统提供动力。Linux 的适应性使其成为精通技术的用户寻求量身定制解决方案的首选。 ","date":"2023-08-23","objectID":"/unix-vs-linux-what-is-the-difference/:5:0","tags":["unix","linux","compare"],"title":"UNIX vs Linux: What's the Difference?","uri":"/unix-vs-linux-what-is-the-difference/"},{"categories":null,"content":"6 User Interface 用户界面（UI）是用户与操作系统进行交互的门户。 UNIX 系统通常采用命令行界面（CLI）作为主要交互方式。虽然强大，但对于新手来说可能存在学习曲线。 同样，Linux 主要通过 CLI 操作。然而，意识到图形用户界面（GUI）的重要性，Linux 拥有各种桌面环境，例如 GNOME、KDE 和 Xfce。这些界面提高了更广泛的受众的可用性，既满足了命令行爱好者，又为那些寻求更直观体验的用户提供了便利。 ","date":"2023-08-23","objectID":"/unix-vs-linux-what-is-the-difference/:6:0","tags":["unix","linux","compare"],"title":"UNIX vs Linux: What's the Difference?","uri":"/unix-vs-linux-what-is-the-difference/"},{"categories":null,"content":"7 Market Share and Industry Application UNIX 和 Linux 在各行各业中的渗透逐渐发展。 UNIX 曾经是一个占据主导地位的力量，但因为其专有限制而看到市场份额下降。尽管如此，UNIX 仍然是金融和电信等领域的稳定点，因为遗留系统仍然存在。 受开放源代码主义的推动，Linux 在不同的领域中正在取得进展。它已经成为网页服务器的基础，驱动着互联网的支柱。此外，Linux 的成本效益和多功能性使其成为云计算环境的首选之一。 ","date":"2023-08-23","objectID":"/unix-vs-linux-what-is-the-difference/:7:0","tags":["unix","linux","compare"],"title":"UNIX vs Linux: What's the Difference?","uri":"/unix-vs-linux-what-is-the-difference/"},{"categories":null,"content":"8 Security and Stability 在操作系统领域，安全性和稳定性至关重要。 UNIX 由于其受控环境和厂商的责任而通常被认为更加安全，其在关键系统中的可靠性历史悠久。 Linux 采用开源开发模式，通过全球社区的持续审查来优先考虑安全性。漏洞得到迅速解决，安全更新得到及时分发。Linux 开发的协作性质有助于其强大的安全态势，甚至可以与 UNIX 等专有系统相媲美。 ","date":"2023-08-23","objectID":"/unix-vs-linux-what-is-the-difference/:8:0","tags":["unix","linux","compare"],"title":"UNIX vs Linux: What's the Difference?","uri":"/unix-vs-linux-what-is-the-difference/"},{"categories":null,"content":"9 Conclusion 在我们结束对 UNIX 和 Linux 的探索时，我们惊叹于所定义的巨大差异。 UNIX 以其专有的遗产继续影响需要坚实表现的行业。相比之下，Linux 的开源基础引领了新时代的协作、灵活性和创新。要做出明智的 UNIX 和 Linux 选择，关键在于了解它们各自的优缺点，以及它们如何与您的技术需求相一致。随着这两个系统不断发展，没有比现在更好的时间深入探讨操作系统和它们所提供的无限可能性了。 UNIX 和 Linux 的不断演化证明了创新和协作的持久力量。虽然 UNIX 为现代操作系统奠定了基础，但 Linux 利用开源哲学的潜力使软件开发民主化。随着我们在越来越复杂的数字景观中穿行，通过 UNIX 和 Linux 的旅程提醒人们技术的变革性质和难以限量的潜力。 ","date":"2023-08-23","objectID":"/unix-vs-linux-what-is-the-difference/:9:0","tags":["unix","linux","compare"],"title":"UNIX vs Linux: What's the Difference?","uri":"/unix-vs-linux-what-is-the-difference/"},{"categories":null,"content":" Table of Contents 1 什么是 HTAP？ 2 HTAP 架构模式有哪些？ 2.1 IN-Memory Store 模式 2.2 主备架构模式 2.3 IN-Memory Computing 模式 2.4 主列存+增量行存模式 3 思考 3.1 GaussDB 对 HTAP 的思考 4 GaussDB 在 HTAP 上的创新 本文为摘录(或转载)，侵删，原文为： https://mp.weixin.qq.com/s?__biz=MzU2MDcxODEyOA==\u0026mid=2247516317\u0026idx=1\u0026sn=1ce041534c61c34cd1ab12d90df7c1d6\u0026chksm=fc0108c2cb7681d4be8d3c1fdb3a10662ad10562288d149c964e8a3f99b3d8cbeb804039be2a\u0026mpshare=1\u0026scene=1\u0026srcid=0822kXJqkOrYaspzxxbWHkai\u0026sharer_sharetime=1692699939078\u0026sharer_shareid=9e76a16cd9cee4d8b92e9f0cc7b3921c#rd ","date":"2023-08-22","objectID":"/gaussdb%E6%8A%80%E6%9C%AF%E8%A7%A3%E8%AF%BB%E7%B3%BB%E5%88%97%E4%B9%8Bhtap%E6%96%B9%E5%90%91%E7%9A%84%E6%8E%A2%E7%B4%A2%E4%B8%8E%E5%8F%91%E5%B1%95/:0:0","tags":["guassdb","htap"],"title":"GaussDB技术解读系列之HTAP方向的探索与发展","uri":"/gaussdb%E6%8A%80%E6%9C%AF%E8%A7%A3%E8%AF%BB%E7%B3%BB%E5%88%97%E4%B9%8Bhtap%E6%96%B9%E5%90%91%E7%9A%84%E6%8E%A2%E7%B4%A2%E4%B8%8E%E5%8F%91%E5%B1%95/"},{"categories":null,"content":"1 什么是 HTAP？ TP 和 AP 的特点 TP 一般是做交易型的业务， 它的数据量通常来说比较小，在 GB~TB 的范围内， 它要求低时延、高吞吐，同时对高可用、故障恢复要求较高。 AP 一般用于对历史数 据做分析，根据数据分析的结论为企业的商业决策提供一些支撑，因此 AP 对时延和吞吐的要求没有 那么高， 主要面对数据量大、查询偏复杂的场景。 2010 年左右，业内开始考虑把 TP 和 AP 同时融合到同一个数据库里，通过这种 方式提升数据库处理数据的能力 总结了 HTAP 有两个关键特点: 一个是采用 In-Memory 的架构。 我们可以看到，无论是老牌的数据库厂商，还是新兴的数据库厂商，都不约而同采用 In-Memory 的架构来实现 HTAP。 另外一个是实时。 我们当前的架构主要是，交易型的业务在行存的数据库上，分析型的业务在列存的数仓上，中间通过 ETL 工具传输数据。这个架构的问题是，它的数据新鲜度不够好，比如说先前在互联网应用方面，我们经常做一些个性化的用户推荐，在给用户推荐感兴趣的商品时，会在登录时对它进行一个用户画像，根据用户画像的结果推荐产品，这是一种实时分析的能力。另外就是防诈骗系统，需要实时的响应，实时分析这笔交易是否为诈骗交易。这种实时性的特点，对 HTAP 方案提出了新的要求。我们当前的 HTAP 架构主要应对实时 AP 分析的能力，实时 AP 对性能上有一些影响，它随着数据新鲜度，也就是实时性要求变高，数据库的性能会有一些下降。 ","date":"2023-08-22","objectID":"/gaussdb%E6%8A%80%E6%9C%AF%E8%A7%A3%E8%AF%BB%E7%B3%BB%E5%88%97%E4%B9%8Bhtap%E6%96%B9%E5%90%91%E7%9A%84%E6%8E%A2%E7%B4%A2%E4%B8%8E%E5%8F%91%E5%B1%95/:1:0","tags":["guassdb","htap"],"title":"GaussDB技术解读系列之HTAP方向的探索与发展","uri":"/gaussdb%E6%8A%80%E6%9C%AF%E8%A7%A3%E8%AF%BB%E7%B3%BB%E5%88%97%E4%B9%8Bhtap%E6%96%B9%E5%90%91%E7%9A%84%E6%8E%A2%E7%B4%A2%E4%B8%8E%E5%8F%91%E5%B1%95/"},{"categories":null,"content":"2 HTAP 架构模式有哪些？ ","date":"2023-08-22","objectID":"/gaussdb%E6%8A%80%E6%9C%AF%E8%A7%A3%E8%AF%BB%E7%B3%BB%E5%88%97%E4%B9%8Bhtap%E6%96%B9%E5%90%91%E7%9A%84%E6%8E%A2%E7%B4%A2%E4%B8%8E%E5%8F%91%E5%B1%95/:2:0","tags":["guassdb","htap"],"title":"GaussDB技术解读系列之HTAP方向的探索与发展","uri":"/gaussdb%E6%8A%80%E6%9C%AF%E8%A7%A3%E8%AF%BB%E7%B3%BB%E5%88%97%E4%B9%8Bhtap%E6%96%B9%E5%90%91%E7%9A%84%E6%8E%A2%E7%B4%A2%E4%B8%8E%E5%8F%91%E5%B1%95/"},{"categories":null,"content":"2.1 IN-Memory Store 模式 这种模式在同一个集群内对行存引擎做了增强，用空间换时间，在内存里保存一份列存数据，我们可以把他看成是一个列存索引，这种架构下的数据新鲜度比较好，行存和列存的数据完全同步，在行存和列存中间，会有一个 Delta 表记录增删改操作带来的增量数据，后台有进程定期将 Delta 表里的数据 Merge 到列存引擎。 但是这种架构的扩展性一般，资源的隔离性不佳，能够支撑的列存的数据量也是有限度的， 因此这种架构适用于 TP 为主，实时 AP 为辅的业务模型。 ","date":"2023-08-22","objectID":"/gaussdb%E6%8A%80%E6%9C%AF%E8%A7%A3%E8%AF%BB%E7%B3%BB%E5%88%97%E4%B9%8Bhtap%E6%96%B9%E5%90%91%E7%9A%84%E6%8E%A2%E7%B4%A2%E4%B8%8E%E5%8F%91%E5%B1%95/:2:1","tags":["guassdb","htap"],"title":"GaussDB技术解读系列之HTAP方向的探索与发展","uri":"/gaussdb%E6%8A%80%E6%9C%AF%E8%A7%A3%E8%AF%BB%E7%B3%BB%E5%88%97%E4%B9%8Bhtap%E6%96%B9%E5%90%91%E7%9A%84%E6%8E%A2%E7%B4%A2%E4%B8%8E%E5%8F%91%E5%B1%95/"},{"categories":null,"content":"2.2 主备架构模式 这种模式下主机上是行存模式，应对 TP 业务负载，在只读的备机上是列存模式，应对 AP 的业务负载，主备之间通过物理复制或逻辑复制的方式实现数据同步。 这种方式的扩展性、资源隔离性都比较好， 但是数据的新鲜度取决于主备之间的数据传输模式，如果采用同步复制，则主备的数据新鲜度较好，但是对主机的事务吞吐量会有所影响；如果采用异步复制模式，则主备的数据新鲜度取决于数据的延迟。 ","date":"2023-08-22","objectID":"/gaussdb%E6%8A%80%E6%9C%AF%E8%A7%A3%E8%AF%BB%E7%B3%BB%E5%88%97%E4%B9%8Bhtap%E6%96%B9%E5%90%91%E7%9A%84%E6%8E%A2%E7%B4%A2%E4%B8%8E%E5%8F%91%E5%B1%95/:2:2","tags":["guassdb","htap"],"title":"GaussDB技术解读系列之HTAP方向的探索与发展","uri":"/gaussdb%E6%8A%80%E6%9C%AF%E8%A7%A3%E8%AF%BB%E7%B3%BB%E5%88%97%E4%B9%8Bhtap%E6%96%B9%E5%90%91%E7%9A%84%E6%8E%A2%E7%B4%A2%E4%B8%8E%E5%8F%91%E5%B1%95/"},{"categories":null,"content":"2.3 IN-Memory Computing 模式 这种模式将列式内存引擎和数据库对接，由数据库负责 TP 业务，列式内存引擎负责 AP 业务。 由于其部署在云上，因此有很好的计算弹性，数据库和列式内存引擎之间通过逻辑复制同步数据，数据的延迟小于 100ms，能够较好的兼顾数据新鲜度和性能之间的平衡。 ","date":"2023-08-22","objectID":"/gaussdb%E6%8A%80%E6%9C%AF%E8%A7%A3%E8%AF%BB%E7%B3%BB%E5%88%97%E4%B9%8Bhtap%E6%96%B9%E5%90%91%E7%9A%84%E6%8E%A2%E7%B4%A2%E4%B8%8E%E5%8F%91%E5%B1%95/:2:3","tags":["guassdb","htap"],"title":"GaussDB技术解读系列之HTAP方向的探索与发展","uri":"/gaussdb%E6%8A%80%E6%9C%AF%E8%A7%A3%E8%AF%BB%E7%B3%BB%E5%88%97%E4%B9%8Bhtap%E6%96%B9%E5%90%91%E7%9A%84%E6%8E%A2%E7%B4%A2%E4%B8%8E%E5%8F%91%E5%B1%95/"},{"categories":null,"content":"2.4 主列存+增量行存模式 通过主列存+增量行存的方式既能够较好的支撑 TP 业务，也能够应对 AP 业务，在 TP/AP 性能上做了一些均衡。其中增量行存可以看做是 delta 表，应对 TP 中的增删改操作，保证增删改操作的性能和 TP 系统基本一致，同时通过主列存引擎对 AP 业务进行加速，当然在做 AP 业务时，会同时访问增量数据和列存数据，达成数据的一致性。 ","date":"2023-08-22","objectID":"/gaussdb%E6%8A%80%E6%9C%AF%E8%A7%A3%E8%AF%BB%E7%B3%BB%E5%88%97%E4%B9%8Bhtap%E6%96%B9%E5%90%91%E7%9A%84%E6%8E%A2%E7%B4%A2%E4%B8%8E%E5%8F%91%E5%B1%95/:2:4","tags":["guassdb","htap"],"title":"GaussDB技术解读系列之HTAP方向的探索与发展","uri":"/gaussdb%E6%8A%80%E6%9C%AF%E8%A7%A3%E8%AF%BB%E7%B3%BB%E5%88%97%E4%B9%8Bhtap%E6%96%B9%E5%90%91%E7%9A%84%E6%8E%A2%E7%B4%A2%E4%B8%8E%E5%8F%91%E5%B1%95/"},{"categories":null,"content":"3 思考 我们有了这么多模式之后，可以思考两个问题。一个是到底什么样的架构才是真正的 HTAP 架构？我个人的观点是没有适合的定义，因为在不同的业务场景下，TP 和 AP 的占比不一样，包括周边各种环境，各种因素都不同，每个用户的选择也会不一样。包括我们在 HTAP 研发过程中接触到很多用户，每个用户都提出很多要求，像 Orcale 这种架构更适合重 TP、轻 AP 的场景，而 HANA 这种架构更多是做偏 AP 分析型的应用。如果我们以 TP、AP 业务占比做一个横轴的话，每个架构在上面都有一个独立的坐标点。 另外一个问题，我们当前这些 HTAP 的主流架构能不能取代以前的那种 TP+ETL+AP 的架构？从目前看，如果我们把 HTAP 定义为实时 TP+实时 AP，实际上是不能取代的，因为 TP+ETL+AP 这种架构，AP 的数据量远远大于当前 HTAP 的主流架构所能支撑的 AP 数据量。 ","date":"2023-08-22","objectID":"/gaussdb%E6%8A%80%E6%9C%AF%E8%A7%A3%E8%AF%BB%E7%B3%BB%E5%88%97%E4%B9%8Bhtap%E6%96%B9%E5%90%91%E7%9A%84%E6%8E%A2%E7%B4%A2%E4%B8%8E%E5%8F%91%E5%B1%95/:3:0","tags":["guassdb","htap"],"title":"GaussDB技术解读系列之HTAP方向的探索与发展","uri":"/gaussdb%E6%8A%80%E6%9C%AF%E8%A7%A3%E8%AF%BB%E7%B3%BB%E5%88%97%E4%B9%8Bhtap%E6%96%B9%E5%90%91%E7%9A%84%E6%8E%A2%E7%B4%A2%E4%B8%8E%E5%8F%91%E5%B1%95/"},{"categories":null,"content":"3.1 GaussDB 对 HTAP 的思考 在 GaussDB HTAP 开发过程中，我们总结了以下实现 HTAP 架构需要关注的核心技术： 3.1.1 第一，透明路由。 它之所以成为关键的原因是因为增加了客户的易用性，提升了 HTAP 产品的商用价值。这里面有两个观点，一个是如果 HTAP 基于行存和冗余列存这种方式，需要判断哪些数据被冗余到列存里面来，因此提供一种自动化的方法根据业务特点来选择加载列存数据，并对用户透明就非常有意义。另外，TP 业务要路由到行存引擎，AP 业务路由到列存引擎，目前大部分架构还需要通过 Hint 的方式来实现业务分流，如果借助优化器的代价系统、以及当前的 AI4DB 技术，能够更大程度的提供业务分流的准确性，从而对用户透明，提高系统的易用性。 3.1.2 第二，性能提升。 我们把 TP 和 AP 融合起来比较困难的关键原因，主要是因为 AP 查询的复杂度比较高。如果是一个纯 TP 数据库，一些常规执行优化技术，比如说并行、编译执行、向量化执行，TP 上虽然也有，但实际上很难有大的作为，因为 TP 要求的是低时延、高吞吐，这种情况下这些技术都有自己的启动代价，这些启动代价会对 TP 的性能产生很大的影响。在 TP 上，如果我们把 HTAP 里面的 AP 融入进来，这些技术就能大有可为，我们在这些技术的基础上对复杂查询进行加速，可以很好地支撑我们现在的性能，支撑我们的 HTAP。 3.1.3 第三，数据新鲜度。 我们多次讨论实时性的问题，不同的数据新鲜度最后带来的就是我们不同的架构，有 In-Memory 的，有主备的，也有基于增量表技术的，都会带来不同的数据新鲜度。在这种数据新鲜度下，我们怎么保证数据新鲜度高，而且性能又好。在这些方面我们需要更多的思考，来保证我们 HTAP 架构能够具备更多应对用户的能力。 3.1.4 第四，资源隔离。 我们看到有的架构，比如说用户对 TP 性能要求比较高，要求你在引入实时 AP 的同时，不能影响 TP 的能力和性能。也有用户提出对整体的能力要求，对硬件没有什么诉求，如果有需要可以增加硬件。不同的用户有不同的要求，我们在面对这样的用户时，需要在资源隔离和数据新鲜度，以及性能的提升方面做好权衡。 ","date":"2023-08-22","objectID":"/gaussdb%E6%8A%80%E6%9C%AF%E8%A7%A3%E8%AF%BB%E7%B3%BB%E5%88%97%E4%B9%8Bhtap%E6%96%B9%E5%90%91%E7%9A%84%E6%8E%A2%E7%B4%A2%E4%B8%8E%E5%8F%91%E5%B1%95/:3:1","tags":["guassdb","htap"],"title":"GaussDB技术解读系列之HTAP方向的探索与发展","uri":"/gaussdb%E6%8A%80%E6%9C%AF%E8%A7%A3%E8%AF%BB%E7%B3%BB%E5%88%97%E4%B9%8Bhtap%E6%96%B9%E5%90%91%E7%9A%84%E6%8E%A2%E7%B4%A2%E4%B8%8E%E5%8F%91%E5%B1%95/"},{"categories":null,"content":"4 GaussDB 在 HTAP 上的创新 GaussDB 在现有基础上对 HTAP 进行改造，并实现以下几个方面的提升： – 性能提升数十倍。GaussDB 已经实现向量化、并行、编译技术，性能提升 10+倍，一些场景下还有更高的性能提升。最近我们基于 HTAP 做了更深度的挖掘和优化，比如基于降低内存拷贝、延迟读等技术，向量化的扫描算子最新的数据又提升了大概 30 倍左右。 – 100%的透明路由。我们既有基于 Hint 手工指定的方式，还有基于规则、基于代价、基于 AI 的透明路由技术。我们在基于代价的透明度路由方面，做了向量化优化技术；基于 AI 的透明路由方面，我们通过轻量的 AI 技术可以真正应用到商业版中，通过这些技术，TP、AP 分流的准确率目前表现还是不错的。 – 100%的数据新鲜度。我们实现了在同 Server 内的列式的内存引擎，数据同步方面支持实时同步、在线同步、定期同步，保证了 TP 上的数据和 IUD 操作带来的数据修改及时同步到引擎上，可以实现 100%的数据新鲜度。 – 100%的资源隔离。如果用户更关注的是 100%的资源隔离，我们也提供了基于主备复制 HTAP 模式，通过读写分离，把 TP 业务放到主机上，AP 业务放到备机上，实现资源的隔离。 目前，GaussDB 既有基于同 Server 的实时的 HTAP，也有基于主备技术的准实时的 HTAP，同时在透明路由的加持下，能够准确的把业务分流同步分到实时的 HTAP 上，达成在性能、资源隔离、数据新鲜度方面有一个均衡的结果。 ","date":"2023-08-22","objectID":"/gaussdb%E6%8A%80%E6%9C%AF%E8%A7%A3%E8%AF%BB%E7%B3%BB%E5%88%97%E4%B9%8Bhtap%E6%96%B9%E5%90%91%E7%9A%84%E6%8E%A2%E7%B4%A2%E4%B8%8E%E5%8F%91%E5%B1%95/:4:0","tags":["guassdb","htap"],"title":"GaussDB技术解读系列之HTAP方向的探索与发展","uri":"/gaussdb%E6%8A%80%E6%9C%AF%E8%A7%A3%E8%AF%BB%E7%B3%BB%E5%88%97%E4%B9%8Bhtap%E6%96%B9%E5%90%91%E7%9A%84%E6%8E%A2%E7%B4%A2%E4%B8%8E%E5%8F%91%E5%B1%95/"},{"categories":null,"content":" Table of Contents 1 Lock out user after three failed login attempts 本文为摘录(或转载)，侵删，原文为： https://wiki.archlinux.org/title/Security#Lock_out_user_after_three_failed_login_attempts ","date":"2023-08-21","objectID":"/security%23lock_out_user_after_three_failed_login_attempts/:0:0","tags":["lock","deny","security"],"title":"Lock out user after three failed login attempts","uri":"/security%23lock_out_user_after_three_failed_login_attempts/"},{"categories":null,"content":"1 Lock out user after three failed login attempts 截至 pambase 20200721.1-2 版本，pam_faillock.so 已默认启用，当用户在 15 分钟内尝试 3 次登录失败后会将其锁定 10 分钟（参见 FS＃67644）。锁定仅适用于密码验证（例如登录和 sudo），通过 SSH 的公钥验证仍然被接受。为了防止完全的拒绝服务，对于默认情况下 root 用户将不会被锁定。 要解除用户的锁定，请执行以下操作： $ faillock –user username –reset 默认情况下，锁定机制是每个用户一个文件，位于 /run/faillock/。删除或清空文件将解锁该用户——该目录由 root 拥有，但文件由用户拥有，因此 faillock 命令仅清空文件，因此不需要 root。 模块 pam_faillock.so 可以通过文件 /etc/security/faillock.conf 进行配置。锁定参数如下： unlock_time —— 锁定时间（秒为单位，默认为 10 分钟） fail_interval —— 允许登录失败引起锁定的时间（以秒为单位，默认值为 15 分钟） deny —— 锁定之前的登录失败次数（默认值为 3） 提示：锁定的主要目的是放慢暴力攻击的速度，使其变得不可行。因此，如果由于密码输错而导致锁定过于频繁，则可以放宽尝试次数以而不是减少锁定时间。 注意：deny = 0 将完全禁用锁定机制。 默认情况下，所有用户锁定在重新启动后都会失效。如果攻击者可以重新启动计算机，则使锁定持续存在更为安全。要使锁定持久存在，请将/etc/security/faillock.conf 中的 dir 参数更改为 /var/lib/faillock。 更改不需要重新启动即可生效。请参阅 faillock.conf(5) 以获取更多配置选项，例如启用 root 帐户的锁定，禁用集中登录（例如 LDAP）等。 ","date":"2023-08-21","objectID":"/security%23lock_out_user_after_three_failed_login_attempts/:1:0","tags":["lock","deny","security"],"title":"Lock out user after three failed login attempts","uri":"/security%23lock_out_user_after_three_failed_login_attempts/"},{"categories":null,"content":"本文为摘录(或转载)，侵删，原文为： https://devblogs.microsoft.com/oldnewthing/20230817-00/?p=108611 C++中的 shared_ptr 管理一个引用计数指针。通常情况下，它是一个指向对象的指针，当最后一个引用过期时将被删除。但它不一定非得是这样。 回想一下， shared_ptr 实际上是两个指针。 指向一个控制块 (control block)的指针，该控制块管理共享和弱引用计数，并在共享引用计数降至零时销毁一个对象（通常称为被管理的对象）。 从 get() 方法返回的指针，通常称为存储指针。 大多数情况下，存储的指针指向托管对象，因为当你使用原始指针构造 shared_ptr 或者调用 make_shared 时，得到的就是托管对象。但是，当托管对象和存储的指针不同的时候，有什么用处呢？ 可能会希望有一个 shared_ptr ，其 get() 方法返回另一个大对象的子对象的指针。在这种情况下，托管对象是较大的对象，而存储的指针是指向子对象的指针。 struct Sample { int value1; int value2; }; void consume(std::shared_ptr\u003cint\u003e pint); std::shared_ptr\u003cSample\u003e p = std::make_shared\u003cSample\u003e(); consume(std::shared_ptr\u003cint\u003e(p, \u0026p-\u003evalue1)); // 或者更简洁地 auto p = std::make_shared\u003cSample\u003e(); consume({p, \u0026p-\u003evalue1}); 在上面的例子中，我们有一个名为 Sample 的类，其中有两个成员。我们创建了一个 shared_ptr 指向该类，并将其保存在 p 中。但是假设还有另一个函数需要一个 shared_ptr\u003cint\u003e 。没问题，我们可以通过重新使用控制块（参数 p）并替换新的存储指针（参数 \u0026p-\u003evalue1 ）来将 std::shared_ptr\u003cSample\u003e 转换为 std::shared_ptr\u003cint\u003e 。consume 函数可以使用 shared_ptr\u003cint\u003e 访问 value1 成员，并且该 shared_ptr\u003cint\u003e 的控制块防止了 Sample 被销毁，从而防止了 value1 被销毁。 这里使用了 C++-20 新增的构造函数 – 别名构造函数 ： shared_ptr( std::nullptr_t ptr, Deleter d, Alloc alloc ); template\u003c class Y \u003e (8) shared_ptr( const shared_ptr\u003cY\u003e\u0026 r, element_type* ptr ) noexcept; template\u003c class Y \u003e (8) (since C++20) shared_ptr( shared_ptr\u003cY\u003e\u0026\u0026 r, element_type* ptr ) noexcept; The aliasing constructor: constructs a shared_ptr which shares ownership information with the initial value of r, but holds an unrelated and unmanaged pointer ptr. If this shared_ptr is the last of the group to go out of scope, it will call the stored deleter for the object originally managed by r. However, calling get() on this shared_ptr will always return a copy of ptr. It is the responsibility of the programmer to make sure that this ptr remains valid as long as this shared_ptr exists, such as in the typical use cases where ptr is a member of the object managed by r or is an alias (e.g., downcast) of r.get() For the second overload taking an rvalue, r is empty and r.get() == nullptr after the call. (since C++20) 别名构造函数： 构造一个 shared_ptr ，与初始值 r 共享所有权信息，但持有一个无关且未被管理的指针 ptr。如果这个 shared_ptr 是组中最后一个超出作用域的对象，它将调用 r 最初管理的对象的存储删除器。然而，在这个 shared_ptr 上调用 get()将始终返回 ptr 的拷贝。程序员负责确保在 shared_ptr 存在期间 ptr 保持有效，例如，在 ptr 是 r 所管理的对象的成员或者是 r.get() 的别名（例如下转型）的典型用例中。对于接受 rvalue 的第二个重载函数，调用之后 r 为空，r.get() == nullptr。（自 C++20 起） 通常情况下，储存的指针的生命周期应该包含在管理对象的生命周期内。这可以是一个直接的包含关系，就像我们在 value1 中所做的那样，也可以是一个更复杂的生命周期依赖链。 struct Other { int value; }; struct Sample2 { const std::unique_ptr\u003cOther\u003e m_other = std::make_unique\u003cOther\u003e(); }; auto p = std::make_shared\u003cSample2\u003e(); consume({p, \u0026p-\u003em_other-\u003evalue}); 在第二个例子中，我们传递给 consume()函数的 shared_ptr\u003cint\u003e的存储指针指向 Sample2 对象内部的 value 成员，而 Sample2 对象包含一个独有指针指向 Other 对象。该 shared_ptr\u003cint\u003e中的控制块控制着 Sample2 对象的生命周期，这是可以接受的，因为只要 Sample2 对象存活，Other 对象中的值也将保持存活。 现在，编译器不会检查您是否具有从托管对象到存储指针的正向生命周期控制链。您可以做一些愚蠢的事情，比如 struct Sample3 { std::unique_ptr\u003cOther\u003e m_other = std::make_unique\u003cOther\u003e(); }; auto p = std::make_shared\u003cSample3\u003e(); consume({ p, \u0026p-\u003em_other-\u003evalue }); p-\u003em_other = nullptr; // 糟糕，链条断了 shared_ptr\u003cint\u003e 将认为它仍在保持值的活动状态，即使您断开了从 Sample3 到 Other 的链接。 或者你可以做更愚蠢的事情，比如 int unrelated; consume({ p, \u0026unrelated }); shared_ptr\u003cint\u003e 将访问 unrelated，即使它的生命周期与 Sample2 无关。如果 unrelated 被销毁，shared_ptr\u003cint\u003e 将具有一个悬空的存储指针。 这些其中托管对象与所指对象不同的 shared_ptr 对象通常被称为别名共享指针。 好的，所以我展示了一种创建别名共享指针的方法，即通过从现有的 shared_ptr 构造一个 shared_ptr（共享托管对象），并提供一个不同的存储指针。如果新的存储指针指向原始对象的基类，则 shared_ptr 具有一个转换运算符，用于创建对基类子对象的别名共享指针。 struct Base { }; struct Derived : Base { }; std::shared_ptr\u003cDerived\u003e p = std::make_shared\u003cDerived\u003e(); std::shared_ptr\u003cBase\u003e b = p; // 自动转换等效于 std::shared_ptr\u003cBase\u003e b(p, p.get()); 如果要进行反向转换（从 Base 到 Derived），可以显式写出： std::shared_ptr\u003cDerived\u003e b(p, static_cast\u003cDerived/\u003e(p.get())); 当然，这需要存储的 Base 指针确实是较大的 Derived 对象的 Base 部分的指针。 C++ 语言提供了一些助手函数，通过对另一个 shared_ptr 的存储指针进行转换来构造一个 shared_ptr 。 一切看起来都很好，直到我们看到 dynamic_pointer_cast ，它与使用 dynamic_cast 的一行代码不等价！ 原因是，与其他转换不同， dynamic_cast 可以将非空指针更改为空指针，这在运行时类型不匹配时发生。在这种情况下， dynamic_pointer_case 返回一个空的 shared_ptr （而不是一个具有控","date":"2023-08-18","objectID":"/p108611/:0:0","tags":["cpp","shared-ptr","lang"],"title":"What it means when you convert between different shared_ptrs - The Old New Thing","uri":"/p108611/"},{"categories":null,"content":" Table of Contents 1 Background 2 Shell Files and Interpreter Invocation 2.1 File Extensions 2.2 SUID/SGID 3 Environment 3.1 STDOUT vs STDERR 4 Comments 4.1 File Header 4.2 Function Comments 4.3 Implementation Comments 4.4 TODO Comments 5 Formatting 5.1 Indentation 5.2 Line Length and Long Strings 5.3 Pipelines 5.4 Loops 5.5 Case statement 5.6 Variable expansion 5.7 Quoting 6 Features and Bugs 6.1 ShellCheck 6.2 Command Substitution 6.3 Test, [ … ], and \\[\\[ … \\]\\] 6.4 Testing Strings 6.5 Wildcard Expansion of Filenames 6.6 Eval 6.7 Arrays 6.8 Pipes to While 6.9 Arithmetic 7 Naming Conventions 7.1 Function Names 7.2 Variable Names 7.3 Constants and Environment Variable Names 7.4 Source Filenames 7.5 Read-only Variables 7.6 Use Local Variables 7.7 Function Location 7.8 main 8 Calling Commands 8.1 Checking Return Values 8.2 Builtin Commands vs. External Commands 9 Conclusion 本文为摘录(或转载)，侵删，原文为： https://google.github.io/styleguide/shellguide.html ","date":"2023-08-17","objectID":"/shellguide/:0:0","tags":["google","style","shell","bash"],"title":"google shell style guide | Style guides for Google-originated open-source projects","uri":"/shellguide/"},{"categories":null,"content":"1 Background Bash is the only shell scripting language permitted for executables. ","date":"2023-08-17","objectID":"/shellguide/:1:0","tags":["google","style","shell","bash"],"title":"google shell style guide | Style guides for Google-originated open-source projects","uri":"/shellguide/"},{"categories":null,"content":"2 Shell Files and Interpreter Invocation ","date":"2023-08-17","objectID":"/shellguide/:2:0","tags":["google","style","shell","bash"],"title":"google shell style guide | Style guides for Google-originated open-source projects","uri":"/shellguide/"},{"categories":null,"content":"2.1 File Extensions 可执行文件: 应该没有扩展名（强烈推荐）, 或者使用 .sh 扩展名。 库文件: 必须使用 .sh 扩展名，且 不应该是可执行 的。 在执行一个程序时，不需要知道它使用的是哪种语言， 而且 shell 不需要扩展名，所以我们更倾向于不给可执行文件使用扩展名。 然而，对于库文件，知道使用的是哪种语言很重要， 有时候需要使用不同语言的相似库文件。这样，具有相同功能但不同语言的库文件可以有相同的文件名，只是在文件名末尾加上特定于语言的后缀。 ","date":"2023-08-17","objectID":"/shellguide/:2:1","tags":["google","style","shell","bash"],"title":"google shell style guide | Style guides for Google-originated open-source projects","uri":"/shellguide/"},{"categories":null,"content":"2.2 SUID/SGID 在 shell 脚本中禁止使用 SUID 和 SGID。 由于 shell 存在许多安全问题，几乎不可能足够安全地使用 SUID/SGID。虽然 bash 确实使得运行 SUID 变得困难，但在某些平台上仍然有可能实现，这就是为什么我们明确禁止使用它的原因。 如果需要提供特权访问，请使用 sudo。 ","date":"2023-08-17","objectID":"/shellguide/:2:2","tags":["google","style","shell","bash"],"title":"google shell style guide | Style guides for Google-originated open-source projects","uri":"/shellguide/"},{"categories":null,"content":"3 Environment ","date":"2023-08-17","objectID":"/shellguide/:3:0","tags":["google","style","shell","bash"],"title":"google shell style guide | Style guides for Google-originated open-source projects","uri":"/shellguide/"},{"categories":null,"content":"3.1 STDOUT vs STDERR 所有错误信息都应该发送到 STDERR 。这样可以更容易区分正常状态和实际问题。 建议创建一个函数，用于打印错误信息以及其他状态信息。 err() { echo \"[$(date +'%Y-%m-%dT%H:%M:%S%z')]: $*\" \u003e\u00262 } if ! do_something; then err \"Unable to do_something\" exit 1 fi ","date":"2023-08-17","objectID":"/shellguide/:3:1","tags":["google","style","shell","bash"],"title":"google shell style guide | Style guides for Google-originated open-source projects","uri":"/shellguide/"},{"categories":null,"content":"4 Comments ","date":"2023-08-17","objectID":"/shellguide/:4:0","tags":["google","style","shell","bash"],"title":"google shell style guide | Style guides for Google-originated open-source projects","uri":"/shellguide/"},{"categories":null,"content":"4.1 File Header 每个文件都要以其内容的描述开始。 每个文件必须包含一个顶级注释，其中包含其内容的简要概述。版权声明和作者信息是可选的。 示例: #!/bin/bash # # Perform hot backups of Oracle databases. ","date":"2023-08-17","objectID":"/shellguide/:4:1","tags":["google","style","shell","bash"],"title":"google shell style guide | Style guides for Google-originated open-source projects","uri":"/shellguide/"},{"categories":null,"content":"4.2 Function Comments 任何不明显且不简短的函数必须注释。 无论长度或复杂性如何，库中的每个函数都必须注释。 通过阅读注释（和提供的自助信息）而无需阅读代码，他人应能够了解如何使用您的程序或使用库中的函数。 所有函数的注释应描述预期的 API 行为，包括： 函数的描述。 全局变量：使用和修改的全局变量列表。 参数：接受的参数。 输出：STDOUT 或 STDERR 的输出。 返回值：除最后一条运行命令的默认退出状态之外的返回值。 Example: ####################################### # Cleanup files from the backup directory. # Globals: # BACKUP_DIR # ORACLE_SID # Arguments: # None ####################################### function cleanup() { … } ","date":"2023-08-17","objectID":"/shellguide/:4:2","tags":["google","style","shell","bash"],"title":"google shell style guide | Style guides for Google-originated open-source projects","uri":"/shellguide/"},{"categories":null,"content":"4.3 Implementation Comments 对复杂、不明显、有趣或重要的部分加以注释 这遵循了注释的一般惯例。不要对每个地方都进行评论。如果有复杂的算法或者你正在做一些与平常不同的事情，可以简短地加上注释。 ","date":"2023-08-17","objectID":"/shellguide/:4:3","tags":["google","style","shell","bash"],"title":"google shell style guide | Style guides for Google-originated open-source projects","uri":"/shellguide/"},{"categories":null,"content":"TODO 4.4 Comments 对于临时的、短期的解决方案或者是足够好但不完美的代码，请使用 TODO 注释。 这与 C++指南的约定一致。 TODO 应该包含全大写的 TODO 字符串，后面跟着在此问题上有最好理解背景的人的名字、电子邮件地址或其他标识符。主要目的是拥有一致的 TODO，可以通过搜索找到如何根据请求获取更多细节的方法。TODO 并不是一个承诺，指定的人会解决这个问题。因此，当您创建一个 TODO 时，通常会使用您自己的名字。 # TODO(mrmonkey): Handle the unlikely edge cases (bug ####) ","date":"2023-08-17","objectID":"/shellguide/:4:4","tags":["google","style","shell","bash"],"title":"google shell style guide | Style guides for Google-originated open-source projects","uri":"/shellguide/"},{"categories":null,"content":"5 Formatting 在修改文件时，应遵循已有的样式，但以下规定适用于任何新代码。 ","date":"2023-08-17","objectID":"/shellguide/:5:0","tags":["google","style","shell","bash"],"title":"google shell style guide | Style guides for Google-originated open-source projects","uri":"/shellguide/"},{"categories":null,"content":"5.1 Indentation 缩进两个空格，不要使用制表符。 使用空行来分隔不同的块以提高可读性。缩进为两个空格。 无论你做什么，都不要使用制表符。 对于现有的文件，请保持忠于现有的缩进方式。 ","date":"2023-08-17","objectID":"/shellguide/:5:1","tags":["google","style","shell","bash"],"title":"google shell style guide | Style guides for Google-originated open-source projects","uri":"/shellguide/"},{"categories":null,"content":"5.2 Line Length and Long Strings 最大行长度是 80 个字符。 如果您必须编写超过 80 个字符的字符串，应尽可能使用 here 文档或嵌入换行进行操作。 如果字面字符串必须超过 80 个字符且无法合理拆分，则可以接受，但强烈建议找到缩短的方法。 # DO use 'here document's cat \u003c\u003cEND I am an exceptionally long string. END # Embedded newlines are ok too long_string=\"I am an exceptionally long string.\" ","date":"2023-08-17","objectID":"/shellguide/:5:2","tags":["google","style","shell","bash"],"title":"google shell style guide | Style guides for Google-originated open-source projects","uri":"/shellguide/"},{"categories":null,"content":"5.3 Pipelines 如果一个管道能全部放在一行上，应该放在一行上。 如果一个管道不能: 应该在每个管道段落上分开一行， 管道放在新的一行上， 下一个管道段落应有两个空格的缩进。 这适用于使用“|”连接的一系列命令以及使用“||”和“\u0026\u0026”进行逻辑连接的组合。 # All fits on one line command1 | command2 # Long commands command1 \\ | command2 \\ | command3 \\ | command4 ","date":"2023-08-17","objectID":"/shellguide/:5:3","tags":["google","style","shell","bash"],"title":"google shell style guide | Style guides for Google-originated open-source projects","uri":"/shellguide/"},{"categories":null,"content":"5.4 Loops 将 ; do 和 ; then 放在与 while 、 for 或 if 同一行。 在 shell 中的循环有点不同，但我们遵循与声明函数时相同的原则。也就是说： ; then 和 ; do 应该与 if/for/while 放在同一行 else 应该自成一行， 关闭语句应该垂直对齐于开放语句的行。 # If inside a function, consider declaring the loop variable as # a local to avoid it leaking into the global environment: # local dir for dir in \"${dirs_to_cleanup[@]}\"; do if [[ -d \"${dir}/${ORACLE_SID}\" ]]; then log_date \"Cleaning up old files in ${dir}/${ORACLE_SID}\" rm \"${dir}/${ORACLE_SID}/\"* if (( $? != 0 )); then error_message fi else mkdir -p \"${dir}/${ORACLE_SID}\" if (( $? != 0 )); then error_message fi fi done ","date":"2023-08-17","objectID":"/shellguide/:5:4","tags":["google","style","shell","bash"],"title":"google shell style guide | Style guides for Google-originated open-source projects","uri":"/shellguide/"},{"categories":null,"content":"5.5 Case statement 替代缩进使用 2 个空格。 一行替代方案需要在模式的关闭括号后和 ;; 前加上一个空格。 长或多命令的替代方案应该分成多行，模式、行为和 ;; 分别放在不同的行上。 匹配表达式离 case 和 esac 缩进一个层级。多行行为再缩进一个层级。通常情况下，没有必要对匹配表达式进行引号。模式表达式之前不应有左括号。避免使用 ;\u0026 和 ;;\u0026 符号。 case \"${expression}\" in a) variable=\"…\" some_command \"${variable}\" \"${other_expr}\" … ;; absolute) actions=\"relative\" another_command \"${actions}\" \"${other_expr}\" … ;; *) error \"Unexpected expression '${expression}'\" ;; esac 只要表达式可读性没有受到影响，简单命令可以与模式和;;放在同一行上。 这通常适用于单字母选项处理。当动作无法放在一行上时，将模式放在独立的一行上，然后是动作，然后再另起一行写;;。当与动作在同一行上时，在模式的闭括号后加一个空格，再在;;之前加一个空格。 verbose='false' aflag='' bflag='' files='' while getopts 'abf:v' flag; do case \"${flag}\" in a) aflag='true' ;; b) bflag='true' ;; f) files=\"${OPTARG}\" ;; v) verbose='true' ;; *) error \"Unexpected option ${flag}\" ;; esac done ","date":"2023-08-17","objectID":"/shellguide/:5:5","tags":["google","style","shell","bash"],"title":"google shell style guide | Style guides for Google-originated open-source projects","uri":"/shellguide/"},{"categories":null,"content":"5.6 Variable expansion 按照优先顺序： 保持与您发现的代码一致； 引用您的变量 (使用 \" )； 优先使用 \"${var}\" 而非 \"$var\" 。 这些是强烈推荐的准则，但并非强制性规定。然而，推荐而非强制并不意味着可以轻视或低估。 ","date":"2023-08-17","objectID":"/shellguide/:5:6","tags":["google","style","shell","bash"],"title":"google shell style guide | Style guides for Google-originated open-source projects","uri":"/shellguide/"},{"categories":null,"content":"5.7 Quoting 无论如何都要引用包含变量、命令替换、空格或 shell 元字符的字符串 除非需要小心地取消引用扩展或它是一个 shell 内部整数（见下一条）。 使用数组来安全引用元素列表，尤其是命令行选项 详见下面的数组部分。 可选择引用 shell 内部的只读特殊变量 这些变量被定义为整数：\\(?、\\)#、$$、$!（参见 man bash）。 为了一致性，更喜欢引用“命名”的内部整数变量，如 PPID 等。 更倾向于引用作为“单词”的字符串（而不是命令选项或路径名）。 永远不要引用字面整数。 了解 \\[\\[..\\]\\] ]]中模式匹配的引用规则。 详见下面的章节。 除非有特定的原因要使用 $* ，否则使用 \"$@\" ，比如只是将参数追加到消息或日志的字符串中。 # 'Single' quotes indicate that no substitution is desired. # \"Double\" quotes indicate that substitution is required/tolerated. # Simple examples # \"quote command substitutions\" # Note that quotes nested inside \"$()\" don't need escaping. flag=\"$(some_command and its args \"$@\" 'quoted separately')\" # \"quote variables\" echo \"${flag}\" # Use arrays with quoted expansion for lists. declare -a FLAGS FLAGS=( --foo --bar='baz' ) readonly FLAGS mybinary \"${FLAGS[@]}\" # It's ok to not quote internal integer variables. if (( $# \u003e 3 )); then echo \"ppid=${PPID}\" fi # \"never quote literal integers\" value=32 # \"quote command substitutions\", even when you expect integers number=\"$(generate_number)\" # \"prefer quoting words\", not compulsory readonly USE_INTEGER='true' # \"quote shell meta characters\" echo 'Hello stranger, and well met. Earn lots of $$$' echo \"Process $$: Done making \\$\\$\\$.\" # \"command options or path names\" # ($1 is assumed to contain a value here) grep -li Hugo /dev/null \"$1\" # Less simple examples # \"quote variables, unless proven false\": ccs might be empty git send-email --to \"${reviewers}\" ${ccs:+\"--cc\" \"${ccs}\"} # Positional parameter precautions: $1 might be unset # Single quotes leave regex as-is. grep -cP '([Ss]pecial|\\|?characters*)$' ${1:+\"$1\"} # For passing on arguments, # \"$@\" is right almost every time, and # $* is wrong almost every time: # # * $* and $@ will split on spaces, clobbering up arguments # that contain spaces and dropping empty strings; # * \"$@\" will retain arguments as-is, so no args # provided will result in no args being passed on; # This is in most cases what you want to use for passing # on arguments. # * \"$*\" expands to one argument, with all args joined # by (usually) spaces, # so no args provided will result in one empty string # being passed on. # (Consult `man bash` for the nit-grits ;-) (set -- 1 \"2 two\" \"3 three tres\"; echo $#; set -- \"$*\"; echo \"$#, $@\") (set -- 1 \"2 two\" \"3 three tres\"; echo $#; set -- \"$@\"; echo \"$#, $@\") ","date":"2023-08-17","objectID":"/shellguide/:5:7","tags":["google","style","shell","bash"],"title":"google shell style guide | Style guides for Google-originated open-source projects","uri":"/shellguide/"},{"categories":null,"content":"6 Features and Bugs ","date":"2023-08-17","objectID":"/shellguide/:6:0","tags":["google","style","shell","bash"],"title":"google shell style guide | Style guides for Google-originated open-source projects","uri":"/shellguide/"},{"categories":null,"content":"6.1 ShellCheck ShellCheck 项目可帮助您识别 shell 脚本中的常见错误和警告。无论是大型还是小型脚本，都推荐使用该工具。 ","date":"2023-08-17","objectID":"/shellguide/:6:1","tags":["google","style","shell","bash"],"title":"google shell style guide | Style guides for Google-originated open-source projects","uri":"/shellguide/"},{"categories":null,"content":"6.2 Command Substitution 使用 $(command) 代替反引号。 嵌套的反引号需要用 \\ 来转义内部的反引号。 $(command) 的格式在嵌套时不会改变，并且更容易读取。 Example: # This is preferred: var=\"$(command \"$(command1)\")\" # This is not: var=\"`command \\`command1\\``\" ","date":"2023-08-17","objectID":"/shellguide/:6:2","tags":["google","style","shell","bash"],"title":"google shell style guide | Style guides for Google-originated open-source projects","uri":"/shellguide/"},{"categories":null,"content":"6.3 Test, [ … ], and \\[\\[ … \\]\\] [[ ... ]] is preferred over [ … ], test and /usr/bin/[. [[ ... ]] 减少错误的发生，因为在 [[ ... ]] 之间没有路径名展开或者单词分割。此外， [[ ... ]] 可以进行正则表达式匹配，而 [ … ] 不可以。 ","date":"2023-08-17","objectID":"/shellguide/:6:3","tags":["google","style","shell","bash"],"title":"google shell style guide | Style guides for Google-originated open-source projects","uri":"/shellguide/"},{"categories":null,"content":"6.4 Testing Strings 在可能的情况下，请使用引号而不是填充字符 (filler character)。 Bash 足够聪明，能够处理测试中的空字符串。因此，考虑到代码更易读性，应该使用 test 来处理空字符串或非空字符串，而不是使用填充字符。 # Do this: if [[ \"${my_var}\" == \"some_string\" ]]; then do_something fi # -z (string length is zero) and -n (string length is not zero) are # preferred over testing for an empty string if [[ -z \"${my_var}\" ]]; then do_something fi # This is OK (ensure quotes on the empty side), but not preferred: if [[ \"${my_var}\" == \"\" ]]; then do_something fi # Not this: if [[ \"${my_var}X\" == \"some_stringX\" ]]; then do_something fi To avoid confusion about what you’re testing for, explicitly use -z or -n. # Use this if [[ -n \"${my_var}\" ]]; then do_something fi # Instead of this if [[ \"${my_var}\" ]]; then do_something fi 为了明确起见，使用==表示相等，而不是=，尽管两者都可以工作。前者鼓励使用[[，而后者可能会与赋值混淆。但是，在[\\[…]]中使用\u003c和\u003e时要小心，它将执行词典比较。使用((…))或-lt 和-gt 进行数值比较。 # Use this if [[ \"${my_var}\" == \"val\" ]]; then do_something fi if (( my_var \u003e 3 )); then do_something fi if [[ \"${my_var}\" -gt 3 ]]; then do_something fi # Instead of this if [[ \"${my_var}\" = \"val\" ]]; then do_something fi # Probably unintended lexicographical comparison. if [[ \"${my_var}\" \u003e 3 ]]; then # True for 4, false for 22. do_something fi ","date":"2023-08-17","objectID":"/shellguide/:6:4","tags":["google","style","shell","bash"],"title":"google shell style guide | Style guides for Google-originated open-source projects","uri":"/shellguide/"},{"categories":null,"content":"6.5 Wildcard Expansion of Filenames 当使用通配符扩展文件名时，请使用显式路径。 由于文件名可能以 - 开头，使用 ./* 而不是 * 来扩展通配符会更安全。 # Here's the contents of the directory: # -f -r somedir somefile # Incorrectly deletes almost everything in the directory by force psa@bilby$ rm -v * removed directory: `somedir' removed `somefile' # As opposed to: psa@bilby$ rm -v ./* removed `./-f' removed `./-r' rm: cannot remove `./somedir': Is a directory removed `./somefile' ","date":"2023-08-17","objectID":"/shellguide/:6:5","tags":["google","style","shell","bash"],"title":"google shell style guide | Style guides for Google-originated open-source projects","uri":"/shellguide/"},{"categories":null,"content":"6.6 Eval eval 应该避免使用。 当用于对变量赋值时，eval 会修改输入，并且可以设置变量，无法检查这些变量是什么。 # What does this set? # Did it succeed? In part or whole? eval $(set_my_variables) # What happens if one of the returned values has a space in it? variable=\"$(eval some_function)\" ","date":"2023-08-17","objectID":"/shellguide/:6:6","tags":["google","style","shell","bash"],"title":"google shell style guide | Style guides for Google-originated open-source projects","uri":"/shellguide/"},{"categories":null,"content":"6.7 Arrays Bash 数组应该用于存储元素列表，以避免引号引用的复杂性。 这尤其适用于参数列表。不应使用数组来方便更复杂的数据结构（参见上面的使用 Shell 时）。 数组存储有序的字符串集合，并且可以安全地展开为命令或循环的单个元素。 应避免使用单个字符串作为多个命令参数， 因为这不可避免地导致作者使用 eval 或尝试在字符串中嵌套引号，这不会产生可靠或可读的结果，并且导致不必要的复杂性。 # An array is assigned using parentheses, and can be appended to # with +=( … ). declare -a flags flags=(--foo --bar='baz') flags+=(--greeting=\"Hello ${name}\") mybinary \"${flags[@]}\" # Don’t use strings for sequences. flags='--foo --bar=baz' flags+=' --greeting=\"Hello world\"' # This won’t work as intended. mybinary ${flags} # Command expansions return single strings, not arrays. Avoid # unquoted expansion in array assignments because it won’t # work correctly if the command output contains special # characters or whitespace. # This expands the listing output into a string, then does special keyword # expansion, and then whitespace splitting. Only then is it turned into a # list of words. The ls command may also change behavior based on the user's # active environment! declare -a files=($(ls /directory)) # The get_arguments writes everything to STDOUT, but then goes through the # same expansion process above before turning into a list of arguments. mybinary $(get_arguments) 6.7.1 Arrays Pros 使用数组可以在不混淆引用语义的情况下创建列表。相反地，不使用数组会导致在字符串内部错误地嵌套引用的尝试。 数组使得可以安全地存储包含空格的任意字符串的序列/列表。 6.7.2 Arrays Cons 使用数组可能会增加脚本的复杂性增加的风险。 6.7.3 Arrays Decision 应该使用数组来安全地创建和传递列表。特别是在构建一组命令参数时，应该使用数组来避免引号的混乱问题。使用引用扩展 - “${array[@]}” - 来访问数组。然而，如果需要更高级的数据操作，应该完全避免使用 shell 脚本;参见上面的内容。 ","date":"2023-08-17","objectID":"/shellguide/:6:7","tags":["google","style","shell","bash"],"title":"google shell style guide | Style guides for Google-originated open-source projects","uri":"/shellguide/"},{"categories":null,"content":"6.8 Pipes to While 使用进程替换或者优先使用 bash4+里的 readarray 命令，而不是使用管道传递给 while。 管道会创建一个子 shell，所以在管道中修改的变量不会传递到父 shell。 管道传递给 while 的隐式子 shell 可能会引入难以追踪的细微错误。 last_line='NULL' your_command | while read -r line; do if [[ -n \"${line}\" ]]; then last_line=\"${line}\" fi done # This will always output 'NULL'! echo \"${last_line}\" 使用进程替换也会创建一个子 shell。然而，它允许从子 shell 重定向到一个 while 循环，而无需将 while（或任何其他命令）放入子 shell 中。 ","date":"2023-08-17","objectID":"/shellguide/:6:8","tags":["google","style","shell","bash"],"title":"google shell style guide | Style guides for Google-originated open-source projects","uri":"/shellguide/"},{"categories":null,"content":"6.9 Arithmetic 始终使用(( … ))或\\((( … ))而不是 let 或\\)[ … ]或 expr。 永远不要使用$[ … ]语法，expr 命令或 let 内置命令。 \u003cand\u003e在\\[[]]表达式内部不执行数字比较（而执行字典比较；请参见字符串测试）。 不要对数值比较使用[\\[]]，而是使用 (( … )) 。 特别是在启用 set -e 的情况下。例如，set -e; i=0; (( i++ ))将导致 shell 退出。 # Simple calculation used as text - note the use of $(( … )) within # a string. echo \"$(( 2 + 2 )) is 4\" # When performing arithmetic comparisons for testing if (( a \u003c b )); then … fi # Some calculation assigned to a variable. (( i = 10 * j + 400 )) # This form is non-portable and deprecated i=$[2 * 10] # Despite appearances, 'let' isn't one of the declarative keywords, # so unquoted assignments are subject to globbing wordsplitting. # For the sake of simplicity, avoid 'let' and use (( … )) let i=\"2 + 2\" # The expr utility is an external program and not a shell builtin. i=$( expr 4 + 4 ) # Quoting can be error prone when using expr too. i=$( expr 4 '*' 4 ) ","date":"2023-08-17","objectID":"/shellguide/:6:9","tags":["google","style","shell","bash"],"title":"google shell style guide | Style guides for Google-originated open-source projects","uri":"/shellguide/"},{"categories":null,"content":"7 Naming Conventions ","date":"2023-08-17","objectID":"/shellguide/:7:0","tags":["google","style","shell","bash"],"title":"google shell style guide | Style guides for Google-originated open-source projects","uri":"/shellguide/"},{"categories":null,"content":"7.1 Function Names 小写字母，用下划线分隔单词。 使用双冒号来分隔库。 在函数名后面需要使用括号。 关键字 function 是可选的，但必须在整个项目中保持一致使用。 如果你正在编写单个函数，请使用小写字母，并使用下划线分隔单词。 如果你正在编写一个包，应使用双冒号分隔包名。 大括号必须与函数名在同一行（与 Google 的其他语言一样），函数名与括号之间不要有空格。 # Single function my_func() { … } # Part of a package mypackage::my_func() { … } 当函数名后面跟着“()”时，“function”关键字是多余的，但它能够加强对函数的快速识别。 ","date":"2023-08-17","objectID":"/shellguide/:7:1","tags":["google","style","shell","bash"],"title":"google shell style guide | Style guides for Google-originated open-source projects","uri":"/shellguide/"},{"categories":null,"content":"7.2 Variable Names 关于函数名称。 循环变量的变量名称应与您正在遍历的任何变量命名方式相似。 for zone in \"${zones[@]}\"; do something_with \"${zone}\" done ","date":"2023-08-17","objectID":"/shellguide/:7:2","tags":["google","style","shell","bash"],"title":"google shell style guide | Style guides for Google-originated open-source projects","uri":"/shellguide/"},{"categories":null,"content":"7.3 Constants and Environment Variable Names 所有字母大写，用下划线分隔，在文件顶部声明。 常量和任何导出到环境的内容都应大写。 # Constant readonly PATH_TO_FILES='/some/path' # Both constant and environment declare -xr ORACLE_SID='PROD' 有些东西在它们第一次设置后变得恒定（例如通过 getopts）。因此，在 getopts 或基于条件设置一个 constant 是可以的，但是之后应立即将其设置为 readonly。为了清晰起见，建议使用 readonly 或 export 而不是等效的 declare 命令。 VERBOSE='false' while getopts 'v' flag; do case \"${flag}\" in v) VERBOSE='true' ;; esac done readonly VERBOSE ","date":"2023-08-17","objectID":"/shellguide/:7:3","tags":["google","style","shell","bash"],"title":"google shell style guide | Style guides for Google-originated open-source projects","uri":"/shellguide/"},{"categories":null,"content":"7.4 Source Filenames 使用小写字母，并在需要时用下划线分隔单词。 这是为了与 Google 中的其他代码风格保持一致：maketemplate 或 make_template，而不是 make-template。 ","date":"2023-08-17","objectID":"/shellguide/:7:4","tags":["google","style","shell","bash"],"title":"google shell style guide | Style guides for Google-originated open-source projects","uri":"/shellguide/"},{"categories":null,"content":"7.5 Read-only Variables 使用 readonly 或 declare -r 来确保它们是只读的。 由于全局变量在 shell 中被广泛使用，因此在处理它们时捕捉错误是很重要的。当你声明一个变量是只读的时候，要明确表示这一点。 zip_version=\"$(dpkg --status zip | grep Version: | cut -d ' ' -f 2)\" if [[ -z \"${zip_version}\" ]]; then error_message else readonly zip_version fi ","date":"2023-08-17","objectID":"/shellguide/:7:5","tags":["google","style","shell","bash"],"title":"google shell style guide | Style guides for Google-originated open-source projects","uri":"/shellguide/"},{"categories":null,"content":"7.6 Use Local Variables 使用 local 关键字在函数内部声明具体函数变量。声明和赋值应该分开放在不同的行上。 通过使用 local 关键字在声明变量时，确保本地变量只在函数及其子函数内部可见。这样可以避免污染全局命名空间，并意外地设置对函数外部可能有重要意义的变量。 当赋值值由命令替换提供时，声明和赋值必须是分开的语句；因为 local 内建函数不会传播来自命令替换的退出代码。 my_func2() { local name=\"$1\" # Separate lines for declaration and assignment: local my_var my_var=\"$(my_func)\" (( $? == 0 )) || return … } my_func2() { # DO NOT do this: # $? will always be zero, as it contains the exit code of 'local', not my_func local my_var=\"$(my_func)\" (( $? == 0 )) || return … } ","date":"2023-08-17","objectID":"/shellguide/:7:6","tags":["google","style","shell","bash"],"title":"google shell style guide | Style guides for Google-originated open-source projects","uri":"/shellguide/"},{"categories":null,"content":"7.7 Function Location 将所有函数放在常量的下方，不要在函数之间隐藏可执行代码。这样做会使代码难以跟踪，并在调试时会产生令人讨厌的意外。 如果您有函数，请将它们都放在文件的顶部附近。只有 includes、set 语句和设置常量可以在声明函数之前完成。 ","date":"2023-08-17","objectID":"/shellguide/:7:7","tags":["google","style","shell","bash"],"title":"google shell style guide | Style guides for Google-originated open-source projects","uri":"/shellguide/"},{"categories":null,"content":"7.8 main 如果脚本足够长，至少包含一个其他函数，则需要一个名为 main 的函数。 为了方便找到程序的起始点，将主程序放在一个名为 main 的函数中，作为最底层的函数。这样可以保持与代码库其余部分的一致性，同时还允许您将更多变量定义为本地变量（如果主代码不是函数，则无法完成此操作）。文件中最后一个非注释行应该是对 main 的调用： ","date":"2023-08-17","objectID":"/shellguide/:7:8","tags":["google","style","shell","bash"],"title":"google shell style guide | Style guides for Google-originated open-source projects","uri":"/shellguide/"},{"categories":null,"content":"8 Calling Commands ","date":"2023-08-17","objectID":"/shellguide/:8:0","tags":["google","style","shell","bash"],"title":"google shell style guide | Style guides for Google-originated open-source projects","uri":"/shellguide/"},{"categories":null,"content":"8.1 Checking Return Values 始终检查返回值并提供有信息的返回值。 对于未使用管道的命令，请使用 $? 或直接通过 if 语句进行检查，以保持简单。 if ! mv \"${file_list[@]}\" \"${dest_dir}/\"; then echo \"Unable to move ${file_list[*]} to ${dest_dir}\" \u003e\u00262 exit 1 fi # Or mv \"${file_list[@]}\" \"${dest_dir}/\" if (( $? != 0 )); then echo \"Unable to move ${file_list[*]} to ${dest_dir}\" \u003e\u00262 exit 1 fi Bash 还有一个名为 PIPESTATUS 的变量，允许检查管道中所有部分的返回代码。如果仅需要检查整个管道的成功或失败，以下方法也是可行的： tar -cf - ./* | ( cd \"${dir}\" \u0026\u0026 tar -xf - ) if (( PIPESTATUS[0] != 0 || PIPESTATUS[1] != 0 )); then echo \"Unable to tar files to ${dir}\" \u003e\u00262 fi 然而，一旦您执行其他命令，PIPESTATUS 将被覆盖，所以如果您需要根据管道中发生错误的位置来进行不同的错误处理，您需要在运行命令后立即将 PIPESTATUS 分配给另一个变量（请记住，[ 是一个命令，会清除 PIPESTATUS）。 tar -cf - ./* | ( cd \"${DIR}\" \u0026\u0026 tar -xf - ) return_codes=( \"${PIPESTATUS[@]}\" ) if (( return_codes[0] != 0 )); then do_something fi if (( return_codes[1] != 0 )); then do_something_else fi ","date":"2023-08-17","objectID":"/shellguide/:8:1","tags":["google","style","shell","bash"],"title":"google shell style guide | Style guides for Google-originated open-source projects","uri":"/shellguide/"},{"categories":null,"content":"8.2 Builtin Commands vs. External Commands 在选择调用内置 shell 和调用独立进程之间，选择内置 shell。 我们更喜欢使用内置的函数，例如 bash(1) 中的参数扩展函数，因为它更健壮和可移植（特别是与类似 sed 的工具相比较）。 # Prefer this: addition=$(( X + Y )) substitution=\"${string/#foo/bar}\" # Instead of this: addition=\"$(expr \"${X}\" + \"${Y}\")\" substitution=\"$(echo \"${string}\" | sed -e 's/^foo/bar/')\" ","date":"2023-08-17","objectID":"/shellguide/:8:2","tags":["google","style","shell","bash"],"title":"google shell style guide | Style guides for Google-originated open-source projects","uri":"/shellguide/"},{"categories":null,"content":"9 Conclusion Use common sense and BE CONSISTENT. ","date":"2023-08-17","objectID":"/shellguide/:9:0","tags":["google","style","shell","bash"],"title":"google shell style guide | Style guides for Google-originated open-source projects","uri":"/shellguide/"},{"categories":null,"content":" Table of Contents 1 慢查询 1.1 功能说明 1.2 监控视图 1.3 慢 SQL 列表 1.4 慢 SQL 统计分析 1.5 功能说明 2 错误日志 3 错误日志默认设置 4 运行日志管理 4.1 PG_LOG 介绍 4.2 修改 PG_LOG 保留时长 本文为摘录(或转载)，侵删，原文为： https://cloud.tencent.com/document/product/409/10790 摘自：https://cloud.tencent.com/document/product/409/49546 ","date":"2023-08-15","objectID":"/10790/:0:0","tags":["慢查询","pg"],"title":"云数据库 PostgreSQL 日志管理及分析-操作指南-文档中心-腾讯云","uri":"/10790/"},{"categories":null,"content":"1 慢查询 ","date":"2023-08-15","objectID":"/10790/:1:0","tags":["慢查询","pg"],"title":"云数据库 PostgreSQL 日志管理及分析-操作指南-文档中心-腾讯云","uri":"/10790/"},{"categories":null,"content":"1.1 功能说明 默认数据库对超过 1s 的 SQL 语句查询判断为 “ 慢查询 ”，对应语句称为“ 慢查询语句 （俗称 慢 SQL ）”，而数据库管理员（DBA）对慢查询语句进行分析并找到慢查询出现原因的过程叫做 慢查询分析 。﻿云数据库 PostgreSQL 控制台 在实例管理页的性能优化模块下，提供慢查询分析能力。如下图： ","date":"2023-08-15","objectID":"/10790/:1:1","tags":["慢查询","pg"],"title":"云数据库 PostgreSQL 日志管理及分析-操作指南-文档中心-腾讯云","uri":"/10790/"},{"categories":null,"content":"1.2 监控视图 控制台中的两个图表为监控视图，可以直观方便地查看数据库慢 SQL 的相关信息。 慢查询与其他监控组合视图：支持通过图表化形式查看慢查询指标以及与其他指标联合对比查看的能力。可以支持的其他指标有： CPU 利用率， QPS， 请求数， 读请求数， 写请求数， 其他请求数， 缓冲区缓存命中率 平均执行时延。 慢 SQL 耗时分布： 可以通过不同时间段的慢 SQL 进行查看慢查询主要分布在什么时段区间内。 ","date":"2023-08-15","objectID":"/10790/:1:2","tags":["慢查询","pg"],"title":"云数据库 PostgreSQL 日志管理及分析-操作指南-文档中心-腾讯云","uri":"/10790/"},{"categories":null,"content":"1.3 慢 SQL 列表 慢 SQL 列表可以实时查看数据库中所产生的慢 SQL 语句，列表根据时间降序排列，最新产生的慢 SQL 会自动生成显示在第一行。 支持查看的慢 SQL 字段：执行时间，慢 SQL 语句，总耗时，客户端 IP 地址，数据库名，执行用户。 注意： 慢 SQL 列表默认保存最近 7 天的慢 SQL 数据与最大 50GiB 的日志总量，当哪一个条件率先满足，则会自动删除超出要求的日志。当单条慢 SQL 大于 20KB，将无法从控制台上查看，请 提交工单，联系腾讯云为您提供。 ","date":"2023-08-15","objectID":"/10790/:1:3","tags":["慢查询","pg"],"title":"云数据库 PostgreSQL 日志管理及分析-操作指南-文档中心-腾讯云","uri":"/10790/"},{"categories":null,"content":"1.4 慢 SQL 统计分析 慢 SQL 统计分析可以根据指定时间范围内的所有慢 SQL 经过系统的参数抽象后，对同类 SQL 进行聚合分析得到的慢 SQL 分析信息。其中包含多种字段信息。 最后执行时间： 在统计范围内，该抽象语句最后一次出现的时间，由于某些预计执行较长，我们统一按语句执行的 begin_time 记录。 抽象后的 SQL 语句： 去掉慢 SQL 中常数后的语句，抽象后的语句可以将同类同性质的语句进行汇总统计，以方便您更好的分析。 数据库： 该语句调用了哪个数据库。 账号： 该语句是使用哪个账号来运行的。 客户端 IP 地址： 语句在哪些客户端上执行过。 首次执行时间： 在统计范围内，该慢 SQL 第一次出现的时间（抽象后汇总后，可能有很多条记录）。 执行总时间： 在统计范围内，慢查询语句查询总耗时。 平均执行时间： 慢查询语句总时间除以总次数的平均时间。 最小执行时间： 所有该条抽象语句中，慢查询语句出现的最小时间；用于帮助判断该语句是否偶发性事件。 最大执行时间： 所有该条抽象语句中，慢查询语句出现的最大时间；用于帮助判断该语句是否偶发性事件。 总时间占比： 在统计范围内，慢查询语句占所有慢查询语句时间的占比。 ","date":"2023-08-15","objectID":"/10790/:1:4","tags":["慢查询","pg"],"title":"云数据库 PostgreSQL 日志管理及分析-操作指南-文档中心-腾讯云","uri":"/10790/"},{"categories":null,"content":"1.5 功能说明 ","date":"2023-08-15","objectID":"/10790/:1:5","tags":["慢查询","pg"],"title":"云数据库 PostgreSQL 日志管理及分析-操作指南-文档中心-腾讯云","uri":"/10790/"},{"categories":null,"content":"2 错误日志 数据库运行过程中，因操作、SQL、系统运行错误等原因产生的日志叫做错误日志，错误日志常用于开发者找出业务系统或数据库出现问题的原因。 云数据库 PostgreSQL 在实例管理页的性能优化模块下，提供错误日志查看能力。如下图： ","date":"2023-08-15","objectID":"/10790/:2:0","tags":["慢查询","pg"],"title":"云数据库 PostgreSQL 日志管理及分析-操作指南-文档中心-腾讯云","uri":"/10790/"},{"categories":null,"content":"3 错误日志默认设置 错误日志功能： 默认开启 错误日志记录级别： log_min_error_statement=ERROR 分析数据输出延迟： 1分钟 - 5分钟 日志记录时长： 7天 （最大最近 10000 条） ","date":"2023-08-15","objectID":"/10790/:3:0","tags":["慢查询","pg"],"title":"云数据库 PostgreSQL 日志管理及分析-操作指南-文档中心-腾讯云","uri":"/10790/"},{"categories":null,"content":"4 运行日志管理 :PROPERTIES: :CUSTOM_ID: h:080465e3-1261-4a03-8ee6-0562db8aced3 :NOTER_DOCUMENT: https://cloud.tencent.com/document/product/409/95763 :NOTER_OPEN: eww :NOTER_PAGE: 1 ","date":"2023-08-15","objectID":"/10790/:4:0","tags":["慢查询","pg"],"title":"云数据库 PostgreSQL 日志管理及分析-操作指南-文档中心-腾讯云","uri":"/10790/"},{"categories":null,"content":"4.1 PG_LOG 介绍 pg_log 一般是记录数据库的状态信息，例如：错误信息、慢查询 SQL、数据库的启动关闭信息等。该日志会按大小和时间自动切割，当前云数据库 PostgreSQL 的 pg_log 默认保留 30 天。pg_log 会占用数据库实例的存储空间，您可以基于实际需要来修改保留时长。 说明： 数据库实例的慢日志和错误日志默认保留 7 天，修改 pg_log 保留时长不影响慢日志和错误日志保留时长。 ","date":"2023-08-15","objectID":"/10790/:4:1","tags":["慢查询","pg"],"title":"云数据库 PostgreSQL 日志管理及分析-操作指南-文档中心-腾讯云","uri":"/10790/"},{"categories":null,"content":"4.2 修改 PG_LOG 保留时长 您可以基于实际需要修改 pg_log 保留时长，系统当前支持 7 天和 30 天两种。具体操作如下： 登录 云数据库 PostgreSQL 控制台。 在实例列表找到需要修改的实例，单击操作 \u003e 管理，进入实例详情。 在实例详情页找到参数设置，在右上方搜索框中搜索需要设置的参数 log_filename 并更新。 log_filename 参数说明如下： 参数值 说明 postgresql_%a_%H.log 选择该值，日志保留 7 天。 postgresql_%d_%H.log 选择该值，日志保留 30 天，系统默认保留 30 天。 ","date":"2023-08-15","objectID":"/10790/:4:2","tags":["慢查询","pg"],"title":"云数据库 PostgreSQL 日志管理及分析-操作指南-文档中心-腾讯云","uri":"/10790/"},{"categories":null,"content":" Table of Contents 1 体系结构 本文为摘录(或转载)，侵删，原文为： ../pptx/9/openGauss+技术架构.pptx ","date":"2023-05-05","objectID":"/opengauss-%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/:0:0","tags":["database","guassdb"],"title":"openGauss+技术架构","uri":"/opengauss-%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/"},{"categories":null,"content":"1 体系结构 ","date":"2023-05-05","objectID":"/opengauss-%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/:1:0","tags":["database","guassdb"],"title":"openGauss+技术架构","uri":"/opengauss-%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/"},{"categories":null,"content":" Table of Contents 1 几个重要的库 本文为摘录(或转载)，侵删，原文为： https://mp.weixin.qq.com/s?__biz=MjM5NjgwMDMxMg==\u0026mid=2652164045\u0026idx=1\u0026sn=305c8d05c0b8b41827a9d4062c44a4a8\u0026chksm=bd03dd9a8a74548c907bc3f1ffac82db0207e14bdd6c2398fa798187b9ea449371a9f0ec1f6f\u0026mpshare=1\u0026scene=1\u0026srcid=1205yZcXcCHhOMmAZpuiFyFo\u0026sharer_sharetime=1688349494576\u0026sharer_shareid=a1eb8d286d4dcd42a0c884a984d12f54#rd ","date":"0001-01-01","objectID":"/kingbase-perf-analyze.org/:0:0","tags":["kingbase","perf"],"title":"  调优\"四剑客\"的实战演练，福尔摩斯•K带你轻松优化性能\n  ","uri":"/kingbase-perf-analyze.org/"},{"categories":null,"content":"1 几个重要的库 KWR ： KES 自动负载信息库（Automatic Workload Repertories），每小时自动采集性能指标生成快照，建立数据库时间模型、IO 模型、等待事件、TOP SQL 和操作系统统计等性能指标，为数据库性能调优提供指导。 KSH： KES 活跃会话历史库（Active Session History），每秒自动采样活跃会话的等待事件、SQL 语句、阻塞等会话信息，提供针对某个历史时间点的性能问题分析。 KDDM： KES 自动诊断和建议（Automatic Database Diagnostic Monitor），基于 KWR 快照和数据库时间模型，给出内存、网络、IO 和 SQL 性能优化建议。 KWR Diff： KWR 差异报告，通过比较 2 段时间内 KWR 性能指标的差异，发现性能变化的趋势。 ","date":"0001-01-01","objectID":"/kingbase-perf-analyze.org/:1:0","tags":["kingbase","perf"],"title":"  调优\"四剑客\"的实战演练，福尔摩斯•K带你轻松优化性能\n  ","uri":"/kingbase-perf-analyze.org/"},{"categories":null,"content":" Table of Contents 1 INTRODUCTION 2 LearnedRewrite 2.1 树形结构 3 PRELIMINARIES 3.1 Query Rewrite Rules 3.2 Query Rewrite 4 TREE SEARCH FOR QUERY REWRITE 4.1 Overview of Policy Tree Search 本文为摘录(或转载)，侵删，原文为： attachments/pdf/7/p46-li.pdf 查询重写使用启发式算法来实现，有两个限制 规则的应用顺序严重影响查询性能，但 可能的重写顺序随查询涉及到的算子指数增长 受限于搜索空间大小限制，很难找到最佳的顺序 针对不同的查询，不同的重写规则的收益也不同 当前的方法，只能应用于单个计划，而不能有效的估计查询重写的收益 提出了基于策略树树的查询重写框架 ","date":"0001-01-01","objectID":"/p46-li/:0:0","tags":["policytree","optimizer","rewrite"],"title":"A Learned Query Rewrite System using Monte Carlo Tree Search","uri":"/p46-li/"},{"categories":null,"content":"1 INTRODUCTION 查询重写：将一个 SQL 查询转换成为等价的、但性能更高的 SQL. 规则的应用顺序严重影响查询性能， 以 下图 为例： q1 采用传统的从上到下的顺序应用规则 仅能应用 O1 和 O3 执行时间 \u003e20 min q2 通过策略树实现 O1,O4,O3,O5 的顺序应用规则 执行时间 1.941s 性能相差 600 倍。 传统方法通过匹配预定义的规则顺序来重写 可能会陷入局部最优解 ","date":"0001-01-01","objectID":"/p46-li/:1:0","tags":["policytree","optimizer","rewrite"],"title":"A Learned Query Rewrite System using Monte Carlo Tree Search","uri":"/p46-li/"},{"categories":null,"content":"2 LearnedRewrite ","date":"0001-01-01","objectID":"/p46-li/:2:0","tags":["policytree","optimizer","rewrite"],"title":"A Learned Query Rewrite System using Monte Carlo Tree Search","uri":"/p46-li/"},{"categories":null,"content":"2.1 树形结构 使用 策略树 表达可能的顺序： 根节点 root: 表示输入的原始 SQL 每个非根节：点表示对其父节点应用重新规则之后生成的新的查询 根节点到其他节点的路径：表示重新的顺序 策略树的优势 不同路径，可以共享相同的祖先 （已经重写的查询） 避免重复应用规则 可以通过蒙特卡罗树搜索 (Monte Carlo Tree Search, MCTS) 来探索策略树从而找到优化节点 ","date":"0001-01-01","objectID":"/p46-li/:2:1","tags":["policytree","optimizer","rewrite"],"title":"A Learned Query Rewrite System using Monte Carlo Tree Search","uri":"/p46-li/"},{"categories":null,"content":"3 PRELIMINARIES ","date":"0001-01-01","objectID":"/p46-li/:3:0","tags":["policytree","optimizer","rewrite"],"title":"A Learned Query Rewrite System using Monte Carlo Tree Search","uri":"/p46-li/"},{"categories":null,"content":"3.1 Query Rewrite Rules 3.1.1 Input Query 3.1.2 Query Tree 3.1.3 Query Rewrite Rules 规则：针对查询的等价变换 定义： \\[r = (o,c,a)\\] 含义： o: operator, 算子 c: condition, 条件 a: rewrite action 解释：对于指定的查询 q ，规则 首先匹配到算子 o 如果 c 满足，或者 o 是子树的 root, 则对 q 应用 a ，得到 \\[q^{(o,r)}\\] , q 和 \\[q^{(o,r)}\\] 等价 3.1.4 Rewrite Benefit of Applying A Rewrite Rule \\[\\Delta Cost(q^{(0,r)},q) = Cost(q) - Cost(q^{(o,r)})\\] where: \\[Cost(q)\\] : 重写之前的代价 \\[Cost(q^{(o,r)})\\] ： 重写之后的代价 3.1.5 The Rewrite Order of Applying Multiple Rewrite Rules ","date":"0001-01-01","objectID":"/p46-li/:3:1","tags":["policytree","optimizer","rewrite"],"title":"A Learned Query Rewrite System using Monte Carlo Tree Search","uri":"/p46-li/"},{"categories":null,"content":"3.2 Query Rewrite 3.2.1 Query Rewrite Human-involved methods 手动干预 性能高 分析，决策耗时长 Heuristic query rewrite 启发式 （如 PG） 自顶向下遍历查询计划中的算子，对每个算子： 如果匹配到规则，则应用规则 效率更高，但有两个主要限制： 应用规则的顺序是固定的 可能会错过更好的重写顺序 该方法不考虑重写的收益 可能会导致重写无用、甚至变得更慢 3.2.2 Learning Models for Databases 3.2.3 Reinforcement Learning ","date":"0001-01-01","objectID":"/p46-li/:3:2","tags":["policytree","optimizer","rewrite"],"title":"A Learned Query Rewrite System using Monte Carlo Tree Search","uri":"/p46-li/"},{"categories":null,"content":"4 TREE SEARCH FOR QUERY REWRITE ","date":"0001-01-01","objectID":"/p46-li/:4:0","tags":["policytree","optimizer","rewrite"],"title":"A Learned Query Rewrite System using Monte Carlo Tree Search","uri":"/p46-li/"},{"categories":null,"content":"4.1 Overview of Policy Tree Search Policy Tree: Given a query q and a set of rewrite rules, we build a policy tree T , where the root node denotes the origin query q, any non-root node denotes a rewritten query (that transforms the query of its parent by applying a rewrite operation), and a leaf denotes a query that cannot be rewritten by any rewrite rules. ","date":"0001-01-01","objectID":"/p46-li/:4:1","tags":["policytree","optimizer","rewrite"],"title":"A Learned Query Rewrite System using Monte Carlo Tree Search","uri":"/p46-li/"},{"categories":null,"content":" Table of Contents 1 ABSTRACT 2 INTRODUCTION 3 APPLICATION EXAMPLE 3.1 Project Siberia 本文为摘录(或转载)，侵删，原文为： attachments/pdf/f/p1714-kossmann.pdf 对目前的架构来讲，和 粗糙索引 作用重叠。。 ","date":"0001-01-01","objectID":"/p1714-kossmann/:0:0","tags":["range","filter","sqlserver"],"title":"Adaptive Range Filters for Cold Data: Avoiding Trips to Siberia","uri":"/p1714-kossmann/"},{"categories":null,"content":"1 ABSTRACT ARF: Adaptive Range Filter, 自适应范围过滤器 ARF is for Range queries, while BloomFilter is for Point queries ","date":"0001-01-01","objectID":"/p1714-kossmann/:1:0","tags":["range","filter","sqlserver"],"title":"Adaptive Range Filters for Cold Data: Avoiding Trips to Siberia","uri":"/p1714-kossmann/"},{"categories":null,"content":"2 INTRODUCTION ","date":"0001-01-01","objectID":"/p1714-kossmann/:2:0","tags":["range","filter","sqlserver"],"title":"Adaptive Range Filters for Cold Data: Avoiding Trips to Siberia","uri":"/p1714-kossmann/"},{"categories":null,"content":"3 APPLICATION EXAMPLE ","date":"0001-01-01","objectID":"/p1714-kossmann/:3:0","tags":["range","filter","sqlserver"],"title":"Adaptive Range Filters for Cold Data: Avoiding Trips to Siberia","uri":"/p1714-kossmann/"},{"categories":null,"content":"3.1 Project Siberia Siberia 是 Hekaton 项目用于管理冷数据的一个项目 Hekaton 则是 SQL Server 套件中的内存数据库 查询处理 Hot Store 用于查询热数据 Cold Store 用于查询冷数据 标准的 SQL Server 表 冷热查询对客户端透明 需要时候由 QueryProcessor 对两种数据的结果进行聚合操作 冷数据的查询代价很高 filter 用于判定冷数据中是否有符合条件的数据 返回 true: 可能有，需要访问冷数据 返回 false: 肯定无，无需访问冷数据 ","date":"0001-01-01","objectID":"/p1714-kossmann/:3:1","tags":["range","filter","sqlserver"],"title":"Adaptive Range Filters for Cold Data: Avoiding Trips to Siberia","uri":"/p1714-kossmann/"},{"categories":null,"content":" Table of Contents 1 Language Features 1.1 New auto rules for direct-list-initialization 1.2 static_assert with no message 1.3 typename in a template template parameter 1.4 Nested namespace definition 本文为摘录(或转载)，侵删，原文为： https://www.cppstories.com/2017/01/cpp17features/ ","date":"0001-01-01","objectID":"/all-major-c-17-features-you-should-know/:0:0","tags":["cpp","c++17"],"title":"All Major C++17 Features You Should Know","uri":"/all-major-c-17-features-you-should-know/"},{"categories":null,"content":"1 Language Features ","date":"0001-01-01","objectID":"/all-major-c-17-features-you-should-know/:1:0","tags":["cpp","c++17"],"title":"All Major C++17 Features You Should Know","uri":"/all-major-c-17-features-you-should-know/"},{"categories":null,"content":"1.1 New auto rules for direct-list-initialization ","date":"0001-01-01","objectID":"/all-major-c-17-features-you-should-know/:1:1","tags":["cpp","c++17"],"title":"All Major C++17 Features You Should Know","uri":"/all-major-c-17-features-you-should-know/"},{"categories":null,"content":"1.2 static_assert with no message static_assert() 可以不用再写 message 了， 类似 C assert ","date":"0001-01-01","objectID":"/all-major-c-17-features-you-should-know/:1:2","tags":["cpp","c++17"],"title":"All Major C++17 Features You Should Know","uri":"/all-major-c-17-features-you-should-know/"},{"categories":null,"content":"1.3 typename in a template template parameter 模板中以前只能用 class 来声明类型，现在可以用 typename 了 template \u003ctemplate \u003ctypename...\u003e typename Container\u003e // used to be invalid ^^^^^^^^ struct foo; foo\u003cstd::vector\u003e my_foo; ","date":"0001-01-01","objectID":"/all-major-c-17-features-you-should-know/:1:3","tags":["cpp","c++17"],"title":"All Major C++17 Features You Should Know","uri":"/all-major-c-17-features-you-should-know/"},{"categories":null,"content":"1.4 Nested namespace definition Allows to write: namespace A::B::C { // ... } Rather than: namespace A { namespace B { namespace C { // ... } } } ","date":"0001-01-01","objectID":"/all-major-c-17-features-you-should-know/:1:4","tags":["cpp","c++17"],"title":"All Major C++17 Features You Should Know","uri":"/all-major-c-17-features-you-should-know/"},{"categories":null,"content":" Table of Contents 1 INTRODUCTION 2 RELATED WORK 3 SYSTEM ARCHITECTURE 3.1 ByteNDB Overview 3.2 System Overview 3.3 Metadata Service 3.4 OLAP Engine 4 SHARED STORAGE WITH HIGH DATA FRESHNESS 4.1 Delta Store 4.2 Base Store 4.3 High Data Freshness 5 LSN-BASED STRONG DATA CONSISTENCY 6 OLAP QUERY PERFORMANCE OPTIMIZATION 6.1 Delete Optimization for Scans 6.2 Computation Pushdown to Storage Engine 6.3 OLAP Query Engine Optimization 本文为摘录(或转载)，侵删，原文为： ../pdf/5/p3411-chen.pdf ByteHTAP: an HTAP system with high data freshness and strong data consistency. 独立引擎和共享存储架构 ","date":"0001-01-01","objectID":"/bytehtap-bytedances-htap-system-with-high-data-freshness-and-strong-data-consistency/:0:0","tags":["HTAP","ByteDance"],"title":"ByteHTAP: ByteDance’s HTAP System with High Data Freshness and Strong Data Consistency","uri":"/bytehtap-bytedances-htap-system-with-high-data-freshness-and-strong-data-consistency/"},{"categories":null,"content":"1 INTRODUCTION 字节的实际需求： 对刚刚(sub-second, 亚秒级)导入的数据进行复杂分析 支持事务和强一致性 Build HTAP with following Global Designs: 规模大 (Large Scale) 字节的应用，有亿级的用户，需要构建分布式、实时分析系统，可以支撑 PB 级数据 实时 （Real time） 高度新数据 Highly fresh data changes 数据强一致性 根据架构，可将 HTAP 分为两类： 1 单引擎系统 使用一个引擎，例如 SAP Hana 和 MemSQL 。 根据数据格式可以分成两类： 单一数据格式 或者 混合数据格式 2 独立引擎 使用不同的引擎来处理 AP 和 TP ，例如 WildFire 和 TiDB 根据存储结构可以分成： 独立存储 生产中使用较为广泛 数据不够“新鲜” 共享存储 字节采用了 独立引擎 + 共享存储 ： 独立引擎 开发一个能够处理 AP 和 TP 的单一引擎，工作量不小 开源的、能够很好的处理混合模型的引擎没几个 而处理单一模型的引擎则较多（开源或者闭源的） 采用独立引擎，各司其职： TP: ByteNDB AP: Apache Flink 共享存储 字节现有的基础系统采用存储计算分离模型 ByteNDB 的架构类似于 Amazon Aurora 将 ByteNDB 的复制存储进行拓展，支持了列存，以便将变更以最小延迟在存储存传播 列存用于 OLAP 还做了一个内存中的 delta store, 用于保存最新的数据变更， 供 OLAP 使用 架构对用户透明 用户使用一套 SQL API 来进行 AP 和 TP 的查询 由代理 （proxy） 将 SQL 自动转发给 AP 或者 TP 引擎 模块化设计，将来可以方便的将 AP 引擎换成其他引擎 仅需要实现一个存储和新引擎之间的 connector ","date":"0001-01-01","objectID":"/bytehtap-bytedances-htap-system-with-high-data-freshness-and-strong-data-consistency/:1:0","tags":["HTAP","ByteDance"],"title":"ByteHTAP: ByteDance’s HTAP System with High Data Freshness and Strong Data Consistency","uri":"/bytehtap-bytedances-htap-system-with-high-data-freshness-and-strong-data-consistency/"},{"categories":null,"content":"2 RELATED WORK SAP Hana MemSQL TiDB TiKV TiFlash WildFire Spark Wiser ","date":"0001-01-01","objectID":"/bytehtap-bytedances-htap-system-with-high-data-freshness-and-strong-data-consistency/:2:0","tags":["HTAP","ByteDance"],"title":"ByteHTAP: ByteDance’s HTAP System with High Data Freshness and Strong Data Consistency","uri":"/bytehtap-bytedances-htap-system-with-high-data-freshness-and-strong-data-consistency/"},{"categories":null,"content":"3 SYSTEM ARCHITECTURE ","date":"0001-01-01","objectID":"/bytehtap-bytedances-htap-system-with-high-data-freshness-and-strong-data-consistency/:3:0","tags":["HTAP","ByteDance"],"title":"ByteHTAP: ByteDance’s HTAP System with High Data Freshness and Strong Data Consistency","uri":"/bytehtap-bytedances-htap-system-with-high-data-freshness-and-strong-data-consistency/"},{"categories":null,"content":"3.1 ByteNDB Overview ByteNDB 的总体架构如图 1 所示。 一写多读 改进了 MySQL 的缓存池， 事务和锁管理 （ 所以 ByteNDB 是基于 MySQL 改的 ？）以支持 master-replica 同步 Log Store: 存储 redo log Page Store: 应用 redo log, 形成真正数据 类似 Aurora: Log is Database! 两个 Store 都是构建在分布式存储之上 ","date":"0001-01-01","objectID":"/bytehtap-bytedances-htap-system-with-high-data-freshness-and-strong-data-consistency/:3:1","tags":["HTAP","ByteDance"],"title":"ByteHTAP: ByteDance’s HTAP System with High Data Freshness and Strong Data Consistency","uri":"/bytehtap-bytedances-htap-system-with-high-data-freshness-and-strong-data-consistency/"},{"categories":null,"content":"3.2 System Overview ByteHTAP 的架构如图 2 所示： 采用 独立引擎+共享存储 一套 API， 通过 proxy 自动分发给 OLTP 或者 OLAP 引擎 OLTP \\[\\Longrightarrow\\] ByteNDB OLAP \\[\\Longrightarrow\\] Flink Proxy 规则 交由 OLTP: DML, DDL, 简单查询 其他需要使用 TP 表的查询 交由 OLAP: 复杂查询 （join, aggr） 每个表必须有一个主键： 列存要按照该建进行排序 主键值可以通过 DML 更改 （受 OLTP 引擎自动提供的约束限制） 用户可对对列存表指定分区列 当前仅支持哈希分区 数据一致性 每个 DML \u0026 DDL 都有一个唯一的 LSN 同一事务中的语句包装在一起 元数据服务向 OLAP 引擎提供全局已提交的 LSN 任何小于此 LSN 的 LSN 都应该已经被 OLAP 所接收并持久化 OLAP 的查询会被赋予一个基于全局已提交 LSN 生成的只读 LSN 用于查询 data changes 通常控制在 1 秒以内。 目前 不支持混合了 DML 与只读查询的事务 无分布式事务支持 ","date":"0001-01-01","objectID":"/bytehtap-bytedances-htap-system-with-high-data-freshness-and-strong-data-consistency/:3:2","tags":["HTAP","ByteDance"],"title":"ByteHTAP: ByteDance’s HTAP System with High Data Freshness and Strong Data Consistency","uri":"/bytehtap-bytedances-htap-system-with-high-data-freshness-and-strong-data-consistency/"},{"categories":null,"content":"3.3 Metadata Service 中心化的元数据服务 (Metadata Service MDS) 用于提供统一的服务，包括： catalog 系统表 仅供 AP 使用 TP 自行存储 跨 AP 和 TP 的分区信息 供 AP 和 TP 所使用的数据统计信息 减少其他 ByteHTAP 模块的状态信息 提供全局已提交 LSN 用于 OLAP 查询作为只读 LSN 使用 MDS 基于 Zookeeper 构建，支持高可用 MDS 的客户端 集成进了 OLAP 计算引擎以及存储服务 以便和 MDS 交互，获取多版本的元数据 集成进了 DDL 解析器 MDS 信息来源： DDL 逻辑日志： 由 OLTP 引擎生成，包含元数据变更信息 由复制框架中继传播给 TP 的 Page Store 和 AP 的 Column Store 以及 MDS MDS 对逻辑日志进行解析，由此产生系统表和分区 schema，并进行序列化和持久化，向外提供信息 ","date":"0001-01-01","objectID":"/bytehtap-bytedances-htap-system-with-high-data-freshness-and-strong-data-consistency/:3:3","tags":["HTAP","ByteDance"],"title":"ByteHTAP: ByteDance’s HTAP System with High Data Freshness and Strong Data Consistency","uri":"/bytehtap-bytedances-htap-system-with-high-data-freshness-and-strong-data-consistency/"},{"categories":null,"content":"3.4 OLAP Engine 使用 Apache Flink 作为 AP 的计算引擎 评估过 Spark, Flink, Presto TPC-H 和 TPC-DS 性能相近 选用 Flink: 公司内使用广泛 支持流式查询 （Streaming Queries） Flink 结合列存，形成计算引擎 Data Connector 用于高效、并行读取列存数据 支持聚集和扫描下推 支持分区修正 （partition prune），过滤掉不需要的分区 ","date":"0001-01-01","objectID":"/bytehtap-bytedances-htap-system-with-high-data-freshness-and-strong-data-consistency/:3:4","tags":["HTAP","ByteDance"],"title":"ByteHTAP: ByteDance’s HTAP System with High Data Freshness and Strong Data Consistency","uri":"/bytehtap-bytedances-htap-system-with-high-data-freshness-and-strong-data-consistency/"},{"categories":null,"content":"4 SHARED STORAGE WITH HIGH DATA FRESHNESS 共享存储： Delta Store + Base Store Delta Store 保存在内存中 行模式 及时应用日志（低延迟）生成新鲜数据供 OLAP 使用 Base Store 以列存形式持久化保存 复制框架 Replication Framework 管理 Delta Store, Base Store 和 Log Store, Page Store ","date":"0001-01-01","objectID":"/bytehtap-bytedances-htap-system-with-high-data-freshness-and-strong-data-consistency/:4:0","tags":["HTAP","ByteDance"],"title":"ByteHTAP: ByteDance’s HTAP System with High Data Freshness and Strong Data Consistency","uri":"/bytehtap-bytedances-htap-system-with-high-data-freshness-and-strong-data-consistency/"},{"categories":null,"content":"4.1 Delta Store 高可用： 分区： OLAP 表会进行分区 副本： 每个分区有三个副本 Delta Store: 每个分区的每个副本一个 Delta Store Delta Store 包含两个列表， 以逻辑日志中的 LSN 为序 Insertion List 记录插入操作 Deletion List 记录删除操作 Delete Hash Map SCAN 操作需要访问 base store 和 delta store 来检查某一行是否已经删除 从 Deletion List 构建 Delete Hash Map, 用于加速查询 Delta Store 有四种主要的操作，且可以并行： 日志应用 LogApply Flush 从 Delta Store 生成 Base Store Garbage Collection Scan ","date":"0001-01-01","objectID":"/bytehtap-bytedances-htap-system-with-high-data-freshness-and-strong-data-consistency/:4:1","tags":["HTAP","ByteDance"],"title":"ByteHTAP: ByteDance’s HTAP System with High Data Freshness and Strong Data Consistency","uri":"/bytehtap-bytedances-htap-system-with-high-data-freshness-and-strong-data-consistency/"},{"categories":null,"content":"4.2 Base Store 持久化列存 每个分片的每个副本创建一个 Base Store 中不保存 LSN 优点 减少存储负担 提升 scan 和 update 的效率 缺点 只能读取 Delta Store 中保存的快照 更老的快照无法获取 Base Store 的数据 保存格式为 Partitioned Attributes Across （PAX） 每个 Base Store 包含多个数据块 （data blocks） 每个数据块默认大为 32MB, 由若干行组成 数据块内部按照主键排序 内部既保存了： 块级的元数据 行数 key range 主键构建的 BloomFilter （XXX: 这个可以考虑） 每列的统计信息：如 min/max 每一列编码后的数据 (encoded data for each column) 仅支持 value based index Groom Why? 数据删除操作，仅更新 bitmap, 而不删除数据 长期操作会导致磁盘使用空间不断增长 Flush 操作产生的分区表的范围可能重叠 scan 操作需要访问多个分区，性能差 数据合并 后台线程运行 周期性检查： 已删除的数据占比 不同数据块主键重叠 将符合上述特征的数据块进行合并 新块将不包含已删除数据 最小化重叠的主键 合并后 更新 metadata 将原 block 添加到 GC list 垃圾回收 后台运行 定期检查 GC list 如果没有 active session 在访问，则删除之 ","date":"0001-01-01","objectID":"/bytehtap-bytedances-htap-system-with-high-data-freshness-and-strong-data-consistency/:4:2","tags":["HTAP","ByteDance"],"title":"ByteHTAP: ByteDance’s HTAP System with High Data Freshness and Strong Data Consistency","uri":"/bytehtap-bytedances-htap-system-with-high-data-freshness-and-strong-data-consistency/"},{"categories":null,"content":"4.3 High Data Freshness ","date":"0001-01-01","objectID":"/bytehtap-bytedances-htap-system-with-high-data-freshness-and-strong-data-consistency/:4:3","tags":["HTAP","ByteDance"],"title":"ByteHTAP: ByteDance’s HTAP System with High Data Freshness and Strong Data Consistency","uri":"/bytehtap-bytedances-htap-system-with-high-data-freshness-and-strong-data-consistency/"},{"categories":null,"content":"5 LSN-BASED STRONG DATA CONSISTENCY ","date":"0001-01-01","objectID":"/bytehtap-bytedances-htap-system-with-high-data-freshness-and-strong-data-consistency/:5:0","tags":["HTAP","ByteDance"],"title":"ByteHTAP: ByteDance’s HTAP System with High Data Freshness and Strong Data Consistency","uri":"/bytehtap-bytedances-htap-system-with-high-data-freshness-and-strong-data-consistency/"},{"categories":null,"content":"6 OLAP QUERY PERFORMANCE OPTIMIZATION ","date":"0001-01-01","objectID":"/bytehtap-bytedances-htap-system-with-high-data-freshness-and-strong-data-consistency/:6:0","tags":["HTAP","ByteDance"],"title":"ByteHTAP: ByteDance’s HTAP System with High Data Freshness and Strong Data Consistency","uri":"/bytehtap-bytedances-htap-system-with-high-data-freshness-and-strong-data-consistency/"},{"categories":null,"content":"6.1 Delete Optimization for Scans ","date":"0001-01-01","objectID":"/bytehtap-bytedances-htap-system-with-high-data-freshness-and-strong-data-consistency/:6:1","tags":["HTAP","ByteDance"],"title":"ByteHTAP: ByteDance’s HTAP System with High Data Freshness and Strong Data Consistency","uri":"/bytehtap-bytedances-htap-system-with-high-data-freshness-and-strong-data-consistency/"},{"categories":null,"content":"6.2 Computation Pushdown to Storage Engine Predicate Pushdown min/max 块级过滤 减少无用 IO 延迟物化 优先计算条件列 再去读取其他列 减少 IO Aggregate Pushdown 每个分片上先做部分聚集 (Partial Aggregate) 最后汇总二次聚集 ","date":"0001-01-01","objectID":"/bytehtap-bytedances-htap-system-with-high-data-freshness-and-strong-data-consistency/:6:2","tags":["HTAP","ByteDance"],"title":"ByteHTAP: ByteDance’s HTAP System with High Data Freshness and Strong Data Consistency","uri":"/bytehtap-bytedances-htap-system-with-high-data-freshness-and-strong-data-consistency/"},{"categories":null,"content":"6.3 OLAP Query Engine Optimization 对 Flink 的改进，包括： 统计信息收集 异步读取 并行优化 ","date":"0001-01-01","objectID":"/bytehtap-bytedances-htap-system-with-high-data-freshness-and-strong-data-consistency/:6:3","tags":["HTAP","ByteDance"],"title":"ByteHTAP: ByteDance’s HTAP System with High Data Freshness and Strong Data Consistency","uri":"/bytehtap-bytedances-htap-system-with-high-data-freshness-and-strong-data-consistency/"},{"categories":null,"content":" Table of Contents 1 ABSTRACT 2 INTRODUCTION 3 PRELIMINARIES AND BACKGROUND 4 EVALUATION PLAN 4.1 CardEst Algorithms 本文为摘录(或转载)，侵删，原文为： attachments/pdf/2/p752-zhu.pdf ","date":"0001-01-01","objectID":"/p752-zhu/:0:0","tags":null,"title":"Cardinality Estimation in DBMS: A Comprehensive Benchmark Evaluation","uri":"/p752-zhu/"},{"categories":null,"content":"1 ABSTRACT we compare the effectiveness of CardEst methods in a real DBMS We establish a new benchmark for CardEst, which: contains a new complex realworld dataset STATS and a diverse query workload STATS-CEB. We integrate multiple most representative CardEst methods into PostgreSQL, and evaluate their true effectiveness in improving query plan quality, and other important aspects affecting their applicability. We obtain key findings for the CardEst methods, under different data and query settings We propose a new metric P-Error to evaluate the performance of CardEst methods which overcomes the limitation of Q-Error and is able to reflect the overall end-to-end performance of CardEst methods. We have made all of the benchmark data and evaluation code publicly available at https://github.com/Nathaniel-Han/End-to-End-CardEst-Benchmark. ","date":"0001-01-01","objectID":"/p752-zhu/:1:0","tags":null,"title":"Cardinality Estimation in DBMS: A Comprehensive Benchmark Evaluation","uri":"/p752-zhu/"},{"categories":null,"content":"2 INTRODUCTION Performance of CardEst has a critical impact on the quality of the query plans. The core task of CardEst: build a compact model capturing data and/or query information. Traditional CardEst Method, mainly use two traditional CardEst methods: histogram (PG, SQL Server) sampling (MySQL, MariaDB) Learned methods (ML) for CardEst 可以分为两类： query-driven （查询驱动）： 将特征化的查询映射到它们的基数 data-driven （数据驱动） ： 直接对所有属性的联合分布进行建模 与传统的基数估计相比，更加准确： 模型更复杂 粒度更细 尽管如此，仍有两个短处： 用于训练的数据和查询负载，并不能够很好的代表实际查询 Therefore, the existing works are not sufficient to reflect the behavior of CardEst methods on complex real-world data with high skewness and correlations and multi-table queries with various join forms and conditions. 大部分的评估并未展示 CardEst 方法在查询优化器上的端到端改进 现有的工作通常评估 CardEst 方法的算法级指标，如估计精度和推理延迟 这些指标仅能评估 CardEst 算法本身的质量，而不能用于评估这些方法在数据库中起到的真实作用，原因有二： 评估的准确不代表作出的计划就好 不同的子查询对整个计划影响很大，一个评估很准确的算法，也可能因错估导致关键的评估而导致很差的计划 We establish a new benchmark for CardEst that can represent real-world settings. ","date":"0001-01-01","objectID":"/p752-zhu/:2:0","tags":null,"title":"Cardinality Estimation in DBMS: A Comprehensive Benchmark Evaluation","uri":"/p752-zhu/"},{"categories":null,"content":"3 PRELIMINARIES AND BACKGROUND In this section, we introduce some preliminaries and background, including a formal definition of the cardinality estimation problem, a brief review on representative CardEst algorithms and a short analysis on existing CardEst benchmarks. The CardEst problem requires estimating Card as accurately as possible without executing Q on T . CardEst solutions for n. Whereas, CardEst methods for “LIKE” queries concern on applying NLP techniques to summarize semantic information in strings. Statistical CardEst methods can not well support “LIKE” queries. Traditional CardEst methods, such as histogram and sampling , are widely applied in DBMS and generally based on simplified assumptions and heuristics. Lots of variants are proposed later to enhance their performance. DBMS . Pos tId= Po kernel-based methods , index based methods and random walk based methods . Some other work, such as the sketch based method , explores a new routine for CardEst. ML-based query-driven CardEst methods try to learn a model to map each featurized query Q to its cardinality Card directly. Some ML-enhanced methods improve the performance of CardEst methods by using more complex models such as DNNs or gradient boosted trees . ML-based data-driven CardEst methods are independent of the queries. To this end, we establish our benchmark on a new real-world dataset with a hand-picked query workload. It overcomes the drawbacks of existing CardEst benchmarks and fully fulfills the properties listed above. We describe the details on the data and workload settings in the following content. It is an anonymized dump of user-contributed content on the Stats Stack Exchange network. STATS consumes 658MB storage space with 8 tables and 71 n. Whereas, STATS has richer and more diverse join types varying in the number of joined tables , join forms , and join keys non-equal joins as they rarely occur in practice and many CardEst algorithms process them in the same way as many-to-many joins. We manually check and retain each join template if it has occurred in the log data of StackExchangeor has its real-world semantics. In the second phrase after deriving these 70 join templates, we generate 146 queries with 1 − 4 queries for each template as the testing query workload STATS-CEB. We make sure all the generated filter predicates reflect real-world semantics and diversify in multiple perspectives. The largest query in STATS-CEB has true cardinality of 20 billion, which is 3 larger than that of the JOB-LIGHT benchmark. predicates join type true cardinality range. ","date":"0001-01-01","objectID":"/p752-zhu/:3:0","tags":null,"title":"Cardinality Estimation in DBMS: A Comprehensive Benchmark Evaluation","uri":"/p752-zhu/"},{"categories":null,"content":"4 EVALUATION PLAN We aim to evaluate how CardEst algorithms behave in a real DBMS, including the end-to-end improvement on optimizing query plans and other practicality aspects, on our new benchmark. ","date":"0001-01-01","objectID":"/p752-zhu/:4:0","tags":null,"title":"Cardinality Estimation in DBMS: A Comprehensive Benchmark Evaluation","uri":"/p752-zhu/"},{"categories":null,"content":"4.1 CardEst Algorithms We identify and choose twelve representative CardEst algorithms across the three classes: traditional ML-based, query-driven ML-based, data-driven PostgreSQL refers to the histogram-based CardEst method used in the well-known DBMS PostgreSQL We use the implementation provided by authors in to generate the sketches and partition the data with 4096 buckets. Different from , we apply the same setting as to populate the bound sketches for queries with selection predicates, which would improve the estimation accuracy and generate better plans. We do not compare with the other variants of traditional methods as they do not exhibit significantly better performance or provide open-source implementation. Specifically, the tree-structured SPN contains sum node to split PT to multiple PT ′ on tuple subset T ′ T , product node to decompose PT to S PT for independent set of attributes S and leaf node if PT is a univariate PDF. Then, the multi-leaf node is used to model the multivariate PDF PT UAE extends the UAE-Q method by unifiying both query and data information using the auto-regression model. It is a representative work aiming at closing the gap between data-driven and query-driven CardEst methods. Otherwise, we run a grid search to explore the combination of value that largely improves the endto-end performance on a validation set of queries. Notice that, there have also been proposed some CardEst modules that are optimized together with other components in a query optimizer in an end-to-end manner. We do not compare with them as they do not fit our evaluation framework. To make our evaluation more realistic and convincing, we integrate each CardEst algorithm into the query optimizer of PostgreSQL , a well-recognized open-source DBMS. Implementation and System Settings CardEst method can be directly reflected by the end-to-end query runtime with their injected cardinality estimation. For example, the subplan queries A, B, and C only touch a single table, their CardEst results may affect the selection of table-scan methods, i.e. Joining A ▷◁ B with C or A ▷◁ C with B, and the join method, i.e. Therefore, the effects of a CardEst method on the final query execution plan are entirely decided by its estimation results over the sub-plan query space. “calc_joinrel_size_estimate” in the planner of PostgreSQL to derive the sub-plan query space for each query in the workload. Then, we call each CardEst method to estimate the cardinalities of the sub-plan queries and inject the estimations back into PostgreSQL. Afterward, we run the compiler of PostgreSQL on Q to generate the plan. It will directly read the injected cardinalities produced by each method. CardEst method without a large modification on the source code of PostgreSQL. SQL query using any CardEst method. Intel Xeon Updating speed reflects the time cost for CardEst models update to fit the data changes. For real-world settings, this metric plays an important role as its underlying data always updates with tuples insertions and deletions. Besides these metrics, proposed some qualitative metrics related to the stability, usage, and deployment of CardEst algorithms and made a comprehensive analysis. In the following, we first evaluate the overall endto-end performance of all methods in Section 5. HOW GOOD ARE CARDEST METHODS? In this section, we first thoroughly investigate the true effectiveness of the aforementioned CardEst methods in improving query plan quality. Our evaluation focuses on a static environment where data in the system has read-only access. This setting is ubiquitous and critical for commercial DBMS, especially in OLAP workloads of data warehouses . Overall End-to-End Performance We evaluate the end-to-end performance on both JOB-LIGHT and STATS-CEB benchmarks for all CardEst methods including two baselines PostgreSQL and TrueCard shown in Table 3. each of these CardEst methods. The astonishing performance of these ML-based data-driven CardEst m","date":"0001-01-01","objectID":"/p752-zhu/:4:1","tags":null,"title":"Cardinality Estimation in DBMS: A Comprehensive Benchmark Evaluation","uri":"/p752-zhu/"},{"categories":null,"content":" Table of Contents 1 Threads (Tasks (threads) versus processes) 1.1 cgroup v2 线程限制 ","date":"0001-01-01","objectID":"/cgroup-memo/:0:0","tags":null,"title":"cgroup memo","uri":"/cgroup-memo/"},{"categories":null,"content":"1 Threads (Tasks (threads) versus processes) cgroup v1 可以单独操作进程中的线程, man cgroups : In cgroups v1, a distinction is drawn between processes and tasks. In this view, a process can con‐ sist of multiple tasks (more commonly called threads, from a user-space perspective, and called such in the remainder of this man page). In cgroups v1, it is possible to independently manipulate the cgroup memberships of the threads in a process. v2 中起初移除了线程支持，然后在后期又将其中的功能 “有限的” 加了回来： The cgroups v1 ability to split threads across different cgroups caused problems in some cases. For example, it made no sense for the memory controller, since all of the threads of a process share a single address space. Because of these problems, the ability to independently manipulate the cgroup memberships of the threads in a process was removed in the initial cgroups v2 implementation, and subsequently restored in a more limited form (see the discussion of “thread mode” below). ","date":"0001-01-01","objectID":"/cgroup-memo/:1:0","tags":null,"title":"cgroup memo","uri":"/cgroup-memo/"},{"categories":null,"content":"1.1 cgroup v2 线程限制 Linux 4.14 为 cgroup v2 增加了线程模式，该模式可以： • The creation of threaded subtrees in which the threads of a process may be spread across cgroups inside the tree. (A threaded subtree may contain multiple multithreaded processes.) • The concept of threaded controllers, which can distribute resources across the cgroups in a threaded subtree. • A relaxation of the “no internal processes rule”, so that, within a threaded subtree, a cgroup can both contain member threads and exercise resource control over child cgroups. ","date":"0001-01-01","objectID":"/cgroup-memo/:1:1","tags":null,"title":"cgroup memo","uri":"/cgroup-memo/"},{"categories":null,"content":" Table of Contents 1 ABSTRACT 2 INTRODUCTION 3 PRELIMINARIES 3.1 Floating Point Time Series 3.2 IEEE 754 Double Precision Floating Point Format 3.3 Gorilla Compression 4 PROPERTIES OF REAL-WORLD TIME SERIES 4.1 Trailing Zeros 4.2 Leading Zeros 4.3 Revisiting Gorilla Compression 5 OVERVIEW 5.1 Our Chimp Algorithm 6 效果对比 6.1 Compression size result 6.2 Compression and decompression time 本文为摘录(或转载)，侵删，原文为： attachments/pdf/1/p3058-liakos.pdf ","date":"0001-01-01","objectID":"/p3058-liakos/:0:0","tags":["timeseries","database","compression"],"title":"Chimp: Efficient Lossless Floating Point Compression for Time Series Databases","uri":"/p3058-liakos/"},{"categories":null,"content":"1 ABSTRACT 时序数据难以高效存储，导致存储代价高昂。 通用压缩 技术可以减少数据大小，但给计算带来额外开销。 通常不能忍受 通常采用快速、 流式压缩 将数据进行编码 该做法无法完全使用压缩的潜力 Chimp 新型流式压缩算法 适用于时间序列的浮点数运算 压缩比与通用算法相当，比目前标准的流式压缩比高 50% 压缩、解压时间更短 ","date":"0001-01-01","objectID":"/p3058-liakos/:1:0","tags":["timeseries","database","compression"],"title":"Chimp: Efficient Lossless Floating Point Compression for Time Series Databases","uri":"/p3058-liakos/"},{"categories":null,"content":"2 INTRODUCTION TSMS: Time Series Management Systems TSMS 压缩存储浮点数据的方法： 将当前值与前一时刻的值进行异或运算 （XOR） 得到的值中，大概率很多的 bit 会是 0: 因为数据一般不会突然变化很大 我们发现，相邻数据 XOR 的结果： 0 通常不会出现在结果的尾部 而是出现在头部 ","date":"0001-01-01","objectID":"/p3058-liakos/:2:0","tags":["timeseries","database","compression"],"title":"Chimp: Efficient Lossless Floating Point Compression for Time Series Databases","uri":"/p3058-liakos/"},{"categories":null,"content":"3 PRELIMINARIES ","date":"0001-01-01","objectID":"/p3058-liakos/:3:0","tags":["timeseries","database","compression"],"title":"Chimp: Efficient Lossless Floating Point Compression for Time Series Databases","uri":"/p3058-liakos/"},{"categories":null,"content":"3.1 Floating Point Time Series 时间序列， Time series （TS） 一系列的数据点 数据点是一对 时间戳 和 值 数据点按照时间递增排序 \\[TS=\\langle(\\,t_1, v_1 )\\,,(\\,t_2, v_2 )\\, ,… \\rangle \\] \\(t_i\\) 表示时间戳 \\(v_i\\) 表示值 Bounded Time series 特殊的时间序列 拥有固定个数的时间序列 \\[TS=\\langle(\\,t_1, v_1 )\\,,…,(\\,t_n, v_n )\\, \\rangle \\] Floating Point Time series 特殊的时间序列 \\[TS=\\langle(\\,t_1, v_1 )\\,,(\\,t_2, v_2 )\\, ,… \\rangle \\] 满足： \\[v_i \\in \\mathbb{R}\\] \\[i \\in \\mathbb{N}\\] ","date":"0001-01-01","objectID":"/p3058-liakos/:3:1","tags":["timeseries","database","compression"],"title":"Chimp: Efficient Lossless Floating Point Compression for Time Series Databases","uri":"/p3058-liakos/"},{"categories":null,"content":"3.2 IEEE 754 Double Precision Floating Point Format 双精度浮点数的格式 符号位， Sign (S) 1 bit 0: 正 1: 负 指数位, biased exponent (E) 11 bits 偏移为 1023 分数位, Fractional (F) 52 bits 数学表示： \\[x = (-1)^s \\times 2 ^{(E-B)} \\times 1.F\\] ","date":"0001-01-01","objectID":"/p3058-liakos/:3:2","tags":["timeseries","database","compression"],"title":"Chimp: Efficient Lossless Floating Point Compression for Time Series Databases","uri":"/p3058-liakos/"},{"categories":null,"content":"3.3 Gorilla Compression Gorilla 的变长编码： 第一个数值不压缩 后续数值与前一个做 XOR: 结果为 0 （即两者相等）， 则存 0 如果不为 0 ：则存 1 ， 后接： 控制位 0 ： 当前有效位数在前者有效位数范围内，即： 当前值（XOR 后）的 leading zeros 的个数大于前值的 leading zeros, 且 当前值的 trailing zeros 的个数大于前值的 trailing zeros 此情况下使用前值的信息，在控制位后进保存 XOR 后的有效数值 控制位 1 ： 使用接下来的 5 bits 来保存 leading zero 的个数 使用接下来的 6 bits 来保存 XOR 结果的有效数值长度 最后保存 XOR 结果的有效数值 ","date":"0001-01-01","objectID":"/p3058-liakos/:3:3","tags":["timeseries","database","compression"],"title":"Chimp: Efficient Lossless Floating Point Compression for Time Series Databases","uri":"/p3058-liakos/"},{"categories":null,"content":"4 PROPERTIES OF REAL-WORLD TIME SERIES ","date":"0001-01-01","objectID":"/p3058-liakos/:4:0","tags":["timeseries","database","compression"],"title":"Chimp: Efficient Lossless Floating Point Compression for Time Series Databases","uri":"/p3058-liakos/"},{"categories":null,"content":"4.1 Trailing Zeros ","date":"0001-01-01","objectID":"/p3058-liakos/:4:1","tags":["timeseries","database","compression"],"title":"Chimp: Efficient Lossless Floating Point Compression for Time Series Databases","uri":"/p3058-liakos/"},{"categories":null,"content":"4.2 Leading Zeros ","date":"0001-01-01","objectID":"/p3058-liakos/:4:2","tags":["timeseries","database","compression"],"title":"Chimp: Efficient Lossless Floating Point Compression for Time Series Databases","uri":"/p3058-liakos/"},{"categories":null,"content":"4.3 Revisiting Gorilla Compression 4.3.1 Flag Bits. 前面介绍 Gorilla 的 flag bits 有三种： 0 ， 10 和 11 。其中 0 表示当前值和前面的值相等。然而这种情形并不常见。 如果能够使用最少的比特位来表示最常见的情况，则应该能够提升压缩比。 4.3.2 Length of Meaningful XORed Value (Center Bits). 4.3.3 Previous Block Position. ","date":"0001-01-01","objectID":"/p3058-liakos/:4:3","tags":["timeseries","database","compression"],"title":"Chimp: Efficient Lossless Floating Point Compression for Time Series Databases","uri":"/p3058-liakos/"},{"categories":null,"content":"5 OVERVIEW ","date":"0001-01-01","objectID":"/p3058-liakos/:5:0","tags":["timeseries","database","compression"],"title":"Chimp: Efficient Lossless Floating Point Compression for Time Series Databases","uri":"/p3058-liakos/"},{"categories":null,"content":"5.1 Our Chimp Algorithm 5.1.1 Possible Flag Sequences 之前的研究表明相邻数据完全相同的概率并不大，使用最少的比特位来表示最常见的情况，能够提升压缩比。 ","date":"0001-01-01","objectID":"/p3058-liakos/:5:1","tags":["timeseries","database","compression"],"title":"Chimp: Efficient Lossless Floating Point Compression for Time Series Databases","uri":"/p3058-liakos/"},{"categories":null,"content":"6 效果对比 ","date":"0001-01-01","objectID":"/p3058-liakos/:6:0","tags":["timeseries","database","compression"],"title":"Chimp: Efficient Lossless Floating Point Compression for Time Series Databases","uri":"/p3058-liakos/"},{"categories":null,"content":"6.1 Compression size result ","date":"0001-01-01","objectID":"/p3058-liakos/:6:1","tags":["timeseries","database","compression"],"title":"Chimp: Efficient Lossless Floating Point Compression for Time Series Databases","uri":"/p3058-liakos/"},{"categories":null,"content":"6.2 Compression and decompression time ","date":"0001-01-01","objectID":"/p3058-liakos/:6:2","tags":["timeseries","database","compression"],"title":"Chimp: Efficient Lossless Floating Point Compression for Time Series Databases","uri":"/p3058-liakos/"},{"categories":null,"content":" Table of Contents 1 INTRODUCTION 2 BACKGROUND 2.1 Apache AsterixDB 本文为摘录(或转载)，侵删，原文为： attachments/pdf/f/p2085-alkowaileet.pdf 这篇论文探讨了文档存储数据库系统的数据模型灵活性限制其在列式关系数据库中进行分析工作负载的表现。作者提出了几种基于Log-Structured Merge (LSM) tree事件的技术，旨在将数据存储在列式布局中。他们扩展了Dremel格式并引入一个新的列式布局来组织和存储数据。论文还强调了在文档存储中使用查询编译技术的潜力，并介绍了他们在Apache AsterixDB中的实现和评估。实验结果显示了显著的性能增益，并在最小程度上影响了摄入性能。 ","date":"0001-01-01","objectID":"/p2085-alkowaileet/:0:0","tags":null,"title":"Columnar Formats for Schemaless LSM-based Document Stores","uri":"/p2085-alkowaileet/"},{"categories":null,"content":"1 INTRODUCTION 本文介绍了一种新的数据存储方案，为用户提供了以列格式存储数据时获得性能提升的同时不牺牲文档存储的灵活性。作者对Dremel格式进行了扩展以解决文档存储的灵活数据模型所带来的限制问题，从而允许具有异构类型和模式更改的值。另外，利用LSM树架构在写性能上的优势，结合[22]提出的技巧，利用LSM刷写操作来推断模式并将记录以行格式写入，然后再利用Dremel扩展格式将其作为列格式写入硬盘。整个方案既满足了用户的性能期望，也保留了文档存储的灵活性。 这篇文章提出了一种新的模型，可以将列保存在 LSM B+ 树的索引中。 在这个模型中，将B+树的叶节点拓展为“超级节点”，其中一个叶节点可以占据多个页面。 我们将此模型称为AsterixDB Mega-Attributes Across 或者简称 AMAX。 尽管它的名字是AMAX，但是AMAX与列的结构无关，将每一列视为一系列字节，因此只需要进行少量修改就可以被其他基于LSM的文档存储所接受。在本文中，我们评估了AMAX模型的摄取性能和查询性能。在扩展版本[23]中，我们提出了一个类似于分区属性跨度（PAX）格式[21] 的APAX格式，其中每个列占据B+树叶子页面中的连续区域（称为“小页面”）。由于篇幅限制，我们省略了APAX格式的详细信息，如有兴趣，请参阅[23]获取更多信息。 ","date":"0001-01-01","objectID":"/p2085-alkowaileet/:1:0","tags":null,"title":"Columnar Formats for Schemaless LSM-based Document Stores","uri":"/p2085-alkowaileet/"},{"categories":null,"content":"2 BACKGROUND ","date":"0001-01-01","objectID":"/p2085-alkowaileet/:2:0","tags":null,"title":"Columnar Formats for Schemaless LSM-based Document Stores","uri":"/p2085-alkowaileet/"},{"categories":null,"content":"2.1 Apache AsterixDB 2.1.1 Storage Engine: 其存储引擎使用基于 LSM 树的 B+ 树索引来存储记录 新插入的记录使用主键进行哈希分区，被插入到相应的分区的主LSM内存组件中。 当内存组件已满时: 会将其中的记录刷新到一个新的 LSM 磁盘组件中， 并在其元数据页上设置一个有效性位，释放内存组件以服务后续插入。 LSM 磁盘组件是不可变的: 因此更新和删除操作需要插入新的条目 删除操作会添加一个“反物质”条目来指示已删除具有指定键的记录 更新操作只需加入一个新的记录 - 包括更新的值 - 具有与原始记录相同的键。 新添加的记录将替换旧记录。因此，基于LSM的文档存储将此操作称为“upsert”，因为不支持记录中值的就地部分更新。 合并策略周期性地在后台将磁盘组件合并成较大的组件，以决定何时和如何进行合并。 删除和更新的旧版本记录在合并操作期间进行垃圾回收 ","date":"0001-01-01","objectID":"/p2085-alkowaileet/:2:1","tags":null,"title":"Columnar Formats for Schemaless LSM-based Document Stores","uri":"/p2085-alkowaileet/"},{"categories":null,"content":"Email me: yang.yingchao@qq.com ","date":"0001-01-01","objectID":"/contact/:0:0","tags":null,"title":"Contact","uri":"/contact/"},{"categories":null,"content":" Table of Contents 1 TL;DR 2 About the TIME-WAIT state 2.1 TCP state diagram 2.2 Purpose 3 Problems 4 Other solutions 4.1 net.ipv4.tcp_tw_reuse 5 Another 6 总结 本文为摘录(或转载)，侵删，原文为： https://vincent.bernat.ch/en/blog/2014-tcp-time-wait-state-linux#summary ","date":"0001-01-01","objectID":"/coping-with-the-tcp-time-wait-state-on-busy-linux-servers/:0:0","tags":["time-wait","tcp","linux"],"title":"Coping with the TCP TIME-WAIT state on busy Linux servers","uri":"/coping-with-the-tcp-time-wait-state-on-busy-linux-servers/"},{"categories":null,"content":"1 TL;DR 不用启用 net.ipv4.tcp_tw_recycle ， 该选项已在 Linux4.12 废弃 多数情况下， TIME-WAIT 状态的 socket 无害 ","date":"0001-01-01","objectID":"/coping-with-the-tcp-time-wait-state-on-busy-linux-servers/:1:0","tags":["time-wait","tcp","linux"],"title":"Coping with the TCP TIME-WAIT state on busy Linux servers","uri":"/coping-with-the-tcp-time-wait-state-on-busy-linux-servers/"},{"categories":null,"content":"2 About the TIME-WAIT state ","date":"0001-01-01","objectID":"/coping-with-the-tcp-time-wait-state-on-busy-linux-servers/:2:0","tags":["time-wait","tcp","linux"],"title":"Coping with the TCP TIME-WAIT state on busy Linux servers","uri":"/coping-with-the-tcp-time-wait-state-on-busy-linux-servers/"},{"categories":null,"content":"2.1 TCP state diagram http://tcpipguide.com/free/t_TCPOperationalOverviewandtheTCPFiniteStateMachineF-2.htm 只有主动关闭连接一端会进入 TIME-WAIT 状态 另外一端通常会走另外一条路径，快速关闭连接 可以通过命令 ss -tan 来查看状态 $ ss -tan | head -5 LISTEN 0 511 *:80 *:* SYN-RECV 0 0 192.0.2.145:80 203.0.113.5:35449 SYN-RECV 0 0 192.0.2.145:80 203.0.113.27:53599 ESTAB 0 0 192.0.2.145:80 203.0.113.27:33605 TIME-WAIT 0 0 192.0.2.145:80 203.0.113.47:50685 ","date":"0001-01-01","objectID":"/coping-with-the-tcp-time-wait-state-on-busy-linux-servers/:2:1","tags":["time-wait","tcp","linux"],"title":"Coping with the TCP TIME-WAIT state on busy Linux servers","uri":"/coping-with-the-tcp-time-wait-state-on-busy-linux-servers/"},{"categories":null,"content":"2.2 Purpose ","date":"0001-01-01","objectID":"/coping-with-the-tcp-time-wait-state-on-busy-linux-servers/:2:2","tags":["time-wait","tcp","linux"],"title":"Coping with the TCP TIME-WAIT state on busy Linux servers","uri":"/coping-with-the-tcp-time-wait-state-on-busy-linux-servers/"},{"categories":null,"content":"3 Problems ","date":"0001-01-01","objectID":"/coping-with-the-tcp-time-wait-state-on-busy-linux-servers/:3:0","tags":["time-wait","tcp","linux"],"title":"Coping with the TCP TIME-WAIT state on busy Linux servers","uri":"/coping-with-the-tcp-time-wait-state-on-busy-linux-servers/"},{"categories":null,"content":"4 Other solutions ","date":"0001-01-01","objectID":"/coping-with-the-tcp-time-wait-state-on-busy-linux-servers/:4:0","tags":["time-wait","tcp","linux"],"title":"Coping with the TCP TIME-WAIT state on busy Linux servers","uri":"/coping-with-the-tcp-time-wait-state-on-busy-linux-servers/"},{"categories":null,"content":"4.1 net.ipv4.tcp_tw_reuse ","date":"0001-01-01","objectID":"/coping-with-the-tcp-time-wait-state-on-busy-linux-servers/:4:1","tags":["time-wait","tcp","linux"],"title":"Coping with the TCP TIME-WAIT state on busy Linux servers","uri":"/coping-with-the-tcp-time-wait-state-on-busy-linux-servers/"},{"categories":null,"content":"5 Another ","date":"0001-01-01","objectID":"/coping-with-the-tcp-time-wait-state-on-busy-linux-servers/:5:0","tags":["time-wait","tcp","linux"],"title":"Coping with the TCP TIME-WAIT state on busy Linux servers","uri":"/coping-with-the-tcp-time-wait-state-on-busy-linux-servers/"},{"categories":null,"content":"6 总结 在某些场景下，60 秒的等待销毁时间确实是难以接受的，例如：高并发的压力测试。当我们通过并发请求测试远程服务的吞吐量和延迟时，本地就可能产生大量处于 TIME_WAIT 状态的 TCP 连接，在 macOS 上可以使用如下所示的命令查看活跃的连接： ","date":"0001-01-01","objectID":"/coping-with-the-tcp-time-wait-state-on-busy-linux-servers/:6:0","tags":["time-wait","tcp","linux"],"title":"Coping with the TCP TIME-WAIT state on busy Linux servers","uri":"/coping-with-the-tcp-time-wait-state-on-busy-linux-servers/"},{"categories":null,"content":" Table of Contents 1 Hash \u0026 TapeSet 2 Slot \u0026 tuple ","date":"0001-01-01","objectID":"/data-structor-in-pg/:0:0","tags":null,"title":"Data Structures in PG","uri":"/data-structor-in-pg/"},{"categories":null,"content":"1 Hash \u0026 TapeSet class LogicalTapeSet { + BufFile pfile + SharedFileSet fileset + int worker + long nBlocksAllocated + long nBlocksWritten + long nHoleBlocks + bool forgetFreeSpace + long freeBlocks + long nFreeBlocks + Size freeBlocksLen + bool enable_prealloc } class LogicalTape { + LogicalTapeSet tapeSet + bool writing + bool frozen + bool dirty + long firstBlockNumber + long curBlockNumber + long nextBlockNumber + long offsetBlockNumber + char buffer + int buffer_size + int max_size + int pos + int nbytes + long prealloc + int nprealloc + int prealloc_size } class BufFile { + int numFiles + File files + bool isInterXact + bool dirty + bool readOnly + FileSet fileset + const name + ResourceOwner resowner + int curFile + off_t curOffset + int pos + int nbytes + PGAlignedBlock buffer } LogicalTapeSet *-- BufFile class HashAggSpill { + int npartitions + LogicalTape partitions + int64 ntuples + uint32 mask + int shift + hyperLogLogState hll_card } HashAggSpill *-- LogicalTape LogicalTape - LogicalTapeSet ","date":"0001-01-01","objectID":"/data-structor-in-pg/:1:0","tags":null,"title":"Data Structures in PG","uri":"/data-structor-in-pg/"},{"categories":null,"content":"2 Slot \u0026 tuple class TupleTableSlot { + NodeTag type + int tts_flags + AttrNumber tts_nvalid + const tts_ops + TupleDesc tts_tupleDescriptor + int tts_values + int tts_isnull + int tts_mcxt + ItemPointerData tts_tid + int tts_tableOid } class MinimalTupleData { + int t_len + char mt_padding + int t_infomask2 + int t_infomask + int t_hoff + int t_bits } class HeapTupleHeaderData { + union t_choice + ItemPointerData t_ctid + int t_infomask2 + int t_infomask + int t_hoff + int t_bits } class union { + HeapTupleFields t_heap + DatumTupleFields t_datum } HeapTupleHeaderData *-- union class MinimalTupleTableSlot { + TupleTableSlot base + HeapTuple tuple + MinimalTuple mintuple + HeapTupleData minhdr + int off } class HeapTupleData { + int t_len + ItemPointerData t_self + int t_tableOid + HeapTupleHeader t_data } class VirtualTupleTableSlot { + TupleTableSlot base + char data } class HeapTupleTableSlot { + TupleTableSlot base + HeapTuple tuple + int off + HeapTupleData tupdata } class BufferHeapTupleTableSlot { + HeapTupleTableSlot base + Buffer buffer } TupleTableSlot \u003c|-- MinimalTupleTableSlot TupleTableSlot \u003c|-- VirtualTupleTableSlot TupleTableSlot \u003c|-- HeapTupleTableSlot HeapTupleTableSlot \u003c|-- BufferHeapTupleTableSlot MinimalTupleTableSlot *-- MinimalTupleData HeapTupleTableSlot *-- HeapTupleData HeapTupleData *-- HeapTupleHeaderData ","date":"0001-01-01","objectID":"/data-structor-in-pg/:2:0","tags":null,"title":"Data Structures in PG","uri":"/data-structor-in-pg/"},{"categories":null,"content":" Table of Contents 1 ABSTRACT 2 INTRODUCTION 3 BACKGROUND 3.1 Hybrid Hash Join 本文为摘录(或转载)，侵删，原文为： attachments/pdf/f/p2257-jahangiri.pdf ","date":"0001-01-01","objectID":"/p2257-jahangiri/:0:0","tags":null,"title":"Design Trade-offs for a Robust Dynamic Hybrid Hash Join","uri":"/p2257-jahangiri/"},{"categories":null,"content":"1 ABSTRACT 探索分片数量对 HHJ 性能的影响 propose a new lower bound for number of partitions design and evaluate different partition insertion techniques to maximize memory utilization with the lest CPU cost ","date":"0001-01-01","objectID":"/p2257-jahangiri/:1:0","tags":null,"title":"Design Trade-offs for a Robust Dynamic Hybrid Hash Join","uri":"/p2257-jahangiri/"},{"categories":null,"content":"2 INTRODUCTION HHJ: Hybrid Hash Join 算法 将数据划分成多个分片 一个分片在内存中 其余分片溢出到磁盘 处理内存中的分片 多趟，处理其余分片 分片数量以及选择哪个分片放在内存中，是生成 operator 时候静态指定的 依据代价模型 有不足之处： 假设 join 列的值程均匀分布 代价模型倚赖于精确的统计信息，如 输入大小等。 然而收集、访问或者预测这些信息有时并不可行： 外部表的统计信息经常不准或者缺失 join 输入的来源如果是其他算子，则其大小可能不准确 ","date":"0001-01-01","objectID":"/p2257-jahangiri/:2:0","tags":null,"title":"Design Trade-offs for a Robust Dynamic Hybrid Hash Join","uri":"/p2257-jahangiri/"},{"categories":null,"content":"3 BACKGROUND ","date":"0001-01-01","objectID":"/p2257-jahangiri/:3:0","tags":null,"title":"Design Trade-offs for a Robust Dynamic Hybrid Hash Join","uri":"/p2257-jahangiri/"},{"categories":null,"content":"3.1 Hybrid Hash Join 3.1.1 Grace Hash Join (GHI) 使用内存作为中间介质，将数据划分成内存中可以装下的分片，然后在做 join 算法 Grace Hash Join 连续的处理 build 和 probe 过程 每个分片都写入磁盘，存程单独的文件 重复划分过程，直到一个分片可以装入内存为止 每个分片创建一个 hash table, 开始 join 适用于 小表 (build 表) 也远远大于内存时候 3.1.2 Simple Hash Join (SHJ) 始终在内存中保存一部分数据，以期减少 IO 的总体开销 算法 records 哈希划分成两个部分： 内存分片 溢出分片 适用于内存可以装下大部分小表数据的时候 3.1.3 Hybrid Hash Join (HHJ) 混合了 GHJ \u0026 SHJ: 通过划分分片来避免不必要的数据比较 使用内存来保存一个分片及其对应的哈希表 如图 1 (a) 所示。 步骤： Build Phase, 使用拆分函数 (split function) 将输入进行哈希划分，其结果： 划分进入内存分片的，驻留内存 其余溢出到磁盘中对应文件 由内存分片构建哈希表 Probe Phase 使用同样的拆分函数 (split function) 将输入进行哈希划分，其结果： 划入内存分片的，直接 probe 其余写入磁盘的对应文件 处理完内存分片后，逐一处理溢出文件。 3.1.4 Dynamic Hybrid Hash Join 与 HHJ 相比： HHJ: 选择预先定义的一个分片常驻内存 DHHJ: 使用动态降级策略来选择内存分片： 如图 1 (b) 所示， Build Phase: build 开始时候，所有分片都在内存中， 只要内存还够用，始终使用内存来保存分片 随着输入的增加，由于数据可能倾斜，各个分片的大小开始不一样 当内存耗尽时， 动态选择 一个分片进行溢出操作 该方法尤其适用于当输入大小或者join 属性的分布未知或者不准确的时候。 ","date":"0001-01-01","objectID":"/p2257-jahangiri/:3:1","tags":null,"title":"Design Trade-offs for a Robust Dynamic Hybrid Hash Join","uri":"/p2257-jahangiri/"},{"categories":null,"content":"本文为摘录(或转载)，侵删，原文为： https://github.com/powa-team/powa Workload Analyzer. ","date":"0001-01-01","objectID":"/powa/:0:0","tags":null,"title":"GitHub - powa-team/powa: PostgreSQL Workload Analyzer","uri":"/powa/"},{"categories":null,"content":" Table of Contents 1 google chrome in hyprland 2 Weird crash when running chrome with: –gtk-version=4 ","date":"0001-01-01","objectID":"/google-chrome-in-hyprland/:0:0","tags":["chrome","hyprland","gtk4","crash"],"title":"google chrome in hyprland","uri":"/google-chrome-in-hyprland/"},{"categories":null,"content":"1 google chrome in hyprland Hyprland is cool, but it may not work smoothly on default Google Chrome. The borders appear distorted and blurry. To resolve this issue, simply open the Chrome settings, navigate to appearance (chrome://settings/appearance), and enable “Use system title bar and borders.” Afterwards, restart the browser. ","date":"0001-01-01","objectID":"/google-chrome-in-hyprland/:1:0","tags":["chrome","hyprland","gtk4","crash"],"title":"google chrome in hyprland","uri":"/google-chrome-in-hyprland/"},{"categories":null,"content":"2 Weird crash when running chrome with: –gtk-version=4 This happens when use GTK theme as shown in above screenshot. Use classic them as a worksaround… ","date":"0001-01-01","objectID":"/google-chrome-in-hyprland/:2:0","tags":["chrome","hyprland","gtk4","crash"],"title":"google chrome in hyprland","uri":"/google-chrome-in-hyprland/"},{"categories":null,"content":" Table of Contents 1 DtaStrutor 本文为摘录(或转载)，侵删，原文为： ../../../Work/pg_gpdb/src/backend/utils/time/sharedsnapshot.c 在 Greenplum 中，作为切片计划的一部分，许多 PostgreSQL 进程（qExecs，QE）在单个段数据库上运行，作为同一用户 SQL 语句的一部分。属于特定用户在特定段数据库上的所有 qExecs 需要具有一致的可见性。为此，使用了一种称为“共享本地快照”（Shared Local Snapshot）的思想。共享内存数据结构 SharedSnapshotSlot 在特定数据库实例上的会话的统一流程（gang processes）之间共享会话和事务信息。这些流程被称为 SegMate 进程组。 SegMate 进程组由一个 QE（查询执行器）Writer 进程和 0 个、1个或多个 QE Reader 进程。 Greenplum 需要发明 SegMate 共享机制，因为在 Postgres 中只有一个后端，并且大部分需要的信息只是在私有内存中可用。通过 Greenplum 在数据库实例上的会话并行性，我们需要一种方式来在 SegMates 之间共享尚未提交的会话信息。这些信息包括事务快照、子事务状态、所谓的 combo-cid 映射等。 举个例子：QE（Query Executor）读取器需要使用与 QE 写入器相同的快照和命令号信息，以便可以看到 QE 写入器所写入的当前数据。在一个事务中，QE 写入器会将新数据写入共享内存缓存中。在同一个事务中的稍后阶段，QE 读取器需要识别出共享内存缓存中属于其会话事务的元组，以便能够正确执行。 另一个例子： QE（查询执行器）读取器需要知道哪些子事务对于一个会话的事务是活动的或已提交的，这样它们才能正确读取由 QE 写入器为该事务所写入的子事务数据。 所以，重点是与 QE 读者共享尚未提交的私有会话事务信息，以便 SegMate 进程组可以正确地处理该事务。我们通常认为 QE 写者/读者位于各个片段上。但是，协调器有一个特殊用途的 QE 读者，称为 Entry DB Singleton。因此，SegMate 模块也可以在协调器上工作。 每个共享快照只在段数据库中本地可见。高级 Writer 团队成员建立了一个本地事务，获得了共享快照 shmem 空间中的槽位，并将快照信息复制到共享内存中，以供其他与该段相关的 qExecs 找到。下一节详细介绍了共享内存的初始化过程，谁写入快照，如何控制以及何时读者可以读取快照，锁定等等。 共享内存初始化 共享内存由 postmaster 设置。 QD 上每个用户连接需要一个槽来存储一组 segmate 的快照信息的数据结构。 在每个槽中，QD 写入器存储由 SharedSnapshotSlot 定义的信息。Shared Memory Initialization: Shared memory is setup by the postmaster. One slot for every user connection on the QD is kind of needed to store a data structure for a set of segmates to store their snapshot information. In each slot QE writer stores information defined by SharedSnapshotSlot. PQsendMppStatement ： 与 PQsendQuery 相同，只是它还发送一个序列化的快照和 xid。已经修改了 postgres.c 以接受这个新的协议消息。它的工作基本上与’Q’（普通查询）相同，只是从 QD（QueryDispatcher）中解开快照和 xid，并将其存储起来。在语句分发期间，所有的 QE（Query Executor）都在 QD 快照中发送。 Global Session ID: The shared snapshot shared memory is split into slots. A set of segmates for a given user requires a single slot. The snapshot information and other information is stored within the snapshot. A unique session id identifies all the components in the system that are working for a single user session. Within a single segment database this essentially defines what it means to be “segmates.” The shared snapshot slot is identified by this unique session id. The unique session id is sent in from the QD as a GUC called “mpp_session_id”. So the slot’s field “slotid” will store the “mpp_session_id” that WRITER to the slot will use. Readers of the slot will find the correct slot by finding the one that has the slotid equal to their own mpp_session_id. 全局会话 ID: 共享快照的共享内存被分割成槽位 (slot)。 对于一个特定用户的 segmate 集合，只需要一个槽位。 快照信息和其他信息都存储在快照中。 唯一会话 ID 标识了系统中为单个用户会话工作的所有组件。 在一个单一段数据库中，这基本上定义了\"segmates\"的含义。共享快照槽位由这个唯一会话 ID 进行标识。这个唯一会话 ID 通过名为 mpp_session_id 的 GUC 从 QD 发送过来。因此，槽位的字段\"slotid\"将存储作为 WRITER 使用的\"mpp_session_id\"。槽位的读取者将通过找到 slotid 与其自己的 mpp_session_id 相等的槽位来找到正确的槽位。 Single Writer: Mechanism is simplified by introducing the restriction of only having a single qExec in a set of segmates capable of writing. Single WRITER qExec is the only qExec amongst all of its segmates that will ever perform database write operations. Benefits of the approach, Single WRITER qExec is the only member of a set of segmates that need to participate in global transactions. Also… only this WRITER qExec really has to do anything during commit. Assumption seems since they are just reader qExecs that this is not a problem. The single WRITER qExec is the only qExec that is guaranteed to participate in every dispatched statement for a given user (at least to that segdb). Also, it is this WRITER qExec that performs any utility statement. 单一写入者: 通过引入只允许在一组能够写入的 segmates 中只有一个 qExec 的限制来简化机制。单一写入者 qExec 是所有 segmates 中唯一执行数据库写入操作的 qExec。这种方法的好处是，单一写入者 qExec 是一组 segmates 中唯一需要参与全局事务的成员。此外…只有这个写入者 qExec 在提交时才真正需要执行任何操作。假设由于它们只是读取者 qExecs，这不是一个问题。单一写入者 qExec 是唯一一个保证参与给定用户的每个分派语句的 qExec（至少对于该 segdb 而言）。同时，这个写入者 qExec 还执行任何实用语句。 Coordinating Readers and Writers: The coordination is on when the writer has set the snapshot such that the readers can get it and use it. In general, we ","date":"0001-01-01","objectID":"/sharedsnapshot/:0:0","tags":["gp","shared","snapshot"],"title":"gp shared snapshot","uri":"/sharedsnapshot/"},{"categories":null,"content":"1 DtaStrutor class SharedSnapshotStruct { + int numSlots + int maxSlots + int nextSlot + SharedSnapshotSlot slots + TransactionId xips } class SharedSnapshotSlot { + int32 slotindex + int32 slotid + PGPROC writer_proc + PGXACT writer_xact + volatile distributedXid + volatile ready + uint32 segmateSync + SnapshotData snapshot + LWLock slotLock + volatile cur_dump_id + volatile dump + SubTransactionId fullXid + TimestampTz startTimestamp } SharedSnapshotStruct *-- SharedSnapshotSlot class PGPROC { + SHM_QUEUE links + PGPROC procgloballist + PGSemaphore sem + int waitStatus + Latch procLatch + LocalTransactionId lxid + LocalDistribXactData localDistribXactData + int pid + int pgprocno + BackendId backendId + Oid databaseId + Oid roleId + int mppSessionId + PGPROC lockGroupLeader + dlist_head lockGroupMembers + dlist_node lockGroupLink } class PGXACT { + TransactionId xid + TransactionId xmin + uint8 vacuumFlags + bool overflowed + bool delayChkpt + uint8 nxids } class SnapshotData { + SnapshotType snapshot_type + TransactionId xmin + TransactionId xmax + TransactionId xip + uint32 xcnt + TransactionId subxip + int32 subxcnt + _Bool suboverflowed + _Bool takenDuringRecovery + _Bool copied + _Bool haveDistribSnapshot + CommandId curcid + uint32 speculativeToken + uint32 active_count + uint32 regd_count + pairingheap_node ph_node + TimestampTz whenTaken + XLogRecPtr lsn + DistributedSnapshotWithLocalMapping distribSnapshotWithLocalMapping } class LWLock { + int tranche + pg_atomic_uint32 state + proclist_head waiters } SharedSnapshotSlot *-- PGPROC SharedSnapshotSlot *-- PGXACT SharedSnapshotSlot *-- SnapshotData SharedSnapshotSlot *-- LWLock ","date":"0001-01-01","objectID":"/sharedsnapshot/:1:0","tags":["gp","shared","snapshot"],"title":"gp shared snapshot","uri":"/sharedsnapshot/"},{"categories":null,"content":" Table of Contents 1 概述 2 pg_class 3 namespace 4 unique_index_violation 5 duplicate ","date":"0001-01-01","objectID":"/gpcheckcat/:0:0","tags":["gp","catlog","repair"],"title":"gpcheckcat","uri":"/gpcheckcat/"},{"categories":null,"content":"1 概述 GP 提供了 gpcheckcat 用于在集群内检查系统表。 Table 1: gpcheckcat | 检查项 || 描述 || Utility 模式 || 复合查询 || 错误等级 | |———————|————————————————————————-|————|——|——| | pg_class || Check pg_class entry that does not have any correspond pg_attribute entry || Y || N || NOREPAIR | | namespace || Check for schemas with a missing schema definition || Y || N || NOREPAIR | | unique_index_violation || Check for violated unique indexes || N || Y || NOREPAIR | | duplicate || Check for duplicate entries || N || Y || | | missing_extraneous || Cross consistency check for missing or extraneous entries || N || Y || | | inconsistent || Cross consistency check for coordinator segment inconsistency || N || || | | foreign_key || Check foreign keys || N || || | | || || || || | Note: Utility 模式： 对应 SQL 是否执行在 utility 模式下 有些 SQL 只能在集群中执行 复合查询： 下发的 SQL 是否为动态生成 有些 SQL 为根据表定义或者其他条件拼接而成 错误等级： SUCCESS success REMOVE error, with repair script removes objects RESYNC error, with repair script that resynchronizes objects NOREPAIR error, no repair script ","date":"0001-01-01","objectID":"/gpcheckcat/:1:0","tags":["gp","catlog","repair"],"title":"gpcheckcat","uri":"/gpcheckcat/"},{"categories":null,"content":"2 pg_class SELECT relname, relkind, tc.oid as oid FROM pg_class tc left outer join pg_attribute ta on (tc.oid = ta.attrelid) WHERE ta.attrelid is NULL and tc.relnatts != 0; ","date":"0001-01-01","objectID":"/gpcheckcat/:2:0","tags":["gp","catlog","repair"],"title":"gpcheckcat","uri":"/gpcheckcat/"},{"categories":null,"content":"3 namespace SELECT o.catalog, o.nsp FROM pg_namespace n right outer join (select 'pg_class' as catalog, relnamespace as nsp from pg_class union select 'pg_type' as catalog, typnamespace as nsp from pg_type union select 'pg_operator' as catalog, oprnamespace as nsp from pg_operator union select 'pg_proc' as catalog,pronamespace as nsp from pg_proc) o on (n.oid = o.nsp) WHERE n.oid is NULL; ","date":"0001-01-01","objectID":"/gpcheckcat/:3:0","tags":["gp","catlog","repair"],"title":"gpcheckcat","uri":"/gpcheckcat/"},{"categories":null,"content":"4 unique_index_violation SQL 为拼接而成，分成两步： 获取有唯一索引约束的表和索引 逐一检查每个表是否违反了唯一约束 代码： unique_index_violation_check.py class UniqueIndexViolationCheck: unique_indexes_query = \"\"\" select table_oid, index_name, table_name, array_agg(attname) as column_names from pg_attribute, ( select pg_index.indrelid as table_oid, index_class.relname as index_name, table_class.relname as table_name, unnest(pg_index.indkey) as column_index from pg_index, pg_class index_class, pg_class table_class where pg_index.indisunique='t' and index_class.relnamespace = (select oid from pg_namespace where nspname = 'pg_catalog') and index_class.relkind = 'i' and index_class.oid = pg_index.indexrelid and table_class.oid = pg_index.indrelid ) as unique_catalog_index_columns where attnum = column_index and attrelid = table_oid group by table_oid, index_name, table_name; \"\"\" def __init__(self): self.violated_segments_query = \"\"\" select distinct(gp_segment_id) from ( (select gp_segment_id, %s from gp_dist_random('%s') where (%s) is not null group by gp_segment_id, %s having count(*) \u003e 1) union (select gp_segment_id, %s from %s where (%s) is not null group by gp_segment_id, %s having count(*) \u003e 1) ) as violations \"\"\" def runCheck(self, db_connection): unique_indexes = db_connection.query(self.unique_indexes_query).getresult() violations = [] for (table_oid, index_name, table_name, column_names) in unique_indexes: column_names = \",\".join(column_names) sql = self.get_violated_segments_query(table_name, column_names) violated_segments = db_connection.query(sql).getresult() if violated_segments: violations.append(dict(table_oid=table_oid, table_name=table_name, index_name=index_name, column_names=column_names, violated_segments=[row[0] for row in violated_segments])) return violations def get_violated_segments_query(self, table_name, column_names): return self.violated_segments_query % ( column_names, table_name, column_names, column_names, column_names, table_name, column_names, column_names ) ","date":"0001-01-01","objectID":"/gpcheckcat/:4:0","tags":["gp","catlog","repair"],"title":"gpcheckcat","uri":"/gpcheckcat/"},{"categories":null,"content":"5 duplicate ","date":"0001-01-01","objectID":"/gpcheckcat/:5:0","tags":["gp","catlog","repair"],"title":"gpcheckcat","uri":"/gpcheckcat/"},{"categories":null,"content":" Table of Contents 1 Data structures 1.1 Slice Table 2 PostgresMain 2.1 Call graph (QE): 2.2 QD 3 Receiver 4 Sender ","date":"0001-01-01","objectID":"/gpdb_cdb/:0:0","tags":null,"title":"gpdb cdb","uri":"/gpdb_cdb/"},{"categories":null,"content":"1 Data structures ","date":"0001-01-01","objectID":"/gpdb_cdb/:1:0","tags":null,"title":"gpdb cdb","uri":"/gpdb_cdb/"},{"categories":null,"content":"1.1 Slice Table @startuml class SliceTable { + NodeTag type + int localSlice + int numSlices + ExecSlice slices + bool hasMotions + int instrument_options + uint32 ic_instance_id } note right of SliceTable::localSlice Index of the slice to execute end note note right of SliceTable::slices Array of slices, indexed by SliceIndex end note note right of SliceTable::hasMotions Are there any Motion nodes anywhere in the plan? end note class ExecSlice { + int sliceIndex + int rootIndex + int parentIndex + int planNumSegments + List children + GangType gangType + List segments + struct primaryGang + List primaryProcesses + Bitmapset processesMap } note right of ExecSlice::primaryProcesses A list of CDBProcess nodes corresponding to the worker processes allocated to implement this plan slice. end note note right of ExecSlice::processesMap A bitmap to identify which QE should execute this slice end note SliceTable o-- ExecSlice class Gang { + GangType type + int size + struct db_descriptors + bool allocated } note right of Gang::db_descriptors Array of QEs/segDBs that make up this gang. Sorted by segment index. end note ExecSlice *-- Gang class CdbProcess { + NodeTag type + char listenerAddr + int listenerPort + int pid + int contentid + int dbid } ExecSlice o-- CdbProcess class SegmentDatabaseDescriptor { + struct segment_database_info + int segindex + int conn + int motionListener + int backendPid + char whoami + int isWriter + int identifier } Gang o-- SegmentDatabaseDescriptor class CdbComponentDatabases { + CdbComponentDatabaseInfo segment_db_info + int total_segment_dbs + CdbComponentDatabaseInfo entry_db_info + int total_entry_dbs + int total_segments + int fts_version + int expand_version + int numActiveQEs + int numIdleQEs + int qeCounter + List freeCounterList } note right of CdbComponentDatabaseInfo::segment_db_info array of SegmentDatabaseInfo for segment databases end note note right of CdbComponentDatabaseInfo::entry_db_info array of SegmentDatabaseInfo for entry databases end note class CdbComponentDatabaseInfo { + struct config + CdbComponentDatabases cdbs + int hostSegs + List freelist + int numIdleQEs + int numActiveQEs } note right of CdbComponentDatabaseInfo::cdbs point to owners end note CdbComponentDatabases o-- CdbComponentDatabaseInfo class GpSegConfigEntry { + int dbid + int segindex + char role + char preferred_role + char mode + char status + int port + char hostname + char address + char datadir + char hostip + char hostaddrs } CdbComponentDatabaseInfo o-- GpSegConfigEntry SegmentDatabaseDescriptor o-- CdbComponentDatabaseInfo @enduml 2 1.1.1 SliceTable SliceTable : 由 Slice 组成的链表， Slice 组织成三类： root slices: Slice 0 motion slices 1 ~ n 为 motion slices, 每个 slice 的根为 sending motion 其余为 initPlans 1.1.2 ExecSlice MPP 中，计划树 (PlanTree) 被切分成多个单独的执行单元 （又称 Slice ） 一个 Slice 在进程组 （process gang） 的一个 worker 上执行 ","date":"0001-01-01","objectID":"/gpdb_cdb/:1:1","tags":null,"title":"gpdb cdb","uri":"/gpdb_cdb/"},{"categories":null,"content":"2 PostgresMain ","date":"0001-01-01","objectID":"/gpdb_cdb/:2:0","tags":null,"title":"gpdb cdb","uri":"/gpdb_cdb/"},{"categories":null,"content":"2.1 Call graph (QE): Main() PostmasterMain() ServerLoop() BackendStartup() BackendRun() PostgresMain() InitPostgres() cdb_setup() ensureInterconnectAddress() InitMotionLayerIPC() InitMotionTCP() setupTCPListeningSocket() sendQEDetails() setupTCPListeningSocket() 会由操作系统分配端口，并返回上层。并在 InitMotionlayerIPC() 中存储在全局变量 Gp_listener_port 中，并随后在函数 sendQEDetails(void) 中将端口信息 “qe_listener_port” 发送给 client 。 ","date":"0001-01-01","objectID":"/gpdb_cdb/:2:1","tags":null,"title":"gpdb cdb","uri":"/gpdb_cdb/"},{"categories":null,"content":"2.2 QD standard_ExecutorStart() CdbDispatchPlan() cdbdisp_dispatchX() AssignGangs() AssignWriterGangFirst() AllocateGang() cdbgang_createGang() cdbgang_createGang_async() cdbconn_doConnectComplete() cdbconn_get_motion_listener_port() setupCdbProcessList() 函数 AssignGangs() 在 QD 上执行， 将 Executor 工厂分配的 gangs 分配给 slice table 中的 slices. 从而构建全局的 slice table 。该过程分成了两步： AssignWriterGangFirst() AllocateGang() 登录到涉及到的 segDB ， 生成会话 （进程）， 从而创建进程组。 cdbgang_createGang_async() buildGangDefinition() 读取 GP 系统表， 构建 CdbComponentDatabases ，随后将该结构转换成为 Gang 结构， 并初始化其中与 connection 无关的成员。随后对其中每个 seg 发起连接。 cdbconn_doConnectStart() 填充 keywords 之后，使用 PQconnectStartParams() 发起连接。 cdbconn_doConnectComplete() 完成连接 cdbconn_get_motion_listener_port() 与 QE 建立连接后，读取 “qe_listener_port” setupCdbProcessList() Create a list of CdbProcess and initialize with Gang information. InventorySliceTree() Helper for AssignGangs takes a simple inventory of the gangs required by a slice tree. ","date":"0001-01-01","objectID":"/gpdb_cdb/:2:2","tags":null,"title":"gpdb cdb","uri":"/gpdb_cdb/"},{"categories":null,"content":"3 Receiver ","date":"0001-01-01","objectID":"/gpdb_cdb/:3:0","tags":null,"title":"gpdb cdb","uri":"/gpdb_cdb/"},{"categories":null,"content":"4 Sender ","date":"0001-01-01","objectID":"/gpdb_cdb/:4:0","tags":null,"title":"gpdb cdb","uri":"/gpdb_cdb/"},{"categories":null,"content":" Table of Contents 1 TODO VMem 2 Resource Group Control 2.1 Bypass 2.2 Fixed Mem 2.3 Memory Limit ","date":"0001-01-01","objectID":"/gpdb-memory-control/:0:0","tags":["gpdb"],"title":"gpdb memory control","uri":"/gpdb-memory-control/"},{"categories":null,"content":"TODO 1 VMem ","date":"0001-01-01","objectID":"/gpdb-memory-control/:1:0","tags":["gpdb"],"title":"gpdb memory control","uri":"/gpdb-memory-control/"},{"categories":null,"content":"2 Resource Group Control ResourceGroupGetQueryMemoryLimit(void) 用于获取内存限制的绝对大小 （非百分比） ","date":"0001-01-01","objectID":"/gpdb-memory-control/:2:0","tags":["gpdb"],"title":"gpdb memory control","uri":"/gpdb-memory-control/"},{"categories":null,"content":"2.1 Bypass 绕开资源限制模式 Enabled when: gp_resource_group_bypass is true: guc_gp.c { {\"gp_resource_group_bypass\", PGC_USERSET, RESOURCES, gettext_noop(\"If the value is true, the query in this session will not be limited by resource group.\"), NULL }, \u0026gp_resource_group_bypass, false, check_gp_resource_group_bypass, NULL, NULL } Or command is one of: SET RESET SHOW ","date":"0001-01-01","objectID":"/gpdb-memory-control/:2:1","tags":["gpdb"],"title":"gpdb memory control","uri":"/gpdb-memory-control/"},{"categories":null,"content":"2.2 Fixed Mem 固定内存大小 if (gp_resgroup_memory_query_fixed_mem) return (uint64) gp_resgroup_memory_query_fixed_mem * 1024L; ","date":"0001-01-01","objectID":"/gpdb-memory-control/:2:2","tags":["gpdb"],"title":"gpdb memory control","uri":"/gpdb-memory-control/"},{"categories":null,"content":"2.3 Memory Limit queryMem = (uint64)(resgLimit *1024L *1024L / caps-\u003econcurrency); ","date":"0001-01-01","objectID":"/gpdb-memory-control/:2:3","tags":["gpdb"],"title":"gpdb memory control","uri":"/gpdb-memory-control/"},{"categories":null,"content":" Table of Contents 1 IP Fragmentation Settings 2 Networking 本文为摘录(或转载)，侵删，原文为： https://docs.vmware.com/en/VMware-Tanzu-Greenplum/6/greenplum-database/GUID-install_guide-prep_os.html ","date":"0001-01-01","objectID":"/gpdb-configuring-your-systems/:0:0","tags":["gpdb","configuration","network"],"title":"GPDB: Configuring Your Systems","uri":"/gpdb-configuring-your-systems/"},{"categories":null,"content":"1 IP Fragmentation Settings IP Fragmentation Settings When the Greenplum Database interconnect uses UDP (the default), the network interface card controls IP packet fragmentation and reassemblies. If the UDP message size is larger than the size of the maximum transmission unit (MTU) of a network, the IP layer fragments the message. (Refer to Networking later in this topic for more information about MTU sizes for Greenplum Database.) The receiver must store the fragments in a buffer before it can reorganize and reassemble the message. The following sysctl.conf operating system parameters control the reassembly process: OS Parameter Description net.ipv4.ipfrag_high_thresh The maximum amount of memory used to reassemble IP fragments before the kernel starts to remove fragments to free up resources. The default value is 4194304 bytes (4MB). net.ipv4.ipfrag_low_thresh The minimum amount of memory used to reassemble IP fragments. The default value is 3145728 bytes (3MB). (Deprecated after kernel version 4.17.) net.ipv4.ipfrag_time The maximum amount of time (in seconds) to keep an IP fragment in memory. The default value is 30. The recommended settings for these parameters for Greenplum Database follow: net.ipv4.ipfrag_high_thresh = 41943040 net.ipv4.ipfrag_low_thresh = 31457280 net.ipv4.ipfrag_time = 60 ","date":"0001-01-01","objectID":"/gpdb-configuring-your-systems/:1:0","tags":["gpdb","configuration","network"],"title":"GPDB: Configuring Your Systems","uri":"/gpdb-configuring-your-systems/"},{"categories":null,"content":"2 Networking The maximum transmission unit (MTU) of a network specifies the size (in bytes) of the largest data packet/frame accepted by a network-connected device. A jumbo frame is a frame that contains more than the standard MTU of 1500 bytes. Greenplum Database utilizes 3 distinct MTU settings: – The Greenplum Database gp_max_packet_size server configuration parameter. The default max packet size is 8192. This default assumes a jumbo frame MTU. – The operating system MTU setting. – The rack switch MTU setting. These settings are connected, in that they should always be either the same, or close to the same, value, or otherwise in the order of : Greenplum \u003c OS \u003c switch for MTU size. 9000 is a common supported setting for switches, and is the recommended OS and rack switch MTU setting for your Greenplum Database hosts. ","date":"0001-01-01","objectID":"/gpdb-configuring-your-systems/:2:0","tags":["gpdb","configuration","network"],"title":"GPDB: Configuring Your Systems","uri":"/gpdb-configuring-your-systems/"},{"categories":null,"content":" Table of Contents 1 使用高速硬件，降低节点间的延迟 2 尽量降低网络中断的次数。 3 尽量提高每一个数据包的有效载荷 本文为摘录(或转载)，侵删，原文为： attachments/pdf/a/cn.greenplum.org-Greenplum部署最佳实践-网络篇.pdf ","date":"0001-01-01","objectID":"/cn.greenplum.org-greenplum%E9%83%A8%E7%BD%B2%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-%E7%BD%91%E7%BB%9C%E7%AF%87/:0:0","tags":["gpdb","network","mtu","jumbo","frame"],"title":"Greenplum 部署最佳实践: 网络篇","uri":"/cn.greenplum.org-greenplum%E9%83%A8%E7%BD%B2%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-%E7%BD%91%E7%BB%9C%E7%AF%87/"},{"categories":null,"content":"1 使用高速硬件，降低节点间的延迟 ","date":"0001-01-01","objectID":"/cn.greenplum.org-greenplum%E9%83%A8%E7%BD%B2%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-%E7%BD%91%E7%BB%9C%E7%AF%87/:1:0","tags":["gpdb","network","mtu","jumbo","frame"],"title":"Greenplum 部署最佳实践: 网络篇","uri":"/cn.greenplum.org-greenplum%E9%83%A8%E7%BD%B2%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-%E7%BD%91%E7%BB%9C%E7%AF%87/"},{"categories":null,"content":"2 尽量降低网络中断的次数。 ","date":"0001-01-01","objectID":"/cn.greenplum.org-greenplum%E9%83%A8%E7%BD%B2%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-%E7%BD%91%E7%BB%9C%E7%AF%87/:2:0","tags":["gpdb","network","mtu","jumbo","frame"],"title":"Greenplum 部署最佳实践: 网络篇","uri":"/cn.greenplum.org-greenplum%E9%83%A8%E7%BD%B2%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-%E7%BD%91%E7%BB%9C%E7%AF%87/"},{"categories":null,"content":"3 尽量提高每一个数据包的有效载荷 ","date":"0001-01-01","objectID":"/cn.greenplum.org-greenplum%E9%83%A8%E7%BD%B2%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-%E7%BD%91%E7%BB%9C%E7%AF%87/:3:0","tags":["gpdb","network","mtu","jumbo","frame"],"title":"Greenplum 部署最佳实践: 网络篇","uri":"/cn.greenplum.org-greenplum%E9%83%A8%E7%BD%B2%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-%E7%BD%91%E7%BB%9C%E7%AF%87/"},{"categories":null,"content":" Table of Contents 1 Resource Group 简介 2 Resource Group 使用 2.1 创建资源组 2.2 将资源组分配给角色 2.3 修改资源组配置 2.4 删除资源组 2.5 取消资源组中的正在运行或已排队的事务 3 Resource Group 监控 3.1 查看资源组限制 3.2 查看资源组查询状态和 CPU/ 内存使用情况 3.3 查看每个主机的资源组 CPU/ 内存使用情况 3.4 查看每个 segment 的资源组 CPU/ 内存使用情况 3.5 查看分配给角色的资源组 3.6 查看资源组的运行和待定查询 4 Resource Group 实现分析 4.1 并发限制 4.2 CPU 限制 4.3 内存限制 4.4 Resource Group 监控 5 常见问题 5.1 Resource Group 是如何利用操作系统的 cgroup 能力的？ 5.2 Resource Group 是如何进行事务级别的资源限制的？ 5.3 Resource Group 的各种操作加不加锁，加什么锁？ 5.4 数据库基于 cgroup 对资源组进行限制，如果某个数据库节点故障，跨机迁移到其他节点，而 cgroup 的配置和路径结构无法迁移，会不会导致对应机器上的 resource group 功能失效？ 5.5 为什么资源组的 CPU 使用率高于配置的 CPU_RATE_LIMIT ？ 5.6 Resource Group 在部署上有什么要求？ 6 总结 本文为摘录(或转载)，侵删，原文为： https://blog.csdn.net/u013970710/article/details/115433014 Greenplum 是一款广泛应用的开源 MPP 数据库的产品，兼容 PostgreSQL 生态，被广泛应用与大数据的存储与分析。 Resource Group 是 Greenplum 的一种资源管理方式。 Resource Group 由 GP5 开始被支持，相比于早期的 Resource Queue 的资源管理方式，具有支持更细粒度的资源管理、 支持组内资源共享等优点。本文会介绍 Resource Group 的使用方式，从源码角度分析它的实现，以及介绍一些使用中遇到的高频问题。 ","date":"0001-01-01","objectID":"/greenplum%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86resource-group%E4%BD%BF%E7%94%A8%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/:0:0","tags":["gpdb","resource","group"],"title":"Greenplum 资源管理——Resource Group使用和实现分析","uri":"/greenplum%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86resource-group%E4%BD%BF%E7%94%A8%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/"},{"categories":null,"content":"1 Resource Group 简介 Resource Group 是 Greenplum 的一种资源管理方式，能够细粒度定义对不同数据库角色（用户）的资源使用限制，支持通过 SQL 语句的方式进行配置。 Resource Group 支持进行三种类型的资源限制：并发限制、 CPU 限制、内存限制。 超级用户可以通过 SQL 在数据库内定义多个资源组，并设置每个资源组的资源限制。在一个数据库中，每个资源组可以关联一个或多个数据库用户，而每个数据库用户只能归属于单个资源组。资源组支持的资源限制配置如下： CONCURRENCY 资源组中允许的最大并发事务数，包括活动和空闲事务。 CPU_RATE_LIMIT 此资源组可用的 CPU 资源百分比。 CPUSET 为该资源组保留的 CPU 核心数。 MEMORY_LIMIT 该资源组可用的内存资源百分比。 MEMORY_SHARED_QUOTA 提交到该资源组的事务之间共享的内存资源百分比。 MEMORY_SPILL_RATIO 内存密集型事务的内存使用阈值。当事务达到此阈值时，它将溢出到磁盘。 CONCURRENCY 代表最大并发事务数； CPU_RATE_LIMIT 代表以百分比形式限制 CPU 使用，各个资源组设置的 CPU_RATE_LIMIT 之和不超过 100% ； CPUSET 代表以 CPU 核的形式限制 CPU ，设置具体使用哪几个 CPU 逻辑核； MEMORY_LIMIT 代表资源组最多能占用的集群可用内存的百分比， 由 MEMORY_LIMIT 设定的部分属于资源组的固定份额， 而各个资源组 MEMORY_LIMIT 之和低于 100% 的部分，被划分所有资源组的共享内存池； Bad boy… MEMORY_SHARED_QUOTA 代表资源组内用于各个事务共享的内存比例； MEMORY_SPILL_RATIO 代表溢出到磁盘的内存使用阈值。 CREATE RESOURCE GROUP rgroup1 WITH ( CONCURRENCY=10, CPU_RATE_LIMIT=20, MEMORY_LIMIT=25, MEMORY_SHARED_QUOTA=20, MEMORY_SPILL_RATIO=20 ); 除了 Resource Group ，GP 早期还支持 Resource Queue 的资源管理方式， Resource Queue 通过指定 MEMORY_LIMIT 、 ACTIVE_STATEMENTS 、PRIORITY 、MAX_COST 字段，配置对于各个资源队列的内存、 CPU 、并发限制， Resource Group 相对 Resource queue 存在以下优势： 特性 Resource Groups Resource Queues CPU 管理 细粒度（Cgroup） 基于粗粒度的优先级 内存限制 细粒度 粗粒度 并发控制 事务级别 语句级别 管理 DDL Utility 语句 是 否 segment 级别监控 是 否 组内内存共享 是 否 Resource Group 通过 Master 上的并发锁实现对并发的限制，通过 cgroup 实现对 cpu 的限制，支持对内存基于 vmtracker 和 cgroup 进行两种方式的限制。 ","date":"0001-01-01","objectID":"/greenplum%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86resource-group%E4%BD%BF%E7%94%A8%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/:1:0","tags":["gpdb","resource","group"],"title":"Greenplum 资源管理——Resource Group使用和实现分析","uri":"/greenplum%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86resource-group%E4%BD%BF%E7%94%A8%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/"},{"categories":null,"content":"2 Resource Group 使用 ","date":"0001-01-01","objectID":"/greenplum%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86resource-group%E4%BD%BF%E7%94%A8%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/:2:0","tags":["gpdb","resource","group"],"title":"Greenplum 资源管理——Resource Group使用和实现分析","uri":"/greenplum%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86resource-group%E4%BD%BF%E7%94%A8%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/"},{"categories":null,"content":"2.1 创建资源组 使用 CREATE RESOURCE GROUP 命令创建新资源组。 为角色创建资源组时，必须提供 CPU_RATE_LIMIT 或 CPUSET 和 MEMORY_LIMIT 限制值。这些限制标识要分配给此资源组的数据库资源的百分比。例如，要创建名为 rgroup1 的资源组，其 CPU 限制为 20 ，内存限制为 25 ： CREATE RESOURCE GROUP rgroup1 WITH (CPU_RATE_LIMIT=20, MEMORY_LIMIT=25); CPU 限制为 20 由 rgroup1 分配到的每个角色共享。同样，内存限制为 25 由 rgroup1 分配到的每个角色共享。rgroup1 使用默认的 MEMORY_AUDITOR vmtracker 和默认的 CONCURRENCY 设置为 20 。 数据库包含两个默认资源组： admin_group 和 default_group 。启用资源组时，将为未明确分配资源组的任何角色分配角色功能的默认组。 SUPERUSER 角色分配了 admin_group ，非管理员角色分配了名为 default_group 的组。 使用以下资源限制创建默认资源组 admin_group 和 default_group ： 限制类型 admin_group default_group CONCURRENCY 10 20 CPU_RATE_LIMIT 10 30 CPUSET -1 -1 MEMORY_LIMIT 10 30 MEMORY_SHARED_QUOTA 50 50 MEMORY_SPILL_RATIO 20 20 MEMORY_AUDITOR vmtracker vmtracker 默认资源组 admin_group 和 default_group 的 CPU_RATE_LIMIT 和 MEMORY_LIMIT 值对分段主机上的总百分比有贡献。 ","date":"0001-01-01","objectID":"/greenplum%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86resource-group%E4%BD%BF%E7%94%A8%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/:2:1","tags":["gpdb","resource","group"],"title":"Greenplum 资源管理——Resource Group使用和实现分析","uri":"/greenplum%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86resource-group%E4%BD%BF%E7%94%A8%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/"},{"categories":null,"content":"2.2 将资源组分配给角色 Greenplum 资源组可用于分配给一个或多个角色（用户）。使用 CREATE ROLE 或 ALTER ROLE 命令的 RESOURCE GROUP 子句将资源组分配给数据库角色。如果未为角色指定资源组，则会为角色分配角色功能的默认组。 SUPERUSER 角色分配了 admin_group ，非管理员角色分配了名为 default_group 的组。 使用 ALTER ROLE 或 CREATE ROLE 命令将资源组分配给角色。例如： ALTER ROLE bill RESOURCE GROUP rg_light; CREATE ROLE mary RESOURCE GROUP exec; 用户可以将资源组分配给一个或多个角色。如果已定义角色层次结构，则将资源组分配给父角色不会向下传播到该角色组的成员。 如果要从角色中删除资源组分配并将角色分配为默认组，请将角色的组名称分配更改为 NONE 。例如： ALTER ROLE mary RESOURCE GROUP NONE; ","date":"0001-01-01","objectID":"/greenplum%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86resource-group%E4%BD%BF%E7%94%A8%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/:2:2","tags":["gpdb","resource","group"],"title":"Greenplum 资源管理——Resource Group使用和实现分析","uri":"/greenplum%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86resource-group%E4%BD%BF%E7%94%A8%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/"},{"categories":null,"content":"2.3 修改资源组配置 ALTER RESOURCE GROUP 命令可以修改资源组配置。要更改资源组的限制，请指定组所需的新值。例如： ALTER RESOURCE GROUP rg_role_light SET CONCURRENCY 7; ALTER RESOURCE GROUP exec SET MEMORY_LIMIT 25; ALTER RESOURCE GROUP rgroup1 SET CPUSET '2,4'; 注意 : 用户无法将 admin_group 的 CONCURRENCY 值设置或更改为 0 。 ","date":"0001-01-01","objectID":"/greenplum%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86resource-group%E4%BD%BF%E7%94%A8%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/:2:3","tags":["gpdb","resource","group"],"title":"Greenplum 资源管理——Resource Group使用和实现分析","uri":"/greenplum%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86resource-group%E4%BD%BF%E7%94%A8%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/"},{"categories":null,"content":"2.4 删除资源组 DROP RESOURCE GROUP 命令会删除资源组。要删除角色的资源组，不能将该组分配给任何角色，也不能在资源组中激活或等待任何事务。 DROP RESOURCE GROUP exec; ","date":"0001-01-01","objectID":"/greenplum%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86resource-group%E4%BD%BF%E7%94%A8%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/:2:4","tags":["gpdb","resource","group"],"title":"Greenplum 资源管理——Resource Group使用和实现分析","uri":"/greenplum%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86resource-group%E4%BD%BF%E7%94%A8%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/"},{"categories":null,"content":"2.5 取消资源组中的正在运行或已排队的事务 在某些情况下，用户可能希望取消资源组中的正在运行或排队的事务。例如，用户可能希望删除在资源组队列中等待但尚未执行的查询。或者，用户可能希望停止执行时间太长的正在运行的查询，或者在事务中处于空闲状态并占用其他用户所需的资源组事务插槽的查询。 要取消正在运行或排队的事务，必须首先确定与事务关联的进程 ID （pid ）。获得进程 ID 后，可以调用 pg_cancel_backend() 来结束该进程。 例如，要查看与当前活动或在所有资源组中等待的所有语句关联的进程信息，请运行以下查询。如果查询未返回任何结果，则任何资源组中都没有正在运行或排队的事务。 SELECT rolname, g.rsgname, procpid, waiting, current_query, datname FROM pg_roles, gp_toolkit.gp_resgroup_status g, pg_stat_activity WHERE pg_roles.rolresgroup=g.groupid AND pg_stat_activity.usename=pg_roles.rolname; 示例部分查询输出： rolname | rsgname | procpid | waiting | current_query | datname ---------+----------+---------+---------+-----------------------+--------- sammy | rg_light | 31861 | f | \u003cIDLE\u003e in transaction | testdb billy | rg_light | 31905 | t | SELECT * FROM topten; | testdb 使用此输出来标识要取消的事务的进程 ID （procpid ），然后取消该进程。例如，要取消上面示例输出中标识的待处理查询： SELECT pg_cancel_backend(31905); 用户可以在 pg_cancel_backend() 的第二个参数中提供可选消息，以向用户指示进程被取消的原因。 ","date":"0001-01-01","objectID":"/greenplum%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86resource-group%E4%BD%BF%E7%94%A8%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/:2:5","tags":["gpdb","resource","group"],"title":"Greenplum 资源管理——Resource Group使用和实现分析","uri":"/greenplum%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86resource-group%E4%BD%BF%E7%94%A8%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/"},{"categories":null,"content":"3 Resource Group 监控 本节主要介绍如何通过系统视图监控集群的资源组，包括各个资源组的配置，各个资源组的资源使用情况等。 以下是资源组相关的监控项的含义： rsgname 资源组名 groupid 资源组 oid cpu 当前资源组的 cpu 利用率 memory_used 当前资源组实际使用的内存总量 memory_available 当前资源组可用的内存总量 memory_quota_used 当前资源组固定份额部分实际使用的内存总量 memory_quota_available 当前资源组固定份额部分可用的内存总量 memory_quota_granted 当前资源组固定份额部分的总体分配量 memory_shared_used 当前资源组共享部分实际使用的内存总量 memory_shared_available 当前资源组共享部分可用的内存总量 memory_shared_granted 当前资源组共享部分的总体分配量 正常情况下，各个资源组监控项有以下关系： memory_used = memory_quota_used + memory_shared_used available = memory_quota_granted + memory_shared_granted - memory_used memory_quota_granted = memory_quota_used + memory_quota_available memory_shared_granted = memory_shared_used + memory_shared_available ","date":"0001-01-01","objectID":"/greenplum%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86resource-group%E4%BD%BF%E7%94%A8%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/:3:0","tags":["gpdb","resource","group"],"title":"Greenplum 资源管理——Resource Group使用和实现分析","uri":"/greenplum%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86resource-group%E4%BD%BF%E7%94%A8%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/"},{"categories":null,"content":"3.1 查看资源组限制 gp_resgroup_config 系统视图显示所有的资源组配置。 SELECT * FROM gp_toolkit.gp_resgroup_config; ","date":"0001-01-01","objectID":"/greenplum%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86resource-group%E4%BD%BF%E7%94%A8%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/:3:1","tags":["gpdb","resource","group"],"title":"Greenplum 资源管理——Resource Group使用和实现分析","uri":"/greenplum%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86resource-group%E4%BD%BF%E7%94%A8%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/"},{"categories":null,"content":"3.2 查看资源组查询状态和 CPU/ 内存使用情况 gp_resgroup_status 系统视图可以查看资源组的状态和活动。该视图显示正在运行和排队的事务数。它还显示资源组的实时 CPU 和内存使用情况。 SELECT * FROM gp_toolkit.gp_resgroup_status; ","date":"0001-01-01","objectID":"/greenplum%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86resource-group%E4%BD%BF%E7%94%A8%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/:3:2","tags":["gpdb","resource","group"],"title":"Greenplum 资源管理——Resource Group使用和实现分析","uri":"/greenplum%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86resource-group%E4%BD%BF%E7%94%A8%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/"},{"categories":null,"content":"3.3 查看每个主机的资源组 CPU/ 内存使用情况 通过 gp_resgroup_status_per_host 系统视图，用户可以基于每个主机查看资源组的实时 CPU 和内存使用情况。 SELECT * FROM gp_toolkit.gp_resgroup_status_per_host; ","date":"0001-01-01","objectID":"/greenplum%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86resource-group%E4%BD%BF%E7%94%A8%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/:3:3","tags":["gpdb","resource","group"],"title":"Greenplum 资源管理——Resource Group使用和实现分析","uri":"/greenplum%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86resource-group%E4%BD%BF%E7%94%A8%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/"},{"categories":null,"content":"3.4 查看每个 segment 的资源组 CPU/ 内存使用情况 通过 gp_resgroup_status_per_segment 系统视图，用户可以按每个 segment ，每个主机查看资源组的实时 CPU 和内存使用情况。 SELECT * FROM gp_toolkit.gp_resgroup_status_per_segment; ","date":"0001-01-01","objectID":"/greenplum%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86resource-group%E4%BD%BF%E7%94%A8%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/:3:4","tags":["gpdb","resource","group"],"title":"Greenplum 资源管理——Resource Group使用和实现分析","uri":"/greenplum%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86resource-group%E4%BD%BF%E7%94%A8%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/"},{"categories":null,"content":"3.5 查看分配给角色的资源组 要查看资源组到角色的分配，请对 pg_roles 和 pg_resgroup 系统表执行以下查询： SELECT rolname, rsgname FROM pg_roles, pg_resgroup WHERE pg_roles.rolresgroup=pg_resgroup.oid; ","date":"0001-01-01","objectID":"/greenplum%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86resource-group%E4%BD%BF%E7%94%A8%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/:3:5","tags":["gpdb","resource","group"],"title":"Greenplum 资源管理——Resource Group使用和实现分析","uri":"/greenplum%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86resource-group%E4%BD%BF%E7%94%A8%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/"},{"categories":null,"content":"3.6 查看资源组的运行和待定查询 要查看资源组的运行查询，挂起的查询以及挂起的查询排队的时间，请检查 pg_stat_activity 系统表： SELECT current_query, waiting, rsgname, rsgqueueduration FROM pg_stat_activity; ","date":"0001-01-01","objectID":"/greenplum%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86resource-group%E4%BD%BF%E7%94%A8%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/:3:6","tags":["gpdb","resource","group"],"title":"Greenplum 资源管理——Resource Group使用和实现分析","uri":"/greenplum%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86resource-group%E4%BD%BF%E7%94%A8%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/"},{"categories":null,"content":"4 Resource Group 实现分析 Greenplum 数据库是 MPP 架构，整体分为一个或多个 Master ，以及多个 segment ，数据在多个 segment 之间可以随机、哈希、复制分布。在 Greenplum 中， Resource Group 的资源限制级别是事务级别。 Resource Group 会在各个 group 内部将资源划分成并发量数目的 slot ，而每个事务在运行前排队等待获取 slot 。 如上文所述， Resource Group 支持对并发、 CPU 和内存进行限制，本节会详细介绍对这几类资源进行限制的实现细节，以及介绍对于资源组的监控是如何实现的。 Resource Group 的代码主要位于如下的路径和文件中： src/backend/utils/resgroup src/backend/utils/ressource_manager src/backend/commands/resgroupcmds.c ","date":"0001-01-01","objectID":"/greenplum%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86resource-group%E4%BD%BF%E7%94%A8%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/:4:0","tags":["gpdb","resource","group"],"title":"Greenplum 资源管理——Resource Group使用和实现分析","uri":"/greenplum%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86resource-group%E4%BD%BF%E7%94%A8%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/"},{"categories":null,"content":"4.1 并发限制 Resource Group 通过 Master 上的并发锁实现对并发的限制。用户连接到数据库集群时，首先会连接到 Master 节点，在开启事务时，会尝试获取 slot 。 static ResGroupSlotData * groupGetSlot(ResGroupData *group) { ResGroupSlotData *slot; ResGroupCaps *caps; int32 slotMemQuota; Assert(LWLockHeldExclusiveByMe(ResGroupLock)); Assert(Gp_role == GP_ROLE_DISPATCH); Assert(groupIsNotDropped(group)); caps = \u0026group-\u003ecaps; /* First check if the concurrency limit is reached */ if (group-\u003enRunning \u003e= caps-\u003econcurrency) return NULL; slotMemQuota = groupReserveMemQuota(group); if (slotMemQuota \u003c 0) return NULL; /* Now actually get a free slot */ slot = slotpoolAllocSlot(); Assert(!slotIsInUse(slot)); initSlot(slot, group, slotMemQuota); group-\u003enRunning++; return slot; } Master 上通过比较资源组当前运行的事务数 group-\u003enRunning ，与设定的并发数 concurrency ，保证限制实际运行的并发数不高于设定值。 Greenplum 是多进程模型，各个资源组的计数量 group-\u003enRunning 放在共享内存中，在 slot 的获取过程中，会获取 ResGroupLock 类型的排他锁，以保证并发安全。 ","date":"0001-01-01","objectID":"/greenplum%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86resource-group%E4%BD%BF%E7%94%A8%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/:4:1","tags":["gpdb","resource","group"],"title":"Greenplum 资源管理——Resource Group使用和实现分析","uri":"/greenplum%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86resource-group%E4%BD%BF%E7%94%A8%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/"},{"categories":null,"content":"4.2 CPU 限制 Resource Group 通过 cgroup 实现对 cpu 的限制。在 resource group 创建或者修改时（比如 initCpu ），数据库会在操作系统 cgroup 路径下，创建与 resource group oid 同名的 cgroup 路径，即做对应挂载。并根据设置的 CPU 配置，更新对应 cgroup 子路径下的 cpu.cfs_period_us 、cpu.cfs_quota_us 、cpu.shares 文件。 而在开始事务时，数据库会将当前进程关联到对应的 cgroup 子节点下，具体逻辑如下： void ResGroupOps_AssignGroup(Oid group, ResGroupCaps *caps, int pid) { bool oldViaCpuset = oldCaps.cpuRateLimit == CPU_RATE_LIMIT_DISABLED; bool curViaCpuset = caps ? caps-\u003ecpuRateLimit == CPU_RATE_LIMIT_DISABLED : false; /* needn't write to file if the pid has already been written in. * Unless it has not been writtien or the group has changed or * cpu control mechanism has changed */ if (IsUnderPostmaster \u0026\u0026 group == currentGroupIdInCGroup \u0026\u0026 caps != NULL \u0026\u0026 oldViaCpuset == curViaCpuset) return; writeInt64(group, BASETYPE_GPDB, RESGROUP_COMP_TYPE_CPU, \"cgroup.procs\", pid); writeInt64(group, BASETYPE_GPDB, RESGROUP_COMP_TYPE_CPUACCT, \"cgroup.procs\", pid); if (gp_resource_group_enable_cgroup_cpuset) { if (caps == NULL || !curViaCpuset) { /* add pid to default group */ writeInt64(DEFAULT_CPUSET_GROUP_ID, BASETYPE_GPDB, RESGROUP_COMP_TYPE_CPUSET, \"cgroup.procs\", pid); } else { writeInt64(group, BASETYPE_GPDB, RESGROUP_COMP_TYPE_CPUSET, \"cgroup.procs\", pid); } } /* * Do not assign the process to cgroup/memory for now. */ currentGroupIdInCGroup = group; if (caps != NULL) { oldCaps.cpuRateLimit = caps-\u003ecpuRateLimit; StrNCpy(oldCaps.cpuset, caps-\u003ecpuset, sizeof(oldCaps.cpuset)); } } 数据库会将对应进程的 pid 写进子路径的 cgroup.procs 文件里，从而利用操作系统的 cgroup 能力对进程的 cpu 使用进行限制。 ","date":"0001-01-01","objectID":"/greenplum%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86resource-group%E4%BD%BF%E7%94%A8%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/:4:2","tags":["gpdb","resource","group"],"title":"Greenplum 资源管理——Resource Group使用和实现分析","uri":"/greenplum%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86resource-group%E4%BD%BF%E7%94%A8%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/"},{"categories":null,"content":"4.3 内存限制 支持对内存基于 vmtracker 和 cgroup 进行两种方式的限制。在使用 cgroup 做内存限制的时候，它的应用原理与 CPU 限制类似：为每个资源组创建一个 cgroup 子节点，在资源组创建和修改时，修改对应 cgroup 的内存管理配置文件 memory.limit_in_bytes 、 memory.usage_in_bytes ；事务运行时通过 pid 与对应 cgroup 关联，支持内存的限制。 而基于 vmtracker 进行内存限制时，则完全是由数据库本身进行高并发场景下的内存审计和分配，这里以内存统计量的修改为例： static int32 groupIncMemUsage(ResGroupData *group, ResGroupSlotData *slot, int32 chunks) { int32 slotMemUsage; /* the memory current slot has been used */ int32 sharedMemUsage; /* the total shared memory usage, sum of group share and global share */ int32 globalOveruse = 0; /* the total over used chunks of global share*/ /* Add the chunks to memUsage in slot */ slotMemUsage = pg_atomic_add_fetch_u32((pg_atomic_uint32 *) \u0026slot-\u003ememUsage, chunks); /* Check whether shared memory should be added */ sharedMemUsage = slotMemUsage - slot-\u003ememQuota; if (sharedMemUsage \u003e 0) { /* Decide how many chunks should be counted as shared memory */ int32 deltaSharedMemUsage = Min(sharedMemUsage, chunks); /* Add these chunks to memSharedUsage in group, * and record the old value*/ int32 oldSharedUsage = pg_atomic_fetch_add_u32((pg_atomic_uint32 *) \u0026group-\u003ememSharedUsage, deltaSharedMemUsage); /* the free space of group share */ int32 oldSharedFree = Max(0, group-\u003ememSharedGranted - oldSharedUsage); /* Calculate the global over used chunks */ int32 deltaGlobalSharedMemUsage = Max(0, deltaSharedMemUsage - oldSharedFree); /* freeChunks -= deltaGlobalSharedMemUsage and get the new value */ int32 newFreeChunks = pg_atomic_sub_fetch_u32((pg_atomic_uint32 *) \u0026pResGroupControl-\u003efreeChunks, deltaGlobalSharedMemUsage); /* calculate the total over used chunks of global share */ globalOveruse = Max(0, 0 - newFreeChunks); } /* Add the chunks to memUsage in group */ pg_atomic_add_fetch_u32((pg_atomic_uint32 *) \u0026group-\u003ememUsage, chunks); return globalOveruse; } 在进行内存限制时，对于某个 slot 的内存请求，首先会通过原子相加的方式从资源组的固定份额部分获取内存；而如果所需要的内存超过固定份额的内存量，会尝试从资源组内的共享内存部分获取；如果依然无法获取到内存，则会尝试从全局的共享内存获取。如果从全局共享内存依然无法获取到内存，则会返回 Out of Memory 错误。 ","date":"0001-01-01","objectID":"/greenplum%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86resource-group%E4%BD%BF%E7%94%A8%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/:4:3","tags":["gpdb","resource","group"],"title":"Greenplum 资源管理——Resource Group使用和实现分析","uri":"/greenplum%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86resource-group%E4%BD%BF%E7%94%A8%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/"},{"categories":null,"content":"4.4 Resource Group 监控 在进行监控时， QD 会把资源组查询 query 分发到各个 segment 上，然后再在 master 进行汇总，返回集群整体的资源利用情况。 Greenplum 支持多种对资源组的监控方式，除了直接的资源组监控视图之外，还支持对 segment 、机器层级的资源组监控。这些不同层级的资源组监控视图往往是通过对系统表和系统函数进行联合查询得到的，比如： CREATE VIEW gp_toolkit.gp_resgroup_status AS SELECT r.rsgname, s.* FROM pg_resgroup_get_status(null) AS s, pg_resgroup AS r WHERE s.groupid = r.oid; 所以，我们介绍最基本的资源监控函数 pg_resgroup_get_status 的实现方式。 static void getResUsage(ResGroupStatCtx *ctx, Oid inGroupId) { int64 *usages; TimestampTz *timestamps; int i, j; usages = palloc(sizeof(*usages) * ctx-\u003enGroups); timestamps = palloc(sizeof(*timestamps) * ctx-\u003enGroups); for (j = 0; j \u003c ctx-\u003enGroups; j++) { ResGroupStat *row = \u0026ctx-\u003egroups[j]; Oid groupId = DatumGetObjectId(row-\u003egroupId); usages[j] = ResGroupOps_GetCpuUsage(groupId); timestamps[j] = GetCurrentTimestamp(); } if (Gp_role == GP_ROLE_DISPATCH) { CdbPgResults cdb_pgresults = {NULL, 0}; StringInfoData buffer; initStringInfo(\u0026buffer); appendStringInfo(\u0026buffer, \"SELECT groupid, cpu_usage, memory_usage \" \"FROM pg_resgroup_get_status(%d)\", inGroupId); CdbDispatchCommand(buffer.data, DF_WITH_SNAPSHOT, \u0026cdb_pgresults); if (cdb_pgresults.numResults == 0) elog(ERROR, \"pg_resgroup_get_status() didn't get back any resource statistic from the segDBs\"); for (i = 0; i \u003c cdb_pgresults.numResults; i++) { struct pg_result *pg_result = cdb_pgresults.pg_results[i]; /* * Any error here should have propagated into errbuf, so we shouldn't * ever see anything other that tuples_ok here. But, check to be * sure. */ if (PQresultStatus(pg_result) != PGRES_TUPLES_OK) { cdbdisp_clearCdbPgResults(\u0026cdb_pgresults); elog(ERROR, \"pg_resgroup_get_status(): resultStatus not tuples_Ok\"); } Assert(PQntuples(pg_result) == ctx-\u003enGroups); for (j = 0; j \u003c ctx-\u003enGroups; j++) { const char *result; ResGroupStat *row = \u0026ctx-\u003egroups[j]; Oid groupId = pg_atoi(PQgetvalue(pg_result, j, 0), sizeof(Oid), 0); Assert(groupId == row-\u003egroupId); if (row-\u003ememUsage-\u003elen == 0) { Datum d = ResGroupGetStat(groupId, RES_GROUP_STAT_MEM_USAGE); row-\u003egroupId = groupId; appendStringInfo(row-\u003ememUsage, \"{\\\"%d\\\":%s\", GpIdentity.segindex, DatumGetCString(d)); appendStringInfo(row-\u003ecpuUsage, \"{\"); calcCpuUsage(row-\u003ecpuUsage, usages[j], timestamps[j], ResGroupOps_GetCpuUsage(groupId), GetCurrentTimestamp()); } result = PQgetvalue(pg_result, j, 1); appendStringInfo(row-\u003ecpuUsage, \", %s\", result); result = PQgetvalue(pg_result, j, 2); appendStringInfo(row-\u003ememUsage, \", %s\", result); if (i == cdb_pgresults.numResults - 1) { appendStringInfoChar(row-\u003ecpuUsage, '}'); appendStringInfoChar(row-\u003ememUsage, '}'); } } } cdbdisp_clearCdbPgResults(\u0026cdb_pgresults); } else { pg_usleep(300000); for (j = 0; j \u003c ctx-\u003enGroups; j++) { ResGroupStat *row = \u0026ctx-\u003egroups[j]; Oid groupId = DatumGetObjectId(row-\u003egroupId); Datum d = ResGroupGetStat(groupId, RES_GROUP_STAT_MEM_USAGE); appendStringInfo(row-\u003ememUsage, \"\\\"%d\\\":%s\", GpIdentity.segindex, DatumGetCString(d)); calcCpuUsage(row-\u003ecpuUsage, usages[j], timestamps[j], ResGroupOps_GetCpuUsage(groupId), GetCurrentTimestamp()); } } } 结合这段代码我们看到， Master 节点（ Gp_role = GP_ROLE_DISPATCH ）在接收到查询资源状态的 SQL 之后，首先会将一个相同的状态查询 SQL （ =SELECT groupid, cpu_usage, memory_usage FROM pg_resgroup_get_status ），分发给所有的 segment 节点。 Master 节点收到各个节点出来的结果之后，会进行排序汇总，然后返回最终结果。 而在各个节点真实计算的时候，对于内存消耗的计算，会返回实时统计的内存统计结果。 而对于 cpu 的计算，会在一开始先调用 ResGroupOps_GetCpuUsage 计算一次 cpu 使用量，通过读取磁盘上 cgroup 对应节点的 cpu 统计结果。然后 sleep 300000 us ，重新调用 ResGroupOps_GetCpuUsage 再计算一次 cpu 使用量，通过两次结果的差值返回 cpu 的统计结果。 static void calcCpuUsage(StringInfoData *str, int64 usageBegin, TimestampTz timestampBegin, int64 usageEnd, TimestampTz timestampEnd) { int64 duration; long secs; int usecs; int64 usage; usage = usageEnd - usageBegin; TimestampDifference(timestampBegin, timestampEnd, \u0026secs, \u0026usecs); duration = secs * 1000000 + usecs; appendStringInfo(str, \"\\\"%d\\\":%.2f\", GpIdentity.segindex, ResGroupOps_ConvertCpuUsageToPercent(usage, duration)); } ","date":"0001-01-01","objectID":"/greenplum%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86resource-group%E4%BD%BF%E7%94%A8%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/:4:4","tags":["gpdb","resource","group"],"title":"Greenplum 资源管理——Resource Group使用和实现分析","uri":"/greenplum%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86resource-group%E4%BD%BF%E7%94%A8%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/"},{"categories":null,"content":"5 常见问题 ","date":"0001-01-01","objectID":"/greenplum%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86resource-group%E4%BD%BF%E7%94%A8%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/:5:0","tags":["gpdb","resource","group"],"title":"Greenplum 资源管理——Resource Group使用和实现分析","uri":"/greenplum%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86resource-group%E4%BD%BF%E7%94%A8%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/"},{"categories":null,"content":"5.1 Resource Group 是如何利用操作系统的 cgroup 能力的？ 答：对于每个资源组，数据库会在系统的 cgroup 路径下创建一个以资源组 oid 命名的子路径，即做对应的 cgroup 挂载。创建资源组或者修改资源组配置的时候，数据库会对应修改对应子节点的 cgroup 配置。实际执行事务时，数据库会将对应进程的 pid 写入对应的 cgroup 路径下，从而纳入 cgroup 的限制中。 ","date":"0001-01-01","objectID":"/greenplum%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86resource-group%E4%BD%BF%E7%94%A8%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/:5:1","tags":["gpdb","resource","group"],"title":"Greenplum 资源管理——Resource Group使用和实现分析","uri":"/greenplum%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86resource-group%E4%BD%BF%E7%94%A8%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/"},{"categories":null,"content":"5.2 Resource Group 是如何进行事务级别的资源限制的？ 答：数据库对于每个资源组，根据并发限制，将资源划分成多个 slot 。 对于每个事务，在开启事务 (startTransaction) 的时候， QD 都会尝试获取一个 slot 。如果获取不到就会一直等待其他事务完成执行并释放 slot 。 ","date":"0001-01-01","objectID":"/greenplum%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86resource-group%E4%BD%BF%E7%94%A8%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/:5:2","tags":["gpdb","resource","group"],"title":"Greenplum 资源管理——Resource Group使用和实现分析","uri":"/greenplum%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86resource-group%E4%BD%BF%E7%94%A8%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/"},{"categories":null,"content":"5.3 Resource Group 的各种操作加不加锁，加什么锁？ 资源组的创建和修改都会加 ResGroupLock 类型的 exclusive lock ，而 backend 获取 slot 来执行事务的时候也会获取 ResGroupLock 的 exclusive lock ，所以资源组相关的变更，会与对应资源组内的事务执行相互阻塞。另外， Resource Group 配置修改的时候，还会对相关系统表加 AccessExclusiveLock 。 ","date":"0001-01-01","objectID":"/greenplum%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86resource-group%E4%BD%BF%E7%94%A8%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/:5:3","tags":["gpdb","resource","group"],"title":"Greenplum 资源管理——Resource Group使用和实现分析","uri":"/greenplum%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86resource-group%E4%BD%BF%E7%94%A8%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/"},{"categories":null,"content":"5.4 数据库基于 cgroup 对资源组进行限制，如果某个数据库节点故障，跨机迁移到其他节点，而 cgroup 的配置和路径结构无法迁移，会不会导致对应机器上的 resource group 功能失效？ 答：不会。在数据库节点初始化的时候 (initPostgres) ，会进行资源组的检测，如果系统表中的资源组配置在 cgroup 路径中不存在，会重新创建对应的 cgroup 挂载。 同理，如果你配置好了 ResourceGroup 之后，直接把你机器上的对应 oid 的 cgroup 子路径删掉，重启下数据库就会恢复正常的状态。 ","date":"0001-01-01","objectID":"/greenplum%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86resource-group%E4%BD%BF%E7%94%A8%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/:5:4","tags":["gpdb","resource","group"],"title":"Greenplum 资源管理——Resource Group使用和实现分析","uri":"/greenplum%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86resource-group%E4%BD%BF%E7%94%A8%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/"},{"categories":null,"content":"5.5 为什么资源组的 CPU 使用率高于配置的 CPU_RATE_LIMIT ？ 答：资源组可能存在 CPU 抢占的情况：当其他资源组空闲时，忙碌的资源组可以使用比其 CPU_RATE_LIMIT 更多的 CPU 。在这种情况下，数据库将空闲资源组的 CPU 资源分配给更繁忙的资源组。 ","date":"0001-01-01","objectID":"/greenplum%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86resource-group%E4%BD%BF%E7%94%A8%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/:5:5","tags":["gpdb","resource","group"],"title":"Greenplum 资源管理——Resource Group使用和实现分析","uri":"/greenplum%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86resource-group%E4%BD%BF%E7%94%A8%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/"},{"categories":null,"content":"5.6 Resource Group 在部署上有什么要求？ 答： 安装并开启 cgroup ； cgroup 做好初始化挂载，初始化配置举例： group gpdb { perm { task { uid = gpadmin; gid = gpadmin; } admin { uid = gpadmin; gid = gpadmin; } } cpu { } cpuacct { } cpuset { } memory { } } 实际使用时要根据自身情况（系统用户名）修改配置； cpu 和 cpuset 对应的路径必须分开挂载。 ","date":"0001-01-01","objectID":"/greenplum%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86resource-group%E4%BD%BF%E7%94%A8%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/:5:6","tags":["gpdb","resource","group"],"title":"Greenplum 资源管理——Resource Group使用和实现分析","uri":"/greenplum%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86resource-group%E4%BD%BF%E7%94%A8%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/"},{"categories":null,"content":"6 总结 资源管理对于数据库集群的多租户管理、资源细粒度分配具有很重要的价值。 Resource Group 巧妙地基于操作系统的 cgroup 隔离能力和 PostgreSQL 本身的基于 MemoryContext 的内存管理能力，以很少的代码量实现了完备的资源管理功能。在 GP5 之后， Resource Group 主键替代 Resource Queue 成为主流的资源管理方式， Greenplum 社区也把 Resource Group 当做主要去维护和优化的资源管理方式。 对 Greenplum 内存管理感兴趣的话，可以参考一下文章：基于 MemoryContext 的内存管理 对另外一种资源管理方式感兴趣的话，可以参考下文章： Greenplum 资源管理—— Resource Queue 使用和实现分析 ","date":"0001-01-01","objectID":"/greenplum%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86resource-group%E4%BD%BF%E7%94%A8%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/:6:0","tags":["gpdb","resource","group"],"title":"Greenplum 资源管理——Resource Group使用和实现分析","uri":"/greenplum%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86resource-group%E4%BD%BF%E7%94%A8%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/"},{"categories":null,"content":" Table of Contents 1 Hash Indexing 2 Page Addressing 本文为摘录(或转载)，侵删，原文为： ../../../Work/pg_master/src/backend/access/hash/README ","date":"0001-01-01","objectID":"/pg_hash_index/:0:0","tags":null,"title":"Hash Index of PG","uri":"/pg_hash_index/"},{"categories":null,"content":"1 Hash Indexing 这个目录包含了 Postgres 的散列索引实现。其中大部分核心思想来自于 Margo Seltzer 和 Ozan Yigit 在 1991 年 1 月举行的冬季 USENIX 会议上的论文《A New Hashing Package for UNIX》。我们的内存哈希表实现（src/backend/utils/hash/dynahash.c）也依赖于相同的概念；它源自于 Esmond Pitt 编写的代码，后来又由 Margo 和其他人进行了改进。 哈希索引由两个或更多“桶”组成，每当元组的哈希键映射到桶号时，就将其放入其中一个桶中。选择键到桶号的映射，以便可以增量扩展索引。当要向索引中添加新桶时，必须“拆分”一个现有的桶，将其中一些元组根据更新的键到桶号映射转移到新桶中。这与 src/backend/utils/hash/dynahash.c 中的内存哈希表管理技术本质上相同。 哈希索引中的每个桶包含一个或多个索引页面。当创建桶时，该桶的第一个页面被永久分配给它。如果桶接收的元组过多，无法放入主桶页面中，则添加附加页面（称为“溢出页面”）。桶的页使用索引页面特殊空间中的字段作为双向链表链接在一起。 目前不存在缩小哈希索引的方法，除非使用 REINDEX 重新构建它。可以重新利用溢出页面以在其他桶中重用，但我们永远不会将它们返回到操作系统。也没有减少桶数的方法。 截至 PostgreSQL 8.4，哈希索引条目仅存储每个索引项的哈希代码，而不是实际的数据值。这使得索引条目更小（可能非常大），并加速了各种操作。特别是，我们可以通过将任何一个索引页面中的索引条目按哈希码排序来加快搜索速度，从而在索引页面内使用二进制搜索。但请注意，对于同一桶的不同索引页面之间的哈希码相对排序没有任何假设。 ","date":"0001-01-01","objectID":"/pg_hash_index/:1:0","tags":null,"title":"Hash Index of PG","uri":"/pg_hash_index/"},{"categories":null,"content":"2 Page Addressing 哈希索引中有四种页面： 元页面（第 0 页），其中包含静态分配的控制信息； 主桶页面； 溢出页面； 位图页面，它们跟踪已被释放且可供重新使用的溢出页面。 为 addressing purposes，位图页面被认为是溢出页面的子集。 主桶页面和溢出页面是独立分配的（因为任何给定的索引可能相对于其桶的数量需要更多或更少的溢出页面）。哈希码使用一组有趣的 addressing rules 来支持可变数量的溢出页面，而不必在创建主桶页面后移动它们。 主桶页面（以下简称“桶页面”）以 2 的幂组分配，称为代码中的 “分割点” 。这意味着每次新的分割点时，我们都会将现有的桶数加倍。一次性分配大量桶页面并不理想，我们需要很长时间才能消耗它们。 为避免指数级增长的索引大小，我们使用了一个技巧，将分割点处的桶分配拆分为 4 个相等的阶段。如果（2 ^ x）是要在分割点分配的总桶数（从现在开始我们将其称为分割点组），则在分割点组的每个阶段中分配总桶数的 1/4（2 ^（x-2））。下一四分之一的分配只会发生在之前的一相桶已经被消耗完了。对于初始分割点组 \u003c 10，我们将仅在单个阶段中分配它们的所有桶，因为初始组分配的桶数很少。对于组 \u003e= 10，分配过程分为四个相等阶段。在组 10 中，我们将 4 个不同阶段（{2 ^ 7，2 ^ 7，2 ^ 7，2 ^ 7}）分配了（2 ^ 9）个桶，括号中的数字表示分割点组的每个阶段分配的桶数 10。对于分割点组 11 和 12，分配阶段将分别为{2 ^ 8，2 ^ 8，2 ^ 8，2 ^ 8}和{2 ^ 9，2 ^ 9，2 ^ 9，2 ^ 9}。我们可以看到，在每个分割点组中，我们将前一个组中桶的总数加倍，但是在增量阶段中完成。同一分割点组中分配的 bucket 页面将依次出现在索引中。这种 addressing scheme 允许相对轻松地通过使用仅少量的控制信息将桶页面的物理位置从桶号计算出来。如果我们看一下给定的桶号的函数 _hash_spareindex，我们首先计算它所属的分割点组，然后计算桶所属的阶段。将它们加起来我们得到桶所属的全局分割点阶段号 S，然后只需添加“hashm_spares[S] + 1”（其中 hashm_spares[] 是存储在元页面中的数组）就可以计算其物理地址。hashm_spares [S] 可以解释为已分配分割点阶段 S 的 bucket 页面之前分配的溢出页面的总数。hashm_spares [0] 始终为 0，因此桶 0 和 1 总是出现在元页后的块编号 1 和 2 中。我们始终有 hashm_spares [N] \u003c= hashm_spares [N ","date":"0001-01-01","objectID":"/pg_hash_index/:2:0","tags":null,"title":"Hash Index of PG","uri":"/pg_hash_index/"},{"categories":null,"content":" Table of Contents 1 Basic Log Viewing 2 Journal Filtering by Time 2.1 Displaying Logs from the Current Boot 2.2 Filtering by Message Interest 本文为摘录(或转载)，侵删，原文为： https://www.digitalocean.com/community/tutorials/how-to-use-journalctl-to-view-and-manipulate-systemd-logs ","date":"0001-01-01","objectID":"/how-to-use-journalctl-to-view-and-manipulate-systemd-logs/:0:0","tags":["journalctl","logs"],"title":"How To Use Journalctl to View and Manipulate Systemd Logs","uri":"/how-to-use-journalctl-to-view-and-manipulate-systemd-logs/"},{"categories":null,"content":"1 Basic Log Viewing 要查看 journald 守护程序收集的日志，请使用 journalctl 命令。 当单独使用时，系统中的每个日志条目都会在翻页器（通常是 less）中显示，供您浏览。最旧的条目将显示在顶部： journalctl Output -- Logs begin at Tue 2015-02-03 21:48:52 UTC, end at Tue 2015-02-03 22:29:38 UTC. -- Feb 03 21:48:52 localhost.localdomain systemd-journal[243]: Runtime journal is using 6.2M (max allowed 49. Feb 03 21:48:52 localhost.localdomain systemd-journal[243]: Runtime journal is using 6.2M (max allowed 49. Feb 03 21:48:52 localhost.localdomain systemd-journald[139]: Received SIGTERM from PID 1 (systemd). Feb 03 21:48:52 localhost.localdomain kernel: audit: type=1404 audit(1423000132.274:2): enforcing=1 old_en Feb 03 21:48:52 localhost.localdomain kernel: SELinux: 2048 avtab hash slots, 104131 rules. Feb 03 21:48:52 localhost.localdomain kernel: SELinux: 2048 avtab hash slots, 104131 rules. Feb 03 21:48:52 localhost.localdomain kernel: input: ImExPS/2 Generic Explorer Mouse as /devices/platform/ Feb 03 21:48:52 localhost.localdomain kernel: SELinux: 8 users, 102 roles, 4976 types, 294 bools, 1 sens, Feb 03 21:48:52 localhost.localdomain kernel: SELinux: 83 classes, 104131 rules . . . 你可能会注意到，当前显示的时间戳都是使用本地时间。现在我们已经在系统上正确地设置了本地时间，因此每条日志条目都可以使用本地时间显示。所有日志都使用这些新信息进行显示。 如果你想显示 UTC 时间戳，可以使用–utc 标志： journalctl --utc 1.0.1 Displaying Kernel Messages 内核消息通常可以在 dmesg 输出中找到，并且也可以从日志中检索。 要仅显示这些消息，我们可以在命令中添加 -k=或 =--dmesg 标志： journalctl -k 默认情况下，这将显示当前启动的内核消息。您可以使用先前讨论过的正常引导选择标志指定其他引导。例如，要获取五个启动前的消息，您可以键入： journalctl -k -b -5 ","date":"0001-01-01","objectID":"/how-to-use-journalctl-to-view-and-manipulate-systemd-logs/:1:0","tags":["journalctl","logs"],"title":"How To Use Journalctl to View and Manipulate Systemd Logs","uri":"/how-to-use-journalctl-to-view-and-manipulate-systemd-logs/"},{"categories":null,"content":"2 Journal Filtering by Time ","date":"0001-01-01","objectID":"/how-to-use-journalctl-to-view-and-manipulate-systemd-logs/:2:0","tags":["journalctl","logs"],"title":"How To Use Journalctl to View and Manipulate Systemd Logs","uri":"/how-to-use-journalctl-to-view-and-manipulate-systemd-logs/"},{"categories":null,"content":"2.1 Displaying Logs from the Current Boot journalctl -b journalctl –list-boots journalctl -b -1 2.1.1 Time Windows journalctl –since “2015-01-10 17:15:00” journalctl –since “2015-01-10” –until “2015-01-11 03:00” ","date":"0001-01-01","objectID":"/how-to-use-journalctl-to-view-and-manipulate-systemd-logs/:2:1","tags":["journalctl","logs"],"title":"How To Use Journalctl to View and Manipulate Systemd Logs","uri":"/how-to-use-journalctl-to-view-and-manipulate-systemd-logs/"},{"categories":null,"content":"2.2 Filtering by Message Interest 2.2.1 By Unit journalctl -u nginx.service journalctl -u nginx.service –since today journalctl -u nginx.service -u php-fpm.service –since today 2.2.2 By Process, User, or Group ID 内核消息通常在 dmesg 的输出中找到，也可以从日志中检索出来。 要仅显示这些消息，我们可以在命令中添加-k 或–dmesg 标志： journalctl -k 默认情况下，这将显示来自当前启动的内核消息。您可以使用之前讨论的标准启动选择标志指定替代启动。例如，要获取五个启动前的消息，可以键入： journalctl -k -b -5 2.2.3 By Priority 系统管理员经常感兴趣的一个过滤器是消息优先级。虽然记录详细信息通常很有用，但在实际处理可用信息时，低优先级的日志可能会分散注意力，使人感到困惑。您可以使用 journalctl 命令使用-p 选项仅显示指定优先级或更高优先级的消息。这允许您过滤掉较低优先级的消息。例如，您可以键入以下内容仅显示在错误级别或更高级别记录的条目： journalctl -p err -b 这将向您显示所有标记为错误、关键、警报或紧急的消息。journal 实现了标准的 syslog 消息级别。您可以使用优先级名称或其相应的数字值。按照从最高到最低优先级的顺序，它们是： – 0：emerg – 1：alert – 2：crit – 3：err – 4：warning – 5：notice – 6：info – 7：debug 上述数字或名称可以在-p 选项中互换使用。选择一个优先级将显示标记为指定级别及其以上级别的消息。 ","date":"0001-01-01","objectID":"/how-to-use-journalctl-to-view-and-manipulate-systemd-logs/:2:2","tags":["journalctl","logs"],"title":"How To Use Journalctl to View and Manipulate Systemd Logs","uri":"/how-to-use-journalctl-to-view-and-manipulate-systemd-logs/"},{"categories":null,"content":" Table of Contents 1 ABSTRACT 2 INTRODUCTION 本文为摘录(或转载)，侵删，原文为： attachments/pdf/e/p1092-loghin.pdf ","date":"0001-01-01","objectID":"/p1092-loghin/:0:0","tags":["blockchain"],"title":"Hybrid Blockchain Database Systems: Design and Performance","uri":"/p1092-loghin/"},{"categories":null,"content":"1 ABSTRACT Abbrs: CFT: crash fault-tolerant BFT: byzantine fault-tolerant Byzantine Fault Tolerance (BFT) is a trait of decentralized, permissionless systems which are capable of successfully identifying and rejecting dishonest or faulty information. Byzantine fault tolerant systems have successfully solved the Byzantine Generals Problem and are robust against sybil attacks. ","date":"0001-01-01","objectID":"/p1092-loghin/:1:0","tags":["blockchain"],"title":"Hybrid Blockchain Database Systems: Design and Performance","uri":"/p1092-loghin/"},{"categories":null,"content":"2 INTRODUCTION 学术界出现了集成分布式数据库与区块链特性的系统 这些系统称为 hybrid blockchain database systems, 混合区块数据库系统，包含： 向区块链中增加数据库特性 改进性能和易用性 在分布式数据库中实现区块链特性 提升安全性 BigchainDB introduces two optimizations Blockchain Pipelining allows nodes to vote for a new block while the current block of the ledger is still undecided. 在当前账本的 block 没有确定的时候，就可以为新 block 投票？ 避免由等待 block 完全提交而阻塞产生新的 block 支持并行验证 可以在多核 CPU 上并行验证事务 作者说，然并卵。。。 ","date":"0001-01-01","objectID":"/p1092-loghin/:2:0","tags":["blockchain"],"title":"Hybrid Blockchain Database Systems: Design and Performance","uri":"/p1092-loghin/"},{"categories":null,"content":" Table of Contents 1 表现 2 原因 3 绕过方法 ","date":"0001-01-01","objectID":"/ireader--calibre/:0:0","tags":["calibre","mtp"],"title":"iReader \u0026 Calibre","uri":"/ireader--calibre/"},{"categories":null,"content":"1 表现 通过 Calibre 向 iReader 中传输书籍失败，报 MTP 相关错误。 ","date":"0001-01-01","objectID":"/ireader--calibre/:1:0","tags":["calibre","mtp"],"title":"iReader \u0026 Calibre","uri":"/ireader--calibre/"},{"categories":null,"content":"2 原因 不知道为什么，无法在设备存储空间中创建目录 ","date":"0001-01-01","objectID":"/ireader--calibre/:2:0","tags":["calibre","mtp"],"title":"iReader \u0026 Calibre","uri":"/ireader--calibre/"},{"categories":null,"content":"3 绕过方法 用文件管理器提前创建 Books目录 （不推荐）, 或者 在 Calibre 中找到设备，选择配置，将传输目录指向已有的目录，例如 iTransfer 推荐第二种，配置过后会生成下面的配置文件 ~/.config/calibre/mtp_devices.json { \"blacklist\": [], \"device-47516c97f972181\": { \"send_to\": [ \"i-transfer\" ] }, \"history\": { \"47516c97f972181\": [ \"Ocean 2\", \"2023-08-09T01:21:19.306004+00:00\" ] } } ","date":"0001-01-01","objectID":"/ireader--calibre/:3:0","tags":["calibre","mtp"],"title":"iReader \u0026 Calibre","uri":"/ireader--calibre/"},{"categories":null,"content":" Table of Contents 1 The Linux Process States 1.1 Running or Runnable State (R) 1.2 Sleeping State: Interruptible (S) and Uninterruptible (D) 1.3 Stopped State (T) 1.4 Zombie State (Z) 2 Checking Process State 2.1 Displaying Process State Using ps 2.2 Using the top Command 2.3 The /proc Pseudo File 3 Summary 本文为摘录(或转载)，侵删，原文为： https://www.baeldung.com/linux/process-states ","date":"0001-01-01","objectID":"/linux-process-states-baeldung-on-linux/:0:0","tags":["process","status","linux"],"title":"Linux Process States","uri":"/linux-process-states-baeldung-on-linux/"},{"categories":null,"content":"1 The Linux Process States Running or Runnable (R) Uninterruptible Sleep (D) Interruptable Sleep (S) Stopped (T) Zombie (Z) 状态机如下： For any Linux process, their starting point is the moment they are created. For example, a parent process can initiate a child process using the fork() system call. Once it starts, the process goes into the running or runnable state. While the process is running, it could come into a code path that requires it to wait for particular resources or signals before proceeding. While waiting for the resources, the process would voluntarily give up the CPU cycles by going into one of the two sleeping states. Additionally, we could suspend a running process and put it into the stopped state. Usually, this is done by sending the SIGSTOP signal to the process. A process in this state will continue to exist until it is killed or resumed with SIGCONT. Finally, the process completes its lifecycle when it’s terminated and placed into a zombie state until its parent process clears it off the process table. ","date":"0001-01-01","objectID":"/linux-process-states-baeldung-on-linux/:1:0","tags":["process","status","linux"],"title":"Linux Process States","uri":"/linux-process-states-baeldung-on-linux/"},{"categories":null,"content":"1.1 Running or Runnable State (R) When a new process is started, it’ll be placed into the running or runnable state. In the running state, the process takes up a CPU core to execute its code and logic. However, the thread scheduling algorithm might force a running process to give up its execution right. This is to ensure each process can have a fair share of CPU resources. In this case, the process will be placed into a run queue, and its state is now a runnable state waiting for its turn to execute. Although the running and runnable states are distinct, they are collectively grouped into a single state denoted by the character R. ","date":"0001-01-01","objectID":"/linux-process-states-baeldung-on-linux/:1:1","tags":["process","status","linux"],"title":"Linux Process States","uri":"/linux-process-states-baeldung-on-linux/"},{"categories":null,"content":"1.2 Sleeping State: Interruptible (S) and Uninterruptible (D) During process execution, it might come across a portion of its code where it needs to request external resources. Mainly, the request for these resources is IO-based such as to read a file from disk or make a network request. Since the process couldn’t proceed without the resources, it would stall and do nothing. In events like these, they should give up their CPU cycles to other tasks that are ready to run, and hence they go into a sleeping state. There are two different sleeping states: the uninterruptible sleeping state (D) and the interruptible sleepingstate (S) The uninterruptible sleeping state (D) will only wait for the resources to be available before it transit into a runnable state, and it doesn’t react to any signals. On the other hand, the interruptible sleeping state (S) will react to signals and the availability of resources. ","date":"0001-01-01","objectID":"/linux-process-states-baeldung-on-linux/:1:2","tags":["process","status","linux"],"title":"Linux Process States","uri":"/linux-process-states-baeldung-on-linux/"},{"categories":null,"content":"1.3 Stopped State (T) From a running or runnable state, we could put a process into the stopped state (T) using the SIGSTOP or SIGTSTP signals. The difference between both signals is that we send the SIGSTOP is programmatic, such as running kill -STOP {pid}. Additionally, the process cannot ignore this signal and will go into the stopped state. On the other hand, we send the SIGTSTP signal using the keyboard CTRL + Z. Unlike SIGSTOP, the process can optionally ignore this signal and continue to execute upon receiving SIGTSTP. While in this state, we could bring back the process into a running or runnable state by sending the SIGCONT signal. ","date":"0001-01-01","objectID":"/linux-process-states-baeldung-on-linux/:1:3","tags":["process","status","linux"],"title":"Linux Process States","uri":"/linux-process-states-baeldung-on-linux/"},{"categories":null,"content":"1.4 Zombie State (Z) When a process has completed its execution or is terminated, it’ll send the SIGCHLD signal to the parent process and go into the zombie state. The zombie process, also known as a defunct process, will remain in this state until the parent process clears it off from the process table. To clear the terminated child process off the process table, the parent process must read the exit value of the child process using the wait() or waitpid() system calls. ","date":"0001-01-01","objectID":"/linux-process-states-baeldung-on-linux/:1:4","tags":["process","status","linux"],"title":"Linux Process States","uri":"/linux-process-states-baeldung-on-linux/"},{"categories":null,"content":"2 Checking Process State There are multiple ways to check the state of a process is in Linux. For example, we can use command-line tools like ps and top to check the state of processes. Alternatively, we can consult the pseudo status file for a particular PID. ","date":"0001-01-01","objectID":"/linux-process-states-baeldung-on-linux/:2:0","tags":["process","status","linux"],"title":"Linux Process States","uri":"/linux-process-states-baeldung-on-linux/"},{"categories":null,"content":"2.1 Displaying Process State Using ps To display process state using ps, let’s run the ps command to include a column that tells us the state of the process: $ ps a PID TTY STAT TIME COMMAND 2234 tty2 Ssl+ 0:00 /usr/lib/gdm3/gdm-x-session --run-script env GNOME_SHELL_SESSION_MODE=ubuntu /usr/bin/gnome-session --systemd --session=ubuntu 2237 tty2 Rl+ 0:07 /usr/lib/xorg/Xorg vt2 -displayfd 3 -auth /run/user/1000/gdm/Xauthority -background none -noreset -keeptty -verbose 3 2287 tty2 Sl+ 0:00 /usr/libexec/gnome-session-binary --systemd --systemd --session=ubuntu 2982 pts/0 Ss 0:00 bash 3467 pts/0 R+ 0:00 ps a The first letter of the value under the STAT column indicates the state that the process is in. For example, the process with PID 2234 is currently in an interruptible sleeping state, as denoted by the character S. Besides that, we can also observe that process 2237 is currently in the running or runnable state. Additionally, we can see that there are additional characters besides each of the state characters. These characters indicate several attributes of the state of the process. For example, the lower capital letter s means the process is the session leader. For a comprehensive list of the meaning of each of the characters, we can find it on the official man page. ","date":"0001-01-01","objectID":"/linux-process-states-baeldung-on-linux/:2:1","tags":["process","status","linux"],"title":"Linux Process States","uri":"/linux-process-states-baeldung-on-linux/"},{"categories":null,"content":"2.2 Using the top Command In Linux, the top command-line tool displays the process details in a real-time fashion. It shows different aspects of the system, such as memory and CPU usage of individual processes. To see the process state, let’s run top in the terminal: Tasks: 183 total, 1 running, 182 sleeping, 0 stopped, 0 zombie %Cpu(s): 0.7 us, 1.1 sy, 0.0 ni, 97.1 id, 0.4 wa, 0.0 hi, 0.7 si, 0.0 st MiB Mem : 3936.4 total, 1925.0 free, 850.6 used, 1160.8 buff/cache MiB Swap: 2048.0 total, 2048.0 free, 0.0 used. 2834.2 avail Mem PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 2237 bob 20 0 252252 81740 49204 S 2.3 2.0 0:09.37 Xorg 2519 bob 20 0 3428664 375256 125080 S 2.0 9.3 0:19.57 gnome-shell 2909 bob 20 0 966852 49944 37308 S 1.0 1.2 0:02.28 gnome-terminal- 1 root 20 0 103500 13312 8620 S 0.7 0.3 0:04.44 systemd 3588 bob 20 0 20600 3936 3380 R 0.3 0.1 0:00.01 top 2 root 20 0 0 0 0 S 0.0 0.0 0:00.00 kthreadd 3 root 0 -20 0 0 0 I 0.0 0.0 0:00.00 rcu_gp At the bottom section of the output of the top command, we can find the S column, which shows the state of each process. Contrary to the ps command, the top command displays the state of each process without additional process attributes. ","date":"0001-01-01","objectID":"/linux-process-states-baeldung-on-linux/:2:2","tags":["process","status","linux"],"title":"Linux Process States","uri":"/linux-process-states-baeldung-on-linux/"},{"categories":null,"content":"2.3 The /proc Pseudo File The /proc pseudo filesystem contains all the information about the processes in our system. Hence, we could directly read the state of a process through this pseudo filesystem. The downside of this approach is we’ll first need to know the PID of the process before we can read its state. To obtain the state of a process, we can extract the value from its pseudo status file under /proc/{pid}/status. For example, we can get the state of the process with PID 2519 by reading the file /proc/2519/status: $ cat /proc/2519/status | grep State State: S (sleeping) ","date":"0001-01-01","objectID":"/linux-process-states-baeldung-on-linux/:2:3","tags":["process","status","linux"],"title":"Linux Process States","uri":"/linux-process-states-baeldung-on-linux/"},{"categories":null,"content":"3 Summary In this tutorial, we’ve looked at the lifecycle of a Linux process. Furthermore, we’ve learned how we can model a Linux process lifecycle as a finite state machine. Then, we’ve looked at the five different states as a Linux process undergoes the entire lifecycle. Finally, we ended the article with demonstrations on getting the Linux process state using various tools such as ps, top, and the /proc pseudo-file. ","date":"0001-01-01","objectID":"/linux-process-states-baeldung-on-linux/:3:0","tags":["process","status","linux"],"title":"Linux Process States","uri":"/linux-process-states-baeldung-on-linux/"},{"categories":null,"content":" Table of Contents 1 ABSTRACT 本文为摘录(或转载)，侵删，原文为： attachments/pdf/4/p1011-jin.pdf ","date":"0001-01-01","objectID":"/p1011-jin/:0:0","tags":["join","graph"],"title":"Making RDBMSs Efficient on Graph Workloads Through Predefined Joins","uri":"/p1011-jin/"},{"categories":null,"content":"1 ABSTRACT ","date":"0001-01-01","objectID":"/p1011-jin/:1:0","tags":["join","graph"],"title":"Making RDBMSs Efficient on Graph Workloads Through Predefined Joins","uri":"/p1011-jin/"},{"categories":null,"content":" Table of Contents 1 ABSTRACT 2 INTRODUCTION 本文为摘录(或转载)，侵删，原文为： attachments/pdf/8/p3548-yan.pdf ","date":"0001-01-01","objectID":"/p3548-yan/:0:0","tags":["vector","engine","database"],"title":"Manu: A Cloud Native Vector Database Management System","uri":"/p3548-yan/"},{"categories":null,"content":"1 ABSTRACT 下一代向量数据库应该有的特性： 可长期演进 tunable consistency good elasticity high performance Manu 通过放宽数据模型和一致性约束来换取上述特性： 使用 WAL 和 binlog 作为服务的骨干 写组件作为日志的发布者 只读组件作为日志的订阅者，只读组件包括： 分析 搜索 使用 MVCC 和增量一致模型来简化组件之间的通讯和协作 ","date":"0001-01-01","objectID":"/p3548-yan/:1:0","tags":["vector","engine","database"],"title":"Manu: A Cloud Native Vector Database Management System","uri":"/p3548-yan/"},{"categories":null,"content":"2 INTRODUCTION ","date":"0001-01-01","objectID":"/p3548-yan/:2:0","tags":["vector","engine","database"],"title":"Manu: A Cloud Native Vector Database Management System","uri":"/p3548-yan/"},{"categories":null,"content":"本文为摘录(或转载)，侵删，原文为： attachments/pdf/a/p1187-zhang.pdf PM stands for Persistent Memory， 持久内存，它是一种非易失性内存，即使断电也能保留数据。 eADR 保证了 CPU 缓存中的数据在电源故障时会被刷新到 PM 中 这使得在 eADR 启用的 PM 系统中，全局可见数据被认为是持久的 不再需要显式的数据清除操作 NBTree a lock-free PM-friendly B+ Tree 实现了高可扩展性和低 PM 开销 NBTree is the first persistent index designed for eADR-enabled PM systems. 是第一个专为启用 eADR 的 PM 系统设计的持久索引 To achieve lock-free, NBTree uses atomic primitives to serialize leaf node operations. NBTree 使用原子操作来序列化叶节点操作 NBTree proposes four novel techniques to enable lock-free access to the leaf during struc- tural modification operations (SMO), including three-phase SMO, sync-on-write, sync-on-read, and cooperative SMO. For inner node operations, we develop a shift-aware search algorithm to resolve read-write conflicts. To reduce PM overhead, NBTree decouples the leaf nodes into a metadata layer and a key-value layer. The metadata layer is stored in DRAM, along with the inner nodes, to reduce PM accesses. NBTree also adopts log-structured insert and in-place update/delete to improve cache utilization. Our evaluation shows that NBTree achieves up to 11× higher throughput and 43× lower 99% tail latency than state-of-the-art persistent B+ -Trees 。。eADR 技术的出现为构建无锁数据结构带来了独特的机会，释放了 PM 的全部潜力。本文提出了 NBTree，一个无锁 PM 友好型 B+树，。NBTree 。为了实现无锁，。此外，NBTree 提出了四种新技术，在结构修改操作(SMO)期间使 Leaf 无锁访问，包括三阶段 SMO、写时同步、读时同步和协作 SMO。对于内部节点操作，我们开发了一种具有移位感知的搜索算法来解决读写冲突。为了减少 PM 开销，NBTree 将叶节点分为元数据层和键值层。元数据层与内部节点一起存储在 DRAM 中，以减少对 PM 的访问。NBTree 还采用了基于日志的插入和原地更新/删除来提高缓存利用率。评估结果表明， NBTree 的吞吐量比最先进的持久性 B +树高 11 倍，并且 99%的尾延迟比最先进的持久性 B+树低 43 倍。 这篇文章介绍了一种新的持久化索引结构——NBTree，它是一种基于 B+树的锁无关、PM 友好的数据结构，旨在充分发挥 eADR 技术的性能和持久化优势。通过使用原子操作来串行化叶节点操作，NBTree 实现了锁无关。此外，该文章还提出了四种新技术，包括三阶段 SMO、写同步、读同步和协同 SMO，以实现锁无关的访问叶节点。对于内部节点操作，NBTree 开发了一种基于移位的搜索算法来解决读写冲突。为了降低 PM 开销，NBTree 将叶节点分离为元数据层和键值层，其中元数据层存储在 DRAM 中，以降低 PM 访问次数。NBTree 还采用基于日志的插入和原地更新/删除来提高缓存利用率。实验表明，NBTree 在 YCSB 工作负载下的吞吐量可以达到比现有持久化 B+树高 11 倍，99%尾延迟低 43 倍。最后，该文章还介绍了持久性内存和 eADR 技术的优劣点以及现有持久化索引结构的常见问题。 ","date":"0001-01-01","objectID":"/p1187-zhang/:0:0","tags":["Persistent","Memory","tag2"],"title":"NBTree: a Lock-free PM-friendly Persistent B+-Tree for eADR-enabled PM Systems","uri":"/p1187-zhang/"},{"categories":null,"content":" Table of Contents 1 INTRODUCTION 本文为摘录(或转载)，侵删，原文为： attachments/pdf/4/p1924-bhattacharya.pdf FPR: Fault Positive Rate Partitioned Bloom Filter , 方法 将 BloomFilter 划分成 segments 每个 segment 使用简单的、基于投影的哈希函数， 函数通过数据计算得来 效果 减少误报 （两个数量级） 相同误报率的话，提升 50% 的压缩率 ","date":"0001-01-01","objectID":"/p1924-bhattacharya/:0:0","tags":["LearnedBloomFilter","PartitionedBloomFilter","FPR"],"title":"New Wine in an Old Bottle: Data-Aware Hash Functions for Bloom Filter","uri":"/p1924-bhattacharya/"},{"categories":null,"content":"1 INTRODUCTION Projection Hash Bloom Filter (PHBF) ","date":"0001-01-01","objectID":"/p1924-bhattacharya/:1:0","tags":["LearnedBloomFilter","PartitionedBloomFilter","FPR"],"title":"New Wine in an Old Bottle: Data-Aware Hash Functions for Bloom Filter","uri":"/p1924-bhattacharya/"},{"categories":null,"content":" Table of Contents 1 Introduction 2 DESIGN OVERVIEW 2.1 Goals 2.2 Criteria of Design 3 架构图 3.1 Application Layer 3.2 Proxy Layer 3.3 Data Service Layer 3.4 Zones 3.5 表 3.6 Node 3.7 SQL Engine 3.8 Multi-tenancy 3.9 Resource Isolation. 3.10 Features 4 STORAGE ENGINE 4.1 LSM Tree-Based Architecture 4.2 Asymmetric Read and Write 4.3 Daily Incremental Major Compaction 4.4 Replica Type 5 TRANSACTION PROCESSING ENGINE 5.1 Partition and Paxos Group 5.2 Timestamp Service 5.3 Transaction Processing 5.4 Isolation Level 5.5 Replicated Table 6 TPC-C BENCHMARK TEST 7 LESSONS IN BUILDING OCEANBASE 7.1 From NoSQL to NewSQL 7.2 Both cost and performance 7.3 Data validation 7.4 Partitioning vs. sharding 本文为摘录(或转载)，侵删，原文为： attachments/pdf/d/p3385-xu.pdf ","date":"0001-01-01","objectID":"/p3385-xu/:0:0","tags":["database","oceanbase","tpmc"],"title":"OceanBase 707M tpmC","uri":"/p3385-xu/"},{"categories":null,"content":"1 Introduction ","date":"0001-01-01","objectID":"/p3385-xu/:1:0","tags":["database","oceanbase","tpmc"],"title":"OceanBase 707M tpmC","uri":"/p3385-xu/"},{"categories":null,"content":"2 DESIGN OVERVIEW ","date":"0001-01-01","objectID":"/p3385-xu/:2:0","tags":["database","oceanbase","tpmc"],"title":"OceanBase 707M tpmC","uri":"/p3385-xu/"},{"categories":null,"content":"2.1 Goals Fast scale-out (scale-in) on commodity hardware to achieve high performance and low TCO. Cross-region deployment and fault tolerance. ","date":"0001-01-01","objectID":"/p3385-xu/:2:1","tags":["database","oceanbase","tpmc"],"title":"OceanBase 707M tpmC","uri":"/p3385-xu/"},{"categories":null,"content":"2.2 Criteria of Design ","date":"0001-01-01","objectID":"/p3385-xu/:2:2","tags":["database","oceanbase","tpmc"],"title":"OceanBase 707M tpmC","uri":"/p3385-xu/"},{"categories":null,"content":"3 架构图 Figure 1: OceanBase 架构图 ","date":"0001-01-01","objectID":"/p3385-xu/:3:0","tags":["database","oceanbase","tpmc"],"title":"OceanBase 707M tpmC","uri":"/p3385-xu/"},{"categories":null,"content":"3.1 Application Layer ","date":"0001-01-01","objectID":"/p3385-xu/:3:1","tags":["database","oceanbase","tpmc"],"title":"OceanBase 707M tpmC","uri":"/p3385-xu/"},{"categories":null,"content":"3.2 Proxy Layer ","date":"0001-01-01","objectID":"/p3385-xu/:3:2","tags":["database","oceanbase","tpmc"],"title":"OceanBase 707M tpmC","uri":"/p3385-xu/"},{"categories":null,"content":"3.3 Data Service Layer ","date":"0001-01-01","objectID":"/p3385-xu/:3:3","tags":["database","oceanbase","tpmc"],"title":"OceanBase 707M tpmC","uri":"/p3385-xu/"},{"categories":null,"content":"3.4 Zones Zones can be restricted to one region or spead over multiple regions. 事务通过 Paxos 在多个区域中复制 Transactions are replicated among the zones, using Paxos. ","date":"0001-01-01","objectID":"/p3385-xu/:3:4","tags":["database","oceanbase","tpmc"],"title":"OceanBase 707M tpmC","uri":"/p3385-xu/"},{"categories":null,"content":"3.5 表 由用户显式地进行分区，并作为数据分布和负载均衡的基本单元 每个分片在每个 zone 中都有一个副本 ","date":"0001-01-01","objectID":"/p3385-xu/:3:5","tags":["database","oceanbase","tpmc"],"title":"OceanBase 707M tpmC","uri":"/p3385-xu/"},{"categories":null,"content":"3.6 Node 每个 Node (OBServer) 与传统的 RDMS 相似。 从 SQL 生成执行计划 如果是 local plan ， 直接执行 否则， 通过两阶段提交协议来执行， 此时该节点作为 coordinator 当 Paxos 组中多数节点的 redo log 持久化后，才提交事务 ","date":"0001-01-01","objectID":"/p3385-xu/:3:6","tags":["database","oceanbase","tpmc"],"title":"OceanBase 707M tpmC","uri":"/p3385-xu/"},{"categories":null,"content":"3.7 SQL Engine 3.7.1 plan cache 收到请求后，仅进行简单的词法分析，然后在 plan cache 中匹配缓存的计划，找不到时候再去走完整的解析流程。 10x 提升。。。 ","date":"0001-01-01","objectID":"/p3385-xu/:3:7","tags":["database","oceanbase","tpmc"],"title":"OceanBase 707M tpmC","uri":"/p3385-xu/"},{"categories":null,"content":"3.8 Multi-tenancy 3.8.1 System Tenant 系统租户 系统内置，主要功能： 作为系统表的容器 – 系统表都存储在系统租户的空间内 。。。 。。。 3.8.2 Ordinary Tenant 普通髭胡 ","date":"0001-01-01","objectID":"/p3385-xu/:3:8","tags":["database","oceanbase","tpmc"],"title":"OceanBase 707M tpmC","uri":"/p3385-xu/"},{"categories":null,"content":"3.9 Resource Isolation. ","date":"0001-01-01","objectID":"/p3385-xu/:3:9","tags":["database","oceanbase","tpmc"],"title":"OceanBase 707M tpmC","uri":"/p3385-xu/"},{"categories":null,"content":"3.10 Features ","date":"0001-01-01","objectID":"/p3385-xu/:3:10","tags":["database","oceanbase","tpmc"],"title":"OceanBase 707M tpmC","uri":"/p3385-xu/"},{"categories":null,"content":"4 STORAGE ENGINE 基于 LSM-tree, 支持非对称数据块读写，日常增量 compaction, 和不同的副本类型。 Figure 3: OB 的存储引擎 ","date":"0001-01-01","objectID":"/p3385-xu/:4:0","tags":["database","oceanbase","tpmc"],"title":"OceanBase 707M tpmC","uri":"/p3385-xu/"},{"categories":null,"content":"4.1 LSM Tree-Based Architecture 数据分成两部分： 静态基准数据 (static baseline data): 存储于 SSTable 中 动态增量数据 (dynamic incremental data) ： 存储于 MemTable 中 SSTable \u0026 MemTable SSTable 为只读数据，生成之后就不再发生更改 MemTable 支持读写操作，只存在内存中 DML 操作 MemTable MemTable 打到一定大小以后， dump 到磁盘，生成 SSTable 查询针对两种存储分别进行，然后进行合并后返回给客户端 针对 SSTable 实现了 Block 缓存和行缓存，以减少对基线数据的随机访问 Compaction Minor Compaction 内存中数据达到一定大小后，开始进行 minor compaction Minor Compaction 将 MemTable 转换成为 SSTable Major Compaction 由系统每天进行增量的 Major Compaction Major Compaction 将 SSTable 和当天发生的变化进行合并，形成新版本的基线 该设计导致每次查询需要读取基准数据和增量数据， OB 做了很多优化 缓存 （block 级与行级） BloomFilter: 用于进行 empty checks ","date":"0001-01-01","objectID":"/p3385-xu/:4:1","tags":["database","oceanbase","tpmc"],"title":"OceanBase 707M tpmC","uri":"/p3385-xu/"},{"categories":null,"content":"4.2 Asymmetric Read and Write OB 实现了非对称读写。 读： 基本单元为 microblock 4K 或者 8K 写： 基本单元为 macroblock 2MB macroblock 同时也是存储系统的分配和垃圾回收的基础单元 多个 microblock 组装成一个 macroblock 磁盘使用更高效 但造成了一定程度上的写放大 ","date":"0001-01-01","objectID":"/p3385-xu/:4:2","tags":["database","oceanbase","tpmc"],"title":"OceanBase 707M tpmC","uri":"/p3385-xu/"},{"categories":null,"content":"4.3 Daily Incremental Major Compaction 数据且分成 2MB 大小的 macroblock, Major Compaction 中： 数据有修改，则重写该 block 数据无修改，则在新的 baseline 中直接重用，无 IO 开销 因此 Compaction 开销比 LevelDB RockDB 更小 ","date":"0001-01-01","objectID":"/p3385-xu/:4:3","tags":["database","oceanbase","tpmc"],"title":"OceanBase 707M tpmC","uri":"/p3385-xu/"},{"categories":null,"content":"4.4 Replica Type 有多种类型的副本： full replica 完全副本，包含 基线数据 增量数据 redo log Data replica, 数据副本 包括基准数据和 relod log 根据需要从完全副本拷贝 minor compactions （compacted mutabtions） 重做完日志后，可以升级至完全副本 与完全副本相比，节省 CPU 和内存资源： 不必重做日志 没有 MemTable Log Replica 日志副本 仅包含 redo log 作为 Paxos 组的成员 部署两个完全副本和一个日志副本，则： 拥有高可用特性 存储和内存开销大大减少 ","date":"0001-01-01","objectID":"/p3385-xu/:4:4","tags":["database","oceanbase","tpmc"],"title":"OceanBase 707M tpmC","uri":"/p3385-xu/"},{"categories":null,"content":"5 TRANSACTION PROCESSING ENGINE ","date":"0001-01-01","objectID":"/p3385-xu/:5:0","tags":["database","oceanbase","tpmc"],"title":"OceanBase 707M tpmC","uri":"/p3385-xu/"},{"categories":null,"content":"5.1 Partition and Paxos Group Partition 分片是数据分布、负载均衡和 Paxos 同步的基础单元 每个分片一个 Paxos Group ","date":"0001-01-01","objectID":"/p3385-xu/:5:1","tags":["database","oceanbase","tpmc"],"title":"OceanBase 707M tpmC","uri":"/p3385-xu/"},{"categories":null,"content":"5.2 Timestamp Service 使用 timestamp Paxos group 来实现时间戳服务的高可用 timestamp paxos group 的 leader 与表分片的 paxos group leader 通常放在一个区域（region）中 ","date":"0001-01-01","objectID":"/p3385-xu/:5:2","tags":["database","oceanbase","tpmc"],"title":"OceanBase 707M tpmC","uri":"/p3385-xu/"},{"categories":null,"content":"5.3 Transaction Processing ","date":"0001-01-01","objectID":"/p3385-xu/:5:3","tags":["database","oceanbase","tpmc"],"title":"OceanBase 707M tpmC","uri":"/p3385-xu/"},{"categories":null,"content":"5.4 Isolation Level read committed: default isolation level 也支持 snapshot isolation ","date":"0001-01-01","objectID":"/p3385-xu/:5:4","tags":["database","oceanbase","tpmc"],"title":"OceanBase 707M tpmC","uri":"/p3385-xu/"},{"categories":null,"content":"5.5 Replicated Table synchronously replicated table 变更需要等所有节点完成 慢 asynchronously replicated table 等待 paxos group 中的多数完成即可 快，但不保证所有节点的数据都为最新 如果查询中某节点遇到了老版本的数据，需要访问远端副本 ","date":"0001-01-01","objectID":"/p3385-xu/:5:5","tags":["database","oceanbase","tpmc"],"title":"OceanBase 707M tpmC","uri":"/p3385-xu/"},{"categories":null,"content":"6 TPC-C BENCHMARK TEST ","date":"0001-01-01","objectID":"/p3385-xu/:6:0","tags":["database","oceanbase","tpmc"],"title":"OceanBase 707M tpmC","uri":"/p3385-xu/"},{"categories":null,"content":"7 LESSONS IN BUILDING OCEANBASE ","date":"0001-01-01","objectID":"/p3385-xu/:7:0","tags":["database","oceanbase","tpmc"],"title":"OceanBase 707M tpmC","uri":"/p3385-xu/"},{"categories":null,"content":"7.1 From NoSQL to NewSQL 应用层不应将数据库尊为一个 key-value 存储系统来用，也不应该倚赖某些数据的高级特性 存储过程对某些 OLTP 应用来说仍有很大的价值 对于使用分布式数据库的应用来说，每个事务、每个 SQL 都应该有超时机制：分布式系统的出错率更高一些（网络，节点等原因） ","date":"0001-01-01","objectID":"/p3385-xu/:7:1","tags":["database","oceanbase","tpmc"],"title":"OceanBase 707M tpmC","uri":"/p3385-xu/"},{"categories":null,"content":"7.2 Both cost and performance ","date":"0001-01-01","objectID":"/p3385-xu/:7:2","tags":["database","oceanbase","tpmc"],"title":"OceanBase 707M tpmC","uri":"/p3385-xu/"},{"categories":null,"content":"7.3 Data validation ","date":"0001-01-01","objectID":"/p3385-xu/:7:3","tags":["database","oceanbase","tpmc"],"title":"OceanBase 707M tpmC","uri":"/p3385-xu/"},{"categories":null,"content":"7.4 Partitioning vs. sharding ","date":"0001-01-01","objectID":"/p3385-xu/:7:4","tags":["database","oceanbase","tpmc"],"title":"OceanBase 707M tpmC","uri":"/p3385-xu/"},{"categories":null,"content":" Table of Contents 1 ABSTRACT 2 INTRODUCTION 3 PIPELINE OVERVIEW 3.1 notation 3.2 better cache utilization, 3.3 4 Phases 本文为摘录(或转载)，侵删，原文为： attachments/pdf/c/p259-arman.pdf ","date":"0001-01-01","objectID":"/p259-arman/:0:0","tags":["algrithm","sort"],"title":"Origami: A High-Performance Mergesort Framework","uri":"/p259-arman/"},{"categories":null,"content":"1 ABSTRACT Mergesort 优点： 不受数据倾斜影响 适于通过向量化执行来进行并行处理 适于多线程操作操作 Origami: 内存归并排序算法框架 对每个向量化指令集，提供寄存器内排序算子 （in-register sorter），小数据量性能提供 8 倍 branchless streaming merge 1.5 倍提升 ","date":"0001-01-01","objectID":"/p259-arman/:1:0","tags":["algrithm","sort"],"title":"Origami: A High-Performance Mergesort Framework","uri":"/p259-arman/"},{"categories":null,"content":"2 INTRODUCTION MergeSort 的优点： 对数据分布不敏感 (distribution insensitivity): constant time on all inputs 支持流式操作 (streaming operation) ， 适用于外存数据，或者分布式数据 适用于多核并行计算 ","date":"0001-01-01","objectID":"/p259-arman/:2:0","tags":["algrithm","sort"],"title":"Origami: A High-Performance Mergesort Framework","uri":"/p259-arman/"},{"categories":null,"content":"3 PIPELINE OVERVIEW ","date":"0001-01-01","objectID":"/p259-arman/:3:0","tags":["algrithm","sort"],"title":"Origami: A High-Performance Mergesort Framework","uri":"/p259-arman/"},{"categories":null,"content":"3.1 notation N ： 待排序的元素数量 C ： 能够装进 L2 Cache 的数量 （约 2^16 ~ 2^18 ） T ： 线程数量，常为 CPU 核数的二倍 W ： 每个 SIMD 寄存器可以装下的元素数量 （约 4 ~ 16 ） R ： 每个 CPU 核上 SIMD 寄存器的个数 （通常 16 or 32 ） B ： 每个元素的 bits 数 （ 32, 64, or 128 ） ","date":"0001-01-01","objectID":"/p259-arman/:3:1","tags":["algrithm","sort"],"title":"Origami: A High-Performance Mergesort Framework","uri":"/p259-arman/"},{"categories":null,"content":"3.2 better cache utilization, L2 Cache 为更好的利用 CPU Cache ， 通常将输入划分成大小为 C 的块 （block） ，然后在 Cache 对其排序， 从而生成 N/C 个有序列表。 然后使用 k 路合并 （ k\u003e=2 ） ，生成最终的有序列表 ","date":"0001-01-01","objectID":"/p259-arman/:3:2","tags":["algrithm","sort"],"title":"Origami: A High-Performance Mergesort Framework","uri":"/p259-arman/"},{"categories":null,"content":"3.3 4 Phases MergeSort 可以分解为四个阶段，标记为 P_1 ~ P_4 3.3.1 (P1) Tiny sorters 将整个输入转换成有序的子列的过程 子列长度为 m ， ( m\u003e=2= ): 子列内容为 [im, (i+1)m) i = 10,1,...,C/m-1 MergeSort 对 P1 阶段效率不高 （长度小于 128 时） 可使用其他排序算法 insert sort SIMD generalizations 3.3.2 (P2) In-cache merge P1 结束后，每个子队列都是有序的 P2 由 \\(log_2(C/m)\\) 个二元合并 (binary merge) 构成 3.3.3 (P3) Out-of-cache independent merge ","date":"0001-01-01","objectID":"/p259-arman/:3:3","tags":["algrithm","sort"],"title":"Origami: A High-Performance Mergesort Framework","uri":"/p259-arman/"},{"categories":null,"content":" Table of Contents 1 INTRODUCTION 2 NETWORK PROCESSING IN THE LINUX KERNEL 2.1 Kernel Accounting 2.2 Packet Transmission 发送 2.3 Packet Reception 接收 2.4 Incorrect SoftIRQ Accounting 3 TESTBED AND KERNEL CONFIGURATION 4 UDP TRANSMISSION 5 TCP TRANSMISSION 6 TCP TRANSMISSION WITH ZERO-COPY 7 THE HARDWARE OFFLOAD FUNCTIONALITIES OF THE NETWORK ADAPTER 8 FIBRE CHANNEL TO 10 GIGABIT ETHERNET TESTS 9 CONCLUSIONS 本文为摘录(或转载)，侵删，原文为： attachments/pdf/3/performanceOf10GbE.pdf ","date":"0001-01-01","objectID":"/performanceof10gbe/:0:0","tags":["ethernet","performance","nic"],"title":"Performance of 10 G Ethernet Using Commodity Hardware","uri":"/performanceof10gbe/"},{"categories":null,"content":"1 INTRODUCTION With the introduction of 10-GbE, network I/O re-entered the “fast network, slow host” scenario that occurred with both the transitions to Fast Ethernet and Gigabit Ethernet. Specifically, three major system bottlenecks may limit the efficiency of high-performance I/O adapters: PCI-X 总线带宽 PCI-X 频率 133MHz ，带宽 8.5Gb/s 已被 PCI-Express (PCIe) 替代： 8 通道 20 Gb/s CPU 利用率 内存带宽 ","date":"0001-01-01","objectID":"/performanceof10gbe/:1:0","tags":["ethernet","performance","nic"],"title":"Performance of 10 G Ethernet Using Commodity Hardware","uri":"/performanceof10gbe/"},{"categories":null,"content":"2 NETWORK PROCESSING IN THE LINUX KERNEL ","date":"0001-01-01","objectID":"/performanceof10gbe/:2:0","tags":["ethernet","performance","nic"],"title":"Performance of 10 G Ethernet Using Commodity Hardware","uri":"/performanceof10gbe/"},{"categories":null,"content":"2.1 Kernel Accounting User 程序运行在用户态的时间 System 程序运行在内核态的时间 IRQ CPU 处理硬件中断的时间 SoftIRQ CPU 处理软中断的时间 ","date":"0001-01-01","objectID":"/performanceof10gbe/:2:1","tags":["ethernet","performance","nic"],"title":"Performance of 10 G Ethernet Using Commodity Hardware","uri":"/performanceof10gbe/"},{"categories":null,"content":"2.2 Packet Transmission 发送 发送队列 每个网卡驱动维持一个数据包的发送队列 内核根据 qdisc (queue discipline) 将数据包插入到队列中 默认的 qdisc 为 pfifo_fast (paccket FIO) Linux 支持其他的策略, 如 RED (Radom Early Drop) CBQ (Class Based Queuing) Others link layer triggered by function dev_queue_xmit(), 该函数负责： 将数据包根据 qdisc 插入到发送队列中 从发送队列中取出待发送的包，调用驱动的发送函数 hard_start_xmit() 来发送 如果因为某些原因 （如设备没有资源了），它会安排 SoftIRQ ， 然后晚些通过软中断再次发送 设备驱动 设备驱动负责将数据从 tx_ring 中转移到网卡的缓冲区中 该操作通过设置 DMA 映射，然后设置硬件上的特定寄存器来完成 驱动无需等待发送完成： 发送完成之后硬件发出硬中断 DMAdone 内核收到中断后安排 SoftIRQ 来释放 packet 使用的内存 释放内存操作耗时相对较长，不适合在硬中断中完成 ","date":"0001-01-01","objectID":"/performanceof10gbe/:2:2","tags":["ethernet","performance","nic"],"title":"Performance of 10 G Ethernet Using Commodity Hardware","uri":"/performanceof10gbe/"},{"categories":null,"content":"2.3 Packet Reception 接收 接收从 NIC 开始。 NIC 接收到一对 Ethernet frames Frames 存储在 rx_ring 内核 reserved 空间中 环形缓冲区 网卡将接收到的数据放到 DMA 后，将中断信号发送给指定的 IRQ line 中断控制器负责中断指定的处理器 ","date":"0001-01-01","objectID":"/performanceof10gbe/:2:3","tags":["ethernet","performance","nic"],"title":"Performance of 10 G Ethernet Using Commodity Hardware","uri":"/performanceof10gbe/"},{"categories":null,"content":"2.4 Incorrect SoftIRQ Accounting ","date":"0001-01-01","objectID":"/performanceof10gbe/:2:4","tags":["ethernet","performance","nic"],"title":"Performance of 10 G Ethernet Using Commodity Hardware","uri":"/performanceof10gbe/"},{"categories":null,"content":"3 TESTBED AND KERNEL CONFIGURATION 测试机配置和网络拓扑： 内核参数： net.core.rmem_max ， net.core.wmem_max 接收端和发送端 socket buffer size net.ipv4.tcp_rmem ， net.ipv4.tcp_wmem 接收端和发送端 tcp buffer size (min, default, max) net.core.netdev_max_backlog 控制软中断函数 net_rx_action() 每次处理的数据包的个数 ","date":"0001-01-01","objectID":"/performanceof10gbe/:3:0","tags":["ethernet","performance","nic"],"title":"Performance of 10 G Ethernet Using Commodity Hardware","uri":"/performanceof10gbe/"},{"categories":null,"content":"4 UDP TRANSMISSION 两个发送进程，MTU 9K 时候性能最好 MTU 9K 时候， packet size 8K 以上可以跑满 ","date":"0001-01-01","objectID":"/performanceof10gbe/:4:0","tags":["ethernet","performance","nic"],"title":"Performance of 10 G Ethernet Using Commodity Hardware","uri":"/performanceof10gbe/"},{"categories":null,"content":"5 TCP TRANSMISSION shows the data transfer rate, measured as a function of the TCP send size. For a MTU of 1500 B, the maximum throughput achieved was around 5.5 Gb/s, reached at the max- imum tested send size of 64 KiB. The throughput decreased as decreased the send size, with a change in the slope at 1500 B. The adoption of the 9000 B MTU with TCP improved the throughput up to 7 Gb/s. ","date":"0001-01-01","objectID":"/performanceof10gbe/:5:0","tags":["ethernet","performance","nic"],"title":"Performance of 10 G Ethernet Using Commodity Hardware","uri":"/performanceof10gbe/"},{"categories":null,"content":"6 TCP TRANSMISSION WITH ZERO-COPY sendfile() 来省略在内核态与用户态之间的数据拷贝 5.5 Gb/s -\u003e 8Gb/s ","date":"0001-01-01","objectID":"/performanceof10gbe/:6:0","tags":["ethernet","performance","nic"],"title":"Performance of 10 G Ethernet Using Commodity Hardware","uri":"/performanceof10gbe/"},{"categories":null,"content":"7 THE HARDWARE OFFLOAD FUNCTIONALITIES OF THE NETWORK ADAPTER offload function: 内核可以将高负载的任务交给硬件去做。 TCP Segmentation Offload, TSO 工作在发送端 当 TCP 的数据包大小超过 MTU 时候，必须进行分片操作 不支持 TSO 的硬件，必须由内核在 TPC 层完成 支持 TSO 的硬件，则可将最大 64K 的数据一次性交给网卡，由网卡来完成分片 Large Receive Offload， LRO 工作在接收端 在 NIC 层将多个 TCP packets 重组成更大的数据包 Scatter-Gather (SG) I/O 可以将不连续的内存地址通过 DMA 映射，减少内存拷贝 Checksum Offload, CO TCP 包的 checksum 计算 这些 offload 的效果: 吞吐量结果： CPU 负载： ","date":"0001-01-01","objectID":"/performanceof10gbe/:7:0","tags":["ethernet","performance","nic"],"title":"Performance of 10 G Ethernet Using Commodity Hardware","uri":"/performanceof10gbe/"},{"categories":null,"content":"8 FIBRE CHANNEL TO 10 GIGABIT ETHERNET TESTS ","date":"0001-01-01","objectID":"/performanceof10gbe/:8:0","tags":["ethernet","performance","nic"],"title":"Performance of 10 G Ethernet Using Commodity Hardware","uri":"/performanceof10gbe/"},{"categories":null,"content":"9 CONCLUSIONS MTU matters Offload matters… ","date":"0001-01-01","objectID":"/performanceof10gbe/:9:0","tags":["ethernet","performance","nic"],"title":"Performance of 10 G Ethernet Using Commodity Hardware","uri":"/performanceof10gbe/"},{"categories":null,"content":" Table of Contents 1 #9: Optimizations past their prime 1.1 Best practices 1.2 #21: Improving the efficiency of your regular expressions 本文为摘录(或转载)，侵删，原文为： https://abseil.io/fast ","date":"0001-01-01","objectID":"/perf-tip-of-week/:0:0","tags":null,"title":"Performance Tip of the Week","uri":"/perf-tip-of-week/"},{"categories":null,"content":"1 #9: Optimizations past their prime ","date":"0001-01-01","objectID":"/perf-tip-of-week/:1:0","tags":null,"title":"Performance Tip of the Week","uri":"/perf-tip-of-week/"},{"categories":null,"content":"1.1 Best practices – 可能的情况下编写清晰、惯用的代码 Prefer writing clear, idiomatic code whenever possible. It is not only easier to read and debug, but in the long run, also easier for the compiler to optimize. 这不仅易于阅读和调试，而且从长远来看，也更容易让编译器进行优化。 – 倾向使用编译器提供的函数： Whenever you find a low-level performance optimization that requires fancy bit-twiddling, intrinsics code, or inline assembly, consider first whether this is something the compiler could do. 当你发现需要使用复杂的位运算、内嵌代码或内联汇编来进行底层性能优化时，请首先考虑这是否是编译器可以完成的工作。 – If the code is hot, and the optimization is not something the compiler can be taught to perform, then: prefer portable code, possibly using hwy to generate efficient and portable vector code, failing that use intrinsics, failing that use inline asm (this should be extremely rare). Avoiding inline assembly makes the code more portable across microarchitectures. 如果代码运行频繁，并且优化不是编译器可以完成的工作， 有多种可选择的实现时，考虑下面的顺序： 请优先使用可移植的代码，（可能使用 hwy 生成高效且可移植的向量代码） 如果不行则使用编译器内部函数 (intrinsics) ， 最后使用内联汇编（这应该是极为罕见的情况）。 避免使用内联汇编可使代码在微体系结构之间更易移植。 – Keep the “naive” code you are replacing. If you are optimizing ComputeFoo, consider keeping the simple implementation in a REFERENCE_ComputeFoo function. This: makes it easy to write a unit-test for the new implementation that ensures the two functions are equivalent; makes it easier to write a microbenchmark; and it makes it easier to revert to the reference code when (not if) the machine-dependent implementation outlives its usefulness. 保留你要替换的“朴素”代码。如果你正在优化 ComputeFoo，考虑将简单的实现保留在 REFERENCE_ComputeFoo 函数中。这使得编写单元测试来确保两个函数是等效的变得容易；它使编写微基准测试变得更容易；它也使得当（而不是如果）与机器相关的实现过时时，更容易恢复到参考代码。 – Include a microbenchmark with your change. 在你的更改中包含一个微基准测试。 – When designing or changing configuration knobs, ensure that the choices stay optimal over time. Frequently, overriding the default can lead to suboptimal behavior when the default changes by pinning things in a worse-than-out-of-the-box state. Designing the knobs in terms of the outcome rather than specific behavior aspects can make such overrides easier (or even possible) to evolve. 在设计或更改配置选项时，请确保选择始终保持最优状态。通常，覆盖默认设置可能会导致次优行为，因为将事物钉在比开箱即用更差的状态。将选项设计为以结果为基础而不是特定行为方面，可以使这些覆盖更易于演变甚至成为可能。 ","date":"0001-01-01","objectID":"/perf-tip-of-week/:1:1","tags":null,"title":"Performance Tip of the Week","uri":"/perf-tip-of-week/"},{"categories":null,"content":"1.2 #21: Improving the efficiency of your regular expressions 1.2.1 Using regular expressions: a representative sample 1.2.2 Writing more efficient code 1.2.3 Writing more efficient regular expressions ","date":"0001-01-01","objectID":"/perf-tip-of-week/:1:2","tags":null,"title":"Performance Tip of the Week","uri":"/perf-tip-of-week/"},{"categories":null,"content":" Table of Contents 1 Introduction 2 Why pgAudit 3 Usage Considerations 4 Settings 4.1 pgaudit.log 4.2 pgaudit.log_catalog 5 Session Audit Logging 6 Object Audit Logging 7 Format 本文为摘录(或转载)，侵删，原文为： https://github.com/pgaudit/pgaudit#readme ","date":"0001-01-01","objectID":"/pgaudit%23readme/:0:0","tags":null,"title":"pgaudit/pgaudit: PostgreSQL Audit Extension","uri":"/pgaudit%23readme/"},{"categories":null,"content":"1 Introduction PostgreSQL 审计扩展（pgAudit）通过标准的 PostgreSQL 日志记录功能提供详细的会话和/或对象审计日志。 pgAudit 的目标是为 PostgreSQL 用户提供生成审计日志的能力，以满足政府、金融或 ISO 认证机构的要求。 审计是对个人或组织账户进行官方检查的行为，通常由独立机构进行。pgAudit 收集的信息被称为审计轨迹或审计日志。本文档中使用审计日志一词。 ","date":"0001-01-01","objectID":"/pgaudit%23readme/:1:0","tags":null,"title":"pgaudit/pgaudit: PostgreSQL Audit Extension","uri":"/pgaudit%23readme/"},{"categories":null,"content":"2 Why pgAudit 标准日志记录工具可以通过设置 log_statement = all 提供基本的语句日志记录。这对于监控和其他用途是可以接受的，但不提供通常需要的详细级别的审计信息。仅仅列出对数据库执行的所有操作是不够的，还必须能够找到对审计员有兴趣的特定语句。标准日志记录工具显示用户请求的内容，而 pgAudit 则专注于数据库在满足请求时发生的详细信息。 例如，审计员可能想要验证某个特定的表是否在文档化的维护窗口内创建。这可能看起来对于 grep 来说是一个简单的任务，但如果你遇到以下模糊示例时呢： DO $$ BEGIN EXECUTE 'CREATE TABLE import' || 'ant_table (id INT)'; END $$; 标准日志记录将给出以下结果： LOG: statement: DO $$ BEGIN EXECUTE 'CREATE TABLE import' || 'ant_table (id INT)'; END $$; 看起来，要找到感兴趣的表可能需要对代码有一定的了解，特别是在动态创建表的情况下。这不是理想的，因为最好只需根据表名进行搜索。这就是 pgAudit 的用武之地。对于相同的输入，它将在日志中产生以下输出： AUDIT: SESSION,33,1,FUNCTION,DO,,,\"DO $$ BEGIN EXECUTE 'CREATE TABLE import' || 'ant_table (id INT)'; END $$;\" AUDIT: SESSION,33,2,DDL,CREATE TABLE,TABLE,public.important_table,CREATE TABLE important_table (id INT) 不仅记录了 DO 块，而且子语句 2 包含了 CREATE TABLE 的完整文本，其中包括语句类型、对象类型和完全限定名称，使搜索变得容易。 在记录 SELECT 和 DML 语句时，pgAudit 可以配置为为每个涉及到的关系记录单独的条目。不需要解析来查找所有涉及特定表的语句。事实上，目标是语句文本主要用于深度取证，对于审计来说不是必需的。 ","date":"0001-01-01","objectID":"/pgaudit%23readme/:2:0","tags":null,"title":"pgaudit/pgaudit: PostgreSQL Audit Extension","uri":"/pgaudit%23readme/"},{"categories":null,"content":"3 Usage Considerations 根据设置，pgAudit 可能会生成大量的日志记录。请务必仔细确定在您的环境中需要对哪些内容进行审计记录，以避免记录过多。 例如， 在 OLAP 环境中工作时，可能不明智对大型事实表的插入进行审计日志记录 :日志文件的大小很可能是插入数据的实际大小的几倍，因为日志文件以文本形式表示。由于日志通常与操作系统一起存储，这可能会导致磁盘空间迅速耗尽。在无法将审计日志限制在特定表上的情况下，请确保在测试时评估性能影响，并在日志卷上分配足够的空间。这对于 OLTP 环境也可能成立。即使插入的数量不多，审计日志的性能影响仍可能明显影响延迟。 为了限制对 SELECT 和 DML 语句进行审计日志记录的关系数量，可以考虑使用 对象审计日志 记录（参见对象审计）。对象审计日志记录允许选择要记录的关系，从而减少整体日志量。但是，当添加新的关系时，必须显式地将其添加到对象审计日志记录中。在这种情况下，可以考虑使用编程解决方案，其中指定的表被排除在日志记录之外，而其他表都被包括在内。 ","date":"0001-01-01","objectID":"/pgaudit%23readme/:3:0","tags":null,"title":"pgaudit/pgaudit: PostgreSQL Audit Extension","uri":"/pgaudit%23readme/"},{"categories":null,"content":"4 Settings Settings may be modified only by a superuser. Allowing normal users to change their settings would defeat the point of an audit log. 设置只能由超级用户修改。允许普通用户更改其设置将违背审计日志的目的。 可通过下面的方式进行设置： 在全局范围内指定（在 postgresql.conf 或使用 ALTER SYSTEM … SET）， 在数据库级别指定（使用 ALTER DATABASE … SET）， 在角色级别指定（使用 ALTER ROLE … SET）。 注意，设置不会通过普通角色继承来传递，并且 SET ROLE 不会更改用户的 pgAudit 设置。这是角色系统的限制，而不是 pgAudit 固有的。 pgAudit 扩展必须加载到 shared_preload_libraries 中 。否则，加载时会引发错误，并且不会进行审计日志记录。 此外，必须先调用 CREATE EXTENSION pgaudit ，然后再设置 pgaudit.log，以确保正确的 pgAudit 功能。该扩展安装了事件触发器，为 DDL 操作添加了额外的审计功能。pgAudit 在未安装该扩展的情况下可以工作，但 DDL 语句将不包含关于对象类型和名称的信息。 如果删除 pgaudit 扩展并需要重新创建，则必须首先取消设置 pgaudit.log，否则将引发错误。 ","date":"0001-01-01","objectID":"/pgaudit%23readme/:4:0","tags":null,"title":"pgaudit/pgaudit: PostgreSQL Audit Extension","uri":"/pgaudit%23readme/"},{"categories":null,"content":"4.1 pgaudit.log 指定会话审计日志记录哪些类别的语句。可能的取值有： READ：当源是关系或查询时，记录 SELECT 和 COPY。 WRITE：当目标是关系时，记录 INSERT、UPDATE、DELETE、TRUNCATE 和 COPY。 FUNCTION：记录函数调用和 DO 块。 ROLE：与角色和权限相关的语句：GRANT、REVOKE、CREATE/ALTER/DROP ROLE。 DDL：除了 ROLE 类别之外的所有 DDL。 MISC：其他命令，例如 DISCARD、FETCH、CHECKPOINT、VACUUM、SET。 MISC_SET：其他 SET 命令，例如 SET ROLE。 ALL：包括上述所有类别。 可以使用逗号分隔的列表提供多个类别，并且可以通过在类别前加上减号来排除某些类别（参见会话审计日志）。 默认值为无。 ","date":"0001-01-01","objectID":"/pgaudit%23readme/:4:1","tags":null,"title":"pgaudit/pgaudit: PostgreSQL Audit Extension","uri":"/pgaudit%23readme/"},{"categories":null,"content":"4.2 pgaudit.log_catalog ","date":"0001-01-01","objectID":"/pgaudit%23readme/:4:2","tags":null,"title":"pgaudit/pgaudit: PostgreSQL Audit Extension","uri":"/pgaudit%23readme/"},{"categories":null,"content":"5 Session Audit Logging Session audit logging provides detailed logs of all statements executed by a user in the backend. ","date":"0001-01-01","objectID":"/pgaudit%23readme/:5:0","tags":null,"title":"pgaudit/pgaudit: PostgreSQL Audit Extension","uri":"/pgaudit%23readme/"},{"categories":null,"content":"6 Object Audit Logging 对象审计日志记录影响特定关系的语句。仅支持 SELECT、INSERT、UPDATE 和 DELETE 命令。 TRUNCATE 不包括在对象审计日志中。 对象审计日志旨在作为 pgaudit.log = ‘read, write’的细粒度替代品。因此，同时使用它们可能是没有意义的，但一种可能的情况是使用会话日志来捕获每个语句，然后通过对象日志来获得有关特定关系的更多详细信息。 ","date":"0001-01-01","objectID":"/pgaudit%23readme/:6:0","tags":null,"title":"pgaudit/pgaudit: PostgreSQL Audit Extension","uri":"/pgaudit%23readme/"},{"categories":null,"content":"7 Format 审核记录会被写入到标准的日志记录工具，并以逗号分隔的格式包含以下列。如果日志记录条目的前缀部分被去除，则输出将符合 CSV 格式。 AUDIT_TYPE - 会话或者对象。 STATEMENT_ID - 该会话的唯一语句 ID。每个语句 ID 代表一个后端调用。即使某些语句没有被记录，语句 ID 也是连续的。当多个关系被记录时，可以存在多个语句 ID 的条目。 SUBSTATEMENT_ID - 主语句内每个子语句的连续 ID。例如，在查询中调用函数。即使某些子语句没有被记录，子语句 ID 也是连续的。当多个关系被记录时，可以存在多个子语句 ID 的条目。 CLASS - 例如，READ, ROLE (参见 pgaudit.log)。 COMMAND 例如，ALTER TABLE, SELECT。 OBJECT_TYPE - 表，索引，视图等。适用于 SELECT、DML 和大多数 DDL 语句。 OBJECT_NAME - 完全限定的对象名称（例如 public.account）。适用于 SELECT、DML 和大多数 DDL 语句。 STATEMENT - 在后端执行的语句。 PARAMETER - 如果设置了 pgaudit.log_parameter 字段，则该字段将包含带引号的 CSV 格式的语句参数，如果没有参数则为\u003cnone\u003e。否则，该字段为\u003cnot logged\u003e。 根据您的审核日志要求，使用 log_line_prefix 添加其他所需的字段。一个典型的日志行前缀可能是 '%m %u %d [%p]: ' ，它将提供每个审核日志的日期/时间、用户名、数据库名称和进程 ID。 ","date":"0001-01-01","objectID":"/pgaudit%23readme/:7:0","tags":null,"title":"pgaudit/pgaudit: PostgreSQL Audit Extension","uri":"/pgaudit%23readme/"},{"categories":null,"content":" Table of Contents 1 Abstract 2 INTRODUCTION 本文为摘录(或转载)，侵删，原文为： ../pdf/d/p1311-even.pdf ","date":"0001-01-01","objectID":"/prefix-filter-better-than-bloom/:0:0","tags":["runtime","filter"],"title":"Prefix Filter: Better Than Bloom","uri":"/prefix-filter-better-than-bloom/"},{"categories":null,"content":"1 Abstract ","date":"0001-01-01","objectID":"/prefix-filter-better-than-bloom/:1:0","tags":["runtime","filter"],"title":"Prefix Filter: Better Than Bloom","uri":"/prefix-filter-better-than-bloom/"},{"categories":null,"content":"2 INTRODUCTION What is a filter 属于近似查询 (approximate membership query), 用于判断独具是否在集合中。 如果输入在集合中，则必定输出 Yes 如果不在集合中，则输出 Yes 的概率不能多于 \\(\\Sigma\\) What are filters used for 与精确查询相比 更省资源， 与数据量无关，而与 Σ （误报率）有关 适于放在内存中，用于真正操作之前来过滤掉无效数据 比如 join ","date":"0001-01-01","objectID":"/prefix-filter-better-than-bloom/:2:0","tags":["runtime","filter"],"title":"Prefix Filter: Better Than Bloom","uri":"/prefix-filter-better-than-bloom/"},{"categories":null,"content":"Nothing to see here… Move along! ","date":"0001-01-01","objectID":"/projects/:0:0","tags":null,"title":"Projects","uri":"/projects/"},{"categories":null,"content":" Table of Contents 1 INTRODUCTION 本文为摘录(或转载)，侵删，原文为： attachments/pdf/0/p1658-zhao.pdf QueryFormer: learning-based query planer representation model with tree-structured Transformer architecture -integrate histograms from database into query plan encoding ","date":"0001-01-01","objectID":"/p1658-zhao/:0:0","tags":["optimization","machie-learning","QueryFormer"],"title":"QueryFormer: A Tree Transformer Model for Query Plan Representation","uri":"/p1658-zhao/"},{"categories":null,"content":"1 INTRODUCTION Physical Query Plan As DAG (Directed Acyclic Graph) Figure 1: Example query and query plan node 表示操作 edge 表示方向 子节点先执行，执行结果给父节点作为输入 Physical Query Plan 作为机器学习的输入，用以数据库优化 ","date":"0001-01-01","objectID":"/p1658-zhao/:1:0","tags":["optimization","machie-learning","QueryFormer"],"title":"QueryFormer: A Tree Transformer Model for Query Plan Representation","uri":"/p1658-zhao/"},{"categories":null,"content":" Table of Contents 1 ABSTRACT 本文为摘录(或转载)，侵删，原文为： attachments/pdf/6/p1024-deep.pdf ","date":"0001-01-01","objectID":"/p1024-deep/:0:0","tags":null,"title":"Ranked Enumeration of Join Queries with Projections","uri":"/p1024-deep/"},{"categories":null,"content":"1 ABSTRACT ","date":"0001-01-01","objectID":"/p1024-deep/:1:0","tags":null,"title":"Ranked Enumeration of Join Queries with Projections","uri":"/p1024-deep/"},{"categories":null,"content":" Table of Contents 1 TOOLS 1.1 top 1.2 ps 1.3 vmstat – Virtual Memory Statistics 1.4 sar – System Activity Repoter 1.5 perf 1.6 tubostat 1.7 iostat 1.8 irqbalance 1.9 ss – socket statistics 1.10 numastat 1.11 numad 本文为摘录(或转载)，侵删，原文为： attachments/pdf/c/red_hat_enterprise_linux-7-performance_tuning_guide-en-us.pdf ","date":"0001-01-01","objectID":"/red_hat_enterprise_linux-7-performance_tuning_guide-en-us/:0:0","tags":["OS","tune","performance","redhat"],"title":"Red Hat Enterprise Linux 7 Performance Tuning Guide","uri":"/red_hat_enterprise_linux-7-performance_tuning_guide-en-us/"},{"categories":null,"content":"1 TOOLS ","date":"0001-01-01","objectID":"/red_hat_enterprise_linux-7-performance_tuning_guide-en-us/:1:0","tags":["OS","tune","performance","redhat"],"title":"Red Hat Enterprise Linux 7 Performance Tuning Guide","uri":"/red_hat_enterprise_linux-7-performance_tuning_guide-en-us/"},{"categories":null,"content":"1.1 top ","date":"0001-01-01","objectID":"/red_hat_enterprise_linux-7-performance_tuning_guide-en-us/:1:1","tags":["OS","tune","performance","redhat"],"title":"Red Hat Enterprise Linux 7 Performance Tuning Guide","uri":"/red_hat_enterprise_linux-7-performance_tuning_guide-en-us/"},{"categories":null,"content":"1.2 ps ","date":"0001-01-01","objectID":"/red_hat_enterprise_linux-7-performance_tuning_guide-en-us/:1:2","tags":["OS","tune","performance","redhat"],"title":"Red Hat Enterprise Linux 7 Performance Tuning Guide","uri":"/red_hat_enterprise_linux-7-performance_tuning_guide-en-us/"},{"categories":null,"content":"1.3 vmstat – Virtual Memory Statistics ","date":"0001-01-01","objectID":"/red_hat_enterprise_linux-7-performance_tuning_guide-en-us/:1:3","tags":["OS","tune","performance","redhat"],"title":"Red Hat Enterprise Linux 7 Performance Tuning Guide","uri":"/red_hat_enterprise_linux-7-performance_tuning_guide-en-us/"},{"categories":null,"content":"1.4 sar – System Activity Repoter ","date":"0001-01-01","objectID":"/red_hat_enterprise_linux-7-performance_tuning_guide-en-us/:1:4","tags":["OS","tune","performance","redhat"],"title":"Red Hat Enterprise Linux 7 Performance Tuning Guide","uri":"/red_hat_enterprise_linux-7-performance_tuning_guide-en-us/"},{"categories":null,"content":"1.5 perf ","date":"0001-01-01","objectID":"/red_hat_enterprise_linux-7-performance_tuning_guide-en-us/:1:5","tags":["OS","tune","performance","redhat"],"title":"Red Hat Enterprise Linux 7 Performance Tuning Guide","uri":"/red_hat_enterprise_linux-7-performance_tuning_guide-en-us/"},{"categories":null,"content":"1.6 tubostat ","date":"0001-01-01","objectID":"/red_hat_enterprise_linux-7-performance_tuning_guide-en-us/:1:6","tags":["OS","tune","performance","redhat"],"title":"Red Hat Enterprise Linux 7 Performance Tuning Guide","uri":"/red_hat_enterprise_linux-7-performance_tuning_guide-en-us/"},{"categories":null,"content":"1.7 iostat ","date":"0001-01-01","objectID":"/red_hat_enterprise_linux-7-performance_tuning_guide-en-us/:1:7","tags":["OS","tune","performance","redhat"],"title":"Red Hat Enterprise Linux 7 Performance Tuning Guide","uri":"/red_hat_enterprise_linux-7-performance_tuning_guide-en-us/"},{"categories":null,"content":"1.8 irqbalance ","date":"0001-01-01","objectID":"/red_hat_enterprise_linux-7-performance_tuning_guide-en-us/:1:8","tags":["OS","tune","performance","redhat"],"title":"Red Hat Enterprise Linux 7 Performance Tuning Guide","uri":"/red_hat_enterprise_linux-7-performance_tuning_guide-en-us/"},{"categories":null,"content":"1.9 ss – socket statistics ","date":"0001-01-01","objectID":"/red_hat_enterprise_linux-7-performance_tuning_guide-en-us/:1:9","tags":["OS","tune","performance","redhat"],"title":"Red Hat Enterprise Linux 7 Performance Tuning Guide","uri":"/red_hat_enterprise_linux-7-performance_tuning_guide-en-us/"},{"categories":null,"content":"1.10 numastat ","date":"0001-01-01","objectID":"/red_hat_enterprise_linux-7-performance_tuning_guide-en-us/:1:10","tags":["OS","tune","performance","redhat"],"title":"Red Hat Enterprise Linux 7 Performance Tuning Guide","uri":"/red_hat_enterprise_linux-7-performance_tuning_guide-en-us/"},{"categories":null,"content":"1.11 numad ","date":"0001-01-01","objectID":"/red_hat_enterprise_linux-7-performance_tuning_guide-en-us/:1:11","tags":["OS","tune","performance","redhat"],"title":"Red Hat Enterprise Linux 7 Performance Tuning Guide","uri":"/red_hat_enterprise_linux-7-performance_tuning_guide-en-us/"},{"categories":null,"content":" Table of Contents 1 ABSTRACT 2 INTRODUCTION 本文为摘录(或转载)，侵删，原文为： attachments/pdf/5/p2161-zhang.pdf ","date":"0001-01-01","objectID":"/p2161-zhang/:0:0","tags":["LSM","Storage"],"title":"SA-LSM: Optimize Data Layout for LSM-tree Based Storage using Survial Analysis","uri":"/p2161-zhang/"},{"categories":null,"content":"1 ABSTRACT 云存储中很大一部分数据很少被访问，被称为 冷数据 。 精确地识别和有效地管理成本效益高的存储中的冷数据是云提供商面临的主要挑战之一，需要平衡降低成本和提高系统性能。 为此，提出了 SA-LSM 来利用生存分析（Survival Analysis）的方式来处理 LSM-tree 键值（KV）存储。 传统上，LSM-tree 的数据布局是由写操作和压实操作共同确定的。 然而，该过程默认情况下并未充分利用数据记录的访问信息，导致次优的数据布局，对系统性能产生负面影响。 SA-LMS 使用生存分析，一种在生物统计学中常用的统计学习算法来优化数据布局。 当与合适的 LSM-tree 实现结合使用时，SA-LSM 可以使用历史信息和访问痕迹准确预测冷数据。 具体实现方面，将 SA-LSM 应用于商业化开源 LSM-tree 存储引擎 X-Engine 中 了使部署更加灵活，还设计了一种非侵入式架构，可以将 CPU 密集型任务（例如模型训练和推断）卸载到外部服务上。 在真实工作负载上的广泛实验表明，与现有技术相比，SA-LSM 可以将尾延迟降低高达 78.9％。 这种方法的通用性和显著性能提升在相关应用中具有巨大潜力。 ","date":"0001-01-01","objectID":"/p2161-zhang/:1:0","tags":["LSM","Storage"],"title":"SA-LSM: Optimize Data Layout for LSM-tree Based Storage using Survial Analysis","uri":"/p2161-zhang/"},{"categories":null,"content":"2 INTRODUCTION 为了降低存储成本，LSM 树变成了一种越来越受欢迎的架构。它引入了多层异构存储: 上层被映射到快速存储，例如固态硬盘（SSD）， 下层则映射到慢速存储，例如硬盘驱动器（HDD）。 其中一个关键组件是压缩策略，它确定如何在不同的层之间动态分配和移动数据记录。 传统的 LSM-tree 数据布局通常是由写操作和压实操作共同决定的 其中背景压实操作定期将数据记录合并到持久存储上，以改善读写和空间放大。 默认情况下，这个过程并没有充分利用数据记录的访问信息，从而导致子优的数据布局，对系统性能产生负面影响。 当不同的 LSM 层面映射到异构存储上时，这种影响甚至更加明显。 因此，我们设计了基于生存分析的 SA-LSM 来增强压实策略，这是一种在生物统计学中常用的统计学习算法，可优化这一过程中的数据布局。 Figure 1: 几种 LSM tree 存储布局的延迟 ","date":"0001-01-01","objectID":"/p2161-zhang/:2:0","tags":["LSM","Storage"],"title":"SA-LSM: Optimize Data Layout for LSM-tree Based Storage using Survial Analysis","uri":"/p2161-zhang/"},{"categories":null,"content":" Table of Contents 1 RTFM… 1.1 ipcs 1.2 ipcrm 2 Check shared memory in Linux 本文为摘录(或转载)，侵删，原文为： https://linuxopsys.com/topics/check-shared-memory-in-linux ","date":"0001-01-01","objectID":"/shared-memory-utilities/:0:0","tags":["ipcs","ipcrm"],"title":"shared memory utilities","uri":"/shared-memory-utilities/"},{"categories":null,"content":"1 RTFM… ","date":"0001-01-01","objectID":"/shared-memory-utilities/:1:0","tags":["ipcs","ipcrm"],"title":"shared memory utilities","uri":"/shared-memory-utilities/"},{"categories":null,"content":"1.1 ipcs ","date":"0001-01-01","objectID":"/shared-memory-utilities/:1:1","tags":["ipcs","ipcrm"],"title":"shared memory utilities","uri":"/shared-memory-utilities/"},{"categories":null,"content":"1.2 ipcrm ","date":"0001-01-01","objectID":"/shared-memory-utilities/:1:2","tags":["ipcs","ipcrm"],"title":"shared memory utilities","uri":"/shared-memory-utilities/"},{"categories":null,"content":"2 Check shared memory in Linux Print active shared memory segments using -m option. # ipcs -m ------ Shared Memory Segments -------- key shmid owner perms bytes nattch status 0x00000000 65536 root 600 393216 2 dest 0x00000000 98305 root 600 393216 2 dest where, “dest” status means memory segment is marked to be destroyed “nattach” field shows how many application pid’s are still attached to the shared memory The following command print information about active shared memory segments: ","date":"0001-01-01","objectID":"/shared-memory-utilities/:2:0","tags":["ipcs","ipcrm"],"title":"shared memory utilities","uri":"/shared-memory-utilities/"},{"categories":null,"content":" Table of Contents 1 ABSTRACT 2 INTRODUCTION 2.1 Range Filters 3 SNARF: A LEARNED FILTER 3.1 SNARF Description 本文为摘录(或转载)，侵删，原文为： attachments/pdf/a/p1632-vaidya.pdf ","date":"0001-01-01","objectID":"/p1632-vaidya/:0:0","tags":["filter","range"],"title":"SNARF: A Learning-Enhanced Range Filter","uri":"/p1632-vaidya/"},{"categories":null,"content":"1 ABSTRACT SNARF: Sparse Numerical Array-Based Range Filters 基于稀疏数组的范围过滤器 用于数值类型的范围过滤 ","date":"0001-01-01","objectID":"/p1632-vaidya/:1:0","tags":["filter","range"],"title":"SNARF: A Learning-Enhanced Range Filter","uri":"/p1632-vaidya/"},{"categories":null,"content":"2 INTRODUCTION Filters are space efficient but appropriate Answer membership queries on a set S Point Filters eg BloomFilter Support point queries: “Is x in the set S ?” Range Filters (可用作范围过滤 where + 单表) for range query: “Is there a key in the set S in between values p \u0026 q?” 允许误报 ","date":"0001-01-01","objectID":"/p1632-vaidya/:2:0","tags":["filter","range"],"title":"SNARF: A Learning-Enhanced Range Filter","uri":"/p1632-vaidya/"},{"categories":null,"content":"2.1 Range Filters range filters can significantly improve the performance of systems for synthetic and real-world workloads e.g RocksDB, SQL Server Adaptive Range Filters for Cold Data: Avoiding Trips to Siberia （TBD） ","date":"0001-01-01","objectID":"/p1632-vaidya/:2:1","tags":["filter","range"],"title":"SNARF: A Learning-Enhanced Range Filter","uri":"/p1632-vaidya/"},{"categories":null,"content":"3 SNARF: A LEARNED FILTER ","date":"0001-01-01","objectID":"/p1632-vaidya/:3:0","tags":["filter","range"],"title":"SNARF: A Learning-Enhanced Range Filter","uri":"/p1632-vaidya/"},{"categories":null,"content":"3.1 SNARF Description 3.1.1 SNARF Construction: 给定一组 keys \\[S=\\{x_1, x_2, …,x_n\\}\\] , 构建一个可以进行范围查询的过滤器 SNARF 通过单调函数 \\[f\\] 将 keys 映射进一个 bit array B: B 中有 \\[|B| = K \\times n\\] 个比特 初始化时候，数组中所有元素均为 0 将 B 中的某些位置置位: \\[f(x_i) = 1\\] , 其中： \\[x_i \\in S\\] 隐射函数为： \\[f(x) = \\lfloor MCDF(x) \\times nK\\rfloor \\] MCDF 为 S 中 key 的 CDF 经验值的单调估计 SNARF 使用压缩：提升空间效率： 3.1.2 SNARF Range Query: ","date":"0001-01-01","objectID":"/p1632-vaidya/:3:1","tags":["filter","range"],"title":"SNARF: A Learning-Enhanced Range Filter","uri":"/p1632-vaidya/"},{"categories":null,"content":" Table of Contents 1 INTRODUCTION 2 ARCHITECTURE 2.1 Modules 本文为摘录(或转载)，侵删，原文为： attachments/pdf/2/p3535-gaffney.pdf ","date":"0001-01-01","objectID":"/p3535-gaffney/:0:0","tags":["sqlite"],"title":"SQLite: Past, Present, and Future","uri":"/p3535-gaffney/"},{"categories":null,"content":"1 INTRODUCTION SQLite is embedded in the process of the host application Instead of communicating with a database server across process boundaries, applications manage a SQLite database by calling SQLite library functions several characteristics combine to make SQLite useful in a broad range of scenario: Cross-platform 数据库保存在单一文件中，文件可以随意拷贝，兼容： 32位/64位 大端，小端架构 SQLite 可以运行在很多类型的机器上 Compact and self-contained sqlite 库可以从一个单一 C 文件编译 库很小 \u003c 570KiB 倚赖很少 无需额外安装和配置 Reliable 每一行 SQLite 的代码，有超过 600 行的测试代码 测试涵盖了所有分支 Fast ","date":"0001-01-01","objectID":"/p3535-gaffney/:1:0","tags":["sqlite"],"title":"SQLite: Past, Present, and Future","uri":"/p3535-gaffney/"},{"categories":null,"content":"2 ARCHITECTURE ","date":"0001-01-01","objectID":"/p3535-gaffney/:2:0","tags":["sqlite"],"title":"SQLite: Past, Present, and Future","uri":"/p3535-gaffney/"},{"categories":null,"content":"2.1 Modules 如下图 所示， SQLite 采用模块化设计，模块可以分成 4 组。 2.1.1 SQL compiler modules 负责将 SQL 表达式转换成位可以被虚拟机执行的二进制代码 神奇的思路， 类似汇编代码。。。 2.1.2 Core modules 负责接收和执行 SQL 执行引擎可视为虚拟机， 又称 Virtual Database Engine, VDBE VDBE 执行 Compiler 模块生成的二进制程序 ","date":"0001-01-01","objectID":"/p3535-gaffney/:2:1","tags":["sqlite"],"title":"SQLite: Past, Present, and Future","uri":"/p3535-gaffney/"},{"categories":null,"content":" Table of Contents 1 Referencing local array 2 The cost of copying elements 本文为摘录(或转载)，侵删，原文为： https://www.cppstories.com/2023/initializer_list_improvements/ ","date":"0001-01-01","objectID":"/stdinitializer_list_caveats_and_improvements/:0:0","tags":["cpp","tag2"],"title":"std::initializer_list in C++","uri":"/stdinitializer_list_caveats_and_improvements/"},{"categories":null,"content":"1 Referencing local array std::initializer_list 在使用中会转化成为常量对象的匿名局部数组： std::initializer_list\u003cint\u003e wrong() { // for illustration only! return { 1, 2, 3, 4}; } int main() { std::initializer_list\u003cint\u003e x = wrong(); } The above code is equivalent to the following: std::initializer_list\u003cint\u003e wrong() { const int arr[] { 1, 2, 3, 4} return std::initializer_list\u003cint\u003e{arr, arr+4}; } int main() { std::initializer_list\u003cint\u003e x = wrong(); } 如果尝试编译的话，会出错： GCC: warning: returning temporary 'initializer_list' does not extend the lifetime of the underlying array [-Winit-list-lifetime] 5 | return { 1, 2, 3, 4}; Or in Clang: \u003csource\u003e:5:12: warning: returning address of local temporary object [-Wreturn-stack-address] return { 1, 2, 3, 4}; 结论： std::initializer_list 是一种 “view” type 他引用一个局部的常量数组 it references some implementation-dependent and a local array of const values. Use it mainly for passing into functions when you need a variable number of arguments of the same type. If you try to return such lists and pass them around, then you risk lifetime issues ","date":"0001-01-01","objectID":"/stdinitializer_list_caveats_and_improvements/:1:0","tags":["cpp","tag2"],"title":"std::initializer_list in C++","uri":"/stdinitializer_list_caveats_and_improvements/"},{"categories":null,"content":"2 The cost of copying elements 通过初始化列表来传递参数很方便，但最好知道，当向 vector 中传递对象时候，vector 中的每个元素都会进行一次拷贝构造，应该了解其代价。 ","date":"0001-01-01","objectID":"/stdinitializer_list_caveats_and_improvements/:2:0","tags":["cpp","tag2"],"title":"std::initializer_list in C++","uri":"/stdinitializer_list_caveats_and_improvements/"},{"categories":null,"content":" Table of Contents 1 SCTP Associations 2 Using Multiple Interfaces 3 Streams 4 Association ID 5 Rec \u0026 Send 6 CDB with SCTP? 7 SCTP Interface Model 7.1 two types of SCTP sockets 7.2 The One-to-One Style 7.3 The One-to-Many Style 本文为摘录(或转载)，侵删，原文为： https://www.linuxjournal.com/article/9749 ","date":"0001-01-01","objectID":"/sctp/:0:0","tags":["network","protocol","sctp"],"title":"Stream Control Transmission Protocol (SCTP)","uri":"/sctp/"},{"categories":null,"content":"1 SCTP Associations SCTP 的联合 (association) 类似于 TCP 的连接 (connection) ， 但又有不同： TCP connection 在服务端和客户端之间的网络接口上建立的 一对一 连接 SCTP association 是 多对多 ： 可以在服务端的多个网口和客户端的多个网口之间建立联合 例如，服务端和客户端各自有两个设备： Ethernet \u0026 Wi-Fi , 则服务端和客户端之间的联合可以包括 4 路： Eth -\u003e Eth Eth -\u003e Wi-Fi Wi-Fi -\u003e Eth Wi-Fi -\u003e Wi-Fi 一个联合中又可以有多个 stream ， 各个 stream 之间互不干扰，不会阻塞 stream 用 stream id 来区分，从 0 开始增加 每个 socket 可以用来服务多个联合 也就是说，每个 scoket 可以用来同多个主机通讯。 每个 association 用 association id 来区分。 ","date":"0001-01-01","objectID":"/sctp/:1:0","tags":["network","protocol","sctp"],"title":"Stream Control Transmission Protocol (SCTP)","uri":"/sctp/"},{"categories":null,"content":"2 Using Multiple Interfaces 服务端可以通过 sctp_bindx() 来绑定多个接口 客户端可以通过 sctp_connectx() 来使用多个地址 客户端可以通过 sctp_getpaddrs() 来获取远端地址 客户端可以通过 sctp_getladdrs() 来获取本地地址 Once an association is set up between two endpoints, messages can be sent between them. Note that SCTP does not concern itself with QoS (Quality-of-Service) issues, such as real-time delivery, but only with reliability issues. SCTP uses the multihomed capabilities to try as many possible routes as possible to get messages through. So on the sending side, there is no control over which interfaces are used; indeed, the sender might even use a scheme such as round-robin among its interfaces for each message. However, the sending application can indicate to its SCTP stack which of the remote peer’s interface it would prefer to use, and it can tell the remote peer on which interfaces it would prefer to receive messages. These are done by using the setsockopt() call with option type as SCTP_PRIMARY_ADDR or SCTP_SET_PEER_PRIMARY_ADDR. Of course, if these particular addresses are not available, SCTP simply will use different addresses in the association. Once SCTP is told which interfaces to use, it basically looks after things itself. It uses heartbeats to keep track of which interfaces are alive, and it switches interfaces transparently when failure occurs. This is to satisfy the design goals of SCTP for improved reliability over TCP. Applications can give hints to the SCTP stack about which interfaces to use, but the stack will ignore these hints on failure. ","date":"0001-01-01","objectID":"/sctp/:2:0","tags":["network","protocol","sctp"],"title":"Stream Control Transmission Protocol (SCTP)","uri":"/sctp/"},{"categories":null,"content":"3 Streams Negotiating the Number of Streams Each endpoint of an association will support a certain number of streams. A Linux endpoint, by default, will expect to be able to send to ten streams, while it can receive on 65,535 streams. Other SCTP stacks may have different default values. These values can be changed by setting the socket option SCTP_INITMSG, which takes a structure sctp_initmsg: struct sctp_initmsg { uint16_t sinit_num_ostreams; uint16_t sinit_max_ostreams; uint16_t sinit_max_attempts; uint16_t sinit_max_init_timeo; } If this socket option is used to set values, it must be done before an association is made. The parameters will be sent to the peer endpoint during association initialisation. ","date":"0001-01-01","objectID":"/sctp/:3:0","tags":["network","protocol","sctp"],"title":"Stream Control Transmission Protocol (SCTP)","uri":"/sctp/"},{"categories":null,"content":"4 Association ID There can be many associations active at any one time—a peer can be connected to many other peers simultaneously. This is different from TCP where only one connection on a socket can exist and also is different from UDP where no connections exist and messages are just sent to arbitrary peers. When there can be many associations, you need to be able to distinguish between them. This is done by an opaque data type called an association ID. You need to use this sometimes, but not every time. one-to-one sockets: 仅用一个联合， Association ID 可以忽略 created a one-to-one socket: sockfd = socket(AF_INET, SOCK_STREAM, IPPROTO_SCTP) one-to-many sockets: 当可以通过目的端地址来标识 Association 时， ID 可以忽略 其余时候需要使用 ID create one-to-many socket: sockfd = socket(AF_INET, SOCK_SEQPACKET, IPPROTO_SCTP) ID 的获取： sctp_assoc_t get_associd(int sockfd, struct sockaddr *sa, socklen_t salen) { struct sctp_paddrinfo sp; int sz; sz = sizeof(struct sctp_paddrinfo); bzero(\u0026sp, sz); memcpy(\u0026sp.spinfo_address, sa, salen); if (sctp_opt_info(sockfd, 0, SCTP_GET_PEER_ADDR_INFO, \u0026sp, \u0026sz) == -1) perror(\"get assoc\"); return (sp.spinfo_assoc_id); } There is no way to specify from which stream to read. This is deliberate; the intention is that when data is ready on any stream, then you read it. Otherwise, data could be blocked on a stream with no one to read it, which eventually could fill up system buffers. So, you can’t restrict reading to any particular stream. But, once a read is done, you can tell which stream it has come from by using the mechanism above. Typically, a server that reads and handles a message will have (pseudocode) that looks like this: while (true) { nread = sctp_recvmsg(..., msg, ..., \u0026sinfo, ...) if (nread \u003c= 0) break; assoc_id = sinfo.sinfo_assoc_id; stream = sinfo.sinfo_stream; handle_mesg(assoc_id, stream, msg, nread); } This is a single-threaded read loop. It ensures that information is read, no matter what association or stream it is sent on. The application function handle_mesg() can, of course, dispatch the message to different threads if it wants. Writes, on the other hand can be sent from multiple threads if desired. ","date":"0001-01-01","objectID":"/sctp/:4:0","tags":["network","protocol","sctp"],"title":"Stream Control Transmission Protocol (SCTP)","uri":"/sctp/"},{"categories":null,"content":"5 Rec \u0026 Send When it comes to sending messages back to all the connected clients, SCTP makes it even easier—the flag SCTP_SENDALL that can can be set in the sctp_sndrcvinfo field of sctp_send(). So a server simply needs to read a message from any client, set the SCTP_SENDALL bit and write it back out. The SCTP stack then will send it to all live peers! There are only a few lines of ","date":"0001-01-01","objectID":"/sctp/:5:0","tags":["network","protocol","sctp"],"title":"Stream Control Transmission Protocol (SCTP)","uri":"/sctp/"},{"categories":null,"content":"6 CDB with SCTP? 发送端 可使用 一个 socket ， 对多个 server 创建 associations 多线程并行发送 接收端 一个 socket ， 类似 UDP 接收 单线程接收，分拣 回发数据？？ ","date":"0001-01-01","objectID":"/sctp/:6:0","tags":["network","protocol","sctp"],"title":"Stream Control Transmission Protocol (SCTP)","uri":"/sctp/"},{"categories":null,"content":"7 SCTP Interface Model https://www.masterraghu.com/subjects/np/introduction/unix_network_programming_v1.3/ch09.html ","date":"0001-01-01","objectID":"/sctp/:7:0","tags":["network","protocol","sctp"],"title":"Stream Control Transmission Protocol (SCTP)","uri":"/sctp/"},{"categories":null,"content":"7.1 two types of SCTP sockets ","date":"0001-01-01","objectID":"/sctp/:7:1","tags":["network","protocol","sctp"],"title":"Stream Control Transmission Protocol (SCTP)","uri":"/sctp/"},{"categories":null,"content":"7.2 The One-to-One Style 便于移植基于 TCP 协议的程序。 ","date":"0001-01-01","objectID":"/sctp/:7:2","tags":["network","protocol","sctp"],"title":"Stream Control Transmission Protocol (SCTP)","uri":"/sctp/"},{"categories":null,"content":"7.3 The One-to-Many Style 一对多模式可以减少 server 所使用的 socket 数量：可以使用一个 socket 来建立多个联合。 联合通过 association id 来标识。 该 ID 由内核指定，对用户透明。 使用该模式需要注意： 当客户端关闭联合之后， server 端自动关闭，并将相关的状态从内核中移除。 使用 one-to-many 方式，可以在四次握手的第三个或者第四个包即开始发送数据。 使用 sendto/sendmsg/sctp_sendmsg 发送数据时候，如果联合不存在，会自动创建。 必须使用 sendto/sctp_sendmsg 来发送数据，而不能使用 send/write 发送数据时，总是使用主目的地址 （建立联合时候系统选定的地址）。可以通过设置 flag MSG_ADDR_OVER 来强制使用其他地址。 该 flag 可以在 sctp_sendmsg() 中通过 sctp_sndrcvinfo 来设置。 事件通知可以通过 SCTP_EVENTS 来控制。 ","date":"0001-01-01","objectID":"/sctp/:7:3","tags":["network","protocol","sctp"],"title":"Stream Control Transmission Protocol (SCTP)","uri":"/sctp/"},{"categories":null,"content":"本文为摘录(或转载)，侵删，原文为： attachments/pdf/c/p3346-gong.pdf ","date":"0001-01-01","objectID":"/p3346-gong/:0:0","tags":["NVME"],"title":"Tair-PMem: A Fully Durable Non-Volatile Memory Database","uri":"/p3346-gong/"},{"categories":null,"content":" Table of Contents 1 Introduction 1.1 Virtual IDs 1.2 Block-oriented and vectorized processing \\\\ 1.3 Late materialization 晚期物化 1.4 Column-specific compression 1.5 Direct operation on compressed data 1.6 Efficient join implementations 1.7 Redundant representation of individual columns in dif- ferent sort orders 1.8 Database cracking and adaptive indexing 1.9 Efficient loading architectures 2 Column-store internals and advanced techniques 2.1 Vectorized Processing 向量化处理 2.2 Compression 2.3 Operating Directly on Compressed Data 压缩态计算 2.4 Late Materialization 本文为摘录(或转载)，侵删，原文为： attachments/pdf/d/The Design and Implementation of Modern Column-Oriented Database Systems (abadi-column-stores).pdf ","date":"0001-01-01","objectID":"/the-design-and-implementation-of-modern-column-oriented-database-systems-abadi-column-stores/:0:0","tags":null,"title":"The Design and Implementation of Modern Column-Oriented Database Systems","uri":"/the-design-and-implementation-of-modern-column-oriented-database-systems-abadi-column-stores/"},{"categories":null,"content":"1 Introduction ","date":"0001-01-01","objectID":"/the-design-and-implementation-of-modern-column-oriented-database-systems-abadi-column-stores/:1:0","tags":null,"title":"The Design and Implementation of Modern Column-Oriented Database Systems","uri":"/the-design-and-implementation-of-modern-column-oriented-database-systems-abadi-column-stores/"},{"categories":null,"content":"1.1 Virtual IDs 通过固定大小来存储数据，省掉存储 ID 的开销 ","date":"0001-01-01","objectID":"/the-design-and-implementation-of-modern-column-oriented-database-systems-abadi-column-stores/:1:1","tags":null,"title":"The Design and Implementation of Modern Column-Oriented Database Systems","uri":"/the-design-and-implementation-of-modern-column-oriented-database-systems-abadi-column-stores/"},{"categories":null,"content":"1.2 Block-oriented and vectorized processing \\\\ CPU 效率和 Cache 使用率更高 算子间传递多个 tuple 组成的 block 每个 block 大小为 cache size 大小 每个 block 中一般包含多个记录 自动向量化（编译器 + CPU） ","date":"0001-01-01","objectID":"/the-design-and-implementation-of-modern-column-oriented-database-systems-abadi-column-stores/:1:2","tags":null,"title":"The Design and Implementation of Modern Column-Oriented Database Systems","uri":"/the-design-and-implementation-of-modern-column-oriented-database-systems-abadi-column-stores/"},{"categories":null,"content":"1.3 Late materialization 晚期物化 延迟将多列 join 成宽表的时机 ","date":"0001-01-01","objectID":"/the-design-and-implementation-of-modern-column-oriented-database-systems-abadi-column-stores/:1:3","tags":null,"title":"The Design and Implementation of Modern Column-Oriented Database Systems","uri":"/the-design-and-implementation-of-modern-column-oriented-database-systems-abadi-column-stores/"},{"categories":null,"content":"1.4 Column-specific compression ","date":"0001-01-01","objectID":"/the-design-and-implementation-of-modern-column-oriented-database-systems-abadi-column-stores/:1:4","tags":null,"title":"The Design and Implementation of Modern Column-Oriented Database Systems","uri":"/the-design-and-implementation-of-modern-column-oriented-database-systems-abadi-column-stores/"},{"categories":null,"content":"1.5 Direct operation on compressed data 尽量让数据以压缩方式存储在内存中，对其进行操作，直到必需的时候再解压给外层。 ","date":"0001-01-01","objectID":"/the-design-and-implementation-of-modern-column-oriented-database-systems-abadi-column-stores/:1:5","tags":null,"title":"The Design and Implementation of Modern Column-Oriented Database Systems","uri":"/the-design-and-implementation-of-modern-column-oriented-database-systems-abadi-column-stores/"},{"categories":null,"content":"1.6 Efficient join implementations ","date":"0001-01-01","objectID":"/the-design-and-implementation-of-modern-column-oriented-database-systems-abadi-column-stores/:1:6","tags":null,"title":"The Design and Implementation of Modern Column-Oriented Database Systems","uri":"/the-design-and-implementation-of-modern-column-oriented-database-systems-abadi-column-stores/"},{"categories":null,"content":"1.7 Redundant representation of individual columns in dif- ferent sort orders ","date":"0001-01-01","objectID":"/the-design-and-implementation-of-modern-column-oriented-database-systems-abadi-column-stores/:1:7","tags":null,"title":"The Design and Implementation of Modern Column-Oriented Database Systems","uri":"/the-design-and-implementation-of-modern-column-oriented-database-systems-abadi-column-stores/"},{"categories":null,"content":"1.8 Database cracking and adaptive indexing ","date":"0001-01-01","objectID":"/the-design-and-implementation-of-modern-column-oriented-database-systems-abadi-column-stores/:1:8","tags":null,"title":"The Design and Implementation of Modern Column-Oriented Database Systems","uri":"/the-design-and-implementation-of-modern-column-oriented-database-systems-abadi-column-stores/"},{"categories":null,"content":"1.9 Efficient loading architectures ","date":"0001-01-01","objectID":"/the-design-and-implementation-of-modern-column-oriented-database-systems-abadi-column-stores/:1:9","tags":null,"title":"The Design and Implementation of Modern Column-Oriented Database Systems","uri":"/the-design-and-implementation-of-modern-column-oriented-database-systems-abadi-column-stores/"},{"categories":null,"content":"2 Column-store internals and advanced techniques ","date":"0001-01-01","objectID":"/the-design-and-implementation-of-modern-column-oriented-database-systems-abadi-column-stores/:2:0","tags":null,"title":"The Design and Implementation of Modern Column-Oriented Database Systems","uri":"/the-design-and-implementation-of-modern-column-oriented-database-systems-abadi-column-stores/"},{"categories":null,"content":"2.1 Vectorized Processing 向量化处理 ","date":"0001-01-01","objectID":"/the-design-and-implementation-of-modern-column-oriented-database-systems-abadi-column-stores/:2:1","tags":null,"title":"The Design and Implementation of Modern Column-Oriented Database Systems","uri":"/the-design-and-implementation-of-modern-column-oriented-database-systems-abadi-column-stores/"},{"categories":null,"content":"2.2 Compression 2.2.1 Run-length Encoding 2.2.2 Bit-Vector Encoding 2.2.3 Dictionary 2.2.4 Frame Of Reference (FOR) 2.2.5 The Patching Technique ","date":"0001-01-01","objectID":"/the-design-and-implementation-of-modern-column-oriented-database-systems-abadi-column-stores/:2:2","tags":null,"title":"The Design and Implementation of Modern Column-Oriented Database Systems","uri":"/the-design-and-implementation-of-modern-column-oriented-database-systems-abadi-column-stores/"},{"categories":null,"content":"2.3 Operating Directly on Compressed Data 压缩态计算 This benefit is magnified for compression schemes like run length encoding that combine multiple values within a column inside a single compression symbol. Operating directly on compressed data requires modifica- tions to the query execution engine. ","date":"0001-01-01","objectID":"/the-design-and-implementation-of-modern-column-oriented-database-systems-abadi-column-stores/:2:3","tags":null,"title":"The Design and Implementation of Modern Column-Oriented Database Systems","uri":"/the-design-and-implementation-of-modern-column-oriented-database-systems-abadi-column-stores/"},{"categories":null,"content":"2.4 Late Materialization ","date":"0001-01-01","objectID":"/the-design-and-implementation-of-modern-column-oriented-database-systems-abadi-column-stores/:2:4","tags":null,"title":"The Design and Implementation of Modern Column-Oriented Database Systems","uri":"/the-design-and-implementation-of-modern-column-oriented-database-systems-abadi-column-stores/"},{"categories":null,"content":" Table of Contents 1 Relfilenode of ordinary table 2 Relfilenode of Nail tables 3 Nail table Relfilenode storage mechanism 4 Summary 本文为摘录(或转载)，侵删，原文为： https://www.highgo.ca/2021/01/12/the-mapping-of-oid-and-relfilenode-in-pg/ A table in PostgreSQL has a relfilenode value, which specifies the file name of the table on disk (except foreign table and partition table). In general, this value can be found in the relfilenode field of the pg_class table, but there are some specific tables whose query result in the relfilenode field is 0. This blog will explore the kernel processing of these special tables relfilenode. ","date":"0001-01-01","objectID":"/the-mapping-of-oid-and-relfilenode-in-pg/:0:0","tags":null,"title":"The mapping of oid and relfilenode in PG","uri":"/the-mapping-of-oid-and-relfilenode-in-pg/"},{"categories":null,"content":"1 Relfilenode of ordinary table When a normal table is created in PostgreSQL, the relfilenode value of the table is stored in pg_class system table. As it can be seen in this example that when a table is created, it’s OID and relfilenode value are both 16808. You can also find a file on the disk with the same name as the Relfilenode node value, in-fact the data inserted for the table is actually stored in the same file. postgres=# create table t2(i int); CREATE TABLE postgres=# select oid,relname,relfilenode from pg_class where relname = ’t2’; oid | relname | relfilenode ——-—————––— 16808 | t2 | 16808 (1 row) postgres=# \\q movead@movead-PC:/h2/pgpgpg/bin$ ll ../data/base/12835/16808 -rw––—+ 1 movead movead 0 12月 31 17:11 ../data/base/12835/16808 movead@movead-PC:/h2/pgpgpg/bin$ After we perform operations such as truncate, vacuum full, etc. on a table, the data in this table will be rewritten and the value of relfilenode for this table will be changed. The following test shows that after truncate, the relfilenode of the t2 table has changed from 16808 to 16811. postgres=# truncate t2; TRUNCATE TABLE postgres=# select oid,relname,relfilenode from pg_class where relname = ’t2’; oid | relname | relfilenode ——-—————––— 16808 | t2 | 16811 (1 row) postgres=# checkpoint; CHECKPOINT postgres=# \\q movead@movead-PC:/h2/pgpgpg/bin$ ll ../data/base/12835/16808 ls: 无法访问’../data/base/12835/16808’: 没有那个文件或目录 movead@movead-PC:/h2/pgpgpg/bin$ ll ../data/base/12835/16811 -rw––—+ 1 movead movead 0 12月 31 17:16 ../data/base/12835/16811 movead@movead-PC:/h2/pgpgpg/bin$ ","date":"0001-01-01","objectID":"/the-mapping-of-oid-and-relfilenode-in-pg/:1:0","tags":null,"title":"The mapping of oid and relfilenode in PG","uri":"/the-mapping-of-oid-and-relfilenode-in-pg/"},{"categories":null,"content":"2 Relfilenode of Nail tables postgres=# select oid, relname, relfilenode,reltablespace from pg_class where relfilenode = 0 and relkind = ‘r’ order by reltablespace; oid | relname | relfilenode | reltablespace —————————–——––—+———-–— 1247 | pg_type | 0 | 0 1255 | pg_proc | 0 | 0 1249 | pg_attribute | 0 | 0 1259 | pg_class | 0 | 0 3592 | pg_shseclabel | 0 | 1664 1262 | pg_database | 0 | 1664 2964 | pg_db_role_setting | 0 | 1664 1213 | pg_tablespace | 0 | 1664 1261 | pg_auth_members | 0 | 1664 1214 | pg_shdepend | 0 | 1664 2396 | pg_shdescription | 0 | 1664 1260 | pg_authid | 0 | 1664 6000 | pg_replication_origin | 0 | 1664 6100 | pg_subscription | 0 | 1664 (14 rows) postgres=# It can be seen from the above query that the relfilenode of these tables queried from the pg_class catalog is 0. Among them, pg_type, pg_proc, pg_attribute, and pg_class are non-shared tables, and they are called Nail tables in the kernel. The remaining tables are shared tables in the pg_global tablespace. The purpose of relfilenode field in the pg_class table is to tell the user about the file name of a given table stored on the disk. For example, when we query the t2 table, the system must get the relfilenode from the pg_class catalog, then find the file on the disk, open it and scan it. But if we want to query the file name of the pg_class table on disk, where should we find its relfilenode? A set of functional interfaces is provided in PostgreSQL to convert oid and relfilenode. postgres=# select pg_relation_filenode(1259); pg_relation_filenode 16475 (1 row) postgres=# select pg_filenode_relation(0,16475); pg_filenode_relation pg_class (1 row) postgres=# select pg_filenode_relation(0,16475)::oid; pg_filenode_relation 1259 (1 row) postgres=# By call pg_relation_filenode(), oid can be converted to relfilenode, and with pg_filenode_relation(), relfilenode can be converted to oid. Since the corresponding relationship between oid and relfilenode for shared and nail tables are not stored in the pg_class table, how does PostgreSQL save this mapping relationship? nail_ ","date":"0001-01-01","objectID":"/the-mapping-of-oid-and-relfilenode-in-pg/:2:0","tags":null,"title":"The mapping of oid and relfilenode in PG","uri":"/the-mapping-of-oid-and-relfilenode-in-pg/"},{"categories":null,"content":"3 Nail table Relfilenode storage mechanism After research, it is found that there are pg_filenode.map files in the data directory, as shown below. movead@movead-PC:/h2/pgpgpg/data/base/12835$ ll pg_filenode.map -rw––—+ 1 movead movead 512 12月 31 15:10 pg_filenode.map movead@movead-PC:/h2/pgpgpg/data/base/12835$ movead@movead-PC:/h2/pgpgpg/data/global$ ll pg_filenode.map -rw––—+ 1 movead movead 512 12月 31 15:10 pg_filenode.map movead@movead-PC:/h2/pgpgpg/data/global$ The mapping relationship between oid and relfilenode for shared tables is stored in pg_filenode.map file in the global directory, and the mapping relationship between oid and relfilenode for nail tables in the database with OID 12835 is stored in the 12835 directory. The struct of the pg_filenode.map file is look like as blow: typedef struct RelMapping { Oid mapoid; * OID of a catalog * Oid mapfilenode; * its filenode number * } RelMapping; typedef struct RelMapFile { int32 magic; * always RELMAPPER_FILEMAGIC * int32 num_mappings; * number of valid RelMapping entries * RelMapping mappings[MAX_MAPPINGS]; pg_crc32c crc; * CRC of all above * int32 pad; * to make the struct size be 512 exactly * } RelMapFile; ","date":"0001-01-01","objectID":"/the-mapping-of-oid-and-relfilenode-in-pg/:3:0","tags":null,"title":"The mapping of oid and relfilenode in PG","uri":"/the-mapping-of-oid-and-relfilenode-in-pg/"},{"categories":null,"content":"4 Summary This blog mainly explains the two different manifestations of oid and relfilenode mapping in PostgreSQL. Just remember that using pg_relation_filenode() will always get the correct result, and query from the pg_class system table may get the wrong result. * Movead Li Movead.Li is kernel development of Highgo Software. Since joining into Highgo Software in 2016, Movead takes the most time on researching the code of Postgres and is good at ‘Write Ahead Log’ and ‘Database Backup And Recovery’. Base on the experience Movead has two open-source software on the Postgres database. One is Walminer which can analyze history wal file to SQL. The other one is pg_lightool which can do a single table or block recovery base on base backup and walfiles or walfiles only. Hello Now he has joined the HighGo community team and hopes to make more contributions to the community in the future. ","date":"0001-01-01","objectID":"/the-mapping-of-oid-and-relfilenode-in-pg/:4:0","tags":null,"title":"The mapping of oid and relfilenode in PG","uri":"/the-mapping-of-oid-and-relfilenode-in-pg/"},{"categories":null,"content":" Table of Contents 1 什么是多版本并发控制？ 2 PostgreSQL 的多版本并发控制 2.1 多版本存储 2.2 Version Vacuum 3 为什么 PostgreSQL 的 MVCC 是最糟糕的 3.1 Problem #1: Version Copying 3.2 Problem #2: Table Bloat 3.3 Problem #3: Secondary Index Maintenance 3.4 Problem #4: Vacuum Management 4 Concluding Remarks 本文为摘录(或转载)，侵删，原文为： https://ottertune.com/blog/the-part-of-postgresql-we-hate-the-most/ ","date":"0001-01-01","objectID":"/the-part-of-postgresql-we-hate-the-most/:0:0","tags":["pg","index","hot","mvcc"],"title":"The Part of PostgreSQL We Hate the Most","uri":"/the-part-of-postgresql-we-hate-the-most/"},{"categories":null,"content":"1 什么是多版本并发控制？ 在 DBMS 中，MVCC 的目标是在可能的情况下允许多个查询同时读取和写入数据库而不相互干扰。 MVCC 的基本思想是，DBMS 永远不会覆盖现有行。 对于每个（逻辑）行，DBMS 维护多个（物理）版本。 当应用程序执行查询时，DBMS 根据某个版本排序（例如创建时间戳），确定要检索哪个版本以满足请求。 这种方法的好处是，多个查询可以读取旧版本的行，而不会被更新它的其他查询阻塞。查询在数据库快照上观察到它开始查询事务时的状态（快照隔离）。 这种方法消除了对显式记录锁的需求，该锁会阻止读者在写入程序修改同一项时访问数据。 构建支持 MVCC 的 DBMS 时，系统工程师必须做出几个设计决策。在高层次上，它归结为以下几点： 如何存储对现有行的更新。 如何在运行时为查询找到正确的行版本。 如何删除不再可见的过期版本。 这些决策并不互相排斥。对于 PostgreSQL 来说，在上世纪 80 年代决定处理第一个问题的方式导致了我们今天仍然需要解决的其他两个问题。 ","date":"0001-01-01","objectID":"/the-part-of-postgresql-we-hate-the-most/:1:0","tags":["pg","index","hot","mvcc"],"title":"The Part of PostgreSQL We Hate the Most","uri":"/the-part-of-postgresql-we-hate-the-most/"},{"categories":null,"content":"2 PostgreSQL 的多版本并发控制 PostgreSQL 的多版本并发控制（MVCC）方案的核心思想似乎很简单： 当查询更新表中的现有行时，数据库管理系统会复制该行并将更改应用于这个新版本，而不是覆盖原始行。 我们将这种方法称为 追加式版本存储方案 。 但正如我们现在所描述的，这种方法在系统的其他部分有一些非平凡的影响。 ","date":"0001-01-01","objectID":"/the-part-of-postgresql-we-hate-the-most/:2:0","tags":["pg","index","hot","mvcc"],"title":"The Part of PostgreSQL We Hate the Most","uri":"/the-part-of-postgresql-we-hate-the-most/"},{"categories":null,"content":"2.1 多版本存储 postgresql 将所有的行版本存储在同一存储空间的表中。要更新现有的元组，数据库管理系统首先从表中获得一个空槽用于新的行版本。然后，将当前版本的行内容复制到新版本，并将修改应用到新分配的版本槽中的行。 当应用程序对电影数据库执行更新查询来将《少林与武当》的发行年份从 1985 年更改为 1983 年时，可以在下面的示例中看到这个过程： 当一个 UPDATE 查询改变表中的一个元组时，PostgreSQL 会复制该元组的原始版本，然后将更改应用于新版本。在这个例子中，表页面 #1 中没有更多空间，因此 PostgreSQL 在表页面 #2 中创建新版本。 2.1.1 N2O (new to old, 新到旧) vs O2N （old to new, 就到新） 现在，使用两个代表相同逻辑行的物理版本，DBMS 需要记录这些版本的血统，以便将来可以找到它们。 MVCC DBMS 通过创建一个单链表来实现版本链。版本链只向一个方向前进，以减少存储和维护开销。这意味着 DBMS 需要决定使用什么顺序：从新到旧（N2O）顺序还是从旧到新（O2N）顺序。 对于 N2O 顺序: 每个元组版本指向其上一个版本， 版本链的头始终是最新版本。 对于 O2N 顺序， 每个元组版本指向其下一个版本， 头是最旧的元组版本。 O2N 方法避免了 DBMS 每次修改元组时更新索引指向较新版本的需要。然而，在查询处理过程中，DBMS 可能需要更长时间来找到最新版本，可能需要遍历长的版本链。 大多数 DBMS，包括 Oracle 和 MySQL，实现了 N2O。但是 PostgreSQL 在使用 O2N 方面独树一帜（除了 Microsoft 的 In-Memory OLTP 引擎用于 SQL Server）。 2.1.2 PostgreSQL 如何确定记录哪些内容 下一个问题是 PostgreSQL 如何确定要记录哪些版本指针。 PostgreSQL 中每行的标头包含了下一个版本的元组 id 字段（ t_tcid ）（如果它是最新版本，则是自己的元组 id）。因此，如下一个例子所示，当一个查询请求最新版本的行时，数据库管理系统遍历索引，定位到最旧的版本，然后跟随指针直到找到所需的版本。 PostgreSQL 开发人员很早就意识到其 MVCC 方案存在两个问题。 首先，每次更新时都要创建一个完整元组的新副本是昂贵的。 其次，为了找到最新版本（大多数查询都需要的）而遍历整个版本链是浪费的。 为了避免遍历整个版本链，PostgreSQL 为每个数据行的物理版本在表的索引中添加一个条目。这意味着如果一个逻辑行有五个物理版本，那么在索引中将会有（至多）五个该元组的条目！在下面的示例中，我们可以看到=idx_name= 索引包含了分别位于不同页面上的每个 “Shaolin and Wu Tang”行的条目。这使得可以直接访问元组的最新版本，而无需遍历长的版本链。 PostgreSQL 尝试通过在相同的磁盘页（块）中创建新的副本来避免安装多个索引条目，并将相关版本存储在多个页面上，以减少磁盘 I/O。这种优化被称为堆唯一元组（ HOT ）更新。如果更新不修改表的索引引用的任何列，并且新版本存储在与旧版本相同的数据页上（如果该页有空间），DBMS 会使用 HOT 方法。现在在我们的例子中，更新后索引仍然指向旧版本，并且查询通过遍历版本链来检索最新版本。在正常操作期间，PostgreSQL 通过删除旧版本来优化此过程，以修剪版本链。 ","date":"0001-01-01","objectID":"/the-part-of-postgresql-we-hate-the-most/:2:1","tags":["pg","index","hot","mvcc"],"title":"The Part of PostgreSQL We Hate the Most","uri":"/the-part-of-postgresql-we-hate-the-most/"},{"categories":null,"content":"2.2 Version Vacuum 每当应用程序更新行时，PostgreSQL 都会复制一份。接下来的问题是系统如何删除旧版本（称为“死元组”）。 上世纪 80 年代的最初版本的 PostgreSQL 没有删除死元组的功能。这样做的想法是保留所有旧版本，以便应用程序可以执行“时光旅行”查询，以查看数据库在特定时间点的状态（例如，在上周末结束时运行一个 SELECT 查询来检查数据库的状态）。但是从未删除死元组意味着如果应用程序删除元组，表的大小永远不会缩小。它还意味着经常更新元组的长版本链，这将减慢查询速度，除非 PostgreSQL 添加索引条目，以便查询可以快速跳转到正确的版本，而不是遍历整个链。但是现在，这意味着索引更大，使它们变得更慢，并增加了额外的内存压力。 为了解决这些问题，PostgreSQL 使用一个净化程序来清理表中的无效元组。这个净化程序会对自上次运行以来被修改的表页进行顺序扫描，找出过期的版本。数据库管理系统认为一个版本\"过期\"是指它对所有活动事务都不可见。这意味着没有当前事务正在访问该版本，未来的事务将使用最新的\"活动\"版本。因此，删除过期的版本并重新利用该空间是安全的。 PostgreSQL 根据其配置设置定期执行此净化程序（自动净化）。除了影响所有表的净化频率的全局设置外， PostgreSQL 还提供了在表级别配置自动净化的灵活性，以便为特定表优化该过程。用户还可以通过 VACUUM SQL 命令手动触发净化，以优化数据库性能。 ","date":"0001-01-01","objectID":"/the-part-of-postgresql-we-hate-the-most/:2:2","tags":["pg","index","hot","mvcc"],"title":"The Part of PostgreSQL We Hate the Most","uri":"/the-part-of-postgresql-we-hate-the-most/"},{"categories":null,"content":"3 为什么 PostgreSQL 的 MVCC 是最糟糕的 我们直言不讳地说：如果今天有人要构建一个新的多版本并发控制（MVCC）数据库管理系统，他们不应该像 PostgreSQL 那样做（例如，自动清理的附加存储）。在我们 2018 年的 VLDB 论文 中（也被称为“有史以来关于 MVCC 的最佳论文”），我们没有找到另一个 DBMS 以 PostgreSQL 的方式来实现 MVCC。它的设计是 20 世纪 80 年代以前的产物，在 20 世纪 90 年代的日志结构系统模式大量出现之前就存在了。 让我们来讨论一下 PostgreSQL 的 MVCC 出现的四个问题。我们还将讨论为什么其他的 MVCC DBMS 如 Oracle 和 MySQL 可以避免这些问题。 ","date":"0001-01-01","objectID":"/the-part-of-postgresql-we-hate-the-most/:3:0","tags":["pg","index","hot","mvcc"],"title":"The Part of PostgreSQL We Hate the Most","uri":"/the-part-of-postgresql-we-hate-the-most/"},{"categories":null,"content":"3.1 Problem #1: Version Copying 在 MVCC 中采用追加方式存储的方案中，如果一个查询更新了一个元组，DBMS 会将所有列复制到新版本中。无论查询是否更新单个列或所有列，都会进行此复制操作。可以想象，追加方式的 MVCC 会导致大量的数据重复和增加的存储需求。这种方法意味着 PostgreSQL 需要比其他 DBMS 更多的内存和磁盘存储来存储数据库，这意味着查询较慢且云端成本更高。 MySQL 和 Oracle 不是将整个元组复制为新版本，而是存储新版本和当前版本之间的紧凑增量（类似于 git diff）。使用增量意味着如果查询只是更新表中的一个元组的单个列，而该表有 1000 个列，则 DBMS 只存储一个包含对该列更改的增量记录。另一方面，PostgreSQL 会创建一个包含查询更改的列和其他 999 个未触及列的新版本。我们将忽略 TOAST 属性，因为 PostgreSQL 对它们的处理方式不同。 曾经有一次尝试去现代化 PostgreSQL 的版本存储实现。EnterpriseDB 于 2013 年开始了 zheap 项目，以替换追加式存储引擎以使用增量版本。不幸的是，根据我们的了解，该努力在 2021 年已经停滞不前。 ","date":"0001-01-01","objectID":"/the-part-of-postgresql-we-hate-the-most/:3:1","tags":["pg","index","hot","mvcc"],"title":"The Part of PostgreSQL We Hate the Most","uri":"/the-part-of-postgresql-we-hate-the-most/"},{"categories":null,"content":"3.2 Problem #2: Table Bloat 在 PostgreSQL 中，过期的版本（即死元组）所占的空间也比增量版本更多。虽然 PostgreSQL 的自动清理（autovacuum）最终会删除这些死元组，但是写入密集型负载可能导致它们累积得比清理工作更快，从而导致数据库持续增长。DBMS 在查询执行期间必须加载死元组到内存中，因为系统将死元组与活元组混合在页面中。不受限制的膨胀会通过导致 DBMS 承担更多的 IOPS，并在表扫描期间消耗更多的内存来降低查询性能。此外，由于死元组引起的不准确的优化器统计信息可能导致查询计划不佳。 假设我们的电影表（movies table）有 1000 万个活元组和 4000 万个死元组，使得表中 80％的数据都是过时的。还假设表中的列比我们展示的要多得多，每个元组的平均大小是 1KB。在这种情况下，活元组占据 10GB 的存储空间，而死元组占据大约 40GB 的存储空间；表的总大小为 50GB。当一个查询在这个表上执行全表扫描时，PostgreSQL 必须从磁盘上检索所有的 50GB 并存储在内存中，即使其中大部分是过时的。尽管 Postgres 有一种保护机制，可以避免顺序扫描对其缓冲池缓存的污染，但它并不能帮助减少 IO 成本。 即使你确保 PostgreSQL 的自动清理（autovacuum）以规律的间隔运行，并且能够跟上你的工作负载（这并不总是容易的，见下文），自动清理也不能回收存储空间。自动清理只会删除死元组，并在每个页面内重新定位活元组，但它不会从磁盘中回收空白页面。 当数据库管理系统由于不存在任何元组而截断最后一个页面时，其他页面将保留在磁盘上。在上面的例子中，即使 PostgreSQL 从 movies 表中删除了 40GB 的无效元组，它仍然保留了 50GB 的分配存储空间，这来自于操作系统（或者在 RDS 的情况下来自于 Amazon）。要重新获取和返回这样未使用的空间，必须使用 VACUUM FULL 或者 pg_repack 扩展将整个表重写到一个没有浪费存储的新空间中。运行这些操作都不是一个简单的任务，不能不考虑对生产数据库性能的影响；它们消耗资源且耗时，会严重影响查询性能。下图展示了 VACUUM 和 VACUUM FULL 的工作原理。 VACUUM 使用 PostgreSQL 的常规 VACUUM 操作，数据库管理系统仅仅从每个表页面中移除已死元组，并重新组织页面以将所有存活元组放在页面的末尾。 VACUUM FULL 使用 VACUUM FULL 时，PostgreSQL 会从每个页面中移除已死元组，将剩余的存活元组合并并压缩到一个新的页面（表页面#3），然后删除不需要的页面（表页面#1 / #2）。 ","date":"0001-01-01","objectID":"/the-part-of-postgresql-we-hate-the-most/:3:2","tags":["pg","index","hot","mvcc"],"title":"The Part of PostgreSQL We Hate the Most","uri":"/the-part-of-postgresql-we-hate-the-most/"},{"categories":null,"content":"3.3 Problem #3: Secondary Index Maintenance 对元组的单个更新需要 PostgreSQL 更新该表的所有索引。更新所有索引是必要的，因为 PostgreSQL 在主索引和次要索引中都使用版本的确切物理位置。除非 DBMS 将新版本存储在与先前版本相同的页面上（HOT 更新），否则系统将为每个更新执行此操作。 回到我们的 UPDATE 查询示例，PostgreSQL 通过将原始版本复制到一个新页面中来创建一个新版本，就像之前一样。但它还在表的主键索引（movies_pkey）和两个次要索引（idx_director，idx_name）中插入指向新版本的条目。 PostgreSQL 索引维护操作的示例，涉及非 HOT 更新。数据库管理系统在表页#2 中创建元组的新版本，然后在所有表的索引中插入指向该版本的新条目。 PostgreSQL 每次更新需要修改表的所有索引，这对性能有几个影响。 显然，这会使更新查询变慢，因为系统需要做更多的工作。数据库管理系统需要额外的 I/O 来遍历每个索引并插入新的条目。访问索引会引入锁/闩锁争用，无论是在索引还是数据库管理系统的内部数据结构（如缓冲池的页表）中。再次强调，即使查询永远不会使用它们（顺便说一下，OtterTune 可以自动找出您数据库中未使用的索引）， PostgreSQL 也会为表的所有索引进行维护工作。这些额外的读取和写入在按 IOPS 计费的 DBMS（如 Amazon Aurora）中是有问题的。 正如上文所述，如果 PostgreSQL 可以执行 HOT 写操作，即新版本位于当前版本的同一页上，它就会避免每次更新索引。我们对 OtterTune 客户的 PostgreSQL 数据库进行的分析显示，平均约有 46%的更新使用 HOT 优化。尽管这个数字令人印象深刻，但仍意味着超过 50%的更新在支付这种代价。 有许多用户在处理 PostgreSQL 的 MVCC 实现的这个方面时遇到了困难。其中最著名的例子是 Uber 在 2016 年发表的一篇博文，解释了他们为何从 Postgres 转为 MySQL。他们的写入密集工作负载在具有许多次要索引的表上遇到了严重的性能问题。 Oracle 和 MySQL 在 MVCC 实现中并没有这个问题，因为它们的次要索引不存储新版本的物理地址，而是存储一个逻辑标识符（如元组 ID、主键），然后 DBMS 使用该标识符来查找当前版本的物理地址。现在，这可能会使次要索引的读取速度较慢，因为 DBMS 必须解析逻辑标识符，但这些 DBMS 在其 MVCC 实现中具有其他优势来减少开销。 旁注：Uber 的博文中关于 PostgreSQL 版本存储的说法有错误。具体来说，每个 PostgreSQL 的元组都存储了指向新版本的指针，而不是博文中所述的指向上一个版本的指针。这导致了一个 O2N 版本链排序，而不是 Uber 错误声称的 N2O 版本链。 ","date":"0001-01-01","objectID":"/the-part-of-postgresql-we-hate-the-most/:3:3","tags":["pg","index","hot","mvcc"],"title":"The Part of PostgreSQL We Hate the Most","uri":"/the-part-of-postgresql-we-hate-the-most/"},{"categories":null,"content":"3.4 Problem #4: Vacuum Management PostgreSQL 的性能非常依赖于自动清理过时数据和回收空间的 autovacuum 的效果（这就是为什么 OtterTune 在您首次连接数据库时立即检查 autovacuum 的健康状态）。无论您使用的是 RDS，Aurora 还是 Aurora Serverless， PostgreSQL 的所有变体都存在相同的 autovacuum 问题。 但是，要确保 PostgreSQL 的 autovacuum 尽可能地运行良好是困难的，因为它非常复杂。 PostgreSQL 针对自动清理进行了默认设置，但对于所有表格来说并不理想，尤其是对于大表格来说。例如，控制在 PostgreSQL 触发 autovacuum 之前需要更新多少百分比的表格的配置选项（autovacuum_vacuum_scale_factor）的默认设置是 20%。这个阈值意味着如果一个表格有 1 亿条数据，数据库管理系统不会触发 autovacuum，直到查询更新至少 2000 万条数据。因此，PostgreSQL 可能会在一个表格中保留很多死元组（从而产生 IO 和内存开销）很长时间。 PostgreSQL 中 autovacuum 的另一个问题是它可能受到长时间运行的事务的阻塞，这可能导致更多的死元组和陈旧的统计信息积累。未能及时清理过期版本会导致许多性能问题，引发更多长时间运行的事务，从而阻塞 autovacuum 进程。这成为一个恶性循环，需要人工干预通过手动终止长时间运行的事务。考虑下面的图表，它显示了一个 OtterTune 客户数据库中两周内死元组的数量： 图表中的锯齿状模式显示自动清理（autovacuum）大约每天进行一次重大清理。例如，在 2 月 14 日，数据库管理系统（DB MS）清理了 320 万个已经死亡的元组。这个图表实际上是一个不健康的 PostgreSQL 数据库的例子。图表清楚地显示了已经死亡元组数量的上升趋势，因为自动清理跟不上。 在 OtterTune，我们经常在客户的数据库中看到这个问题。一个 PostgreSQL RDS 实例在大量插入后因为旧的统计信息导致一个长时间运行的查询。这个查询阻塞了自动清理更新统计信息，导致更多的长时间运行的查询。OtterTune 的自动健康检查识别出了这个问题，但管理员仍然需要手动终止查询并在大量插入后运行 ANALYZE。好消息是，长查询的执行时间从 52 分钟减少到只有 34 秒。 ","date":"0001-01-01","objectID":"/the-part-of-postgresql-we-hate-the-most/:3:4","tags":["pg","index","hot","mvcc"],"title":"The Part of PostgreSQL We Hate the Most","uri":"/the-part-of-postgresql-we-hate-the-most/"},{"categories":null,"content":"4 Concluding Remarks 在构建数据库管理系统（DBMS）时，总会面临艰难的设计决策。这些决策将导致不同工作负载下的 DBMS 性能不同。对于 Uber 的特定写入密集工作负载来说，由于 MVCC（多版本并发控制）导致的 PostgreSQL 索引写入放大是他们转向 MySQL 的原因。但请不要误解我们的口吻，以为我们认为你永远不应该使用 PostgreSQL。虽然它的 MV CC 实现方式并不正确，但 PostgreSQL 仍然是我们最喜欢的 DBMS。爱一样东西就意味着愿意和它的缺陷共事（参见丹·萨维奇的《入场费》）。 那么，如何解决 PostgreSQL 的怪癖呢？嗯，你可以花费大量的时间和精力来自行调优。祝你好运。 ","date":"0001-01-01","objectID":"/the-part-of-postgresql-we-hate-the-most/:4:0","tags":["pg","index","hot","mvcc"],"title":"The Part of PostgreSQL We Hate the Most","uri":"/the-part-of-postgresql-we-hate-the-most/"},{"categories":null,"content":" Table of Contents 1 ABSTRACT 2 BACKGROUND 2.1 Design Overview 3 DATA MODEL 3.1 Projections 3.2 Join Indexes 3.3 Prejoin Projections 3.4 Encoding and Compression 3.5 Partitioning 3.6 Segmentation: Cluster Distribution 3.7 Read and Write Optimized Stores 4 TUPLE MOVER 5 QUERY EXECUTION 5.1 Query Operators and Plan Format 5.2 Query Optimization 本文为摘录(或转载)，侵删，原文为： attachments/pdf/3/The Vertica Analytic Database- C-Store 7 Years Later (p1790_andrewlamb_vldb2012).pdf ","date":"0001-01-01","objectID":"/the-vertica-analytic-database-c-store-7-years-later-p1790_andrewlamb_vldb2012/:0:0","tags":null,"title":"The Vertica Analytic Database- C-Store 7 Years Later","uri":"/the-vertica-analytic-database-c-store-7-years-later-p1790_andrewlamb_vldb2012/"},{"categories":null,"content":"1 ABSTRACT Vertica 是 C-Store 的商业化成果 ","date":"0001-01-01","objectID":"/the-vertica-analytic-database-c-store-7-years-later-p1790_andrewlamb_vldb2012/:1:0","tags":null,"title":"The Vertica Analytic Database- C-Store 7 Years Later","uri":"/the-vertica-analytic-database-c-store-7-years-later-p1790_andrewlamb_vldb2012/"},{"categories":null,"content":"2 BACKGROUND ","date":"0001-01-01","objectID":"/the-vertica-analytic-database-c-store-7-years-later-p1790_andrewlamb_vldb2012/:2:0","tags":null,"title":"The Vertica Analytic Database- C-Store 7 Years Later","uri":"/the-vertica-analytic-database-c-store-7-years-later-p1790_andrewlamb_vldb2012/"},{"categories":null,"content":"2.1 Design Overview 2.1.1 Design Goals Designed for analytic workloads rather than for transactional workloads Transactional workloads are characterized by: a large number of transactions per second (e.g. thousands) 事务性工作负载指的是每秒钟有大量的交易（比如数千次）， each transaction involves a handful of tuples. 每个交易仅涉及几个元组。 most of the transactions take the form of single row insertions or modifications to existing rows. 大多数交易采用单行插入或修改现有行的形式。 例如，插入新的销售记录或更新银行帐户余额。 Analytic workloads are characterized by: smaller transaction volume (e.g. tens per second), 每秒钟的交易量较小（例如每秒钟几十次）， each transaction examines a significant fraction of the tuples in a table. 但每个交易都会检查表中相当一部分的元组。 例如，跨时间和地理维度聚合销售数据以及分析网站上不同用户的行为。 Share nothing storage 尽量进行本地计算： 优化器， 执行器避免通过网络搬运大量数据 加载，尤其是批量加载，要快 ","date":"0001-01-01","objectID":"/the-vertica-analytic-database-c-store-7-years-later-p1790_andrewlamb_vldb2012/:2:1","tags":null,"title":"The Vertica Analytic Database- C-Store 7 Years Later","uri":"/the-vertica-analytic-database-c-store-7-years-later-p1790_andrewlamb_vldb2012/"},{"categories":null,"content":"3 DATA MODEL ","date":"0001-01-01","objectID":"/the-vertica-analytic-database-c-store-7-years-later-p1790_andrewlamb_vldb2012/:3:0","tags":null,"title":"The Vertica Analytic Database- C-Store 7 Years Later","uri":"/the-vertica-analytic-database-c-store-7-years-later-p1790_andrewlamb_vldb2012/"},{"categories":null,"content":"3.1 Projections 它将表数据物理地组织成投影 这些投影是表属性的排序子集 可以允许使用任意数量的具有不同排序顺序和表列子集的投影。 ","date":"0001-01-01","objectID":"/the-vertica-analytic-database-c-store-7-years-later-p1790_andrewlamb_vldb2012/:3:1","tags":null,"title":"The Vertica Analytic Database- C-Store 7 Years Later","uri":"/the-vertica-analytic-database-c-store-7-years-later-p1790_andrewlamb_vldb2012/"},{"categories":null,"content":"3.2 Join Indexes 未使用 C-Store 中使用的连接索引 ","date":"0001-01-01","objectID":"/the-vertica-analytic-database-c-store-7-years-later-p1790_andrewlamb_vldb2012/:3:2","tags":null,"title":"The Vertica Analytic Database- C-Store 7 Years Later","uri":"/the-vertica-analytic-database-c-store-7-years-later-p1790_andrewlamb_vldb2012/"},{"categories":null,"content":"3.3 Prejoin Projections ","date":"0001-01-01","objectID":"/the-vertica-analytic-database-c-store-7-years-later-p1790_andrewlamb_vldb2012/:3:3","tags":null,"title":"The Vertica Analytic Database- C-Store 7 Years Later","uri":"/the-vertica-analytic-database-c-store-7-years-later-p1790_andrewlamb_vldb2012/"},{"categories":null,"content":"3.4 Encoding and Compression ","date":"0001-01-01","objectID":"/the-vertica-analytic-database-c-store-7-years-later-p1790_andrewlamb_vldb2012/:3:4","tags":null,"title":"The Vertica Analytic Database- C-Store 7 Years Later","uri":"/the-vertica-analytic-database-c-store-7-years-later-p1790_andrewlamb_vldb2012/"},{"categories":null,"content":"3.5 Partitioning ","date":"0001-01-01","objectID":"/the-vertica-analytic-database-c-store-7-years-later-p1790_andrewlamb_vldb2012/:3:5","tags":null,"title":"The Vertica Analytic Database- C-Store 7 Years Later","uri":"/the-vertica-analytic-database-c-store-7-years-later-p1790_andrewlamb_vldb2012/"},{"categories":null,"content":"3.6 Segmentation: Cluster Distribution ","date":"0001-01-01","objectID":"/the-vertica-analytic-database-c-store-7-years-later-p1790_andrewlamb_vldb2012/:3:6","tags":null,"title":"The Vertica Analytic Database- C-Store 7 Years Later","uri":"/the-vertica-analytic-database-c-store-7-years-later-p1790_andrewlamb_vldb2012/"},{"categories":null,"content":"3.7 Read and Write Optimized Stores ROS: Read Optimized Store WOS: Write Optimized Store 3.7.1 Data Modifications and Delete Vectors A delete vector is a list of positions of rows that have been deleted. ","date":"0001-01-01","objectID":"/the-vertica-analytic-database-c-store-7-years-later-p1790_andrewlamb_vldb2012/:3:7","tags":null,"title":"The Vertica Analytic Database- C-Store 7 Years Later","uri":"/the-vertica-analytic-database-c-store-7-years-later-p1790_andrewlamb_vldb2012/"},{"categories":null,"content":"4 TUPLE MOVER ","date":"0001-01-01","objectID":"/the-vertica-analytic-database-c-store-7-years-later-p1790_andrewlamb_vldb2012/:4:0","tags":null,"title":"The Vertica Analytic Database- C-Store 7 Years Later","uri":"/the-vertica-analytic-database-c-store-7-years-later-p1790_andrewlamb_vldb2012/"},{"categories":null,"content":"5 QUERY EXECUTION ","date":"0001-01-01","objectID":"/the-vertica-analytic-database-c-store-7-years-later-p1790_andrewlamb_vldb2012/:5:0","tags":null,"title":"The Vertica Analytic Database- C-Store 7 Years Later","uri":"/the-vertica-analytic-database-c-store-7-years-later-p1790_andrewlamb_vldb2012/"},{"categories":null,"content":"5.1 Query Operators and Plan Format ","date":"0001-01-01","objectID":"/the-vertica-analytic-database-c-store-7-years-later-p1790_andrewlamb_vldb2012/:5:1","tags":null,"title":"The Vertica Analytic Database- C-Store 7 Years Later","uri":"/the-vertica-analytic-database-c-store-7-years-later-p1790_andrewlamb_vldb2012/"},{"categories":null,"content":"5.2 Query Optimization ","date":"0001-01-01","objectID":"/the-vertica-analytic-database-c-store-7-years-later-p1790_andrewlamb_vldb2012/:5:2","tags":null,"title":"The Vertica Analytic Database- C-Store 7 Years Later","uri":"/the-vertica-analytic-database-c-store-7-years-later-p1790_andrewlamb_vldb2012/"},{"categories":null,"content":" Table of Contents 1 展开 Bash 数组 (array) 时候， ${ARRARY[@]} 和 ${ARRARY[*]} 有什么区别？ 2 How do you escape characters in heredoc? 2.1 Question 2.2 Answer 3 special expansion: 4 will .bash_profile be sourced when executing scripts? 本文为摘录(或转载)，侵删，原文为： https://unix.stackexchange.com/questions/505949/expanding-only-certain-variables-inside-a-heredoc ","date":"0001-01-01","objectID":"/tips-of-bash-zsh/:0:0","tags":["utility","bash","zsh"],"title":"Tips of Bash/Zsh","uri":"/tips-of-bash-zsh/"},{"categories":null,"content":"1 展开 Bash 数组 (array) 时候， ${ARRARY[@]} 和 ${ARRARY[*]} 有什么区别？ INFO 中有相关说明： 数组的任何元素可以使用’${NAME[SUBSCRIPT]}‘来引用。 这些大括号是为了避免与 shell 的文件名扩展操作符产生冲突。如果 SUBSCRIPT 为’@‘或’*’，那么该词会扩展为数组 NAME 的所有成员。这些下标在词出现在双引号内时才有所不同。如果该词被双引号括起来，’\\({NAME[*]}‘会扩展为单词，其值为每个数组成员之间以 IFS 变量的第一个字符分隔，而’\\){NAME[@]}‘会将 NAME 的每个元素扩展为独立的单词。当数组没有成员时，’${NAME[@]}‘扩展为空。如果双引号扩展出现在一个单词中，第一个参数的扩展将与原始单词的开头部分连接，而最后一个参数的扩展将与最后部分连接。 例子： a=('1' \"2\" \"3\" \"4\") export IFS=\"|\" echo \"${a[@]}\" echo \"${a[*]}\" 输出为： -*- mode: compilation; default-directory: \"~/tmp/\" -*- 1 2 3 4 1|2|3|4 ","date":"0001-01-01","objectID":"/tips-of-bash-zsh/:1:0","tags":["utility","bash","zsh"],"title":"Tips of Bash/Zsh","uri":"/tips-of-bash-zsh/"},{"categories":null,"content":"2 How do you escape characters in heredoc? ","date":"0001-01-01","objectID":"/tips-of-bash-zsh/:2:0","tags":["utility","bash","zsh"],"title":"Tips of Bash/Zsh","uri":"/tips-of-bash-zsh/"},{"categories":null,"content":"2.1 Question 我正在使用一个 bash 脚本，试图阻止它尝试替换 heredoc 中的变量。如何将 heredoc 设置为 A）转义变量名而不解析它们，或者 B）返回整个字符串而不改变它？ cat \u003e /etc/nginx/sites-available/default_php \u003c\u003cEND server { listen 80 default; server_name _; root /var/www/$host; \u003c--- $host is a problem child } END 就现状而言，当我将它注入到文件中结束时，我得到的是这个： server { listen 80 default; server_name _; root /var/www/; } ","date":"0001-01-01","objectID":"/tips-of-bash-zsh/:2:1","tags":["utility","bash","zsh"],"title":"Tips of Bash/Zsh","uri":"/tips-of-bash-zsh/"},{"categories":null,"content":"2.2 Answer 从 bash(1) man 页: 如果 word 中的任何字符被引用，那么分隔符就是对 word 进行引号移除的结果，并且 here-document 中的行不会被展开。 cat \u003e /etc/nginx/sites-available/default_php \u003c\u003c\"END\" a=\"this is a test\" cat \u003c\u003cEOF echo \"a should be expanded: $a\" EOF cat \u003c\u003c'EOF' echo \"a should not be expanded: $a\" EOF ","date":"0001-01-01","objectID":"/tips-of-bash-zsh/:2:2","tags":["utility","bash","zsh"],"title":"Tips of Bash/Zsh","uri":"/tips-of-bash-zsh/"},{"categories":null,"content":"3 special expansion: cat \u003c\u003c-'EOF' ### ${PARAMETER:+WORD} `${PARAMETER:+WORD}` 是一种 bash shell 中的参数扩展语法，它的含义如下： - 如果变量 `PARAMETER` 已经被设置并且不是空值，那么该表达式的值为 `WORD`。 - 如果变量 `PARAMETER` 没有被设置或者是空值，那么该表达式的值为为空字符串。 在这种情况下，`${PARAMETER:+WORD}` 的作用是在变量 `PARAMETER` 已经被设置并且不是空值时，返回 `WORD`；否则返回空字符串。 EOF A=MMM echo \"1: ${A:+WORD}\" A= echo \"2: ${A:+WORD}\" cat \u003c\u003c-'EOF' ### ${PARAMETER:-WORD} `${PARAMETER:-WORD}` 是一种 bash shell 中的参数扩展语法，它的含义如下： - 如果变量 `PARAMETER` 已经被设置并且不是空值，那么该表达式的值为变量 `PARAMETER` 的值。 - 如果变量 `PARAMETER` 没有被设置或者是空值，那么该表达式的值为 `WORD`。 在这种情况下，`${PARAMETER:-WORD}` 的作用是在变量 `PARAMETER` 未设置或者为空值时提供一个默认值 `WORD`。 EOF echo \"----\" A=MMM echo \"1: ${A:-WORD}\" A= echo \"2: ${A:-WORD}\" cat \u003c\u003c-'EOF' ### ${PARAMETER:=WORD} `${PARAMETER:=WORD}` 是一种 bash shell 中的参数扩展语法，它的含义如下： - 如果变量 `PARAMETER` 已经被设置并且不是空值，那么该表达式的值为变量 `PARAMETER` 的值。 - 如果变量 `PARAMETER` 没有被设置或者是空值，那么该表达式的值为 `WORD`，并且同时将变量 `PARAMETER` 设置为 `WORD` 的值。 在这种情况下，`${PARAMETER:=WORD}` 的作用是在变量 `PARAMETER` 未设置或者为空值时，用默认值 `WORD` 初始化该变量。 EOF echo \"----\" A=MMM echo \"1: ${A:=WORD}\" A= echo \"2: ${A:=WORD}\" ","date":"0001-01-01","objectID":"/tips-of-bash-zsh/:3:0","tags":["utility","bash","zsh"],"title":"Tips of Bash/Zsh","uri":"/tips-of-bash-zsh/"},{"categories":null,"content":"4 will .bash_profile be sourced when executing scripts? .bash_profile gets called when you login and not at restart. ~/.bash_profile is only sourced by bash when started in interactive login mode. When you log in graphically, ~/.profile will be specifically sourced by the script that launches gnome-session (or whichever desktop environment you’re using). So ~/.bash_profile is not sourced at all when you log in graphically. When you open a terminal, the terminal starts bash in (non-login) interactive mode, which means it will source ~/.bashrc. The right place for you to put these environment variables is in ~/.profile, and the effect should be apparent next time you log in. Sourcing ~/.bash_profile from ~/.bashrc is the wrong solution. It’s supposed to be the other way around; ~/.bash_profile should source ~/.bashrc. You also need to enable crond service via sys v / BSD init style system. 当您登录时会调用.bash_profile，而在重新启动时不会调用。只有当 bash 以交互式登录模式启动时，才会通过.bash_profile 进行资源引用。当您通过图形界面登录时，/.profile 将被启动 gnome-session（或您正在使用的其他桌面环境）的脚本特别调用。因此，在图形登录时根本不会调用/.bash_profile。当您打开终端时，终端会以（非登录的）交互模式启动 bash，这意味着它将会引用~/.bashrc。您应该将这些环境变量放在~/.profile 中，下次登录时效果应该就会显现出来。从~/.bashrc 中引用~/.bash_profile 是错误的解决方案。正确的做法是相反的；/.bash_profile 应该引用/.bashrc。您还需要通过 sys v / BSD init 样式系统来启用 crond 服务。 ","date":"0001-01-01","objectID":"/tips-of-bash-zsh/:4:0","tags":["utility","bash","zsh"],"title":"Tips of Bash/Zsh","uri":"/tips-of-bash-zsh/"},{"categories":null,"content":" Table of Contents 1 Introduction 2 Related Work 2.1 Storage Layouts 2.2 Bit-(Un)Packing 3 SIMD-Friendly Bit-(Un)Packing 4 Composable Functions 5 Composable Compression Schemes 本文为摘录(或转载)，侵删，原文为： attachments/pdf/a/Towards a New File Format for Big Data - SIMD-Friendly Composable Compression (2020-AzimAfroozeh).pdf ","date":"0001-01-01","objectID":"/towards-a-new-file-format-for-big-data-simd-friendly-composable-compression-2020-azimafroozeh/:0:0","tags":["simd","compression"],"title":"Towards a New File Format for Big Data - SIMD-Friendly Composable Compression","uri":"/towards-a-new-file-format-for-big-data-simd-friendly-composable-compression-2020-azimafroozeh/"},{"categories":null,"content":"1 Introduction ","date":"0001-01-01","objectID":"/towards-a-new-file-format-for-big-data-simd-friendly-composable-compression-2020-azimafroozeh/:1:0","tags":["simd","compression"],"title":"Towards a New File Format for Big Data - SIMD-Friendly Composable Compression","uri":"/towards-a-new-file-format-for-big-data-simd-friendly-composable-compression-2020-azimafroozeh/"},{"categories":null,"content":"2 Related Work ","date":"0001-01-01","objectID":"/towards-a-new-file-format-for-big-data-simd-friendly-composable-compression-2020-azimafroozeh/:2:0","tags":["simd","compression"],"title":"Towards a New File Format for Big Data - SIMD-Friendly Composable Compression","uri":"/towards-a-new-file-format-for-big-data-simd-friendly-composable-compression-2020-azimafroozeh/"},{"categories":null,"content":"2.1 Storage Layouts 2.1.1 NSM 传统上，在数据库系统中，表格数据通常按照磁盘页的起始行逐行存储。这种存储方式被称为 N-ary 存储模型（NSM）。如图 2.1 所示，如果元组大小是可变的，NSM 可能会在页面末尾使用偏移表来定位每个元组的起始位置。此外，每个元组都以元组头（RH）开头，包含有关元组的信息。RH 以空位图开头，用于支持空值；以偏移量开头，用于支持可变属性的变量长度值；以及其他实现特定的细节，以使布局更加灵活。 2.1.2 DSM 这段文字介绍了分解存储模型（DSM）和它与非分解存储模型（NSM）的比较。DSM 将数据按列存储，只提供需要的属性。与 NSM 相比，DSM 提供更高效的缓存利用，因为属性值聚集在一起。此外，由于相邻元组的相似性，DSM 相比 NSM 提供更多的压缩机会。 2.1.3 PAX 这段文字介绍了在处理在线分析处理（OLAP）工作负载时，DSM 是更好的模型。但是，如果需要重构整个元组，DSM 会产生性能开销，因为需要在运行时显式地进行元组重构。Ailamaki 等人提出了“跨分区属性”（PAX）技术，该技术结合了 DSM 的元组间空间局部性和 NSM 的低元组重构成本。PAX 将元组的所有属性存储在同一个页面中。但是，在页面内，PAX 按列存储所有属性。 ","date":"0001-01-01","objectID":"/towards-a-new-file-format-for-big-data-simd-friendly-composable-compression-2020-azimafroozeh/:2:1","tags":["simd","compression"],"title":"Towards a New File Format for Big Data - SIMD-Friendly Composable Compression","uri":"/towards-a-new-file-format-for-big-data-simd-friendly-composable-compression-2020-azimafroozeh/"},{"categories":null,"content":"2.2 Bit-(Un)Packing 32 位系统架构中，整数通常使用 32 位存储，尽管可能可以使用更少的位来存储它们。例如，具有值为 70（0b1000110）的 32 位整数可以使用 7 位而不是 32 位进行存储。一般来说，在[0，2b]范围内的整数可以使用 b 位编码并连接成一个单独的位字符串。这个过程被称为 位填充 (bit-packing) 。反向操作，即将位字符串转换回可由机器寻址的整数数组的操作被称为 位取消填充 , bit-unpacking 。位取消填充可以使用五个简单的操作（加载、移位、与、或和存储）来提取每个整数，如图 2.3 所示。 在将 32 位数据加载到 CPU 寄存器中之后，使用右移操作将期望的位放置到寄存器的开头。此外，使用预定义的掩码寄存器进行按位 AND 操作（用 0 表示随机位，用 1 表示期望的位），可以将具有任意值的位更改为 0。这种实现效率高，因为它不涉及任何分支。 Bit Alignment: 2.2.1 Vectorized Bit-Unpacking Willhaml 等提出了一个方法来通过 SIMD 来批量 bitunpack: 16-Byte Alignment: 通过 128 位的 SIMD aligned load 从内存中加载 128-bit 的数据 使用一个 128 位的 SIMD 对齐加载指令从内存中加载 128 位的数据。对于一些位宽值，比如 9，第一个整数值可能不完全加载，因为它跨越了两个 128 位的寄存器。为了处理这些情况，作者更喜欢使用一个 128 位 SIMD 寄存器串联指令，而不是 128 位 SIMD 不对齐加载指令，因为 SIMD 不对齐的指令在旧处理器上的计算成本高昂。 4-Byte Alignment: four compressed integer values are copied to four separate 32-bit lanes in a new register using a SIMD shuffle mask instruction. 使用 SIMD 洗牌掩码指令将四个压缩整数值复制到新寄存器中的四个独立的 32 位通道。 Bit Alignment: 通过将每个语段任意移动几次，通过 SIMD 乘以四个不同整数和一个 SIMD 右移指令将最后一个寄存器中的四个整数的每个语段的第一位对齐。 然而，Willhalm 等人的方法仅适用于 SSE，无法扩展到 AVX2，因为 Shuffle 指令无法跨所有 lane 移动字节。 Polychroniou 等人提出了一项更改，以调整 Willhalm 等人的方法以适用于 AVX2（33）。为了模拟 256 位跨 lane Shuffle，我们可以将寄存器的每个半段（128 位）复制到两个半段，并使用常规的 256 位 Shuffle。此外，Willhalm 等人将他们的位解压实现翻译为英特尔 AVX2 指令（34）。在 Willhalm 的新实现中，模拟的移位操作被 AVX2 矢量-矢量移位指令所取代。此外，与他们之前的实现相反，新的实现使用非对齐加载指令而不是对齐加载指令，因为他们声称对于当前架构，这个指令比对齐加载指令更快。只有在数据加载分裂跨越缓存线时才会有性能损失，这被其他情况下的减少所分摊。 除了水平布局（即连续存储元组）外，Schlegel 等人提出了一种称为垂直布局的替代布局（2）。在 k-垂直布局中，k个连续的位压缩元组存储在不同的存储字中。 图 2.4 显示了一个 4 路垂直布局的示例，其中每个数字表示序列中整数的位置。可以看到，每 4 个连续整数分布在 4 个不同的字中。垂直布局使我们能够使用单个加载/存储 SIMD 指令加载/存储压缩数据，而无需使用置换指令将元组分配到 SIMD lane 中。Lemire 等人使用 4 路垂直布局使用相同的位宽位压缩 128 个元组，以利用 SSE SIMD 指令（35）。 ","date":"0001-01-01","objectID":"/towards-a-new-file-format-for-big-data-simd-friendly-composable-compression-2020-azimafroozeh/:2:2","tags":["simd","compression"],"title":"Towards a New File Format for Big Data - SIMD-Friendly Composable Compression","uri":"/towards-a-new-file-format-for-big-data-simd-friendly-composable-compression-2020-azimafroozeh/"},{"categories":null,"content":"3 SIMD-Friendly Bit-(Un)Packing In this chapter we present our 1024-bit interleaved bit-(un)packing technique. As discussed in Section 2.2.1, the most efficient Bit-(un)packing approach is proposed by Lemire et al. (35), which uses a 4-way vertical layout. 在本章中，我们介绍了我们的 1024 位交错位（非）打包技术。正如第 2.2.1 节所讨论的那样，Lemire 等人（35）提出了最有效的位（非）打包方法，采用 4 路垂直布局。 ","date":"0001-01-01","objectID":"/towards-a-new-file-format-for-big-data-simd-friendly-composable-compression-2020-azimafroozeh/:3:0","tags":["simd","compression"],"title":"Towards a New File Format for Big Data - SIMD-Friendly Composable Compression","uri":"/towards-a-new-file-format-for-big-data-simd-friendly-composable-compression-2020-azimafroozeh/"},{"categories":null,"content":"4 Composable Functions ","date":"0001-01-01","objectID":"/towards-a-new-file-format-for-big-data-simd-friendly-composable-compression-2020-azimafroozeh/:4:0","tags":["simd","compression"],"title":"Towards a New File Format for Big Data - SIMD-Friendly Composable Compression","uri":"/towards-a-new-file-format-for-big-data-simd-friendly-composable-compression-2020-azimafroozeh/"},{"categories":null,"content":"5 Composable Compression Schemes ","date":"0001-01-01","objectID":"/towards-a-new-file-format-for-big-data-simd-friendly-composable-compression-2020-azimafroozeh/:5:0","tags":["simd","compression"],"title":"Towards a New File Format for Big Data - SIMD-Friendly Composable Compression","uri":"/towards-a-new-file-format-for-big-data-simd-friendly-composable-compression-2020-azimafroozeh/"},{"categories":null,"content":" Table of Contents 1 INTRODUCTION 2 DESIGN AND METHODOLOGY 本文为摘录(或转载)，侵删，原文为： attachments/pdf/6/p2613-guagliardo.pdf ","date":"0001-01-01","objectID":"/p2613-guagliardo/:0:0","tags":null,"title":"Troubles with Nulls, Views from the Users","uri":"/p2613-guagliardo/"},{"categories":null,"content":"1 INTRODUCTION NULL 用于表示不完整的数据 ","date":"0001-01-01","objectID":"/p2613-guagliardo/:1:0","tags":null,"title":"Troubles with Nulls, Views from the Users","uri":"/p2613-guagliardo/"},{"categories":null,"content":"2 DESIGN AND METHODOLOGY ","date":"0001-01-01","objectID":"/p2613-guagliardo/:2:0","tags":null,"title":"Troubles with Nulls, Views from the Users","uri":"/p2613-guagliardo/"},{"categories":null,"content":" Table of Contents 1 ABSTRACT 2 INTRODUCTION 本文为摘录(或转载)，侵删，原文为： attachments/pdf/7/p3402-wang.pdf ","date":"0001-01-01","objectID":"/p3402-wang/:0:0","tags":["optimization","ai"],"title":"UDO: Universal Database Optimization using Reinforcement Learning","uri":"/p3402-wang/"},{"categories":null,"content":"1 ABSTRACT UDO: Universal Database Optimization, 通用数据库优化 为数据库的某种工作负载所做的特殊优化 包含多种调优：从索引选择到系统参数 基于强化学习 达到近似优化配置 创建不同的配置，并通过实际执行评估不同的配置的效果 而不是简单的代价模型 ","date":"0001-01-01","objectID":"/p3402-wang/:1:0","tags":["optimization","ai"],"title":"UDO: Universal Database Optimization using Reinforcement Learning","uri":"/p3402-wang/"},{"categories":null,"content":"2 INTRODUCTION 迭代模型 选择配置 创建 评估 迭代 增强学习 用来决定后续使用哪个配置 ","date":"0001-01-01","objectID":"/p3402-wang/:2:0","tags":["optimization","ai"],"title":"UDO: Universal Database Optimization using Reinforcement Learning","uri":"/p3402-wang/"},{"categories":null,"content":" Table of Contents 1 ulimit 是做什么的 2 ulimit 从哪里读取配置文件 3 How PAM Modules related to /etc/security/limit.d/*.conf 本文为摘录(或转载)，侵删，原文为： https://mydbops.wordpress.com/2017/12/10/ulimit-conflict-with-pam-and-systemd%E2%80%8B%E2%80%8B%E2%80%8B/#content ","date":"0001-01-01","objectID":"/ulimit-conflict-with-pam-and-systemd/:0:0","tags":["ulimit","pam"],"title":"Ulimit conflict with PAM and Systemd","uri":"/ulimit-conflict-with-pam-and-systemd/"},{"categories":null,"content":"1 ulimit 是做什么的 User limits command, limit the use of system-wide resources. ","date":"0001-01-01","objectID":"/ulimit-conflict-with-pam-and-systemd/:1:0","tags":["ulimit","pam"],"title":"Ulimit conflict with PAM and Systemd","uri":"/ulimit-conflict-with-pam-and-systemd/"},{"categories":null,"content":"2 ulimit 从哪里读取配置文件 从下面的文件、目录中读取配置文件 /etc/security/limits.conf /etc/security/limits.d/*.conf 默认从前者读取，然后用后面的文件中读取来覆盖前者。 目录 etc/security/limits.d 中的文件，按照 C locale 的顺序来读取、解析并应用 ","date":"0001-01-01","objectID":"/ulimit-conflict-with-pam-and-systemd/:2:0","tags":["ulimit","pam"],"title":"Ulimit conflict with PAM and Systemd","uri":"/ulimit-conflict-with-pam-and-systemd/"},{"categories":null,"content":"3 How PAM Modules related to /etc/security/limit.d/*.conf The pam_limits PAM module sets limits on the system resources that can be obtained in a user session. When accessing a system via ssh through sshd the /etc.pam.d/sshd policy file is consulted. ","date":"0001-01-01","objectID":"/ulimit-conflict-with-pam-and-systemd/:3:0","tags":["ulimit","pam"],"title":"Ulimit conflict with PAM and Systemd","uri":"/ulimit-conflict-with-pam-and-systemd/"},{"categories":null,"content":" Table of Contents 1 Why quantum computing 本文为摘录(或转载)，侵删，原文为： attachments/pdf/0/Understanding Quantum Technologies Olivier Ezratty.pdf ","date":"0001-01-01","objectID":"/understanding-quantum-technologies-olivier-ezratty/:0:0","tags":null,"title":"Understanding Quantum Technologies","uri":"/understanding-quantum-technologies-olivier-ezratty/"},{"categories":null,"content":"1 Why quantum computing to solve complex problems that are and will stay inaccessible to classical computers. problems whose solutions scale exponentially in computing time on classical machines. ","date":"0001-01-01","objectID":"/understanding-quantum-technologies-olivier-ezratty/:1:0","tags":null,"title":"Understanding Quantum Technologies","uri":"/understanding-quantum-technologies-olivier-ezratty/"},{"categories":null,"content":" Table of Contents 1 ABSTRACT 2 INTRODUCTION 3 LIBRARY OVERVIEW 4 USE CASES 5 DEEP DIVE 5.1 TODO Type System 5.2 Vectors 5.3 Expression Eval 5.4 Functions 5.5 Operators 5.6 Memory Management 本文为摘录(或转载)，侵删，原文为： attachments/pdf/8/p3372-pedreira.pdf ","date":"0001-01-01","objectID":"/p3372-pedreira/:0:0","tags":["vectorization","engine"],"title":"Velox: Meta’s Unified Execution Engine","uri":"/p3372-pedreira/"},{"categories":null,"content":"1 ABSTRACT Velox: C++ database acceleration library 用来： 构建执行引擎 应对复杂数据类型 增强数据管理系统 (enhance data management system) 倚赖： 向量化 (vectorization) 自适应 (adaptivity) Meta 内部已经或正在将其与其他组件集成，包括： 分析型查询引擎 Presto Spark 流处理平台 消息总线 数据仓库 机器学习 PyTorch ","date":"0001-01-01","objectID":"/p3372-pedreira/:1:0","tags":["vectorization","engine"],"title":"Velox: Meta’s Unified Execution Engine","uri":"/p3372-pedreira/"},{"categories":null,"content":"2 INTRODUCTION 仅做计算，无 SQL 解析、优化器等，其价值： 效率 一致性 工程效率 ","date":"0001-01-01","objectID":"/p3372-pedreira/:2:0","tags":["vectorization","engine"],"title":"Velox: Meta’s Unified Execution Engine","uri":"/p3372-pedreira/"},{"categories":null,"content":"3 LIBRARY OVERVIEW 是什么 开源 C++ 数据库加速库 可用来加速、扩展和增强数据的计算引擎： 高性能计算 可重用 可扩展 不是什么 无语法前端 SQL 解析 全局优化等 也就意味着： Velox 的输入是 已经优化好的执行计划 将执行计划在本地执行 Velox 的组件 ","date":"0001-01-01","objectID":"/p3372-pedreira/:3:0","tags":["vectorization","engine"],"title":"Velox: Meta’s Unified Execution Engine","uri":"/p3372-pedreira/"},{"categories":null,"content":"4 USE CASES ","date":"0001-01-01","objectID":"/p3372-pedreira/:4:0","tags":["vectorization","engine"],"title":"Velox: Meta’s Unified Execution Engine","uri":"/p3372-pedreira/"},{"categories":null,"content":"5 DEEP DIVE ","date":"0001-01-01","objectID":"/p3372-pedreira/:5:0","tags":["vectorization","engine"],"title":"Velox: Meta’s Unified Execution Engine","uri":"/p3372-pedreira/"},{"categories":null,"content":"TODO 5.1 Type System TypeSystem 用于表示各种数据类型： 原生类型 整形 不同精度的浮点数类型 字符串 varchar varbinary 日期 时间戳 函数 （lambda 表达式） 复杂类型 数组 固定长度的数组 maps rows, structs 上述类型可以嵌套，并序列化、反序列化 还可以包装 C++ 的结构体 支持类型扩展： Find How???? ","date":"0001-01-01","objectID":"/p3372-pedreira/:5:1","tags":["vectorization","engine"],"title":"Velox: Meta’s Unified Execution Engine","uri":"/p3372-pedreira/"},{"categories":null,"content":"5.2 Vectors Vectors 用来表示列式数据 列式、编码后的数据 用作组件之间的输入和输出 扩展自 Apache Arrow 格式，扩展包括 size （行数） type null bitmap 可嵌套 Velox Buffers 从内存池中分配出的连续空间 Vector 保存在 Velox buffers 中 引用计数 Buffer 和 Vector 都有引用计数 一个 buffer 可以被多个 Vector 引用 只有引用计数为 1 的数据是可变的 shared vector 和 buffer 可通用 copy-on-write 技术变成可写 5.2.1 Arrow Comparison ","date":"0001-01-01","objectID":"/p3372-pedreira/:5:2","tags":["vectorization","engine"],"title":"Velox: Meta’s Unified Execution Engine","uri":"/p3372-pedreira/"},{"categories":null,"content":"5.3 Expression Eval 表达式计算引擎，可用作 过滤投影算子 – 用于过滤和投影表达式 TableScan 和 IO connectors: 过滤条件下推 用作单独的计算组件：计算表达式 使用 Expression Tree 用作输入 树的每个节点可能是 input column 常量 函数调用，由函数名和一系列的参数（表达式）构成 CAST 表达式：用于类型转换？ lambda 函数 函数计算分成两个部分： 编译和执行 5.3.1 Compilation 将输入的表达式树转换成为可执行的表达式，若干运行时优化技术： Common Subexpression Elimination Constant Folding Adaptive Conjunct Reordering 5.3.2 Evaluation. ","date":"0001-01-01","objectID":"/p3372-pedreira/:5:3","tags":["vectorization","engine"],"title":"Velox: Meta’s Unified Execution Engine","uri":"/p3372-pedreira/"},{"categories":null,"content":"5.4 Functions 5.4.1 Scalar Functions. 5.4.2 Aggregate Functions ","date":"0001-01-01","objectID":"/p3372-pedreira/:5:4","tags":["vectorization","engine"],"title":"Velox: Meta’s Unified Execution Engine","uri":"/p3372-pedreira/"},{"categories":null,"content":"5.5 Operators 5.5.1 Table Scans, Filter, and Project 5.5.2 Aggregate and Hash Joins. ","date":"0001-01-01","objectID":"/p3372-pedreira/:5:5","tags":["vectorization","engine"],"title":"Velox: Meta’s Unified Execution Engine","uri":"/p3372-pedreira/"},{"categories":null,"content":"5.6 Memory Management 5.6.1 Caching ","date":"0001-01-01","objectID":"/p3372-pedreira/:5:6","tags":["vectorization","engine"],"title":"Velox: Meta’s Unified Execution Engine","uri":"/p3372-pedreira/"},{"categories":null,"content":" Table of Contents 1 Abstract 2 System Overview 2.1 Storage layout. 本文为摘录(或转载)，侵删，原文为： attachments/pdf/7/sigmod-xengine.pdf ","date":"0001-01-01","objectID":"/sigmod-xengine/:0:0","tags":["LSM","xengine"],"title":"X-Engine: An optimized storage engine for TP","uri":"/sigmod-xengine/"},{"categories":null,"content":"1 Abstract 在线电商交易具有三个显著特点： 随着主要销售和促销活动的开始，每秒交易数量急剧增加； 大量的热门记录很容易压垮系统缓冲区； 由于不同类别的促销在不同的短时间内可用，不同记录的“温度”（热、温、冷）会快速转换。 为了解决这些挑战，阿里巴巴引入了一种名为 X-Engine 的新的存储引擎，它是 POLARDB 的一种优化的写入存储引擎。它采用分层存储体系结构和 LSM 树（日志结构合并树）来利用硬件加速，例如 FPGA 加速压实，并提供一系列优化，包括事务中的异步写入、多阶段管道和压实期间的增量缓存替换。评估结果表明，X-Engine 在此类事务负载下表现出更高的性能。 为了提高系统性能，需要充分发掘内存层次结构（包括 RAM、SSD 和 HDD）提供的容量。 X-Engine 采用分层存储的方案，根据数据的访问频率，把数据存储在不同的存储层中，并利用新的内存技术（如 NVM）来优化存储效能。同时，该系统采用 LSM-tree 数据结构作为一种天然的分层存储选择，其中包括内存和磁盘两部分。内存部分利用了追加写入方法实现了快速插入，而磁盘部分则采取不同层次构建树形结构，以更好地应对海啸和洪水般的数据量。本文还指出，单一的加速写入方法无法满足电子商务交易的需求，需要结合各种优化技术，选用适合复杂读写混合负载的数据结构来处理数据。 The fast-moving current problem. “快速移动的当前问题”。 热门记录往往在一个稳定的时间段内表现出强烈的空间局部性。然而，在诸如“双十一”购物节这样的大型促销活动中，热门记录的空间局部性常常会随着时间迅速发生变化。这是因为不同商品或记录会被不同的促销活动吸引，出现在不同的时间段内。文章举例说明，每天会有“秒杀”活动，用于刺激需求和吸引顾客在不同的商品上消费，而这些商品则会在不同的时间段内随机推出。因此，数据库缓存中的热门记录会不断变化，任何记录的温度都可能迅速从冷/温转变为热或从热转变为冷/温。如果把数据库缓存看作水库，把底层（大型）数据库看作海洋，这种现象就会导致一种“潮流”（即热门与冷门记录的变化）。 ","date":"0001-01-01","objectID":"/sigmod-xengine/:1:0","tags":["LSM","xengine"],"title":"X-Engine: An optimized storage engine for TP","uri":"/sigmod-xengine/"},{"categories":null,"content":"2 System Overview X-Engine 是一种基于 LSM-Tree 的存储引擎，用于处理阿里巴巴电商平台面临的挑战。 它利用多核处理器的线程级并行性（TLP）在主内存中处理大多数请求， 并将写操作解耦，使其异步化，并将长的写操作路径分解为多个阶段以提高整体吞吐量。 为了解决大流量问题，X-Engine 采用分层存储方法，利用优化的 LSM-Tree 结构和算法移动记录。 将 FPGA 适用于压缩。 最后，为了解决快速移动的当前问题，引入了多版本元数据索引，并采用写时复制的方式更新，以加速点查找操作。 ","date":"0001-01-01","objectID":"/sigmod-xengine/:2:0","tags":["LSM","xengine"],"title":"X-Engine: An optimized storage engine for TP","uri":"/sigmod-xengine/"},{"categories":null,"content":"2.1 Storage layout. 图 2 展示了 X-Engine 的体系结构。 X-Engine 将每个表分成多个子表，并为每个子表维护 LSM 树、相关的元快照和索引。 X-Engine 包含每个数据库实例一个重做日志。 每个 LSM 树由一个热数据层和一个暖/冷数据层组成，分别驻留在主内存和 NVM/SSD/HDD 上（这些层级进一步分成不同的级别），其中: 热、暖和冷是指数据温度，表示应该放置于相应层级的数据的理想访问频率。 热数据层包含一个活跃的内存表和多个不可变的内存表，它们存储最近插入的记录，并缓存热记录。 暖/冷数据层将数据组织成树形结构 树的每个级别都存储一系列有序的数据块。 一个数据块打包了记录的块和它们关联的过滤器和索引。 ","date":"0001-01-01","objectID":"/sigmod-xengine/:2:1","tags":["LSM","xengine"],"title":"X-Engine: An optimized storage engine for TP","uri":"/sigmod-xengine/"},{"categories":null,"content":" Table of Contents 1 ABSTRACT 2 INTRODUCTION 3 BACKGROUND 3.1 I/O Asymmetry in Flash SSDs 3.2 RAW Protocol in DBMS Buffer 3.3 RAW Protocol in Storage Buffer 4 READ STALL IN DBMS AND RW COMMAND 4.1 Read Stalls inRelational DBMS Buffer 4.2 RW Command 5 READ STALL IN STORAGE AND R-BUF 5.1 Read Stalls in SSD Buffer 本文为摘录(或转载)，侵删，原文为： attachments/pdf/e/p1911-lee.pdf ","date":"0001-01-01","objectID":"/p1911-lee/:0:0","tags":["read","performance","ssd","raw","rw","openssd"],"title":"Your Read is Our Priority in Flash Storage","uri":"/p1911-lee/"},{"categories":null,"content":"1 ABSTRACT 问题： 读阻塞 buffer manager 采用 read-after-write (RAW) 策略 读写速率不同，导致 读阻塞 RAW 分两层： DBMS buffer Storage buffer （硬件层） 方案： RW as new storage interface: fused read and write, RW, 读写融合 buffermgr 可同时发出读写请求 脏页拷贝到存储 buffer 之后 马上 read R-Buf 分离读写 buffer 效果 RW: tpcc -\u003e 3.2x RW + R-Buf: tpcc -\u003e 3.9x ","date":"0001-01-01","objectID":"/p1911-lee/:1:0","tags":["read","performance","ssd","raw","rw","openssd"],"title":"Your Read is Our Priority in Flash Storage","uri":"/p1911-lee/"},{"categories":null,"content":"2 INTRODUCTION ","date":"0001-01-01","objectID":"/p1911-lee/:2:0","tags":["read","performance","ssd","raw","rw","openssd"],"title":"Your Read is Our Priority in Flash Storage","uri":"/p1911-lee/"},{"categories":null,"content":"3 BACKGROUND ","date":"0001-01-01","objectID":"/p1911-lee/:3:0","tags":["read","performance","ssd","raw","rw","openssd"],"title":"Your Read is Our Priority in Flash Storage","uri":"/p1911-lee/"},{"categories":null,"content":"3.1 I/O Asymmetry in Flash SSDs SSD 读写非对称： 读快，写慢 MLC 闪存，写一个页面需要 1500us ，而读仅需 50us 闪存的 GC 进一步加剧了这一现象 下表为一个测试结果 （FIO） OpenSSD is a solid-state drive which does not have a firmware Flash Translation Layer implemented on the device relies on OS to manage of the physical solid-state storage more flexibility with regard to: data placement decisions, overprovisioning, scheduling, garbage collection and wear leveling ","date":"0001-01-01","objectID":"/p1911-lee/:3:1","tags":["read","performance","ssd","raw","rw","openssd"],"title":"Your Read is Our Priority in Flash Storage","uri":"/p1911-lee/"},{"categories":null,"content":"3.2 RAW Protocol in DBMS Buffer ","date":"0001-01-01","objectID":"/p1911-lee/:3:2","tags":["read","performance","ssd","raw","rw","openssd"],"title":"Your Read is Our Priority in Flash Storage","uri":"/p1911-lee/"},{"categories":null,"content":"3.3 RAW Protocol in Storage Buffer S-Buf Shared buffer, for both read \u0026 write SSD architecture ","date":"0001-01-01","objectID":"/p1911-lee/:3:3","tags":["read","performance","ssd","raw","rw","openssd"],"title":"Your Read is Our Priority in Flash Storage","uri":"/p1911-lee/"},{"categories":null,"content":"4 READ STALL IN DBMS AND RW COMMAND ","date":"0001-01-01","objectID":"/p1911-lee/:4:0","tags":["read","performance","ssd","raw","rw","openssd"],"title":"Your Read is Our Priority in Flash Storage","uri":"/p1911-lee/"},{"categories":null,"content":"4.1 Read Stalls inRelational DBMS Buffer the read stall problem can be alleviated or even disappear with a large buffer PG: 会下降的更多： 61% 4.1.1 Problem Definition 数据库 buffer 层的 write-then-read ，阻挡了使用底层异步并行优化 （libaio or io_uring） ","date":"0001-01-01","objectID":"/p1911-lee/:4:1","tags":["read","performance","ssd","raw","rw","openssd"],"title":"Your Read is Our Priority in Flash Storage","uri":"/p1911-lee/"},{"categories":null,"content":"4.2 RW Command 4.2.1 Key Idea. new block I/O command: RW write a dirty page to storage, and in parallel, read the missingpage to the host in on I/O call. 4.2.2 Abstraction and Architecture. 当前存储接口中不存在这样的命令， 作者将 RW 作为 NVME vendor specific command 添加 rw(rdLBA, wrLBA, len, buf) rdLBA/wrLBA: 读写操作的逻辑块地址 len: 两个页面的大小 （假设相等） buf: host buffer 虚地址 当主机向控制器发出 RW 命令后， NVME Controller 并行处理 READ 和 WRITE 将与 wrLBA 相关的脏页拷贝进控制器缓存 （storage buffer） 马上读取 rdLBA 好处 存储控制器内部可以并行 减少 SYSCALL 和 IO 中断 Consistency and Durability 4.2.3 Prototype Implementation 向 OpenSSD 添加了新的 RW 命令，并扩展固件代码来支持这一语义。 Changes in OpenSSD 使用 OpenSSD OpenSSD 可以自由修改软件和硬件设计 使用了 Comos+ board, 该板支持 NVMe 接口 定义了新的 opcode 固件上实现了自定义操作 固件的读写地址不同，可以利用 SSD 的多通道特性来实现并行 Changes in MySQL 直接使用 VFS 接口的话，不会有提升 扩展 ioctl 使之可以掠过 VFS 直接发送 RW 命令 修改了 MySQL 的 buffer manager 添加新的 IO 函数， buffer manager 可通过该函数来： 获取 read write 的 LBA 发送 RW 命令 修改了 MySQL 的 read 函数： read 返回后当前事务可以直接进行，而无需再申请 buffer （通过操作 LRU list） ","date":"0001-01-01","objectID":"/p1911-lee/:4:2","tags":["read","performance","ssd","raw","rw","openssd"],"title":"Your Read is Our Priority in Flash Storage","uri":"/p1911-lee/"},{"categories":null,"content":"5 READ STALL IN STORAGE AND R-BUF ","date":"0001-01-01","objectID":"/p1911-lee/:5:0","tags":["read","performance","ssd","raw","rw","openssd"],"title":"Your Read is Our Priority in Flash Storage","uri":"/p1911-lee/"},{"categories":null,"content":"5.1 Read Stalls in SSD Buffer 5.1.1 Problem Definition ","date":"0001-01-01","objectID":"/p1911-lee/:5:1","tags":["read","performance","ssd","raw","rw","openssd"],"title":"Your Read is Our Priority in Flash Storage","uri":"/p1911-lee/"},{"categories":null,"content":"https://motherduck.com/blog/big-data-is-dead/ 谷歌的大数据工程师乔丹·蒂加尼 （Jordan Tigani），最近直言不讳地说：“大数据已死”。 他认为，大数据时代已经结束了，大数据的存储和分析，作为一个技术问题已经解决了。 用户已经不必担心数据大小了，再多的数据都不是问题。 他提出了\"大数据已死\"的6个理由，我觉得很有说服力，下面就跟大家分享。 （1）绝大多数企业到不了大数据级别。 企业的数据量往往不到 1TB，很多甚至不到 100GB。 假设一家中等规模的制造业公司，拥有1000个客户，每个客户每天产生一个订单，每个订单包含100个产品。这家公司一天产生的数据量，依然远远小于 1 MB。三年后，数据总量也只有 1 GB，达到 1 TB 需要几千年。 就算是大型互联网公司，大多数时候也到不了大数据级别。假设某个营销活动有100万用户参加，并且同一时间，该公司开展了几十个这样的营销活动，每天的数据量依然不足 1 GB，就算加上各种日志，可能也只有几个 GB，这跟大数据相差甚远。 （2）存储和计算正在分离。 大数据包含\"数据存储\"和\"数据计算\"两个方面，如果放在一个系统里面处理，确实很难。 但是，这两方面现在已经能够脱钩，变成两个独立系统，各自都能独立扩展。这意味着，“数据计算\"不受\"数据存储”（数据库大小）的限制，反之依然。 因此，大数据作为单一问题就不存在了，变成了海量存储和大型计算两个问题。 （3）没有新业务的情况下，数据是线性增长的， 即每天的新增数据与以前的数据结构相同。 以前的数据一旦写入数据库，通常就不再发生变化，也没有新的计算需求，相关计算在以前就完成了。这时只要对最近的新增数据进行单独计算，然后保存就可以了。你很少需要每天扫描一遍旧数据：那些数据一成不变，为什么要一遍一遍计算它们呢？ 因此，对于一家企业来说，“数据会指数式增长\"这个假设并不成立。而且，数据计算的需求，其实比数据存储的需求小得多，因为老数据很少需要再次计算。 （4）人们看重的往往只是最近的数据。最频繁的查询是针对24小时内产生的数据，一周前的数据的查询可能性要低20倍，一个月前的历史数据只会偶尔被查询。 这意味着，大数据更像静态数据，而不完全是动态数据。既然以前的数据很少用到，那么就可以压缩保存。一个包含10年数据的表格，可能会达到 PB 级别，但是如果压缩保存历史数据，压缩后可能不到 50 GB。 （5）真正拥有大数据的公司，几乎从不查询全部数据。他们90%的查询涉及的数据少于 100 MB，涉及 TB 级别数据的查询非常少。 就算查询 TB 级别数据，查询性能的优先级往往并不高。等一个周末或几天才拿到结果，通常是可以接受的。 另外，大型数据集的查询非常昂贵。谷歌的 BigQuery 的 PB 级别查询报价是 5,000 美元，即使是大公司也不会经常使用。 （6）硬件的飞速发展，使得单台计算机的计算能力大增。 2004年，谷歌发表 MapReduce 论文时，单机的计算能力还比较弱，很多计算必须通过分布式完成。 2006年，AWS 推出了 EC2 云主机，你只能用到一个单核 CPU 和 2 GB 内存。今天，AWS 的标准实例具有64个内核和 256 GB 内存。如果愿意多花钱，还可以拿到445个内核和超过 24 TB 内存。 单机计算能力大大增强，意味着大数据的最大难点-—分布式计算-—即使被用到，困难程度也大大降低。 综上所述，结论就是：数据量已经不需要特别关注了，再也不必担心处理不了海量数据了。 大数据作为一个技术问题，已经解决了。 ","date":"0001-01-01","objectID":"/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%B7%B2%E6%AD%BB/:0:0","tags":["bigdata","tag2"],"title":"大数据已死","uri":"/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%B7%B2%E6%AD%BB/"},{"categories":null,"content":"本文为摘录(或转载)，侵删，原文为： https://mp.weixin.qq.com/s/xf7qb4oAVHyi4_U32FSKPA ","date":"0001-01-01","objectID":"/%E5%85%A8%E6%96%B9%E4%BD%8D%E5%AF%B9%E6%AF%94-postgres-%E5%92%8C-mysql.org/:0:0","tags":null,"title":"全方位对比 Postgres 和 MySQL","uri":"/%E5%85%A8%E6%96%B9%E4%BD%8D%E5%AF%B9%E6%AF%94-postgres-%E5%92%8C-mysql.org/"},{"categories":null,"content":"本文为摘录(或转载)，侵删，原文为： http://www.ruanyifeng.com/blog/2023/05/weekly-issue-254.html 大家可能听说过\"水桶原理\"：水桶的容量由最短的那块木板决定。 它的意思是，某些系统的关键，不在于发展最强点，而在于避免最弱点。99%的地方都没有问题，只要 1%的地方出现问题，整个系统就会失败。 人体健康就是这样，有一个器官出现严重问题，哪怕其他器官完全正常，生活甚至生命就会受到影响。 这类由短板决定的问题，统称为\"短板问题\"。日常生活有很多这样的例子，除了人体健康，还有食品安全，只要有一样成份不干净，你可能就会食物中毒。 汽车、电视机、手机等消费品也是这样，只要有一个部件不合格，这个产品就有质量问题。 但是，这不是今天的主题。我最近读到一篇文章，才意识到除了短板问题，还有长板问题。 “长板问题\"指的是，问题的关键不在于最弱点，而在于最强点。 只要有一个点特别出色，这件事情就成功了，其他点的好坏无所谓。 文艺作品就属于这种情况。你购买了一张专辑，其他的歌曲都不爱听，但是有一首歌你特别喜欢，这张专辑就值得了。电影和小说只要有一个角色或情节特别打动人，作品就成功了。 风险投资也是这样，只要投了一个特别成功的项目，就能把所有损失补回来。 最重要的是，人生就是一个\"长板问题”。 一生中，失败和挫折其实不重要，多少次都不重要，只要有一次大的成功，人生就成功了。 最大的那一次成功，决定了你一生的成就和高度。很多诺贝尔奖得主，一生就做出了一个重要的科学发现，就足够成为伟大科学家了。 程序员写过多少代码不重要，只要创造过一个重大影响力的软件，职业生涯就成功了。 我们必须学会区分\"短板问题\"和\"长板问题\"，它们的解决方法完全不同。 短板问题的解决，需要盯着薄弱环节，补齐最短的那块板；长板问题的解决，只需要推进最强的环节，不要在乎别的。 人生不必在乎那些不重要的事情，没必要为了挫折和拒绝而沮丧，都会过去的。你要做的是向前看，拼命争取一次大的成功，让它足够大、更大，只要一次就够了。 ","date":"0001-01-01","objectID":"/weekly-issue-254/:0:0","tags":null,"title":"人生是一个长板问题","uri":"/weekly-issue-254/"},{"categories":null,"content":"围在城里的人想逃出来， 城外的人想冲进去， 对婚姻也罢，职业也罢，人生的愿望大都如此。 ","date":"0001-01-01","objectID":"/%E5%9B%B4%E5%9F%8E%E6%91%98%E6%8A%84/:0:0","tags":["note","ireader","novel"],"title":"围城摘抄","uri":"/%E5%9B%B4%E5%9F%8E%E6%91%98%E6%8A%84/"},{"categories":null,"content":"1 一 眼睛两条斜缝，眉毛高高在上，跟眼睛远隔得彼此要害相思病。 只有国文是国货土产，还需要外国招牌，方可维持地位，正好像中国官吏、商人在本国剥削来的钱要换外汇，才能保持国币的原来价值 忠厚老实人的恶毒，像饭里的砂砾或者出骨鱼片里未净的刺，会给人一种不期待的伤痛。 孙太太眼睛红肿，眼眶似乎饱和着眼泪，像夏天早晨花瓣上的露水，手指那么轻轻一碰就会掉下来。 ","date":"0001-01-01","objectID":"/%E5%9B%B4%E5%9F%8E%E6%91%98%E6%8A%84/:1:0","tags":["note","ireader","novel"],"title":"围城摘抄","uri":"/%E5%9B%B4%E5%9F%8E%E6%91%98%E6%8A%84/"},{"categories":null,"content":"2 二 他们俩虽然十分亲密，方鸿渐自信对她的情谊到此而止，好比两条平行的直线，无论彼此距离怎么近，拉得怎么长，终合不拢来成为一体 张太太上海话比丈夫讲得好，可是时时流露本乡土音，仿佛罩褂太小，遮不了里面的袍子。 ","date":"0001-01-01","objectID":"/%E5%9B%B4%E5%9F%8E%E6%91%98%E6%8A%84/:2:0","tags":["note","ireader","novel"],"title":"围城摘抄","uri":"/%E5%9B%B4%E5%9F%8E%E6%91%98%E6%8A%84/"},{"categories":null,"content":"3 三 早晨方醒，听见窗外树上鸟叫，无理由地高兴，无目的地期待，心似乎减轻重量，直升上去。可是这欢喜是空的，像小孩子放的气球，上去不到几尺，便爆裂归于乌有，只留下忽忽若失的无名怅惘。 好比杨花在春风里飘荡，而身轻无力，终飞不远 他把带到银行里偷空看的书翻开，每个字都认识，没一句有意义 诗有出典，给识货人看了，愈觉得滋味浓厚，读着一首诗就联想到无数诗来烘云托月。 从前人不中进士，随你官做得多么大，总抱着终身遗憾。留了学也可以解脱这种自卑心理，并非为高深学问。出洋好比出痘子，出痧子，非出不可。小孩子出过痧痘，就可以安全长大，以后碰见这两种毛病，不怕传染。我们出过洋，也算了了一桩心愿，灵魂健全，见了博士硕士们这些微生虫，有抵抗力来自卫。痘出过了，我们就把出痘这一回事忘了；留过学的人也应说把留学这事忘了。 女子有女子特别的聪明，轻盈活泼得跟她的举动一样。比了这种聪明，才学不过是沉淀渣滓。说女子有才学，就仿佛赞美一朵花，说它在天平上称起来有白菜番薯的斤两。真聪明的女子决不用功要做成才女，她只巧妙的偷懒。 关于 Bertie 结婚离婚的事，我也和他谈过。他引一句英国古话，说结婚仿佛金漆的鸟笼，笼子外面的鸟想住进去，笼内的鸟想飞出来；所以结而离，离而结，没有了局。”苏小姐道：“法国也有这么一句话。不过，不说是鸟笼，说是被围困的城堡 fortresse assiégée，城外的人想冲进去，城里的人想逃出来。 鸿渐身心仿佛通电似的发麻，只知道唐小姐在说自己，没心思来领会她话里的意义，好比头脑里蒙上一层油纸，她的话雨点似的渗不进，可是油纸震颤着雨打的重量。 ","date":"0001-01-01","objectID":"/%E5%9B%B4%E5%9F%8E%E6%91%98%E6%8A%84/:3:0","tags":["note","ireader","novel"],"title":"围城摘抄","uri":"/%E5%9B%B4%E5%9F%8E%E6%91%98%E6%8A%84/"},{"categories":null,"content":"4 四 他个人的天地忽然从世人公共生活的天地里分出来，宛如与活人幽明隔绝的孤鬼，瞧着阳世的乐事，自己插不进，瞧着阳世的太阳，自己晒不到。 有人失恋了，会把他们的伤心立刻像叫化子的烂腿，血淋淋地公开展览，博人怜悯，或者事过境迁，像战士的金疮旧斑，脱衣指示，使人惊佩。鸿渐只希望能在心理的黑暗里隐蔽着，仿佛害病的眼睛避光，破碎的皮肉怕风。 他所说的“让她三分”，不是“三分流水七分尘”的“三分”，而是“天下只有三分月色”的“三分”。 同乡一位庸医是他邻居，仰慕他的名望，杀人有暇，偶来陪他闲谈。这位庸医在本乡真的是“三世行医，一方尽知”，总算那一方人抵抗力强，没给他祖父父亲医绝了种，把四方剩了三方。 ","date":"0001-01-01","objectID":"/%E5%9B%B4%E5%9F%8E%E6%91%98%E6%8A%84/:4:0","tags":["note","ireader","novel"],"title":"围城摘抄","uri":"/%E5%9B%B4%E5%9F%8E%E6%91%98%E6%8A%84/"},{"categories":null,"content":"5 五 你这人真无赖！你倒不说是我自己打鼾，赖在你身上？我只恨当时没法请唱片公司的人把你的声音灌成片子。”假使真灌成片子，那声气哗啦哗啦，又像风涛澎湃，又像狼吞虎咽，中间还夹着一丝又尖又细的声音，忽高忽低，袅袅不绝。有时这一条丝高上去、高上去，细得、细得像放足的风筝线要断了，不知怎么像过一个峰尖，又降落安稳下来。赵辛楣刺激得神经给它吊上去，掉下来，这时候追想起还恨得要扭断鸿渐的鼻子，警告他下次小心。 天仿佛听见了这句话，半空里轰隆隆一声回答，像天宫的地板上滚着几十面铜鼓。从早晨起，空气闷塞得像障碍着呼吸，忽然这时候天不知哪里漏了个洞，天外的爽气一阵阵冲进来，半黄落的草木也自昏沉里一时清醒，普遍地微微叹息，瑟瑟颤动，大地像蒸笼揭去了盖。雨跟着来了，清凉畅快，不比上午的雨只仿佛天空郁热出来的汗。雨愈下愈大，宛如水点要抢着下地，等不及排行分列，我挤了你，你拚上我，合成整块的冷水，没头没脑浇下来。 鸿渐忙叫：“我有个小手电。”打开身上的提箱掏它出来，向地面一射，手掌那么大的一圈黄光，无数的雨线飞蛾见火似的匆忙扑向这光圈里来。孙小姐的大手电雪亮地光射丈余，从黑暗的心脏里挖出一条隧道。 买到票子的那一堆人全上了车，真料不到小车厢会像有弹性，容得下这许多人。这车厢仿佛沙丁鱼罐，里面的人紧紧的挤得身体都扁了。可是沙丁鱼的骨头，深藏在自己身里，这些乘客的肘骨膝骨都向旁人的身体里硬嵌。罐装的沙丁鱼条条挺直，这些乘客都蜷曲波折，腰跟腿弯成几何学上有名目的角度。 这是辆病车，正害疟疾，走的时候，门窗无不发抖，坐在车梢的人更给它震动得骨节松脱、腑脏颠倒，方才吃的粳米饭仿佛在胃里琮跳碰，有如赌场中碗里的骰子。 这时候，有个三四岁的女孩子两手向头发里乱爬，嚷到那胖女店主身边。胖女人一手拍怀里睡熟的孩子，一手替那女孩子搔痒。她手上生的五根香肠，灵敏得很，在头发里抓一下就捉到个虱，掐死了，叫孩子摊开手掌受着，陈尸累累。女孩子把另一手指着死虱，口里乱数：“一，二，五，八，十…… 这是暮秋天气，山深日短，云雾里露出一线月亮，宛如一只挤着的近视眼睛。少顷，这月亮圆滑得什么都粘不上，轻盈得什么都压不住，从蓬松如絮的云堆下无牵挂地浮出来，原来还有一边没满，像被打耳光的脸肿着一边。 ","date":"0001-01-01","objectID":"/%E5%9B%B4%E5%9F%8E%E6%91%98%E6%8A%84/:5:0","tags":["note","ireader","novel"],"title":"围城摘抄","uri":"/%E5%9B%B4%E5%9F%8E%E6%91%98%E6%8A%84/"},{"categories":null,"content":"6 六 鸿渐上图书馆找书，馆里通共不上一千本书，老的、糟的、破旧的中文教科书居其大半，都是因战事而停办的学校的遗产。一千年后，这些书准像敦煌石室的卷子那样名贵，现在呢，它们古而不稀，短见浅识的藏书家还不知道收买。一切图书馆本来像死用功人大考时的头脑，是学问的坟墓；这图书馆倒像个敬惜字纸的老式慈善机关，若是天道有知，办事人今世决不遭雷打，来生一定个个聪明、人人博士。 现代人有两个流行的信仰。第一：女子无貌便是德，所以漂亮女人准比不上丑女人那样有思想，有品节；第二：男子无口才，就表示有道德，所以哑巴是天下最诚朴的人。 不轻易开口的人总使旁人想他满腹深藏着智慧，正像密封牢锁的箱子，一般人总以为里面结结实实都是宝贝。 韩太太虽然相貌丑，红头发，满脸雀斑像面饼上苍蝇下的粪，而举止活泼得通了电似的。鸿渐研究出西洋人丑得跟中国人不同：中国人丑得像造物者偷工减料的结果，潦草塞责的丑；西洋人丑像造物者恶意的表现，存心跟脸上五官开玩笑，所以丑得有计划、有作用。 事实上，一个人的缺点正像猴子的尾巴，猴子蹲在地面的时候，尾巴是看不见的，直到他向树上爬，就把后部供大众瞻仰，可是这红臀长尾巴本来就有，并非地位爬高了的新标识。 我有一个印象，我们在社会上一切说话全像戏院子的入场券，一边印着‘过期作废’，可是那一边并不注明什么日期，随我们的便可以提早或延迟。 宿舍楼上楼下都睡得静悄悄的，脚步就像践踏在这些睡人的梦上，钉铁跟的皮鞋太重，会踏碎几个脆薄的梦。门外地上全是霜。竹叶所剩无几，而冷风偶然一阵，依旧为了吹几片小叶子使那么大的傻劲。虽然没有月亮，几株梧桐树的秃枝骨鲠地清晰。只有厕所前面挂的一盏植物油灯，光色昏浊，是清爽的冬夜上一点垢腻。厕所的气息也像怕冷，缩在屋子里不出来，不比在夏天，老远就放着哨。 刘东方教鸿渐对坏卷子分数批得宽，对好卷子分数批得紧，因为不及格的人多了，引起学生的恶感，而好分数的人太多了，也会减低先生的威望。总而言之，批分数该雪中送炭，万万不能悭吝-–—用刘东方的话说：“一分钱也买不了东西，别说一分分数！”-–—切不可锦上添花，让学生把分数看得太贱，功课看得太容易-–—用刘东方的话说：“给穷人至少要一块钱，那就是一百分，可是给学生一百分，那不可以。” ","date":"0001-01-01","objectID":"/%E5%9B%B4%E5%9F%8E%E6%91%98%E6%8A%84/:6:0","tags":["note","ireader","novel"],"title":"围城摘抄","uri":"/%E5%9B%B4%E5%9F%8E%E6%91%98%E6%8A%84/"},{"categories":null,"content":"7 八 天下只有两种人。譬如一串葡萄到手，一种人挑最好的先吃，另一种人把最好的留在最后吃。照例第一种人应该乐观，因为他每吃一颗都是吃剩的葡萄里最好的；第二种人应该悲观，因为他每吃一颗都是吃剩的葡萄里最坏的。不过事实上适得其反，缘故是第二种人还有希望，第一种人只有回忆 ","date":"0001-01-01","objectID":"/%E5%9B%B4%E5%9F%8E%E6%91%98%E6%8A%84/:7:0","tags":["note","ireader","novel"],"title":"围城摘抄","uri":"/%E5%9B%B4%E5%9F%8E%E6%91%98%E6%8A%84/"},{"categories":null,"content":"8 九 两亲家见过面，彼此请过客，往来拜访过，心里还交换过鄙视，谁也不满意谁。方家恨孙家简慢，孙家厌方家陈腐，双方背后都嫌对方不阔。遯翁一天听太太批评亲家母，灵感忽来。日记上添了精彩的一条，说他现在才明白为什么两家攀亲要叫“结为秦晋”：“夫春秋之时，秦晋二国，世缔婚姻，而世寻干戈。亲家相恶，于今为烈，号曰秦晋，亦固其宜。” 在小乡镇时，他怕人家倾轧，到了大都市，他又恨人家冷淡，倒觉得倾轧还是瞧得起自己的表示。就是条微生虫，也沾沾自喜，希望有人搁它在显微镜下放大了看的。拥挤里的孤寂，热闹里的凄凉，使他像许多住在这孤岛上的人，心灵也仿佛一个无凑畔的孤岛 生存竞争渐渐脱去文饰和面具，露出原始的狠毒。廉耻并不廉，许多人维持它不起。发国难财和破国难产的人同时增加，各不相犯：因为穷人只在大街闹市行乞，不会到财主的幽静住宅区去；只会跟着步行的人要钱，财主坐的流线型汽车是跟不上的。贫民区逐渐蔓延，像市容上生的一块癣，政治性的恐怖事件，几乎天天发生，有志之士被压迫得慢慢像西洋大都市的交通路线，向地下发展，地底下原有的那些阴毒暧昧的人形爬虫，攀附了他们自增声价 他入世多年，明白在一切机关里，人总有人可替，坐位总有人来坐，怄气辞职只是辞职的人吃亏，被辞的职位漠然不痛不痒；人不肯坐椅子，苦了自己的腿，椅子空着不会肚子饿，椅子立着不会腿酸的。 ","date":"0001-01-01","objectID":"/%E5%9B%B4%E5%9F%8E%E6%91%98%E6%8A%84/:8:0","tags":["note","ireader","novel"],"title":"围城摘抄","uri":"/%E5%9B%B4%E5%9F%8E%E6%91%98%E6%8A%84/"},{"categories":null,"content":"9 附录 记钱钟书与《围城》 “假如你吃了个鸡蛋觉得不错，何必认识那下蛋的母鸡呢？ 创作的一个重要成分是想象，经验好比黑暗里点上的火，想象是这个火所发的光；没有火就没有光，但光照所及，远远超过火点儿的大小。创造的故事往往从多方面超越作者本人的经验。要从创造的故事里返求作者的经验是颠倒的。作者的思想情感经过创造，就好比发过酵而酿成了酒；从酒里辨认酿酒的原料，也不容易。 同学中我们受钱钟书的影响最大。他的中英文造诣很深，又精于哲学及心理学，终日博览中西新旧书籍，最怪的是上课时从不记笔记，只带一本和课堂无关的闲书，一面听讲一面看自己的书，但是考试时总是第一，他自己喜欢读书，也鼓励别人读书。……” 小猫知感，钟书说它有灵性，特别宝贝。猫儿长大了，半夜和别的猫儿打架。钟书特备长竹竿一枝，倚在门口，不管多冷的天，听见猫儿叫闹，就急忙从热被窝里出来，拿了竹竿，赶出去帮自己的猫儿打架。 钱家人常说钟书“痴人有痴福”。他作为书痴，倒真是有点痴福。供他阅读的书，好比富人“命中的禄食”那样丰足，会从各方面源源供应（除了下放期间，他只好“反刍”似的读读自己的笔记，和携带的字典）。 兴致也许还有，才气已与年俱减。要想写作而没有可能，那只会有遗恨；有条件写作而写出来的不成东西，那就只有后悔了。遗恨里还有哄骗自己的馀地，后悔是你所学的西班牙语里所谓‘面对真理的时刻’，使不得一点儿自我哄骗、开脱、或宽容的，味道不好受。我宁恨毋悔。 ","date":"0001-01-01","objectID":"/%E5%9B%B4%E5%9F%8E%E6%91%98%E6%8A%84/:9:0","tags":["note","ireader","novel"],"title":"围城摘抄","uri":"/%E5%9B%B4%E5%9F%8E%E6%91%98%E6%8A%84/"}]