<!doctype html><html lang=zh-CH><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><title>StarRocks 技术内幕：查询原理浅析 - 杂货铺</title><meta name=Description content="杂七杂八的，随手记录。"><meta property="og:url" content="https://yangyingchao.github.io/my_oschina_net_blog_5519656/"><meta property="og:site_name" content="杂货铺"><meta property="og:title" content="StarRocks 技术内幕：查询原理浅析"><meta property="og:description" content="Table of Contents 1 从 SQL 文本到执行计划 1.1 SQL Parse 1.2 SQL Analyze 1.3 SQL Logical Plan 1.4 SQL Optimize 1.5 Logical Plan Rewrite 1.6 CBO Transform 1.7 统计信息和 Cost 估计 1.8 生成 Plan fragment 2 执行计划的调度 3 执行计划的执行 3.1 MPP 多机并行执行 3.2 Pipeline 单机并行执行 3.3 向量化执行 4 总结 本文为摘录(或转载)，侵删，原文为： https://my.oschina.net/u/5658056/blog/5519656"><meta property="og:locale" content="zh_CH"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-01-02T00:00:00+00:00"><meta property="article:modified_time" content="2025-01-02T00:00:00+00:00"><meta property="article:tag" content="Starrocks"><meta property="og:image" content="https://yangyingchao.github.io/logo.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://yangyingchao.github.io/logo.png"><meta name=twitter:title content="StarRocks 技术内幕：查询原理浅析"><meta name=twitter:description content="Table of Contents 1 从 SQL 文本到执行计划 1.1 SQL Parse 1.2 SQL Analyze 1.3 SQL Logical Plan 1.4 SQL Optimize 1.5 Logical Plan Rewrite 1.6 CBO Transform 1.7 统计信息和 Cost 估计 1.8 生成 Plan fragment 2 执行计划的调度 3 执行计划的执行 3.1 MPP 多机并行执行 3.2 Pipeline 单机并行执行 3.3 向量化执行 4 总结 本文为摘录(或转载)，侵删，原文为： https://my.oschina.net/u/5658056/blog/5519656"><meta name=application-name content="杂货铺"><meta name=apple-mobile-web-app-title content="杂货铺"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://yangyingchao.github.io/my_oschina_net_blog_5519656/><link rel=prev href=https://yangyingchao.github.io/docs_starrocks_io_features/><link rel=next href=https://yangyingchao.github.io/segmentfault_com_a_1190000042739883/><link rel=stylesheet href=/css/style.min.css><link rel=preload href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css></noscript><link rel=preload href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"StarRocks 技术内幕：查询原理浅析","inLanguage":"zh-CH","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/yangyingchao.github.io\/my_oschina_net_blog_5519656\/"},"image":["https:\/\/yangyingchao.github.io\/images\/Apple-Devices-Preview.png"],"genre":"posts","keywords":"starrocks","wordcount":4429,"url":"https:\/\/yangyingchao.github.io\/my_oschina_net_blog_5519656\/","datePublished":"2025-01-02T00:00:00+00:00","dateModified":"2025-01-02T00:00:00+00:00","publisher":{"@type":"Organization","name":"xxxx","logo":{"@type":"ImageObject","url":"https:\/\/yangyingchao.github.io\/images\/avatar.jpg","width":160,"height":160}},"author":{"@type":"Person","name":"yc"},"description":""}</script></head><body data-header-desktop=fixed data-header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("theme","dark")</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title=杂货铺><span class=header-title-pre><i class='fa-solid fa-house-chimney'></i></span>老杨的杂货铺</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/>所有文章 </a><a class=menu-item href=/tags/>标签 </a><a class=menu-item href=/categories/>分类 </a><a class=menu-item href=https://github.com/yangyingchao title=GitHub rel="noopener noreffer" target=_blank><i class='fab fa-github fa-fw' aria-hidden=true></i> </a><span class="menu-item delimiter"></span><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title=杂货铺><span class=header-title-pre><i class='fa-solid fa-house-chimney'></i></span>老杨的杂货铺</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><a class=menu-item href=/posts/ title>所有文章</a><a class=menu-item href=/tags/ title>标签</a><a class=menu-item href=/categories/ title>分类</a><a class=menu-item href=https://github.com/yangyingchao title=GitHub rel="noopener noreffer" target=_blank><i class='fab fa-github fa-fw' aria-hidden=true></i> </a><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题><i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></header><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>目录</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">StarRocks 技术内幕：查询原理浅析</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=/ title=Author rel=author class=author><i class="fas fa-user-circle fa-fw" aria-hidden=true></i>yc</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw" aria-hidden=true></i>&nbsp;<time datetime=2025-01-02>2025-01-02</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden=true></i>&nbsp;约 4429 字&nbsp;
<i class="far fa-clock fa-fw" aria-hidden=true></i>&nbsp;预计阅读 9 分钟&nbsp;</div></div><div class="details toc" id=toc-static data-kept><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fas fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#从-sql-文本到执行计划><span class=section-num>1</span> 从 SQL 文本到执行计划</a><ul><li><a href=#sql-parse><span class=section-num>1.1</span> SQL Parse</a></li><li><a href=#sql-analyze><span class=section-num>1.2</span> SQL Analyze</a></li><li><a href=#sql-logical-plan><span class=section-num>1.3</span> SQL Logical Plan</a></li><li><a href=#sql-optimize><span class=section-num>1.4</span> SQL Optimize</a></li><li><a href=#logical-plan-rewrite><span class=section-num>1.5</span> Logical Plan Rewrite</a></li><li><a href=#cbo-transform><span class=section-num>1.6</span> CBO Transform</a></li><li><a href=#统计信息和-cost-估计><span class=section-num>1.7</span> 统计信息和 Cost 估计</a></li><li><a href=#生成-plan-fragment><span class=section-num>1.8</span> 生成 Plan fragment</a></li></ul></li><li><a href=#执行计划的调度><span class=section-num>2</span> 执行计划的调度</a></li><li><a href=#执行计划的执行><span class=section-num>3</span> 执行计划的执行</a><ul><li><a href=#mpp-多机并行执行><span class=section-num>3.1</span> MPP 多机并行执行</a></li><li><a href=#pipeline-单机并行执行><span class=section-num>3.2</span> Pipeline 单机并行执行</a></li><li><a href=#向量化执行><span class=section-num>3.3</span> 向量化执行</a></li></ul></li><li><a href=#总结><span class=section-num>4</span> 总结</a></li></ul></nav></div></div><div class=content id=content><div class="ox-hugo-toc toc has-section-numbers"><div class=heading>Table of Contents</div><ul><li><span class=section-num>1</span> <a href=#%e4%bb%8e-sql-%e6%96%87%e6%9c%ac%e5%88%b0%e6%89%a7%e8%a1%8c%e8%ae%a1%e5%88%92 rel>从 SQL 文本到执行计划</a><ul><li><span class=section-num>1.1</span> <a href=#sql-parse rel>SQL Parse</a></li><li><span class=section-num>1.2</span> <a href=#sql-analyze rel>SQL Analyze</a></li><li><span class=section-num>1.3</span> <a href=#sql-logical-plan rel>SQL Logical Plan</a></li><li><span class=section-num>1.4</span> <a href=#sql-optimize rel>SQL Optimize</a></li><li><span class=section-num>1.5</span> <a href=#logical-plan-rewrite rel>Logical Plan Rewrite</a></li><li><span class=section-num>1.6</span> <a href=#cbo-transform rel>CBO Transform</a></li><li><span class=section-num>1.7</span> <a href=#%e7%bb%9f%e8%ae%a1%e4%bf%a1%e6%81%af%e5%92%8c-cost-%e4%bc%b0%e8%ae%a1 rel>统计信息和 Cost 估计</a></li><li><span class=section-num>1.8</span> <a href=#%e7%94%9f%e6%88%90-plan-fragment rel>生成 Plan fragment</a></li></ul></li><li><span class=section-num>2</span> <a href=#%e6%89%a7%e8%a1%8c%e8%ae%a1%e5%88%92%e7%9a%84%e8%b0%83%e5%ba%a6 rel>执行计划的调度</a></li><li><span class=section-num>3</span> <a href=#%e6%89%a7%e8%a1%8c%e8%ae%a1%e5%88%92%e7%9a%84%e6%89%a7%e8%a1%8c rel>执行计划的执行</a><ul><li><span class=section-num>3.1</span> <a href=#mpp-%e5%a4%9a%e6%9c%ba%e5%b9%b6%e8%a1%8c%e6%89%a7%e8%a1%8c rel>MPP 多机并行执行</a></li><li><span class=section-num>3.2</span> <a href=#pipeline-%e5%8d%95%e6%9c%ba%e5%b9%b6%e8%a1%8c%e6%89%a7%e8%a1%8c rel>Pipeline 单机并行执行</a></li><li><span class=section-num>3.3</span> <a href=#%e5%90%91%e9%87%8f%e5%8c%96%e6%89%a7%e8%a1%8c rel>向量化执行</a></li></ul></li><li><span class=section-num>4</span> <a href=#%e6%80%bb%e7%bb%93 rel>总结</a></li></ul></div><p>本文为摘录(或转载)，侵删，原文为： <a href=https://my.oschina.net/u/5658056/blog/5519656 target=_blank rel="noopener noreffer">https://my.oschina.net/u/5658056/blog/5519656</a></p><p>一条查询 SQL 在关系型分布式数据库中的处理，通常需要经过 3 大步骤：</p><ol><li><p>将 SQL 文本转换成一个 <strong>“最佳的”</strong> 分布式物理执行计划</p></li><li><p>将执行计划调度到计算节点</p></li><li><p>计算节点执行具体的物理执行计划</p></li></ol><p>本文将详细解释在 StarRocks 中如何完成一条查询 SQL 的处理。</p><p>首先来了解 StarRocks 中的基本概念：<br></p><ul><li>FE： 负责查询解析，查询优化，查询调度和元数据管理</li><li>BE： 负责查询执行和数据存储</li></ul><h2 id=从-sql-文本到执行计划><span class=section-num>1</span> 从 SQL 文本到执行计划</h2><p>从 SQL 文本到分布式物理执行计划, 在 StarRocks 中，需要经过以下 5 个步骤:</p><ol><li>SQL Parse： 将 SQL 文本转换成一个 AST（抽象语法树）</li><li>SQL Analyze： 基于 AST 进行语法和语义分析</li><li>SQL Logical Plan： 将 AST 转换成逻辑计划</li><li>SQL Optimize：基于关系代数、统计信息、Cost 模型，对逻辑计划进行重写、转换，选择出 Cost “最低” 的物理执行计划</li><li>生成 Plan Fragment：将 Optimizer 选择的物理执行计划转换为 BE 可以直接执行的 Plan Fragment SQL Parse</li></ol><h3 id=sql-parse><span class=section-num>1.1</span> SQL Parse</h3><figure><img src=/ox-hugo/up-bd359337afd16fd733410f5629962ca5d96.png width=800px></figure><p>Query Parse 的输入是 SQL 的 String 字符串，Query Parse 的输出是 Abstract Syntax Tree，每个节点都是一个
ParseNode 。</p><p>一个查询 SQL Parse 后生成一个 QueryStmt，由 SelectList, FromClause, wherePredicate, GroupByClause,
havingPredicate, OrderByElement, LimitElement 等组成，基本和 SQL 文本一一对应。</p><p>StarRocks 目前使用的 Parser 是 ANTLR4，语法规则定义的文件可在 GitHub 搜索 StarRocks g4 获取。</p><h3 id=sql-analyze><span class=section-num>1.2</span> SQL Analyze</h3><p>StarRocks 获取到 AST 后，接着会进行语法分析和语义分析，完成下面的工作：</p><ol><li>检查并绑定 Database, Table, Column 等元信息</li><li>SQL 的合法性检查：Where 中不能有 Grouping 操作， HLL 和 Bitmap 列不能 Sum 等</li><li>Table 和 Column 的别名处理</li><li>函数参数的合法性检测: Sum 的参数类型必须是数值类型，Lead 和 Lag 窗口函数第 2 和第 3 个参数必须常量等</li><li>类型检查和类型转换：BIGINT 和 DECIMAL 比较，BIGINT 类型需要 Cast 成 DECIMAL</li></ol><p>SQL Analyze 的结果是一个有层级结构的 Relation，如图 2 所示，比如一个 From 子句对应一个 TableRelation，一个子查询对应一个 SubqueryRelation。</p><h3 id=sql-logical-plan><span class=section-num>1.3</span> SQL Logical Plan</h3><figure><img src=/ox-hugo/fe7db2f59af_up-e07d92221b86c2484f8795943dc0dca5eed.png width=800px></figure><p>接下来，StarRocks 会将 Relations 转化成一颗 Logical Plan Tree，如图 2 所示，可以简单理解为每个集合操作都会对应一个 Logical Node。</p><h3 id=sql-optimize><span class=section-num>1.4</span> SQL Optimize</h3><figure><img src=/ox-hugo/fe7db2f59af_up-32034317f22690551ae08c905f680f6f93b.png width=800px></figure><p>StarRocks Optimizer 的输入是一棵逻辑计划树，输出是一棵 Cost “最低” 的分布式物理计划树。</p><p>一般 SQL 越复杂，Join 的表越多，数据量越大，Optimizer 的意义就越大，因为不同执行方式的性能差别可能有成百上千倍。StarRocks 优化器完全自研，主要基于 Cascades 和 ORCA 论文实现，并结合 StarRocks 执行器和调度器进行了深度定制，优化和创新。</p><p>它完整支持了 TPC-DS 99 条 SQL，实现了公共表达式复用，相关子查询重写，Lateral Join， CTE 复用，Join Rorder，
Join 分布式执行策略选择，Global Runtime Filter 下推，低基数字典优化等重要功能和优化。</p><h3 id=logical-plan-rewrite><span class=section-num>1.5</span> Logical Plan Rewrite</h3><figure><img src=/ox-hugo/fe7db2f59af_up-cd82bd80f56a4d01ba4ef44e2f6b0aa11d1.png width=800px></figure><p>在正式进入 CBO 之前，StarRocks 会首先进行一系列 Logical Plan 的 Rewrite，Rewrite 阶段的 Rule 我们认为都会生成更优的 Logical Plan，主要的 Rewrite Rule 有下面这些：</p><ul><li>各种表达式的重写和化简</li><li>列裁剪</li><li>谓词下推</li><li>Limit Merge, Limit 下推</li><li>聚合 Merge</li><li>等价谓词推导（常量传播）</li><li>Outer Join 转 Inner Join</li><li>常量折叠</li><li>公共表达式复用</li><li>子查询重写</li><li>Lateral Join 化简</li><li>分区分桶裁剪</li><li>Empty Node 优化</li><li>Empty Union, Intersect, Except 裁剪</li><li>Intersect Reorder</li><li>Count Distinct 相关聚合函数重写</li></ul><h3 id=cbo-transform><span class=section-num>1.6</span> CBO Transform</h3><p>我们在 Logical Plan Rewrite 完成后，正式基于 Columbia 论文进行 CBO 优化，主要包括下面的优化：</p><ul><li><p>多阶段聚合优化：普通聚合（count, sum, max, min 等）会拆分成两阶段，单个 Count Distinct 查询会拆分成三阶段或是四阶段。</p></li><li><p>Join 左右表调整：StarRocks 始终用右表构建 Hash 表，所以右表应该是小表，StarRocks 可以基于 cost 自动调整左右表顺序，也会自动把 Left Join 转 Right Join。</p></li><li><p>Join 多表 Reorder：多表 Join 如何选择出正确的 Join 顺序，是 CBO 优化器的核心。当 Join 表的数量小于等于 5 时，
StarRocks 会基于 Join 交换律和结合律进行 Join Reorder，大于 5 时，StarRocks 会基于贪心算法和动态规划进行 Join
Reorder。</p></li><li><p>Join 分布式执行选择：StarRocks 支持的分布式 Join 方式有 Broadcast、Shuffle、单边 Shuffle、Colocate、Replicated。
StarRocks 会基于 Cost 估算和 Property Enforce 机制选择出 “最佳” 的 Join 分布式执行方式。</p></li><li><p>Push Down Aggregate to Join</p></li><li><p>物化视图选择与重写</p></li></ul><figure><img src=/ox-hugo/fe7db2f59af_up-b070e46f73d9429092cc35064d776252dc6.png width=800px></figure><p>如图 5 所示，在 CBO 优化中，Logical Plan 会先转成 Memo 的数据结构。Memo 的中文含义是备忘录，所有的逻辑计划和物理计划都会记录在 Memo 中， Memo 就构成了整个搜索空间。</p><p>然后如图 6 所示，StarRocks 应用各种 Rule 扩展搜索空间，并生成对应的物理执行计划，再基于统计信息和 Cost 估计从
Memo 中选择一组 Cost 最低的物理执行计划。</p><figure><img src=/ox-hugo/fe7db2f59af_up-521744c1fb16dafe1abfc109a5d5a9af841.png width=800px></figure><h3 id=统计信息和-cost-估计><span class=section-num>1.7</span> 统计信息和 Cost 估计</h3><p>CBO 优化器好坏的关键之一是 Cost 估计是否准确，而 Cost 估计是否准确的关键点之一是统计信息是否收集及时准确。</p><p>StarRocks 目前支持表级别和列级别的统计信息，支持自动收集和手动收集两种方式。无论自动还是手动，都支持全量和抽样收集两种方式。</p><p>有了统计信息之后， StarRocks 就会基于统计信息进行 Cost 估算。StarRocks 估算 Cost 时会考虑 CPU、内存、网络、IO
等资源因子，每个资源因子会有不同的权重，每个执行算子的 Cost 计算公式都不太一样。</p><p>当你使用 StarRocks 发现 Join 左右表不合理、Join 分布式执行策略不合理时，可以参考 StarRocks CBO 使用文档收集统计信息。</p><h3 id=生成-plan-fragment><span class=section-num>1.8</span> 生成 Plan fragment</h3><figure><img src=/ox-hugo/fe7db2f59af_up-7a6337891cba681fc9c5917ec0af9119260.png width=800px></figure><p>StarRocks Optimizer 的输出是一棵分布式物理执行计划树，但并不能直接被 BE 节点执行，所以需要转换成 BE 可以直接执行的 PlanFragment。转换过程基本是个一一映射的过程。</p><h2 id=执行计划的调度><span class=section-num>2</span> 执行计划的调度</h2><p>在生成查询的分布式 Plan 之后，FE 调度模块会负责 PlanFragment 的执行实例生成、PlanFragment 的调度、每个 BE 执行状态的管理、查询结果的接收。</p><figure><img src=/ox-hugo/fe7db2f59af_up-f8998676f68f1291f91225f6c93c5f05fde.png width=800px></figure><p>有了分布式执行计划之后，我们需要解决下面的问题：</p><ol><li>哪个 BE 执行哪个 PlanFragment</li><li>每个 Tablet 选择哪个副本去查询</li><li>多个 PlanFragment 如何调度</li></ol><p>StarRocks 会首先确认 Scan Operator 所在的 Fragment 在哪些 BE 节点执行，每个 Scan Operator 有需要访问的 Tablet
列表。然后对于每个 Tablet，StarRocks 会先选择版本匹配的、健康的、所在的 BE 状态正常的副本进行查询。在最终决定每个 Tablet 选择哪个副本查询时，采用的是随机方式，不过 StarRocks 会尽可能保证每个 BE 的请求均衡。假如我们有
10 个 BE、10 个 Tablet，最终调度的结果理论上就是每个 BE 负责 1 个 Tablet 的 Scan。</p><p>当确定包含 Scan 的 PlanFragment 由哪些 BE 节点执行后，其他的 PlanFragment 实例也会在 Scan 的 BE 节点上执行（也可以通过参数选择其他 BE 节点），不过具体选择哪个 BE 是随机选取的。</p><p>当 FE 确定每个 PlanFragment 由哪个 BE 执行，每个 Tablet 查询哪个副本后，FE 就会将 PlanFragment 执行相关的参数通过 Thrift 的方式发送给 BE。</p><p>目前 FE 对多个 PlanFragment 调度的方式是 All At Once 的方式，是按照自顶向下的方式遍历 PlanFragment 树，将每个
PlanFragment 的执行信息发送给对应的 BE。</p><h2 id=执行计划的执行><span class=section-num>3</span> 执行计划的执行</h2><p>StarRocks 是通过 MPP 多机并行机制来充分利用多机的资源，通过 Pipeline 并行机制来充分利用单机上多核的资源，通过向量化执行来充分利用单核的资源，进而达到极致的查询性能。</p><h3 id=mpp-多机并行执行><span class=section-num>3.1</span> MPP 多机并行执行</h3><p>MPP 是大规模并行计算的简称，核心做法是将查询 Plan 拆分成很多可在单个节点上执行的计算实例，然后多个节点并行执行。每个节点不共享 CPU、内存、磁盘资源。MPP 数据库的查询性能可以随着集群的水平扩展而不断提升。</p><figure><img src=/ox-hugo/fe7db2f59af_up-7ac4fe561b2b002527f95dbfc543d74e2ce.png width=800px></figure><p>如图 9 所示，StarRocks 会将一个查询在逻辑上切分为多个 Query Fragment（查询片段），每个 Query Fragment 可以有一个或者多个 Fragment 执行实例，每个 Fragment 执行实例会被调度到集群某个 BE 上执行。一个 Fragment 可以包括一个或者多个 Operator（执行算子），图中的 Fragment 包括了 Scan、Filter、Aggregate。每个 Fragment 可以有不同的并行度。</p><figure><img src=/ox-hugo/fe7db2f59af_up-c92caa80003311154ea83429a8576f7f6d8.png width=800px></figure><p>如图 10 所示，多个 Fragment 之间会以 Pipeline 的方式在内存中并行执行，而不是像批处理引擎那样 Stage By Stage
执行。Shuffle （数据重分布）操作是 MPP 数据库查询性能可以随着集群的水平扩展而不断提升的关键，也是实现高基数聚合和大表 Join 的关键。</p><h3 id=pipeline-单机并行执行><span class=section-num>3.2</span> Pipeline 单机并行执行</h3><p>StarRocks 在 Fragment 和 Operator 之间引入了 Pipeline 的概念，一个 Pipeline 内的数据没有到达终点前不需要
Materialize，遇到需要 Materialize 的算子（Agg, Sort, Join)，则需要拆分出一个新的 Pipeline，所以 1 个 Fragment 会对应多个 Pipeline。</p><figure><img src=/ox-hugo/fe7db2f59af_up-b8eaf5140d4344627836d89d3d6272508cf.png width=800px></figure><p>如图 11 所示，一个 Pipeline 由多个 Operator 组成。第一个 Operator 是 Source Operator，负责产生数据，一般是 Scan
节点和 Exchange 节点。最后一个 Operator 是 Sink Operator，负责物化或者消费数据。中间的 Operator 负责对数据进行
Transform。</p><figure><img src=/ox-hugo/fe7db2f59af_up-81644ff5f6ee2580e8ee43ec4ab554fb02e.png width=800px></figure><p>那么 Pipeline 如何并行呢？答案是 Pipeline 和 Fragment 一样，可以生成多个实例，每个实例称为一个 Pipeline Driver。当一个 Pipeline 需要 N 个并行度去执行时，一个 Pipeline 就会生成 N 个 Pipeline Driver，如图 12 所示，并行度是 3，一个 Pipeline 就产生了 3 个 Pipeline Driver。</p><figure><img src=/ox-hugo/fe7db2f59af_up-f4572758d468d0ddbd2035df045e937f991.png width=800px></figure><p>如图 13 所示，一个 Pipeline 执行中，当前一个 Operator 可以产生数据，且后一个 Operator 可以消费数据时，
Pipeline 的执行线程就会从前一个 Operator Pull 出数据，然后 Push 到后一个 Operator。每个 Pipeline 的执行状态是很清晰的，简单可以理解为有 Ready、Running、Blocked 等 3 种状态。当前面的 Operator 无法产生数据，或者后面的
Operator 不需要消费数据时，Pipeline 就会处于 Blocked 的状态。</p><figure><img src=/ox-hugo/fe7db2f59af_up-35b7e0cebdb49e78586cea19bfcaae5a233.png width=800px></figure><p>如图 14 所示， Pipeline 并行执行框架的核心是实现一个用户态的协程调度，不再依赖操作系统的内核态线程调度，减少线程创建、线程销毁、线程上下文切换的成本。</p><p>在 Pipeline 并行执行框架中，StarRocks 会启动机器 CPU 核数个执行线程，每个执行线程会从一个多级反馈就绪队列中获取 Ready 状态的 Pipeline 去执行，同时会有一个全局 Poller 线程不断检查 Blocked 队列中的 Pipeline 是否解除了阻塞，可以变为 Ready 状态。如果可以变为了 Ready 状态，就可以把 Pipeline 从阻塞队列移到多级反馈就绪队列中。</p><h3 id=向量化执行><span class=section-num>3.3</span> 向量化执行</h3><figure><img src=/ox-hugo/fe7db2f59af_up-0a2c57c179a48657c2cdbac46dfcc0df994.jpg width=800px></figure><p>随着数据库执行的瓶颈逐渐从 IO 转移到 CPU，为了充分发挥 CPU 的执行性能，StarRocks 基于向量化技术重新实现了整个执行引擎，向量化执行引擎是为了充分利用单核 CPU 的能力。</p><p>向量化在实现上主要是算子和表达式的向量化，图 15 是算子向量化的示例，图 16 是表达式向量化的示例，算子和表达式向量化执行的核心是批量按列执行。相比于单行执行，批量执行可以有更少的虚函数调用，更少的分支判断；相比于按行执行，按列执行对 CPU Cache 更友好，更易于 SIMD 优化。</p><p>向量化执行不仅仅是数据库所有算子的向量化和表达式的向量化，而是一项巨大和复杂的性能优化工程，包括数据在磁盘、内存、网络中的按列组织，数据结构和算法的重新设计，内存管理的重新设计，SIMD 指令优化，CPU Cache 优化，C++
Level 优化等。经过努力，StarRocks 向量化执行引擎相比之前的按行执行，取得了整体 5 到 10 倍的性能提升。</p><p>每个算子和表达式具体如何实现、如何进行向量化，之后的文章会详细解释，本文不再赘述。</p><h2 id=总结><span class=section-num>4</span> 总结</h2><p>本文主要介绍了 StarRocks 如何完成一条查询 SQL 的处理：</p><ol><li>通过高效强大的 CBO 优化器生成最佳的分布式物理执行计划；</li><li>通过查询调度器选择合适的数据副本，并将分布式物理执行计划调度到合适的计算节点进行计算；</li><li>通过 MPP 分布式执行框架充分利用多机的资源，做到查询性能可以随着机器数量近似线性扩展；</li><li>通过 Pipeline 并行执行框架充分利用多核资源，做到查询性能可以随着机器核数近似线性扩展；</li><li>通过向量化执行引擎充分利用 CPU 单核资源，将单核执行性能做到极致。</li></ol><p>作者</p><p>康凯森 | StarRocks 核心研发、StarRocks 查询团队负责人</p></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>更新于 2025-01-02</span></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw" aria-hidden=true></i>&nbsp;<a href=/tags/starrocks/>Starrocks</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/docs_starrocks_io_features/ class=prev rel=prev title="产品特性 | StarRocks"><i class="fas fa-angle-left fa-fw" aria-hidden=true></i>产品特性 | StarRocks</a>
<a href=/segmentfault_com_a_1190000042739883/ class=next rel=next title="数据库 - StarRocks 技术内幕 | Join 查询优化">数据库 - StarRocks 技术内幕 | Join 查询优化<i class="fas fa-angle-right fa-fw" aria-hidden=true></i></a></div></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line itemscope itemtype=http://schema.org/CreativeWork>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title=回到顶部><i class="fas fa-arrow-up fa-fw" aria-hidden=true></i>
</a><a href=# id=view-comments class=fixed-button title=查看评论><i class="fas fa-comment fa-fw" aria-hidden=true></i></a></div><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"复制到剪贴板",maxShownLines:50},comment:{}}</script><script type=text/javascript src=/js/theme.min.js></script></body></html>