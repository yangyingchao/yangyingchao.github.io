<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><title>What it means when you convert between different shared_ptrs - The Old New Thing - 杂货铺</title><meta name=Description content="杂七杂八的，随手记录。"><meta property="og:url" content="https://yangyingchao.github.io/p108611/"><meta property="og:site_name" content="杂货铺"><meta property="og:title" content="What it means when you convert between different shared_ptrs - The Old New Thing"><meta property="og:description" content="本文为摘录(或转载)，侵删，原文为： https://devblogs.microsoft.com/oldnewthing/20230817-00/?p=108611
C++中的 shared_ptr 管理一个引用计数指针。通常情况下，它是一个指向对象的指针，当最后一个引用过期时将被删除。但它不一定非得是这样。"><meta property="og:locale" content="zh_cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-08-18T00:00:00+00:00"><meta property="article:modified_time" content="2023-08-18T00:00:00+00:00"><meta property="article:tag" content="Cpp"><meta property="article:tag" content="Shared-Ptr"><meta property="article:tag" content="Lang"><meta property="og:image" content="https://yangyingchao.github.io/logo.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://yangyingchao.github.io/logo.png"><meta name=twitter:title content="What it means when you convert between different shared_ptrs - The Old New Thing"><meta name=twitter:description content="本文为摘录(或转载)，侵删，原文为： https://devblogs.microsoft.com/oldnewthing/20230817-00/?p=108611
C++中的 shared_ptr 管理一个引用计数指针。通常情况下，它是一个指向对象的指针，当最后一个引用过期时将被删除。但它不一定非得是这样。"><meta name=application-name content="LoveIt"><meta name=apple-mobile-web-app-title content="LoveIt"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://yangyingchao.github.io/p108611/><link rel=prev href=https://yangyingchao.github.io/shellguide/><link rel=next href=https://yangyingchao.github.io/security%23lock_out_user_after_three_failed_login_attempts/><link rel=stylesheet href=/css/style.min.css><link rel=preload href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css></noscript><link rel=preload href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"What it means when you convert between different shared_ptrs - The Old New Thing","inLanguage":"zh-cn","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/yangyingchao.github.io\/p108611\/"},"image":["https:\/\/yangyingchao.github.io\/images\/Apple-Devices-Preview.png"],"genre":"posts","keywords":"cpp, shared-ptr, lang","wordcount":1943,"url":"https:\/\/yangyingchao.github.io\/p108611\/","datePublished":"2023-08-18T00:00:00+00:00","dateModified":"2023-08-18T00:00:00+00:00","publisher":{"@type":"Organization","name":"xxxx","logo":"https:\/\/yangyingchao.github.io\/images\/avatar.png"},"author":{"@type":"Person","name":"yc"},"description":""}</script></head><body data-header-desktop=normal data-header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("theme","dark")</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title=杂货铺><span class=header-title-pre><i class="fa-solid fa-house-chimney"></i></span>老杨的杂货铺</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/>所有文章 </a><a class=menu-item href=/tags/>标签 </a><a class=menu-item href=/categories/>分类 </a><a class=menu-item href=https://github.com/yangyingchao/MyNotes title=GitHub rel="noopener noreffer" target=_blank><i class='fab fa-github fa-fw' aria-hidden=true></i> </a><span class="menu-item delimiter"></span><span class="menu-item search" id=search-desktop>
<input type=text placeholder=搜索文章标题或内容... id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fas fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fas fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-desktop><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i>
</span></span><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题><i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title=杂货铺><span class=header-title-pre><i class="fa-solid fa-house-chimney"></i></span>老杨的杂货铺</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><div class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容... id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fas fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fas fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-mobile><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></div><a class=menu-item href=/posts/ title>所有文章</a><a class=menu-item href=/tags/ title>标签</a><a class=menu-item href=/categories/ title>分类</a><a class=menu-item href=https://github.com/yangyingchao/MyNotes title=GitHub rel="noopener noreffer" target=_blank><i class='fab fa-github fa-fw' aria-hidden=true></i> </a><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题><i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>目录</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">What it means when you convert between different shared_ptrs - The Old New Thing</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=/ title=Author rel=author class=author><i class="fas fa-user-circle fa-fw" aria-hidden=true></i>yc</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw" aria-hidden=true></i>&nbsp;<time datetime=2023-08-18>2023-08-18</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden=true></i>&nbsp;约 1943 字&nbsp;
<i class="far fa-clock fa-fw" aria-hidden=true></i>&nbsp;预计阅读 4 分钟&nbsp;</div></div><div class="details toc" id=toc-static data-kept><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fas fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents></nav></div></div><div class=content id=content><p>本文为摘录(或转载)，侵删，原文为： <a href="https://devblogs.microsoft.com/oldnewthing/20230817-00/?p=108611" target=_blank rel="noopener noreffer">https://devblogs.microsoft.com/oldnewthing/20230817-00/?p=108611</a></p><p>C++中的 <code>shared_ptr</code> 管理一个引用计数指针。通常情况下，它是一个指向对象的指针，当最后一个引用过期时将被删除。但它不一定非得是这样。</p><p>回想一下， <code>shared_ptr</code> 实际上是两个指针。</p><ul><li>指向一个控制块 (control block)的指针，该控制块管理共享和弱引用计数，并在共享引用计数降至零时销毁一个对象（通常称为被管理的对象）。</li><li>从 <code>get()</code> 方法返回的指针，通常称为存储指针。</li></ul><p>大多数情况下，存储的指针指向托管对象，因为当你使用原始指针构造 <code>shared_ptr</code> 或者调用
<code>make_shared</code> 时，得到的就是托管对象。但是，当托管对象和存储的指针不同的时候，有什么用处呢？</p><p>可能会希望有一个 <code>shared_ptr</code> ，其 <code>get()</code> 方法返回另一个大对象的子对象的指针。在这种情况下，托管对象是较大的对象，而存储的指针是指向子对象的指针。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Sample</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>value1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>value2</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>consume</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>pint</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>Sample</span><span class=o>&gt;</span> <span class=n>p</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>make_shared</span><span class=o>&lt;</span><span class=n>Sample</span><span class=o>&gt;</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=n>consume</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span><span class=p>(</span><span class=n>p</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>value1</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 或者更简洁地
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>auto</span> <span class=n>p</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>make_shared</span><span class=o>&lt;</span><span class=n>Sample</span><span class=o>&gt;</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=n>consume</span><span class=p>({</span><span class=n>p</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>value1</span><span class=p>});</span>
</span></span></code></pre></td></tr></table></div></div><p>在上面的例子中，我们有一个名为 Sample 的类，其中有两个成员。我们创建了一个 <code>shared_ptr</code>
指向该类，并将其保存在 p 中。但是假设还有另一个函数需要一个 <code>shared_ptr&lt;int></code> 。没问题，我们可以通过重新使用控制块（参数 p）并替换新的存储指针（参数 <code>&amp;p->value1</code> ）来将
<code>std::shared_ptr&lt;Sample></code> 转换为 <code>std::shared_ptr&lt;int></code> 。consume 函数可以使用
<code>shared_ptr&lt;int></code> 访问 value1 成员，并且该 <code>shared_ptr&lt;int></code> 的控制块防止了 Sample 被销毁，从而防止了 value1 被销毁。</p><p>这里使用了 C++-20 新增的构造函数 – <strong>别名构造函数</strong> ：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>shared_ptr</span><span class=p>(</span> <span class=n>std</span><span class=o>::</span><span class=n>nullptr_t</span> <span class=n>ptr</span><span class=p>,</span> <span class=n>Deleter</span> <span class=n>d</span><span class=p>,</span> <span class=n>Alloc</span> <span class=n>alloc</span> <span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span> <span class=k>class</span> <span class=nc>Y</span> <span class=o>&gt;</span>   										<span class=p>(</span><span class=mi>8</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>shared_ptr</span><span class=p>(</span> <span class=k>const</span> <span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>Y</span><span class=o>&gt;&amp;</span> <span class=n>r</span><span class=p>,</span> <span class=n>element_type</span><span class=o>*</span> <span class=n>ptr</span> <span class=p>)</span> <span class=k>noexcept</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span> <span class=k>class</span> <span class=nc>Y</span> <span class=o>&gt;</span>   										<span class=p>(</span><span class=mi>8</span><span class=p>)</span>   <span class=p>(</span><span class=n>since</span> <span class=n>C</span><span class=o>++</span><span class=mi>20</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>shared_ptr</span><span class=p>(</span> <span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>Y</span><span class=o>&gt;&amp;&amp;</span> <span class=n>r</span><span class=p>,</span> <span class=n>element_type</span><span class=o>*</span> <span class=n>ptr</span> <span class=p>)</span> <span class=k>noexcept</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><ol><li>The aliasing constructor: constructs a shared_ptr which shares ownership information with the initial value of r, but</li></ol><p>holds an unrelated and unmanaged pointer ptr. If this shared_ptr is the last of the group to go out of scope, it will
call the stored deleter for the object originally managed by r. However, calling get() on this shared_ptr will always
return a copy of ptr. It is the responsibility of the programmer to make sure that this ptr remains valid as long as
this shared_ptr exists, such as in the typical use cases where ptr is a member of the object managed by r or is an alias
(e.g., downcast) of r.get() For the second overload taking an rvalue, r is empty and r.get() == nullptr after the call.
(since C++20)</p><ol><li><strong>别名构造函数：</strong> 构造一个 <code>shared_ptr</code> ，与初始值 r 共享所有权信息，但持有一个无关且未被管理的指针 ptr。如果这个 <code>shared_ptr</code> 是组中最后一个超出作用域的对象，它将调用 r
最初管理的对象的存储删除器。然而，在这个 <code>shared_ptr</code> 上调用 get()将始终返回 ptr 的拷贝。程序员负责确保在 <code>shared_ptr</code> 存在期间 ptr 保持有效，例如，在 ptr 是 r 所管理的对象的成员或者是 r.get() 的别名（例如下转型）的典型用例中。对于接受 rvalue 的第二个重载函数，调用之后 r 为空，r.get() == nullptr。（自 C++20 起）</li></ol><p>通常情况下，储存的指针的生命周期应该包含在管理对象的生命周期内。这可以是一个直接的包含关系，就像我们在 value1 中所做的那样，也可以是一个更复杂的生命周期依赖链。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Other</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>value</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Sample2</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=n>Other</span><span class=o>&gt;</span> <span class=n>m_other</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>make_unique</span><span class=o>&lt;</span><span class=n>Other</span><span class=o>&gt;</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>p</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>make_shared</span><span class=o>&lt;</span><span class=n>Sample2</span><span class=o>&gt;</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=n>consume</span><span class=p>({</span><span class=n>p</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>m_other</span><span class=o>-&gt;</span><span class=n>value</span><span class=p>});</span>
</span></span></code></pre></td></tr></table></div></div><p>在第二个例子中，我们传递给 consume()函数的 shared_ptr&lt;int>的存储指针指向 Sample2 对象内部的
value 成员，而 Sample2 对象包含一个独有指针指向 Other 对象。该 shared_ptr&lt;int>中的控制块控制着
Sample2 对象的生命周期，这是可以接受的，因为只要 Sample2 对象存活，Other 对象中的值也将保持存活。</p><p>现在，编译器不会检查您是否具有从托管对象到存储指针的正向生命周期控制链。您可以做一些愚蠢的事情，比如</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Sample3</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=n>Other</span><span class=o>&gt;</span> <span class=n>m_other</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>make_unique</span><span class=o>&lt;</span><span class=n>Other</span><span class=o>&gt;</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>p</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>make_shared</span><span class=o>&lt;</span><span class=n>Sample3</span><span class=o>&gt;</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=n>consume</span><span class=p>({</span> <span class=n>p</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>m_other</span><span class=o>-&gt;</span><span class=n>value</span> <span class=p>});</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>p</span><span class=o>-&gt;</span><span class=n>m_other</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span> <span class=c1>// 糟糕，链条断了
</span></span></span></code></pre></td></tr></table></div></div><p><code>shared_ptr&lt;int></code> 将认为它仍在保持值的活动状态，即使您断开了从 Sample3 到 Other 的链接。</p><p>或者你可以做更愚蠢的事情，比如</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>int</span> <span class=n>unrelated</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>consume</span><span class=p>({</span> <span class=n>p</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>unrelated</span> <span class=p>});</span>
</span></span></code></pre></td></tr></table></div></div><p>shared_ptr&lt;int> 将访问 unrelated，即使它的生命周期与 Sample2 无关。如果 unrelated 被销毁，shared_ptr&lt;int> 将具有一个悬空的存储指针。</p><p>这些其中托管对象与所指对象不同的 shared_ptr 对象通常被称为别名共享指针。</p><p>好的，所以我展示了一种创建别名共享指针的方法，即通过从现有的 shared_ptr 构造一个
shared_ptr（共享托管对象），并提供一个不同的存储指针。如果新的存储指针指向原始对象的基类，则 shared_ptr 具有一个转换运算符，用于创建对基类子对象的别名共享指针。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Base</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Derived</span> <span class=o>:</span> <span class=n>Base</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>Derived</span><span class=o>&gt;</span> <span class=n>p</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>make_shared</span><span class=o>&lt;</span><span class=n>Derived</span><span class=o>&gt;</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>Base</span><span class=o>&gt;</span> <span class=n>b</span> <span class=o>=</span> <span class=n>p</span><span class=p>;</span> <span class=c1>// 自动转换等效于
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>Base</span><span class=o>&gt;</span> <span class=n>b</span><span class=p>(</span><span class=n>p</span><span class=p>,</span> <span class=n>p</span><span class=p>.</span><span class=n>get</span><span class=p>());</span>
</span></span></code></pre></td></tr></table></div></div><p>如果要进行反向转换（从 Base 到 Derived），可以显式写出：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>Derived</span><span class=o>&gt;</span> <span class=n>b</span><span class=p>(</span><span class=n>p</span><span class=p>,</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=n>Derived</span><span class=o>/&gt;</span><span class=p>(</span><span class=n>p</span><span class=p>.</span><span class=n>get</span><span class=p>()));</span>
</span></span></code></pre></td></tr></table></div></div><p>当然，这需要存储的 Base 指针确实是较大的 Derived 对象的 Base 部分的指针。</p><p>C++ 语言提供了一些助手函数，通过对另一个 <code>shared_ptr</code> 的存储指针进行转换来构造一个 <code>shared_ptr</code> 。</p><p><a id=figure--fig:screenshot@2023-08-18-09:37:06></a></p><figure><img src=/ox-hugo/screenshot@2023-08-18_09:37:06.png width=800px></figure><p>一切看起来都很好，直到我们看到 <code>dynamic_pointer_cast</code> ，它与使用 <code>dynamic_cast</code> 的一行代码不等价！</p><p>原因是，与其他转换不同， <code>dynamic_cast</code> 可以将非空指针更改为空指针，这在运行时类型不匹配时发生。在这种情况下， <code>dynamic_pointer_case</code> 返回一个空的 <code>shared_ptr</code> （而不是一个具有控制块但没有存储指针的 <code>shared_ptr</code> ），因为没有需要扩展生命周期的对象。</p><p>现在我们可以完成该表格：</p><p><a id=figure--fig:screenshot@2023-08-18-09:38:00></a></p><figure><img src=/ox-hugo/screenshot@2023-08-18_09:38:00.png alt="Figure 2: 最终转换表格" width=800px><figcaption><p><span class=figure-number>Figure 2: </span>最终转换表格</p></figcaption></figure><p>关于空指针的控制块的这种细节，说明了共享指针图中两个框在技术上是合法但奇怪的。</p><p><a id=figure--fig:screenshot@2023-08-18-09:39:32></a></p><figure><img src=/ox-hugo/screenshot@2023-08-18_09:39:32.png></figure><p>到目前为止，我们已经处理了空的 <code>shared_ptr</code> （不管理对象且没有存储指针）和完整的
<code>shared_ptr</code> （管理对象且具有存储指针）。但还有另外两个框，我将它们命名为“神秘”和“放纵”。下次我们将看看这两个奇怪的家伙。</p></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>更新于 2023-08-18</span></div></div><div class=post-info-line><div class=post-info-md><span><a class=link-to-markdown href=/p108611/index.md target=_blank>阅读原始文档</a></span></div><div class=post-info-share><span></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw" aria-hidden=true></i>&nbsp;<a href=/tags/cpp/>Cpp</a>,&nbsp;<a href=/tags/shared-ptr/>Shared-Ptr</a>,&nbsp;<a href=/tags/lang/>Lang</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/shellguide/ class=prev rel=prev title="google shell style guide | Style guides for Google-originated open-source projects"><i class="fas fa-angle-left fa-fw" aria-hidden=true></i>google shell style guide | Style guides for Google-originated open-source projects</a>
<a href=/security%23lock_out_user_after_three_failed_login_attempts/ class=next rel=next title="Lock out user after three failed login attempts">Lock out user after three failed login attempts<i class="fas fa-angle-right fa-fw" aria-hidden=true></i></a></div></div><div id=comments><div id=giscus class=comment></div><noscript>Please enable JavaScript to view the comments powered by <a href=https://giscus.app>Giscus</a>.</noscript></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line itemscope itemtype=http://schema.org/CreativeWork>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title=回到顶部><i class="fas fa-arrow-up fa-fw" aria-hidden=true></i>
</a><a href=# id=view-comments class=fixed-button title=查看评论><i class="fas fa-comment fa-fw" aria-hidden=true></i></a></div><script type=text/javascript src=https://cdn.jsdelivr.net/npm/autocomplete.js@0.38.1/dist/autocomplete.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/algoliasearch@4.13.1/dist/algoliasearch-lite.umd.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"复制到剪贴板",maxShownLines:50},comment:{giscus:{category:"Announcements",categoryId:"R_kgDON6NYZA",darkTheme:"dark",emitMetadata:"0",inputPosition:"bottom",lang:"zh-CN",lazyLoading:!1,lightTheme:"light",mapping:"pathname",reactionsEnabled:"1",repo:"yangyingchao/giscus",repoId:""}},search:{algoliaAppID:null,algoliaIndex:"index.zh-cn",algoliaSearchKey:null,highlightTag:"em",maxResultLength:10,noResultsFound:"没有找到结果",snippetLength:30,type:"algolia"}}</script><script type=text/javascript src=/js/theme.min.js></script></body></html>