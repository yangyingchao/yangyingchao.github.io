<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><title>Linux内核机制—spin_lock (转载) - 老杨的杂货铺</title><meta name=Description content="杂七杂八的，随手记录。"><meta property="og:url" content="https://yangyingchao.github.io/p_16368024/">
<meta property="og:site_name" content="老杨的杂货铺"><meta property="og:title" content="Linux内核机制—spin_lock (转载)"><meta property="og:description" content="Table of Contents 1 pin_lock 概述 2 相关数据结构 2.1 struct spinlock 2.2 struct qnode 3 相关函数 3.1 初始化函数 3.2 上锁函数 3.3 解锁函数 3.4 尝试获取锁函数 3.5 判断上锁状态 3.6 还可以直接使用 raw_spinlock_t 和与其配套的一组 raw_spin_xxx() 4 锁代码分析 4.1 spin_lock() 4.2 spin_lock 持锁慢速路径 queued_spin_lock_slowpath(): 5 解锁代码分析 5.1 spin_unlock() 函数 6 总结 7 补充 本文为摘录(或转载)，侵删，原文为： https://www.cnblogs.com/hellokitty2/p/16368024.html
1 pin_lock 概述 spin lock 是一种不可休眠锁，可用于原子上下文。当获取不到锁的时候会 spin 等待，此时是 running 状态。"><meta property="og:locale" content="zh_cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-12-28T00:00:00+00:00"><meta property="article:modified_time" content="2023-12-28T00:00:00+00:00"><meta property="og:image" content="https://yangyingchao.github.io/logo.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://yangyingchao.github.io/logo.png"><meta name=twitter:title content="Linux内核机制—spin_lock (转载)"><meta name=twitter:description content="Table of Contents 1 pin_lock 概述 2 相关数据结构 2.1 struct spinlock 2.2 struct qnode 3 相关函数 3.1 初始化函数 3.2 上锁函数 3.3 解锁函数 3.4 尝试获取锁函数 3.5 判断上锁状态 3.6 还可以直接使用 raw_spinlock_t 和与其配套的一组 raw_spin_xxx() 4 锁代码分析 4.1 spin_lock() 4.2 spin_lock 持锁慢速路径 queued_spin_lock_slowpath(): 5 解锁代码分析 5.1 spin_unlock() 函数 6 总结 7 补充 本文为摘录(或转载)，侵删，原文为： https://www.cnblogs.com/hellokitty2/p/16368024.html
1 pin_lock 概述 spin lock 是一种不可休眠锁，可用于原子上下文。当获取不到锁的时候会 spin 等待，此时是 running 状态。"><meta name=application-name content="My cool site"><meta name=apple-mobile-web-app-title content="My cool site"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://yangyingchao.github.io/p_16368024/><link rel=prev href=https://yangyingchao.github.io/2173/><link rel=next href=https://yangyingchao.github.io/1211161453667_how-can-3ware-and-megaraid-performance-be-increased-in-linux/><link rel=stylesheet href=/css/style.min.css><link rel=preload href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css></noscript><link rel=preload href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"Linux内核机制—spin_lock (转载)","inLanguage":"zh-cn","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/yangyingchao.github.io\/p_16368024\/"},"image":["https:\/\/yangyingchao.github.io\/images\/Apple-Devices-Preview.png"],"genre":"posts","wordcount":7077,"url":"https:\/\/yangyingchao.github.io\/p_16368024\/","datePublished":"2023-12-28T00:00:00+00:00","dateModified":"2023-12-28T00:00:00+00:00","publisher":{"@type":"Organization","name":"xxxx","logo":"https:\/\/yangyingchao.github.io\/images\/avatar.png"},"author":{"@type":"Person","name":"yc"},"description":""}</script></head><body data-header-desktop=normal data-header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("theme","dark")</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title=老杨的杂货铺><span class=header-title-pre><i class="fa-solid fa-house-chimney"></i></span>老杨的杂货铺</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/>所有文章 </a><a class=menu-item href=/tags/>标签 </a><a class=menu-item href=/categories/>分类 </a><a class=menu-item href=https://github.com/yangyingchao/MyNotes title=GitHub rel="noopener noreffer" target=_blank><i class='fab fa-github fa-fw' aria-hidden=true></i> </a><span class="menu-item delimiter"></span><span class="menu-item search" id=search-desktop>
<input type=text placeholder=搜索文章标题或内容... id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fas fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fas fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-desktop><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i>
</span></span><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题><i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title=老杨的杂货铺><span class=header-title-pre><i class="fa-solid fa-house-chimney"></i></span>老杨的杂货铺</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><div class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容... id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fas fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fas fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-mobile><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></div><a class=menu-item href=/posts/ title>所有文章</a><a class=menu-item href=/tags/ title>标签</a><a class=menu-item href=/categories/ title>分类</a><a class=menu-item href=https://github.com/yangyingchao/MyNotes title=GitHub rel="noopener noreffer" target=_blank><i class='fab fa-github fa-fw' aria-hidden=true></i></a><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>目录</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">Linux内核机制—spin_lock (转载)</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=/ title=Author rel=author class=author><i class="fas fa-user-circle fa-fw" aria-hidden=true></i>yc</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw" aria-hidden=true></i>&nbsp;<time datetime=2023-12-28>2023-12-28</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden=true></i>&nbsp;约 7077 字&nbsp;
<i class="far fa-clock fa-fw" aria-hidden=true></i>&nbsp;预计阅读 15 分钟&nbsp;</div></div><div class="details toc" id=toc-static data-kept><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fas fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#h:ac3c4fa2-488d-4149-b554-d2218edc64e9><span class=section-num>1</span> <code>pin_lock</code> 概述</a></li><li><a href=#h:af803ca3-6514-4ef5-a060-23dc07163a51><span class=section-num>2</span> 相关数据结构</a><ul><li><a href=#h:0bc412b4-41a6-47f9-a084-5b9c4dba03c7><span class=section-num>2.1</span> struct spinlock</a></li><li><a href=#h:ff217c37-8fee-4d66-899c-1b61079fdcc9><span class=section-num>2.2</span> struct qnode</a></li></ul></li><li><a href=#h:de96322f-228c-4b02-816e-2c21f180b8d8><span class=section-num>3</span> 相关函数</a><ul><li><a href=#h:5d759b92-82ff-42b4-9d57-33c6bcbbd80b><span class=section-num>3.1</span> 初始化函数</a></li><li><a href=#h:3c9c36a5-9705-4007-a997-cd9fa364e497><span class=section-num>3.2</span> 上锁函数</a></li><li><a href=#h:6ed0c420-d4d7-4a49-8429-d63a29040446><span class=section-num>3.3</span> 解锁函数</a></li><li><a href=#h:0328de7e-60d8-4fed-84ee-9f87ea212509><span class=section-num>3.4</span> 尝试获取锁函数</a></li><li><a href=#h:7d4fd4ec-c540-4189-b61e-89be724f406f><span class=section-num>3.5</span> 判断上锁状态</a></li><li><a href=#h:e5859ac4-e6ed-4d9d-aad8-55bff1770ccd><span class=section-num>3.6</span> 还可以直接使用 <code>raw_spinlock_t</code> 和与其配套的一组 <code>raw_spin_xxx()</code></a></li></ul></li><li><a href=#h:99559801-d2f0-4850-8000-f4326f72a359><span class=section-num>4</span> 锁代码分析</a><ul><li><a href=#h:21c8b10c-e5e1-4d2e-9a4b-dd13c57332b5><span class=section-num>4.1</span> <code>spin_lock()</code></a></li><li><a href=#h:2dcaa6de-51ee-4f66-9dcc-7380cc1cd15d><span class=section-num>4.2</span> spin_lock 持锁慢速路径 queued_spin_lock_slowpath():</a></li></ul></li><li><a href=#h:1f8557df-11a7-4ad4-bcf7-d3a4d569749d><span class=section-num>5</span> 解锁代码分析</a><ul><li><a href=#h:8ad2683c-f285-4321-8995-dc22478091a8><span class=section-num>5.1</span> <code>spin_unlock()</code> 函数</a></li></ul></li><li><a href=#h:07457cda-612a-4a0e-bd61-f9ce0c077db3><span class=section-num>6</span> 总结</a></li><li><a href=#h:d77f1671-6696-4f58-9f58-4011809165f8><span class=section-num>7</span> 补充</a></li></ul></nav></div></div><div class=content id=content><div class="ox-hugo-toc toc has-section-numbers"><div class=heading>Table of Contents</div><ul><li><span class=section-num>1</span> <a href=#h:ac3c4fa2-488d-4149-b554-d2218edc64e9 rel><code>pin_lock</code> 概述</a></li><li><span class=section-num>2</span> <a href=#h:af803ca3-6514-4ef5-a060-23dc07163a51 rel>相关数据结构</a><ul><li><span class=section-num>2.1</span> <a href=#h:0bc412b4-41a6-47f9-a084-5b9c4dba03c7 rel>struct spinlock</a></li><li><span class=section-num>2.2</span> <a href=#h:ff217c37-8fee-4d66-899c-1b61079fdcc9 rel>struct qnode</a></li></ul></li><li><span class=section-num>3</span> <a href=#h:de96322f-228c-4b02-816e-2c21f180b8d8 rel>相关函数</a><ul><li><span class=section-num>3.1</span> <a href=#h:5d759b92-82ff-42b4-9d57-33c6bcbbd80b rel>初始化函数</a></li><li><span class=section-num>3.2</span> <a href=#h:3c9c36a5-9705-4007-a997-cd9fa364e497 rel>上锁函数</a></li><li><span class=section-num>3.3</span> <a href=#h:6ed0c420-d4d7-4a49-8429-d63a29040446 rel>解锁函数</a></li><li><span class=section-num>3.4</span> <a href=#h:0328de7e-60d8-4fed-84ee-9f87ea212509 rel>尝试获取锁函数</a></li><li><span class=section-num>3.5</span> <a href=#h:7d4fd4ec-c540-4189-b61e-89be724f406f rel>判断上锁状态</a></li><li><span class=section-num>3.6</span> <a href=#h:e5859ac4-e6ed-4d9d-aad8-55bff1770ccd rel>还可以直接使用 <code>raw_spinlock_t</code> 和与其配套的一组 <code>raw_spin_xxx()</code></a></li></ul></li><li><span class=section-num>4</span> <a href=#h:99559801-d2f0-4850-8000-f4326f72a359 rel>锁代码分析</a><ul><li><span class=section-num>4.1</span> <a href=#h:21c8b10c-e5e1-4d2e-9a4b-dd13c57332b5 rel><code>spin_lock()</code></a></li><li><span class=section-num>4.2</span> <a href=#h:2dcaa6de-51ee-4f66-9dcc-7380cc1cd15d rel>spin_lock 持锁慢速路径 queued_spin_lock_slowpath():</a></li></ul></li><li><span class=section-num>5</span> <a href=#h:1f8557df-11a7-4ad4-bcf7-d3a4d569749d rel>解锁代码分析</a><ul><li><span class=section-num>5.1</span> <a href=#h:8ad2683c-f285-4321-8995-dc22478091a8 rel><code>spin_unlock()</code> 函数</a></li></ul></li><li><span class=section-num>6</span> <a href=#h:07457cda-612a-4a0e-bd61-f9ce0c077db3 rel>总结</a></li><li><span class=section-num>7</span> <a href=#h:d77f1671-6696-4f58-9f58-4011809165f8 rel>补充</a></li></ul></div><p>本文为摘录(或转载)，侵删，原文为： <a href=https://www.cnblogs.com/hellokitty2/p/16368024.html target=_blank rel="noopener noreffer">https://www.cnblogs.com/hellokitty2/p/16368024.html</a></p><h2 id=h:ac3c4fa2-488d-4149-b554-d2218edc64e9><span class=section-num>1</span> <code>pin_lock</code> 概述</h2><ol><li><p>spin lock 是一种不可休眠锁，可用于原子上下文。当获取不到锁的时候会 spin 等待，此时是 running 状态。</p></li><li><p>spin lock 的发展到现在经历了四个阶段</p></li></ol><p>(1) CAS</p><p>锁只有一个原子变量，执行单个 compare-and-swap 指令来获取锁。问题是没有公平可言，无法让等待最长的那个任务优先拿到锁，为了解决这个问题引入了 ticket spinlock。</p><p>(2) ticket spinlock</p><p>类似排队叫号，只有任务手中事先领取的号和被叫到的号相等时才能持锁进入临界区。这解决了不公平的问题。但是出现叫号时，所有等待的任务所在的 cpu 都要读取内存，刷新对应的 cache line，而只有获取锁的那个任务所在的 cpu 对 cache line 的刷新才是有意义的，锁争抢的越激烈，无谓的开销也就越大。</p><p>(3) MCS Lock</p><p>在 ticket spinlock 的基础上做一定的修改，让多个 CPU 不再等待同一个 spinlock 变量，而是基于各自的 per-CPU 的变量进行等待，那么每个
CPU 平时只需要查询自己对应的这个变量所在的本地 cache line，仅在这个变量发生变化的时候，才需要读取内存和刷新这条 cache line，这样就可以解决上述问题。要实现类似这样的 spinlock 的分身，其中的一种方法就是使用 MCS lock。试图获取一个 spinlock 的每个 CPU，都有一份自己的 MCS lock。</p><p>(4) qspinlock</p><p>相比起 Linux 中只占 4 个字节的 ticket spinlock，MCS lock 多了一个指针，要多占 4（或者 8）个字节，消耗的存储空间是原来的 2-3 倍。
qspinlock 的首要目标就是改进原生的 MCS lock 结构体，尽量将原生 MCS lock 要包含的内容塞进 4 字节的空间里。</p><p>如果只有 1 个或 2 个 CPU 试图获取锁，那么只需要一个 4 字节的 qspinlock 就可以了，其所占内存的大小和 ticket spinlock 一样。当有 3 个以上的 CPU 试图获取锁，需要一个 qspinlock 加上(N-2)个 MCS node。</p><p>qspinlock 中加入”pending”位域，如果是两个 CPU 试图获取锁，那么第二个 CPU 只需要简单地设置”pending”为 1，而不用另起炉灶创建一个
MCS node。</p><p>试图加锁的 CPU 数目超过 3 个是小概率事件，但一旦发生，使用 ticket spinlock 机制就会造成多个 CPU 的 cache line 无谓刷新的问题，而
qspinlock 可以利用 MCS node 队列来解决这个问题。</p><p>可见，使用 qspinlock 机制来实现 spinlock，具有很好的可扩展性，也就是无论当前锁的争抢程度如何，性能都可以得到保证。</p><h2 id=h:af803ca3-6514-4ef5-a060-23dc07163a51><span class=section-num>2</span> 相关数据结构</h2><h3 id=h:0bc412b4-41a6-47f9-a084-5b9c4dba03c7><span class=section-num>2.1</span> struct spinlock</h3><p>除去使能 deug 才会有的相关成员，结构如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=n>spinlock</span> <span class=p>{</span> <span class=c1>//include/linux/spinlock_types.h
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>struct</span> <span class=n>raw_spinlock</span> <span class=n>rlock</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=kt>spinlock_t</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=n>raw_spinlock</span> <span class=p>{</span> <span class=c1>//include/linux/spinlock_types.h
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>arch_spinlock_t</span> <span class=n>raw_lock</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=kt>raw_spinlock_t</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=n>qspinlock</span> <span class=p>{</span> <span class=c1>//include/asm-generic/qspinlock_types.h
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>union</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>         * &#34;val&#34;作为一个 32 位的变量，包含了三个部分：&#34;locked byte&#34;,
</span></span></span><span class=line><span class=cl><span class=cm>         * &#34;pending&#34;和&#34;tail&#34;，&#34;tail&#34;又细分为&#34;tail index&#34;和&#34;tail cpu&#34;
</span></span></span><span class=line><span class=cl><span class=cm>         *
</span></span></span><span class=line><span class=cl><span class=cm>         * bit0-7: locked byte
</span></span></span><span class=line><span class=cl><span class=cm>         * bit8: pending
</span></span></span><span class=line><span class=cl><span class=cm>         * bit9-15: not used(实际上算在 pending 上了，只不过只使用了 bit8)
</span></span></span><span class=line><span class=cl><span class=cm>         * bit16-17: tail index
</span></span></span><span class=line><span class=cl><span class=cm>         * bit18-31: tail cpu(+1)
</span></span></span><span class=line><span class=cl><span class=cm>         *
</span></span></span><span class=line><span class=cl><span class=cm>         * 为了方便演示和说明，下面将&#34;tail&#34;表示为 x, &#34;pending&#34;表示为 y,
</span></span></span><span class=line><span class=cl><span class=cm>         * &#34;locked byte&#34;表示为 z, 组成一个三元组(x,y,z)
</span></span></span><span class=line><span class=cl><span class=cm>         */</span>
</span></span><span class=line><span class=cl>        <span class=kt>atomic_t</span> <span class=n>val</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>u16</span>    <span class=n>tail</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>u16</span>    <span class=n>locked_pending</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>};</span>
</span></span><span class=line><span class=cl>        <span class=k>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>u8</span>    <span class=n>reserved</span><span class=p>[</span><span class=mi>2</span><span class=p>];</span>
</span></span><span class=line><span class=cl>            <span class=n>u8</span>    <span class=n>pending</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>u8</span>    <span class=n>locked</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=kt>arch_spinlock_t</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p>其实 <code>arch_spinlock_t</code> 结构中只是一个 val 变量，分成多个位段使用，但是为了使用方便，不用进行位于/位或的操作，将其定义成了联合体，每个变量表示 val 中的一个位段。</p><p>spinlock 结构中只有一个类型为 <code>raw_spinlock</code> 的 rlock 成员。而 raw_spinlock 结构中只有一个类型为 qspinlock 的 raw_lock 成员。
qspinlock 结构中维护的是一个联合体。</p><p>val：为 0 表示没有人持锁，然后对其赋值为 _Q_LOCKED_VAL(1)表示持有了该锁。</p><h3 id=h:ff217c37-8fee-4d66-899c-1b61079fdcc9><span class=section-num>2.2</span> struct qnode</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>qnode</span> <span class=p>{</span> <span class=c1>//kernel/locking/qspinlock.c
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>struct</span> <span class=n>mcs_spinlock</span> <span class=n>mcs</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=cp>#ifdef CONFIG_PARAVIRT_SPINLOCKS </span><span class=c1>//默认不使能，没有下面成员
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>long</span> <span class=n>reserved</span><span class=p>[</span><span class=mi>2</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>mcs_spinlock</span> <span class=p>{</span> <span class=c1>//kernel/locking/mcs_spinlock.h
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>struct</span> <span class=n>mcs_spinlock</span> <span class=o>*</span><span class=n>next</span><span class=p>;</span> <span class=cm>/* 组成单链表 */</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>locked</span><span class=p>;</span> <span class=cm>/* 1 if lock acquired */</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>count</span><span class=p>;</span>  <span class=cm>/* nesting count, see qspinlock.c */</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=nf>DEFINE_PER_CPU_ALIGNED</span><span class=p>(</span><span class=k>struct</span> <span class=n>qnode</span><span class=p>,</span> <span class=n>qnodes</span><span class=p>[</span><span class=n>MAX_NODES</span><span class=p>]);</span> <span class=c1>//MAX_NODES=4
</span></span></span></code></pre></td></tr></table></div></div><p>MAX_NODES=4, 因为 CPU 只能处于 4 种上下文(thread、soft irq、irq、nmi)，因此一个 CPU 最多只能同时持有 4 个 spin_lock，嵌套 4 层。本次使用哪个 qnode 结构是由 lock->val 的 tail_cpu 和 tail idx 决定。</p><h2 id=h:de96322f-228c-4b02-816e-2c21f180b8d8><span class=section-num>3</span> 相关函数</h2><h3 id=h:5d759b92-82ff-42b4-9d57-33c6bcbbd80b><span class=section-num>3.1</span> 初始化函数</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>//定义并初始化为 unlock 状态的，名为 x 的 spin_lock 变量。
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>DEFINE_SPINLOCK</span><span class=p>(</span><span class=n>x</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>//初始化为非持锁状态
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>spin_lock_init</span><span class=p>(</span><span class=n>_lock</span><span class=p>)</span> <span class=c1>//include/linux/spinlock.h 宏
</span></span></span></code></pre></td></tr></table></div></div><h3 id=h:3c9c36a5-9705-4007-a997-cd9fa364e497><span class=section-num>3.2</span> 上锁函数</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>//里面直接调用的是 raw_spin_lock(&amp;lock-&gt;rlock)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>static</span> <span class=n>__always_inline</span> <span class=kt>void</span> <span class=nf>spin_lock</span><span class=p>(</span><span class=kt>spinlock_t</span> <span class=o>*</span><span class=n>lock</span><span class=p>)</span> <span class=c1>//include/linux/spinlock.h
</span></span></span><span class=line><span class=cl><span class=c1>//里面直接调用的是 raw_spin_lock_bh(&amp;lock-&gt;rlock)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>static</span> <span class=n>__always_inline</span> <span class=kt>void</span> <span class=nf>spin_lock_bh</span><span class=p>(</span><span class=kt>spinlock_t</span> <span class=o>*</span><span class=n>lock</span><span class=p>)</span> <span class=c1>//include/linux/spinlock.h
</span></span></span><span class=line><span class=cl><span class=c1>//里面直接调用的是 raw_spin_lock_irq(&amp;lock-&gt;rlock)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>static</span> <span class=n>__always_inline</span> <span class=kt>void</span> <span class=nf>spin_lock_irq</span><span class=p>(</span><span class=kt>spinlock_t</span> <span class=o>*</span><span class=n>lock</span><span class=p>)</span> <span class=c1>//include/linux/spinlock.h
</span></span></span><span class=line><span class=cl><span class=c1>//宏，等效于 raw_spin_lock_irqsave(spinlock_check(lock), flags)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>spin_lock_irqsave</span><span class=p>(</span><span class=n>lock</span><span class=p>,</span> <span class=n>flags</span><span class=p>)</span> <span class=c1>//include/linux/spinlock.h 宏
</span></span></span></code></pre></td></tr></table></div></div><h3 id=h:6ed0c420-d4d7-4a49-8429-d63a29040446><span class=section-num>3.3</span> 解锁函数</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>//里面直接调用的是 raw_spin_unlock(&amp;lock-&gt;rlock)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>static</span> <span class=n>__always_inline</span> <span class=kt>void</span> <span class=nf>spin_unlock</span><span class=p>(</span><span class=kt>spinlock_t</span> <span class=o>*</span><span class=n>lock</span><span class=p>)</span> <span class=c1>//include/linux/spinlock.h
</span></span></span><span class=line><span class=cl><span class=c1>//里面直接调用的是 raw_spin_unlock_bh(&amp;lock-&gt;rlock)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>static</span> <span class=n>__always_inline</span> <span class=kt>void</span> <span class=nf>spin_unlock_bh</span><span class=p>(</span><span class=kt>spinlock_t</span> <span class=o>*</span><span class=n>lock</span><span class=p>)</span> <span class=c1>//include/linux/spinlock.h
</span></span></span><span class=line><span class=cl><span class=c1>//里面直接调用的是 raw_spin_unlock_irq(&amp;lock-&gt;rlock)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>static</span> <span class=n>__always_inline</span> <span class=kt>void</span> <span class=nf>spin_unlock_irq</span><span class=p>(</span><span class=kt>spinlock_t</span> <span class=o>*</span><span class=n>lock</span><span class=p>)</span> <span class=c1>//include/linux/spinlock.h
</span></span></span><span class=line><span class=cl><span class=c1>//里面直接调用的是 raw_spin_unlock_irqrestore(&amp;lock-&gt;rlock, flags)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>static</span> <span class=n>__always_inline</span> <span class=kt>void</span> <span class=nf>spin_unlock_irqrestore</span><span class=p>(</span><span class=kt>spinlock_t</span> <span class=o>*</span><span class=n>lock</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>flags</span><span class=p>)</span> <span class=c1>//include/linux/spinlock.h
</span></span></span></code></pre></td></tr></table></div></div><h3 id=h:0328de7e-60d8-4fed-84ee-9f87ea212509><span class=section-num>3.4</span> 尝试获取锁函数</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>//里面直接调用的是 raw_spin_trylock(&amp;lock-&gt;rlock)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>static</span> <span class=n>__always_inline</span> <span class=kt>int</span> <span class=nf>spin_trylock</span><span class=p>(</span><span class=kt>spinlock_t</span> <span class=o>*</span><span class=n>lock</span><span class=p>)</span> <span class=c1>//include/linux/spinlock.h
</span></span></span><span class=line><span class=cl><span class=c1>//里面直接调用的是 raw_spin_trylock_bh(&amp;lock-&gt;rlock)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>static</span> <span class=n>__always_inline</span> <span class=kt>int</span> <span class=nf>spin_trylock_bh</span><span class=p>(</span><span class=kt>spinlock_t</span> <span class=o>*</span><span class=n>lock</span><span class=p>)</span> <span class=c1>//include/linux/spinlock.h
</span></span></span><span class=line><span class=cl><span class=c1>//里面直接调用的是 raw_spin_trylock_irq(&amp;lock-&gt;rlock)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>static</span> <span class=n>__always_inline</span> <span class=kt>int</span> <span class=nf>spin_trylock_irq</span><span class=p>(</span><span class=kt>spinlock_t</span> <span class=o>*</span><span class=n>lock</span><span class=p>)</span> <span class=c1>//include/linux/spinlock.h
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=o>//</span><span class=err>宏，里面直接调用的是</span> <span class=nf>raw_spin_trylock_irqsave</span><span class=p>(</span><span class=nf>spinlock_check</span><span class=p>(</span><span class=n>lock</span><span class=p>),</span> <span class=n>flags</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nf>spin_trylock_irqsave</span><span class=p>(</span><span class=n>lock</span><span class=p>,</span> <span class=n>flags</span><span class=p>)</span> <span class=c1>//include/linux/spinlock.h 宏
</span></span></span></code></pre></td></tr></table></div></div><h3 id=h:7d4fd4ec-c540-4189-b61e-89be724f406f><span class=section-num>3.5</span> 判断上锁状态</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>//直接调用的是 raw_spin_is_locked(&amp;lock-&gt;rlock), 直接返回的是 lock-&gt;val，非 0 表示 locked 的状态，0表示非 locked 状态
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>static</span> <span class=n>__always_inline</span> <span class=kt>int</span> <span class=nf>spin_is_locked</span><span class=p>(</span><span class=kt>spinlock_t</span> <span class=o>*</span><span class=n>lock</span><span class=p>)</span> <span class=c1>//include/linux/spinlock.h
</span></span></span><span class=line><span class=cl><span class=c1>//直接调用的是 raw_spin_is_contended(&amp;lock-&gt;rlock), 判断锁是否处于被竞争状态，也即是否有任务在等待获取锁，为真表示锁处于竞争状态
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>static</span> <span class=n>__always_inline</span> <span class=kt>int</span> <span class=nf>spin_is_contended</span><span class=p>(</span><span class=kt>spinlock_t</span> <span class=o>*</span><span class=n>lock</span><span class=p>)</span> <span class=c1>//include/linux/spinlock.h
</span></span></span><span class=line><span class=cl><span class=c1>//判断上锁状态，等效于调用 BUG_ON(!raw_spin_is_locked(&amp;lock-&gt;rlock))
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>assert_spin_locked</span><span class=p>(</span><span class=n>lock</span><span class=p>)</span> <span class=c1>//include/linux/spinlock.h 宏
</span></span></span></code></pre></td></tr></table></div></div><p>raw_XXX() 函数是直接对 lock->rlock 操作，一般使用不会直接使用。</p><p>可以看到，spin lock 的使用是需要区分是何种上下文的。spin_lock() 在持锁前先关抢占，通过在
current->thread_info.preempt.count 的"preempt bit"位段上加 1 来实现。spin_lock_bh() 持锁前先关底半部，通过在"software
interrupt count" bit 位段上加 2 和在"preempt bit"位段上加 1 实现的。spin_lock_irq() 持锁之前先关本地中断，再关抢占(这里关中断是没有直接操作 preempt.count 的位段)。spin_lock_irqsave() 持锁之前先关中断再关抢占，同时保存中断标志位。</p><h3 id=h:e5859ac4-e6ed-4d9d-aad8-55bff1770ccd><span class=section-num>3.6</span> 还可以直接使用 <code>raw_spinlock_t</code> 和与其配套的一组 <code>raw_spin_xxx()</code></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#define DEFINE_RAW_SPINLOCK(x) </span><span class=c1>//include/linux/spinlock_types.h
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>raw_spin_lock_irqsave</span><span class=p>(</span><span class=n>lock</span><span class=p>,</span> <span class=n>flags</span><span class=p>)</span> <span class=c1>//include/linux/spinlock.h
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>raw_spin_unlock_irqrestore</span><span class=p>(</span><span class=n>lock</span><span class=p>,</span> <span class=n>flags</span><span class=p>)</span> <span class=c1>//include/linux/spinlock.h
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>...</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=h:99559801-d2f0-4850-8000-f4326f72a359><span class=section-num>4</span> 锁代码分析</h2><h3 id=h:21c8b10c-e5e1-4d2e-9a4b-dd13c57332b5><span class=section-num>4.1</span> <code>spin_lock()</code></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=n>__always_inline</span> <span class=kt>void</span> <span class=nf>spin_lock</span><span class=p>(</span><span class=kt>spinlock_t</span> <span class=o>*</span><span class=n>lock</span><span class=p>)</span> <span class=c1>//include/linux/spinlock.h
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>raw_spin_lock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>lock</span><span class=o>-&gt;</span><span class=n>rlock</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=cp>#define raw_spin_lock(lock)    _raw_spin_lock(lock) </span><span class=c1>//include/linux/spinlock.h
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=n>__lockfunc</span> <span class=nf>_raw_spin_lock</span><span class=p>(</span><span class=kt>raw_spinlock_t</span> <span class=o>*</span><span class=n>lock</span><span class=p>)</span> <span class=c1>//kernel/locking/spinlock.c
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>__raw_spin_lock</span><span class=p>(</span><span class=n>lock</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kr>inline</span> <span class=kt>void</span> <span class=nf>__raw_spin_lock</span><span class=p>(</span><span class=kt>raw_spinlock_t</span> <span class=o>*</span><span class=n>lock</span><span class=p>)</span> <span class=c1>//include/linux/spinlock_api_smp.h
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* 关抢占 */</span>
</span></span><span class=line><span class=cl>    <span class=nf>preempt_disable</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* 默认不使能 CONFIG_LOCKDEP，是个空函数 */</span>
</span></span><span class=line><span class=cl>    <span class=nf>spin_acquire</span><span class=p>(</span><span class=o>&amp;</span><span class=n>lock</span><span class=o>-&gt;</span><span class=n>dep_map</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=n>_RET_IP_</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* 默认不使能 CONFIG_LOCK_STAT,      等效于 do_raw_spin_lock(lock) */</span>
</span></span><span class=line><span class=cl>    <span class=nf>LOCK_CONTENDED</span><span class=p>(</span><span class=n>lock</span><span class=p>,</span> <span class=n>do_raw_spin_trylock</span><span class=p>,</span> <span class=n>do_raw_spin_lock</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kr>inline</span> <span class=kt>void</span> <span class=nf>do_raw_spin_lock</span><span class=p>(</span><span class=kt>raw_spinlock_t</span> <span class=o>*</span><span class=n>lock</span><span class=p>)</span> <span class=nf>__acquires</span><span class=p>(</span><span class=n>lock</span><span class=p>)</span> <span class=c1>//include/linux/spinlock.h
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* 静态代码检查相关，忽略之 */</span>
</span></span><span class=line><span class=cl>    <span class=nf>__acquire</span><span class=p>(</span><span class=n>lock</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>arch_spin_lock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>lock</span><span class=o>-&gt;</span><span class=n>raw_lock</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>mmiowb_spin_lock</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=cp>#define arch_spin_lock(l)    queued_spin_lock(l) </span><span class=c1>//include/asm-generic/qspinlock.h
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * queued_spin_lock - acquire a queued spinlock
</span></span></span><span class=line><span class=cl><span class=cm> * @lock: Pointer to queued spinlock structure, that is arch_spinlock_t.
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=n>__always_inline</span> <span class=kt>void</span> <span class=nf>queued_spin_lock</span><span class=p>(</span><span class=k>struct</span> <span class=n>qspinlock</span> <span class=o>*</span><span class=n>lock</span><span class=p>)</span> <span class=c1>//include/asm-generic/qspinlock.h
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>u32</span> <span class=n>val</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>     * 参数(*v, *old, new):
</span></span></span><span class=line><span class=cl><span class=cm>     *    if (*v == *old) {*v = new; return true;}
</span></span></span><span class=line><span class=cl><span class=cm>     *    if (*v != *old) {*old = *v; return false;}
</span></span></span><span class=line><span class=cl><span class=cm>     *
</span></span></span><span class=line><span class=cl><span class=cm>     * 如果 lock-&gt;val == 0, lock-&gt;val = _Q_LOCKED_VAL; return true;
</span></span></span><span class=line><span class=cl><span class=cm>     * 也就是说 lock-&gt;val 为 0 表示没有人持锁，此时赋值为 1 表示持有了该锁
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>likely</span><span class=p>(</span><span class=nf>atomic_try_cmpxchg_acquire</span><span class=p>(</span><span class=o>&amp;</span><span class=n>lock</span><span class=o>-&gt;</span><span class=n>val</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>val</span><span class=p>,</span> <span class=n>_Q_LOCKED_VAL</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* 若是上面持锁失败，进入持锁慢速路径，上面进行了赋值，传参 val=lock-&gt;val */</span>
</span></span><span class=line><span class=cl>    <span class=nf>queued_spin_lock_slowpath</span><span class=p>(</span><span class=n>lock</span><span class=p>,</span> <span class=n>val</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=h:2dcaa6de-51ee-4f66-9dcc-7380cc1cd15d><span class=section-num>4.2</span> spin_lock 持锁慢速路径 queued_spin_lock_slowpath():</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>  1
</span><span class=lnt>  2
</span><span class=lnt>  3
</span><span class=lnt>  4
</span><span class=lnt>  5
</span><span class=lnt>  6
</span><span class=lnt>  7
</span><span class=lnt>  8
</span><span class=lnt>  9
</span><span class=lnt> 10
</span><span class=lnt> 11
</span><span class=lnt> 12
</span><span class=lnt> 13
</span><span class=lnt> 14
</span><span class=lnt> 15
</span><span class=lnt> 16
</span><span class=lnt> 17
</span><span class=lnt> 18
</span><span class=lnt> 19
</span><span class=lnt> 20
</span><span class=lnt> 21
</span><span class=lnt> 22
</span><span class=lnt> 23
</span><span class=lnt> 24
</span><span class=lnt> 25
</span><span class=lnt> 26
</span><span class=lnt> 27
</span><span class=lnt> 28
</span><span class=lnt> 29
</span><span class=lnt> 30
</span><span class=lnt> 31
</span><span class=lnt> 32
</span><span class=lnt> 33
</span><span class=lnt> 34
</span><span class=lnt> 35
</span><span class=lnt> 36
</span><span class=lnt> 37
</span><span class=lnt> 38
</span><span class=lnt> 39
</span><span class=lnt> 40
</span><span class=lnt> 41
</span><span class=lnt> 42
</span><span class=lnt> 43
</span><span class=lnt> 44
</span><span class=lnt> 45
</span><span class=lnt> 46
</span><span class=lnt> 47
</span><span class=lnt> 48
</span><span class=lnt> 49
</span><span class=lnt> 50
</span><span class=lnt> 51
</span><span class=lnt> 52
</span><span class=lnt> 53
</span><span class=lnt> 54
</span><span class=lnt> 55
</span><span class=lnt> 56
</span><span class=lnt> 57
</span><span class=lnt> 58
</span><span class=lnt> 59
</span><span class=lnt> 60
</span><span class=lnt> 61
</span><span class=lnt> 62
</span><span class=lnt> 63
</span><span class=lnt> 64
</span><span class=lnt> 65
</span><span class=lnt> 66
</span><span class=lnt> 67
</span><span class=lnt> 68
</span><span class=lnt> 69
</span><span class=lnt> 70
</span><span class=lnt> 71
</span><span class=lnt> 72
</span><span class=lnt> 73
</span><span class=lnt> 74
</span><span class=lnt> 75
</span><span class=lnt> 76
</span><span class=lnt> 77
</span><span class=lnt> 78
</span><span class=lnt> 79
</span><span class=lnt> 80
</span><span class=lnt> 81
</span><span class=lnt> 82
</span><span class=lnt> 83
</span><span class=lnt> 84
</span><span class=lnt> 85
</span><span class=lnt> 86
</span><span class=lnt> 87
</span><span class=lnt> 88
</span><span class=lnt> 89
</span><span class=lnt> 90
</span><span class=lnt> 91
</span><span class=lnt> 92
</span><span class=lnt> 93
</span><span class=lnt> 94
</span><span class=lnt> 95
</span><span class=lnt> 96
</span><span class=lnt> 97
</span><span class=lnt> 98
</span><span class=lnt> 99
</span><span class=lnt>100
</span><span class=lnt>101
</span><span class=lnt>102
</span><span class=lnt>103
</span><span class=lnt>104
</span><span class=lnt>105
</span><span class=lnt>106
</span><span class=lnt>107
</span><span class=lnt>108
</span><span class=lnt>109
</span><span class=lnt>110
</span><span class=lnt>111
</span><span class=lnt>112
</span><span class=lnt>113
</span><span class=lnt>114
</span><span class=lnt>115
</span><span class=lnt>116
</span><span class=lnt>117
</span><span class=lnt>118
</span><span class=lnt>119
</span><span class=lnt>120
</span><span class=lnt>121
</span><span class=lnt>122
</span><span class=lnt>123
</span><span class=lnt>124
</span><span class=lnt>125
</span><span class=lnt>126
</span><span class=lnt>127
</span><span class=lnt>128
</span><span class=lnt>129
</span><span class=lnt>130
</span><span class=lnt>131
</span><span class=lnt>132
</span><span class=lnt>133
</span><span class=lnt>134
</span><span class=lnt>135
</span><span class=lnt>136
</span><span class=lnt>137
</span><span class=lnt>138
</span><span class=lnt>139
</span><span class=lnt>140
</span><span class=lnt>141
</span><span class=lnt>142
</span><span class=lnt>143
</span><span class=lnt>144
</span><span class=lnt>145
</span><span class=lnt>146
</span><span class=lnt>147
</span><span class=lnt>148
</span><span class=lnt>149
</span><span class=lnt>150
</span><span class=lnt>151
</span><span class=lnt>152
</span><span class=lnt>153
</span><span class=lnt>154
</span><span class=lnt>155
</span><span class=lnt>156
</span><span class=lnt>157
</span><span class=lnt>158
</span><span class=lnt>159
</span><span class=lnt>160
</span><span class=lnt>161
</span><span class=lnt>162
</span><span class=lnt>163
</span><span class=lnt>164
</span><span class=lnt>165
</span><span class=lnt>166
</span><span class=lnt>167
</span><span class=lnt>168
</span><span class=lnt>169
</span><span class=lnt>170
</span><span class=lnt>171
</span><span class=lnt>172
</span><span class=lnt>173
</span><span class=lnt>174
</span><span class=lnt>175
</span><span class=lnt>176
</span><span class=lnt>177
</span><span class=lnt>178
</span><span class=lnt>179
</span><span class=lnt>180
</span><span class=lnt>181
</span><span class=lnt>182
</span><span class=lnt>183
</span><span class=lnt>184
</span><span class=lnt>185
</span><span class=lnt>186
</span><span class=lnt>187
</span><span class=lnt>188
</span><span class=lnt>189
</span><span class=lnt>190
</span><span class=lnt>191
</span><span class=lnt>192
</span><span class=lnt>193
</span><span class=lnt>194
</span><span class=lnt>195
</span><span class=lnt>196
</span><span class=lnt>197
</span><span class=lnt>198
</span><span class=lnt>199
</span><span class=lnt>200
</span><span class=lnt>201
</span><span class=lnt>202
</span><span class=lnt>203
</span><span class=lnt>204
</span><span class=lnt>205
</span><span class=lnt>206
</span><span class=lnt>207
</span><span class=lnt>208
</span><span class=lnt>209
</span><span class=lnt>210
</span><span class=lnt>211
</span><span class=lnt>212
</span><span class=lnt>213
</span><span class=lnt>214
</span><span class=lnt>215
</span><span class=lnt>216
</span><span class=lnt>217
</span><span class=lnt>218
</span><span class=lnt>219
</span><span class=lnt>220
</span><span class=lnt>221
</span><span class=lnt>222
</span><span class=lnt>223
</span><span class=lnt>224
</span><span class=lnt>225
</span><span class=lnt>226
</span><span class=lnt>227
</span><span class=lnt>228
</span><span class=lnt>229
</span><span class=lnt>230
</span><span class=lnt>231
</span><span class=lnt>232
</span><span class=lnt>233
</span><span class=lnt>234
</span><span class=lnt>235
</span><span class=lnt>236
</span><span class=lnt>237
</span><span class=lnt>238
</span><span class=lnt>239
</span><span class=lnt>240
</span><span class=lnt>241
</span><span class=lnt>242
</span><span class=lnt>243
</span><span class=lnt>244
</span><span class=lnt>245
</span><span class=lnt>246
</span><span class=lnt>247
</span><span class=lnt>248
</span><span class=lnt>249
</span><span class=lnt>250
</span><span class=lnt>251
</span><span class=lnt>252
</span><span class=lnt>253
</span><span class=lnt>254
</span><span class=lnt>255
</span><span class=lnt>256
</span><span class=lnt>257
</span><span class=lnt>258
</span><span class=lnt>259
</span><span class=lnt>260
</span><span class=lnt>261
</span><span class=lnt>262
</span><span class=lnt>263
</span><span class=lnt>264
</span><span class=lnt>265
</span><span class=lnt>266
</span><span class=lnt>267
</span><span class=lnt>268
</span><span class=lnt>269
</span><span class=lnt>270
</span><span class=lnt>271
</span><span class=lnt>272
</span><span class=lnt>273
</span><span class=lnt>274
</span><span class=lnt>275
</span><span class=lnt>276
</span><span class=lnt>277
</span><span class=lnt>278
</span><span class=lnt>279
</span><span class=lnt>280
</span><span class=lnt>281
</span><span class=lnt>282
</span><span class=lnt>283
</span><span class=lnt>284
</span><span class=lnt>285
</span><span class=lnt>286
</span><span class=lnt>287
</span><span class=lnt>288
</span><span class=lnt>289
</span><span class=lnt>290
</span><span class=lnt>291
</span><span class=lnt>292
</span><span class=lnt>293
</span><span class=lnt>294
</span><span class=lnt>295
</span><span class=lnt>296
</span><span class=lnt>297
</span><span class=lnt>298
</span><span class=lnt>299
</span><span class=lnt>300
</span><span class=lnt>301
</span><span class=lnt>302
</span><span class=lnt>303
</span><span class=lnt>304
</span><span class=lnt>305
</span><span class=lnt>306
</span><span class=lnt>307
</span><span class=lnt>308
</span><span class=lnt>309
</span><span class=lnt>310
</span><span class=lnt>311
</span><span class=lnt>312
</span><span class=lnt>313
</span><span class=lnt>314
</span><span class=lnt>315
</span><span class=lnt>316
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * queued_spin_lock_slowpath - acquire the queued spinlock
</span></span></span><span class=line><span class=cl><span class=cm> * @lock: Pointer to queued spinlock structure
</span></span></span><span class=line><span class=cl><span class=cm> * @val: Current value of the queued spinlock 32-bit word
</span></span></span><span class=line><span class=cl><span class=cm> *
</span></span></span><span class=line><span class=cl><span class=cm> * val: (queue tail(bit16-31 x), pending bit(bit8 y), lock value(bit0-7 z))
</span></span></span><span class=line><span class=cl><span class=cm> *
</span></span></span><span class=line><span class=cl><span class=cm> *              fast     :    slow                                  :    unlock
</span></span></span><span class=line><span class=cl><span class=cm> *                       :                                          :
</span></span></span><span class=line><span class=cl><span class=cm> * uncontended  (0,0,0) -:--&gt; (0,0,1) ------------------------------:--&gt; (*,*,0)
</span></span></span><span class=line><span class=cl><span class=cm> *                       :       | ^--------.------.             /  :
</span></span></span><span class=line><span class=cl><span class=cm> *                       :       v           \      \            |  :
</span></span></span><span class=line><span class=cl><span class=cm> * pending               :    (0,1,1) +--&gt; (0,1,0)   \           |  :
</span></span></span><span class=line><span class=cl><span class=cm> *                       :       | ^--&#39;              |           |  :
</span></span></span><span class=line><span class=cl><span class=cm> *                       :       v                   |           |  :
</span></span></span><span class=line><span class=cl><span class=cm> * uncontended           :    (n,x,y) +--&gt; (n,0,0) --&#39;           |  :
</span></span></span><span class=line><span class=cl><span class=cm> *   queue               :       | ^--&#39;                          |  :
</span></span></span><span class=line><span class=cl><span class=cm> *                       :       v                               |  :
</span></span></span><span class=line><span class=cl><span class=cm> * contended             :    (*,x,y) +--&gt; (*,0,0) ---&gt; (*,0,1) -&#39;  :
</span></span></span><span class=line><span class=cl><span class=cm> *   queue               :         ^--&#39;                             :
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>queued_spin_lock 传参(lock, lock-&gt;val)
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>queued_spin_lock_slowpath</span><span class=p>(</span><span class=k>struct</span> <span class=n>qspinlock</span> <span class=o>*</span><span class=n>lock</span><span class=p>,</span> <span class=n>u32</span> <span class=n>val</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>mcs_spinlock</span> <span class=o>*</span><span class=n>prev</span><span class=p>,</span> <span class=o>*</span><span class=n>next</span><span class=p>,</span> <span class=o>*</span><span class=n>node</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>u32</span> <span class=n>old</span><span class=p>,</span> <span class=n>tail</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>idx</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* 32 &gt;= 1&lt;&lt;14 恒不成立 */</span>
</span></span><span class=line><span class=cl>    <span class=nf>BUILD_BUG_ON</span><span class=p>(</span><span class=n>CONFIG_NR_CPUS</span> <span class=o>&gt;=</span> <span class=p>(</span><span class=mi>1U</span> <span class=o>&lt;&lt;</span> <span class=n>_Q_TAIL_CPU_BITS</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* 默认为 false，恒不执行 */</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>pv_enabled</span><span class=p>())</span>
</span></span><span class=line><span class=cl>        <span class=k>goto</span> <span class=n>pv_queue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* 默认为 false，恒不执行 */</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>virt_spin_lock</span><span class=p>(</span><span class=n>lock</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>     * Wait for in-progress pending-&gt;locked hand-overs with a bounded
</span></span></span><span class=line><span class=cl><span class=cm>     * number of spins so that we guarantee forward progress. 0,1,0 -&gt; 0,0,1
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>     * 进入慢速路径时有任务在等待 spin lock，执行这段代码时间内它可能已经获取到 spin lock 了，
</span></span></span><span class=line><span class=cl><span class=cm>     * 这里更新下从 lock-&gt;val 读取到的值.
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>val</span> <span class=o>==</span> <span class=n>_Q_PENDING_VAL</span><span class=p>)</span> <span class=p>{</span> <span class=c1>//1&lt;&lt;8
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=kt>int</span> <span class=n>cnt</span> <span class=o>=</span> <span class=n>_Q_PENDING_LOOPS</span><span class=p>;</span> <span class=c1>//1
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>         * 函数作用：死循环读取 lock-&gt;val 的值，直到 arg2 为真才返回读取的结果。
</span></span></span><span class=line><span class=cl><span class=cm>         * VAL 为读取的 lock-&gt;val 的值.
</span></span></span><span class=line><span class=cl><span class=cm>         * 含义为死循环读取 lock-&gt;val 的值，直到 lock-&gt;val != _Q_PENDING_VAL(即 1&lt;&lt;8),
</span></span></span><span class=line><span class=cl><span class=cm>         * 或尝试读取的次数达到 cnt 次，这里 cnt 初始化为 1，其实就只是读取一次。
</span></span></span><span class=line><span class=cl><span class=cm>         */</span>
</span></span><span class=line><span class=cl>        <span class=n>val</span> <span class=o>=</span> <span class=nf>atomic_cond_read_relaxed</span><span class=p>(</span><span class=o>&amp;</span><span class=n>lock</span><span class=o>-&gt;</span><span class=n>val</span><span class=p>,</span> <span class=p>(</span><span class=n>VAL</span> <span class=o>!=</span> <span class=n>_Q_PENDING_VAL</span><span class=p>)</span> <span class=o>||</span> <span class=o>!</span><span class=n>cnt</span><span class=o>--</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>     * If we observe any contention; queue.
</span></span></span><span class=line><span class=cl><span class=cm>     *
</span></span></span><span class=line><span class=cl><span class=cm>     * 除了 lock value(即 z)之外，还有其它位段不为 0，说明已经有任务处于 pending 等锁的状态了，
</span></span></span><span class=line><span class=cl><span class=cm>     * 那么就直接 queue，在自己的 mcs 锁上自旋，不要在 lock-&gt;val 上自旋了。
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>val</span> <span class=o>&amp;</span> <span class=o>~</span><span class=n>_Q_LOCKED_MASK</span><span class=p>)</span> <span class=c1>// val &amp; ~0xff
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>goto</span> <span class=n>queue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>     * trylock || pending
</span></span></span><span class=line><span class=cl><span class=cm>     * 0,0,* -&gt; 0,1,* -&gt; 0,0,1 pending, trylock
</span></span></span><span class=line><span class=cl><span class=cm>     *
</span></span></span><span class=line><span class=cl><span class=cm>     * 代码走到这里，说明没有任务处于 pending 状态，那么设置锁的 pending 标志，标识本任务
</span></span></span><span class=line><span class=cl><span class=cm>     * 要 pending 了。
</span></span></span><span class=line><span class=cl><span class=cm>     * 函数等效于 ret = lock-&gt;val; lock-&gt;val |= _Q_PENDING_VAL(1&lt;&lt;8); val = ret;
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=n>val</span> <span class=o>=</span> <span class=nf>queued_fetch_set_pending_acquire</span><span class=p>(</span><span class=n>lock</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>     * If we observe contention, there is a concurrent locker.
</span></span></span><span class=line><span class=cl><span class=cm>     *
</span></span></span><span class=line><span class=cl><span class=cm>     * Undo and queue; our setting of PENDING might have made the
</span></span></span><span class=line><span class=cl><span class=cm>     * n,0,0 -&gt; 0,0,0 transition fail and it will now be waiting
</span></span></span><span class=line><span class=cl><span class=cm>     * on @next to become !NULL.
</span></span></span><span class=line><span class=cl><span class=cm>     *
</span></span></span><span class=line><span class=cl><span class=cm>     * 在执行这段代码期间，若是有任务进入了 pending 状态(设置了 pending 标识或
</span></span></span><span class=line><span class=cl><span class=cm>     * 在 msc lock 上 spin 了)，那么也是要直接 queue 的，在自己的 msc lock 上 spin，
</span></span></span><span class=line><span class=cl><span class=cm>     * 不要在 lock-&gt;val 上 spin 了。
</span></span></span><span class=line><span class=cl><span class=cm>     * 若情况是其它任务在 mcs lock 上自旋了，就清除自己或上的 pending 标志。
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>unlikely</span><span class=p>(</span><span class=n>val</span> <span class=o>&amp;</span> <span class=o>~</span><span class=n>_Q_LOCKED_MASK</span><span class=p>))</span> <span class=p>{</span> <span class=c1>//~0xff
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=cm>/* Undo PENDING if we set it. */</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=p>(</span><span class=n>val</span> <span class=o>&amp;</span> <span class=n>_Q_PENDING_MASK</span><span class=p>))</span> <span class=c1>//_Q_PENDING_MASK = 0xff&lt;&lt;8
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=cm>/* 直接 lock-&gt;pending=0, 将 pending 位段清 0，看来 pending 位段只使用了 bit8 */</span>
</span></span><span class=line><span class=cl>            <span class=nf>clear_pending</span><span class=p>(</span><span class=n>lock</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>goto</span> <span class=n>queue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>     * We&#39;re pending, wait for the owner to go away.
</span></span></span><span class=line><span class=cl><span class=cm>     *
</span></span></span><span class=line><span class=cl><span class=cm>     * 0,1,1 -&gt; 0,1,0
</span></span></span><span class=line><span class=cl><span class=cm>     *
</span></span></span><span class=line><span class=cl><span class=cm>     * this wait loop must be a load-acquire such that we match the
</span></span></span><span class=line><span class=cl><span class=cm>     * store-release that clears the locked bit and create lock
</span></span></span><span class=line><span class=cl><span class=cm>     * sequentiality; this is because not all
</span></span></span><span class=line><span class=cl><span class=cm>     * clear_pending_set_locked() implementations imply full
</span></span></span><span class=line><span class=cl><span class=cm>     * barriers.
</span></span></span><span class=line><span class=cl><span class=cm>     *
</span></span></span><span class=line><span class=cl><span class=cm>     * 代码走到这里，说明目前只有一个任务正持有锁(也可能已经释放了)，且没有任务等待。
</span></span></span><span class=line><span class=cl><span class=cm>     * 那么就在 lock-&gt;val 上自旋等待，只有锁的 owner 退出临界区。
</span></span></span><span class=line><span class=cl><span class=cm>     * 上面的这个 pending 位段为 1 还是上面本任务设置的。
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>val</span> <span class=o>&amp;</span> <span class=n>_Q_LOCKED_MASK</span><span class=p>)</span> <span class=c1>//0xff
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nf>atomic_cond_read_acquire</span><span class=p>(</span><span class=o>&amp;</span><span class=n>lock</span><span class=o>-&gt;</span><span class=n>val</span><span class=p>,</span> <span class=o>!</span><span class=p>(</span><span class=n>VAL</span> <span class=o>&amp;</span> <span class=n>_Q_LOCKED_MASK</span><span class=p>));</span> <span class=c1>//【1. 在 lock-&gt;val 上 spin】
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>     * take ownership and clear the pending bit.
</span></span></span><span class=line><span class=cl><span class=cm>     * 0,1,0 -&gt; 0,0,1
</span></span></span><span class=line><span class=cl><span class=cm>     *
</span></span></span><span class=line><span class=cl><span class=cm>     * owner 退出临界区释放锁了，我们就获取锁，清除我们设置的 pending 标志位。
</span></span></span><span class=line><span class=cl><span class=cm>     * 通过将 bit0-15 设置为 1 来实现的。
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=nf>clear_pending_set_locked</span><span class=p>(</span><span class=n>lock</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* 默认不使能 CONFIG_LOCK_EVENT_COUNTS，为空 */</span>
</span></span><span class=line><span class=cl>    <span class=nf>lockevent_inc</span><span class=p>(</span><span class=n>lock_pending</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* 这个路径下，我们就是锁的第一继承人，获取到锁后就退出了 */</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>     * End of pending bit optimistic spinning and beginning of MCS queuing.
</span></span></span><span class=line><span class=cl><span class=cm>     *
</span></span></span><span class=line><span class=cl><span class=cm>     * 下面就是非第一位继承人，要在自己的 msc node 节点上自旋了。
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl><span class=nl>queue</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* 原生有记录进入执行慢速路径的次数 */</span>
</span></span><span class=line><span class=cl>    <span class=nf>lockevent_inc</span><span class=p>(</span><span class=n>lock_slowpath</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nl>pv_queue</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* 获取当前 cpu 的 spin lock 嵌套深度 */</span>
</span></span><span class=line><span class=cl>    <span class=n>node</span> <span class=o>=</span> <span class=nf>this_cpu_ptr</span><span class=p>(</span><span class=o>&amp;</span><span class=n>qnodes</span><span class=p>[</span><span class=mi>0</span><span class=p>].</span><span class=n>mcs</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>idx</span> <span class=o>=</span> <span class=n>node</span><span class=o>-&gt;</span><span class=n>count</span><span class=o>++</span><span class=p>;</span> <span class=c1>//先赋值，再嵌套计数加 1
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//对 tail(即 x)的 tail cpu 和 tail idx 位段进行编码
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>tail</span> <span class=o>=</span> <span class=nf>encode_tail</span><span class=p>(</span><span class=nf>smp_processor_id</span><span class=p>(),</span> <span class=n>idx</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>     * 4 nodes are allocated based on the assumption that there will
</span></span></span><span class=line><span class=cl><span class=cm>     * not be nested NMIs taking spinlocks. That may not be true in
</span></span></span><span class=line><span class=cl><span class=cm>     * some architectures even though the chance of needing more than
</span></span></span><span class=line><span class=cl><span class=cm>     * 4 nodes will still be extremely unlikely. When that happens,
</span></span></span><span class=line><span class=cl><span class=cm>     * we fall back to spinning on the lock directly without using
</span></span></span><span class=line><span class=cl><span class=cm>     * any MCS node. This is not the most elegant solution, but is
</span></span></span><span class=line><span class=cl><span class=cm>     * simple enough.
</span></span></span><span class=line><span class=cl><span class=cm>     * 翻译：基于不会有嵌套 NMI 采用自旋锁的假设分配了 4 个节点。这在某
</span></span></span><span class=line><span class=cl><span class=cm>     * 些架构中可能并非如此，即使需要超过 4 的可能性仍然极小。发生这种情
</span></span></span><span class=line><span class=cl><span class=cm>     * 况时，我们会退回到直接在锁上自旋而不使用任何 MCS 节点。这不是最优
</span></span></span><span class=line><span class=cl><span class=cm>     * 雅的解决方案，但足够简单。
</span></span></span><span class=line><span class=cl><span class=cm>     * 判断了等于，说明最大只允许嵌套 3 层。这里有个统计，若为真，说明出现
</span></span></span><span class=line><span class=cl><span class=cm>     * 了 nmi 中断中持 spin lock 锁的嵌套。
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>unlikely</span><span class=p>(</span><span class=n>idx</span> <span class=o>&gt;=</span> <span class=n>MAX_NODES</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>lockevent_inc</span><span class=p>(</span><span class=n>lock_no_node</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* 退回到在 lock-&gt;val 上 spin 的状态，几乎不可能进到上面 if 语句中来 */</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=p>(</span><span class=o>!</span><span class=nf>queued_spin_trylock</span><span class=p>(</span><span class=n>lock</span><span class=p>))</span>
</span></span><span class=line><span class=cl>            <span class=nf>cpu_relax</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=k>goto</span> <span class=n>release</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* 返回当前 cpu 的 qnodes[idx].mcs 节点的地址 */</span>
</span></span><span class=line><span class=cl>    <span class=n>node</span> <span class=o>=</span> <span class=nf>grab_mcs_node</span><span class=p>(</span><span class=n>node</span><span class=p>,</span> <span class=n>idx</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* Keep counts of non-zero index values: */</span>
</span></span><span class=line><span class=cl>    <span class=nf>lockevent_cond_inc</span><span class=p>(</span><span class=n>lock_use_node2</span> <span class=o>+</span> <span class=n>idx</span> <span class=o>-</span> <span class=mi>1</span><span class=p>,</span> <span class=n>idx</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>     * Ensure that we increment the head node-&gt;count before initialising
</span></span></span><span class=line><span class=cl><span class=cm>     * the actual node. If the compiler is kind enough to reorder these
</span></span></span><span class=line><span class=cl><span class=cm>     * stores, then an IRQ could overwrite our assignments.
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=nf>barrier</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=cm>/*不是继承者 locked 为 0, 最尾部节点指向 NULL */</span>
</span></span><span class=line><span class=cl>    <span class=n>node</span><span class=o>-&gt;</span><span class=n>locked</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>node</span><span class=o>-&gt;</span><span class=n>next</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* 默认没有定义_GEN_PV_LOCK_SLOWPATH，是空函数 */</span>
</span></span><span class=line><span class=cl>    <span class=nf>pv_init_node</span><span class=p>(</span><span class=n>node</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>     * We touched a (possibly) cold cacheline in the per-cpu queue node;
</span></span></span><span class=line><span class=cl><span class=cm>     * attempt the trylock once more in the hope someone let go while we
</span></span></span><span class=line><span class=cl><span class=cm>     * weren&#39;t watching.
</span></span></span><span class=line><span class=cl><span class=cm>     * 尝试获取锁，成功返回 1，失败返回 0
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>queued_spin_trylock</span><span class=p>(</span><span class=n>lock</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=k>goto</span> <span class=n>release</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>     * Ensure that the initialisation of @node is complete before we
</span></span></span><span class=line><span class=cl><span class=cm>     * publish the updated tail via xchg_tail() and potentially link
</span></span></span><span class=line><span class=cl><span class=cm>     * @node into the waitqueue via WRITE_ONCE(prev-&gt;next, node) below.
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=nf>smp_wmb</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>     * Publish the updated tail. We have already touched the queueing cacheline;
</span></span></span><span class=line><span class=cl><span class=cm>     * don&#39;t bother with pending stuff.
</span></span></span><span class=line><span class=cl><span class=cm>     * p,*,* -&gt; n,*,*
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>     * 等效于：ret=lock-&gt;tail; lock-&gt;tail=tail&gt;&gt;_Q_TAIL_OFFSET; old = ret&lt;&lt;_Q_TAIL_OFFSET
</span></span></span><span class=line><span class=cl><span class=cm>     * 也即是将 tail 值赋值给 lock-&gt;val 的 bit16-31.
</span></span></span><span class=line><span class=cl><span class=cm>     * 也就是说 lock-&gt;tail 恒指向最后一个 pending 锁的任务对应的 msc node 节点上 ###########
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=n>old</span> <span class=o>=</span> <span class=nf>xchg_tail</span><span class=p>(</span><span class=n>lock</span><span class=p>,</span> <span class=n>tail</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>next</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>     * if there was a previous node; link it and wait until reaching the head of the
</span></span></span><span class=line><span class=cl><span class=cm>     * waitqueue.
</span></span></span><span class=line><span class=cl><span class=cm>     * 为真，说明之前已经有 mcs node 等待节点存在了。
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>old</span> <span class=o>&amp;</span> <span class=n>_Q_TAIL_MASK</span><span class=p>)</span> <span class=p>{</span> <span class=c1>//bit16-bit31, 也即是 tail 的掩码
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=cm>/* 获取的是 cpu 的嵌套深度 idx 为下标的节点 */</span>
</span></span><span class=line><span class=cl>        <span class=n>prev</span> <span class=o>=</span> <span class=nf>decode_tail</span><span class=p>(</span><span class=n>old</span><span class=p>);</span> <span class=c1>//return per_cpu_ptr(&amp;qnodes[idx].mcs, cpu)
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=cm>/* Link @node into the waitqueue. 构建 msc 链表 */</span>
</span></span><span class=line><span class=cl>        <span class=nf>WRITE_ONCE</span><span class=p>(</span><span class=n>prev</span><span class=o>-&gt;</span><span class=n>next</span><span class=p>,</span> <span class=n>node</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>pv_wait_node</span><span class=p>(</span><span class=n>node</span><span class=p>,</span> <span class=n>prev</span><span class=p>);</span> <span class=c1>//空函数
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=cm>/* 死循环，spin 等待，直到 node-&gt;locked 不为 0 才退出 spin */</span>
</span></span><span class=line><span class=cl>        <span class=nf>arch_mcs_spin_lock_contended</span><span class=p>(</span><span class=o>&amp;</span><span class=n>node</span><span class=o>-&gt;</span><span class=n>locked</span><span class=p>);</span> <span class=c1>//【2. 在 mcs node-&gt;locked 上 spin】
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>         * While waiting for the MCS lock, the next pointer may have
</span></span></span><span class=line><span class=cl><span class=cm>         * been set by another lock waiter. We optimistically load
</span></span></span><span class=line><span class=cl><span class=cm>         * the next pointer &amp; prefetch the cacheline for writing
</span></span></span><span class=line><span class=cl><span class=cm>         * to reduce latency in the upcoming MCS unlock operation.
</span></span></span><span class=line><span class=cl><span class=cm>         * 翻译：在等待 MCS 锁时，下一个指针可能已被另一个锁的 waiter 设置(在另一个 cpu 上，
</span></span></span><span class=line><span class=cl><span class=cm>         * 若被设置 next 就不为 NULL)。我们乐观地加载下一个指针并为写入预取缓存线，以减少
</span></span></span><span class=line><span class=cl><span class=cm>         * 即将到来的 MCS 解锁操作的延迟。
</span></span></span><span class=line><span class=cl><span class=cm>         */</span>
</span></span><span class=line><span class=cl>        <span class=n>next</span> <span class=o>=</span> <span class=nf>READ_ONCE</span><span class=p>(</span><span class=n>node</span><span class=o>-&gt;</span><span class=n>next</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>next</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=nf>prefetchw</span><span class=p>(</span><span class=n>next</span><span class=p>);</span> <span class=c1>//cache line 预取
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>     * we&#39;re at the head of the waitqueue, wait for the owner &amp; pending to
</span></span></span><span class=line><span class=cl><span class=cm>     * go away.
</span></span></span><span class=line><span class=cl><span class=cm>     *
</span></span></span><span class=line><span class=cl><span class=cm>     * *,x,y -&gt; *,0,0
</span></span></span><span class=line><span class=cl><span class=cm>     *
</span></span></span><span class=line><span class=cl><span class=cm>     * this wait loop must use a load-acquire such that we match the
</span></span></span><span class=line><span class=cl><span class=cm>     * store-release that clears the locked bit and create lock
</span></span></span><span class=line><span class=cl><span class=cm>     * sequentiality; this is because the set_locked() function below
</span></span></span><span class=line><span class=cl><span class=cm>     * does not imply a full barrier.
</span></span></span><span class=line><span class=cl><span class=cm>     *
</span></span></span><span class=line><span class=cl><span class=cm>     * The PV pv_wait_head_or_lock function, if active, will acquire
</span></span></span><span class=line><span class=cl><span class=cm>     * the lock and return a non-zero value. So we have to skip the
</span></span></span><span class=line><span class=cl><span class=cm>     * atomic_cond_read_acquire() call. As the next PV queue head hasn&#39;t
</span></span></span><span class=line><span class=cl><span class=cm>     * been designated yet, there is no way for the locked value to become
</span></span></span><span class=line><span class=cl><span class=cm>     * _Q_SLOW_VAL. So both the set_locked() and the
</span></span></span><span class=line><span class=cl><span class=cm>     * atomic_cmpxchg_relaxed() calls will be safe.
</span></span></span><span class=line><span class=cl><span class=cm>     *
</span></span></span><span class=line><span class=cl><span class=cm>     * If PV isn&#39;t active, 0 will be returned instead.
</span></span></span><span class=line><span class=cl><span class=cm>     *
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* 没有使能，函数直接返回 0 */</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>((</span><span class=n>val</span> <span class=o>=</span> <span class=nf>pv_wait_head_or_lock</span><span class=p>(</span><span class=n>lock</span><span class=p>,</span> <span class=n>node</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>        <span class=k>goto</span> <span class=n>locked</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* 代码走到这里，当前任务就是锁的第一继承人了 */</span>
</span></span><span class=line><span class=cl>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>     * 死循环等待，直到         lock-&gt;val 的 y(pending bit)和 z(locked byte)都是 0,  并返回 lock-&gt;val
</span></span></span><span class=line><span class=cl><span class=cm>     * spin_unlock 时直接将 lock-&gt;val 赋值为 0, 判断 pending bit 是为还没进入 msc spin 的尝试
</span></span></span><span class=line><span class=cl><span class=cm>     * 持锁的任务让路的应该。
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=n>val</span> <span class=o>=</span> <span class=nf>atomic_cond_read_acquire</span><span class=p>(</span><span class=o>&amp;</span><span class=n>lock</span><span class=o>-&gt;</span><span class=n>val</span><span class=p>,</span> <span class=o>!</span><span class=p>(</span><span class=n>VAL</span> <span class=o>&amp;</span> <span class=n>_Q_LOCKED_PENDING_MASK</span><span class=p>));</span> <span class=c1>//【3. 在 lock-&gt;val 上 spin】
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nl>locked</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>     * claim the lock:
</span></span></span><span class=line><span class=cl><span class=cm>     *
</span></span></span><span class=line><span class=cl><span class=cm>     * n,0,0 -&gt; 0,0,1 : lock, uncontended
</span></span></span><span class=line><span class=cl><span class=cm>     * *,*,0 -&gt; *,*,1 : lock, contended
</span></span></span><span class=line><span class=cl><span class=cm>     *
</span></span></span><span class=line><span class=cl><span class=cm>     * If the queue head is the only one in the queue (lock value == tail)
</span></span></span><span class=line><span class=cl><span class=cm>     * and nobody is pending, clear the tail code and grab the lock.
</span></span></span><span class=line><span class=cl><span class=cm>     * Otherwise, we only need to grab the lock.
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>     * In the PV case we might already have _Q_LOCKED_VAL set, because
</span></span></span><span class=line><span class=cl><span class=cm>     * of lock stealing; therefore we must also allow:
</span></span></span><span class=line><span class=cl><span class=cm>     *
</span></span></span><span class=line><span class=cl><span class=cm>     * n,0,1 -&gt; 0,0,1
</span></span></span><span class=line><span class=cl><span class=cm>     *
</span></span></span><span class=line><span class=cl><span class=cm>     * Note: at this point: (val &amp; _Q_PENDING_MASK) == 0, because of the
</span></span></span><span class=line><span class=cl><span class=cm>     *       above wait condition, therefore any concurrent setting of
</span></span></span><span class=line><span class=cl><span class=cm>     *       PENDING will make the uncontended transition fail.
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>     * 走到这里，val 的 lock 和 pending 是为 0 的，但是 tail 中可能还保存着其它等待者的信息。
</span></span></span><span class=line><span class=cl><span class=cm>     * lock-&gt;tail 指向最后一个等待获取锁的任务的 mcs node 节点，若和自己相等，说明自己
</span></span></span><span class=line><span class=cl><span class=cm>     * 是唯一一个 mcs node 节点。
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>((</span><span class=n>val</span> <span class=o>&amp;</span> <span class=n>_Q_TAIL_MASK</span><span class=p>)</span> <span class=o>==</span> <span class=n>tail</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>         * if (lock-&gt;val == val) {lock-&gt;val = _Q_LOCKED_VAL; return true;} 持锁退出
</span></span></span><span class=line><span class=cl><span class=cm>         * if (lock-&gt;val != val) {val = lock-&gt;val; return false;} //没持锁
</span></span></span><span class=line><span class=cl><span class=cm>         */</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=nf>atomic_try_cmpxchg_relaxed</span><span class=p>(</span><span class=o>&amp;</span><span class=n>lock</span><span class=o>-&gt;</span><span class=n>val</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>val</span><span class=p>,</span> <span class=n>_Q_LOCKED_VAL</span><span class=p>))</span>
</span></span><span class=line><span class=cl>            <span class=k>goto</span> <span class=n>release</span><span class=p>;</span> <span class=cm>/* No contention */</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* 下面就是还有新的任务等待了，有新 msc                 node 串联在链表上了 */</span>
</span></span><span class=line><span class=cl>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>     * Either somebody is queued behind us or _Q_PENDING_VAL got set
</span></span></span><span class=line><span class=cl><span class=cm>     * which will then detect the remaining tail and queue behind us
</span></span></span><span class=line><span class=cl><span class=cm>     * ensuring we&#39;ll see a @next.
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* 直接赋值 lock-&gt;locked = _Q_LOCKED_VAL，即对 bit0-7 locked byte 进行赋值，已经持锁了 */</span>
</span></span><span class=line><span class=cl>    <span class=nf>set_locked</span><span class=p>(</span><span class=n>lock</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>     * contended path; wait for next if not observed yet, release.
</span></span></span><span class=line><span class=cl><span class=cm>     * 等待已经更新 lock-&gt;tail 的新的 waiter 挂在 msc 链表上
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>next</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* 死循环等待，直到 node-&gt;next 不为 NULL，通过不会等待很多次 */</span>
</span></span><span class=line><span class=cl>        <span class=n>next</span> <span class=o>=</span> <span class=nf>smp_cond_load_relaxed</span><span class=p>(</span><span class=o>&amp;</span><span class=n>node</span><span class=o>-&gt;</span><span class=n>next</span><span class=p>,</span> <span class=p>(</span><span class=n>VAL</span><span class=p>));</span> <span class=c1>//【4. 在 mcs node-&gt;next 上 spin】
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>     * 直接 next-&gt;locked = 1, 将下一个 mcs 节点设为第一继承人，
</span></span></span><span class=line><span class=cl><span class=cm>     * 其就会退出在 node-&gt;locked 上的自旋，改为在 lock-&gt;val 上的自旋
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=nf>arch_mcs_spin_unlock_contended</span><span class=p>(</span><span class=o>&amp;</span><span class=n>next</span><span class=o>-&gt;</span><span class=n>locked</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=cm>/*没有使能，为空 */</span>
</span></span><span class=line><span class=cl>    <span class=nf>pv_kick_node</span><span class=p>(</span><span class=n>lock</span><span class=p>,</span> <span class=n>next</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* 下面就是获取到 spin_lock 锁后的逻辑了 */</span>
</span></span><span class=line><span class=cl><span class=nl>release</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* release the node. qnodes[0].mcs.count - 1 应该是和前面的加 1 相对应的 */</span>
</span></span><span class=line><span class=cl>    <span class=nf>__this_cpu_dec</span><span class=p>(</span><span class=n>qnodes</span><span class=p>[</span><span class=mi>0</span><span class=p>].</span><span class=n>mcs</span><span class=p>.</span><span class=n>count</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nf>EXPORT_SYMBOL</span><span class=p>(</span><span class=n>queued_spin_lock_slowpath</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><p>a. spin lock 持锁后就一直在临界区了，不会休眠，因此不需要记录锁的 owner。
b. 非第一继承人的 waiter 在自己的 mcs node 的 node->locked 上的自旋，而第一继承人在 lock->val 上自旋。
c. 每个 cpu 有一个 mcs node[]数组，数组中有 4 个 mcs node 成员，对应四种嵌套深度(thread、softirq、irq、nmi)，若是没有嵌套的话，使用的恒定是 node[0].
d. 一个锁对应的 mcs node 节点构成一个单链表，以 NULL 结尾，lock->val 的 tail 域"指向"最后一个获取锁的 waiter 所对应的 mcs node 节点。</p><p>(1) queued_spin_trylock 函数，尝试获取 spin lock。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * queued_spin_trylock - try to acquire the queued spinlock
</span></span></span><span class=line><span class=cl><span class=cm> * @lock : Pointer to queued spinlock structure
</span></span></span><span class=line><span class=cl><span class=cm> * Return: 1 if lock acquired, 0 if failed
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=n>__always_inline</span> <span class=kt>int</span> <span class=nf>queued_spin_trylock</span><span class=p>(</span><span class=k>struct</span> <span class=n>qspinlock</span> <span class=o>*</span><span class=n>lock</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>u32</span> <span class=n>val</span> <span class=o>=</span> <span class=nf>atomic_read</span><span class=p>(</span><span class=o>&amp;</span><span class=n>lock</span><span class=o>-&gt;</span><span class=n>val</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* 这里 val 不等于 0 就退出了，若没退出走到下面就是本线程可以持锁的状态了 */</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>unlikely</span><span class=p>(</span><span class=n>val</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>     * 参数：(atomic_t *v, int *old, int new)
</span></span></span><span class=line><span class=cl><span class=cm>     * if (*v == *old) {*v = new; return true;}
</span></span></span><span class=line><span class=cl><span class=cm>     * if (*v != *old) {*old = *v; return false;}
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nf>likely</span><span class=p>(</span><span class=nf>atomic_try_cmpxchg_acquire</span><span class=p>(</span><span class=o>&amp;</span><span class=n>lock</span><span class=o>-&gt;</span><span class=n>val</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>val</span><span class=p>,</span> <span class=n>_Q_LOCKED_VAL</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=h:1f8557df-11a7-4ad4-bcf7-d3a4d569749d><span class=section-num>5</span> 解锁代码分析</h2><h3 id=h:8ad2683c-f285-4321-8995-dc22478091a8><span class=section-num>5.1</span> <code>spin_unlock()</code> 函数</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=n>__always_inline</span> <span class=kt>void</span> <span class=nf>spin_unlock</span><span class=p>(</span><span class=kt>spinlock_t</span> <span class=o>*</span><span class=n>lock</span><span class=p>)</span> <span class=c1>//include/linux/spinlock.h
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>raw_spin_unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>lock</span><span class=o>-&gt;</span><span class=n>rlock</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=cp>#define raw_spin_unlock(lock)    _raw_spin_unlock(lock) </span><span class=c1>//include/linux/spinlock.h
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=n>__lockfunc</span> <span class=nf>_raw_spin_unlock</span><span class=p>(</span><span class=kt>raw_spinlock_t</span> <span class=o>*</span><span class=n>lock</span><span class=p>)</span> <span class=c1>//kernel/locking/spinlock.c
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>__raw_spin_unlock</span><span class=p>(</span><span class=n>lock</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nf>EXPORT_SYMBOL</span><span class=p>(</span><span class=n>_raw_spin_unlock</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kr>inline</span> <span class=kt>void</span> <span class=nf>__raw_spin_unlock</span><span class=p>(</span><span class=kt>raw_spinlock_t</span> <span class=o>*</span><span class=n>lock</span><span class=p>)</span> <span class=c1>//include/linux/spinlock_api_smp.h
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>spin_release</span><span class=p>(</span><span class=o>&amp;</span><span class=n>lock</span><span class=o>-&gt;</span><span class=n>dep_map</span><span class=p>,</span> <span class=n>_RET_IP_</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>do_raw_spin_unlock</span><span class=p>(</span><span class=n>lock</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* unlock 后开抢占 */</span>
</span></span><span class=line><span class=cl>    <span class=nf>preempt_enable</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kr>inline</span> <span class=kt>void</span> <span class=nf>do_raw_spin_unlock</span><span class=p>(</span><span class=kt>raw_spinlock_t</span> <span class=o>*</span><span class=n>lock</span><span class=p>)</span> <span class=nf>__releases</span><span class=p>(</span><span class=n>lock</span><span class=p>)</span> <span class=c1>//include/linux/spinlock.h
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* 没使能 CONFIG_MMIOWB，是个空函数 */</span>
</span></span><span class=line><span class=cl>    <span class=nf>mmiowb_spin_unlock</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=nf>arch_spin_unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>lock</span><span class=o>-&gt;</span><span class=n>raw_lock</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>__release</span><span class=p>(</span><span class=n>lock</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=cp>#define arch_spin_unlock(l)    queued_spin_unlock(l) </span><span class=c1>//include/asm-generic/qspinlock.h
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>static</span> <span class=n>__always_inline</span> <span class=kt>void</span> <span class=nf>queued_spin_unlock</span><span class=p>(</span><span class=k>struct</span> <span class=n>qspinlock</span> <span class=o>*</span><span class=n>lock</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>     * unlock() needs release semantics:
</span></span></span><span class=line><span class=cl><span class=cm>     * 直接将 lock-&gt;locked 赋值为 0，也即只是将 lock-&gt;val 的 bit0-8 设置为 0
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=nf>smp_store_release</span><span class=p>(</span><span class=o>&amp;</span><span class=n>lock</span><span class=o>-&gt;</span><span class=n>locked</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=h:07457cda-612a-4a0e-bd61-f9ce0c077db3><span class=section-num>6</span> 总结</h2><ol><li><p>spin lock 是不休眠锁，不像其它锁一样，没有 owner 成员保存当前持锁任务。其持锁之前是抢占的，使用需要区分是在哪个上下文中使用，来用对应的函数。</p></li><li><p>spin lock 实现机制中考虑了中断嵌套，由于只有 4 种上下文，为每个 cpu 分配了 4 个 mcs node。</p></li><li><p>当一个 spin lock 在不同 cpu 上存在竞争时，各个 cpu 的 mcs node 构成一个单链表，
lock->tail 字段"指向"最后尝试获取锁的任务所在 cpu 对应的 mcs node 节点。第一顺位继承人在 lock->val 上进行自旋，非第一顺位继承人在自己的 msc node 的 locked 成员上自旋，这样就做了释放锁时只有一个 cpu 需要更新其 cache line。</p></li></ol><h2 id=h:d77f1671-6696-4f58-9f58-4011809165f8><span class=section-num>7</span> 补充</h2><ol><li>内核中为了 debug spin_lock 方便，对函数原型进行了 inline 和 unline 的封装</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>//kernel/locking/spinlock.c
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#ifndef CONFIG_INLINE_SPIN_LOCK </span><span class=c1>//默认不使能
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=n>__lockfunc</span> <span class=nf>_raw_spin_lock</span><span class=p>(</span><span class=kt>raw_spinlock_t</span> <span class=o>*</span><span class=n>lock</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>__raw_spin_lock</span><span class=p>(</span><span class=n>lock</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nf>EXPORT_SYMBOL</span><span class=p>(</span><span class=n>_raw_spin_lock</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp>#ifdef CONFIG_UNINLINE_SPIN_UNLOCK </span><span class=c1>//默认使能
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=n>__lockfunc</span> <span class=nf>_raw_spin_unlock</span><span class=p>(</span><span class=kt>raw_spinlock_t</span> <span class=o>*</span><span class=n>lock</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>__raw_spin_unlock</span><span class=p>(</span><span class=n>lock</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nf>EXPORT_SYMBOL</span><span class=p>(</span><span class=n>_raw_spin_unlock</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=c1>//include/linux/spinlock_api_smp.h
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#ifndef CONFIG_UNINLINE_SPIN_UNLOCK
</span></span></span><span class=line><span class=cl><span class=cp>#define _raw_spin_unlock(lock) __raw_spin_unlock(lock)
</span></span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp>#ifdef CONFIG_INLINE_SPIN_LOCK
</span></span></span><span class=line><span class=cl><span class=cp>#define _raw_spin_lock(lock) __raw_spin_lock(lock)
</span></span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span></code></pre></td></tr></table></div></div><p>kernel/locking/spinlock.c 中还有 CONFIG_INLINE_READ_LOCK_IRQ、CONFIG_INLINE_SPIN_UNLOCK_BH 等。</p><ol><li>linux-5.15.41 中新增: 若使能 CONFIG_PREEMPT_RT(Linux RT patch 默认不使能)，则将 spin_lock 的实现改为基于 rt_mutex 的可</li></ol><p>休眠 spin_lock 实现了。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/* include\linux\spinlock_types.h */</span>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;linux/rtmutex.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=k>typedef</span> <span class=k>struct</span> <span class=n>spinlock</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>rt_mutex_base</span>    <span class=n>lock</span><span class=p>;</span> <span class=c1>//5.10 的内核还是 struct raw_spinlock rlock;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span> <span class=kt>spinlock_t</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p>因此有实现以下两套 lock 和 raw lock 接口：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>//raw spinlock:
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>raw_spinlock_t</span> <span class=n>lock</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nf>raw_spin_lock_init</span><span class=p>(</span><span class=o>&amp;</span><span class=n>lock</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nf>raw_spin_lock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>lock</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nf>raw_spin_unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>lock</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>//spinlock:
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>spinlock_t</span> <span class=n>lock</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nf>spin_lock_init</span><span class=p>(</span><span class=o>&amp;</span><span class=n>lock</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nf>spin_lock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>lock</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nf>spin_unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>lock</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><p>在没有配置 CONFIG_PREEMPT_RT 的情况下两者实现是一样的，但是在使能了 CONFIG_PREEMPT_RT(默认不使能) 的 RT 内核中，spinlock 会被实现为基于 rtmutex 的可休眠锁，raw spinlock 保持和之前一致的逻辑。</p><p>内核工匠中有一篇类似博客：<a href=https://blog.csdn.net/feelabclihu/article/details/125454456 target=_blank rel="noopener noreffer">https://blog.csdn.net/feelabclihu/article/details/125454456</a></p></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>更新于 2023-12-28</span></div></div><div class=post-info-line><div class=post-info-md><span><a class=link-to-markdown href=/p_16368024/index.md target=_blank>阅读原始文档</a></span></div><div class=post-info-share><span></span></div></div></div><div class=post-info-more><section class=post-tags></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/2173/ class=prev rel=prev title="A Close Look at a Spinlock – Embedded in Academia"><i class="fas fa-angle-left fa-fw" aria-hidden=true></i>A Close Look at a Spinlock – Embedded in Academia</a>
<a href=/1211161453667_how-can-3ware-and-megaraid-performance-be-increased-in-linux/ class=next rel=next title="How can 3ware and MegaRAID performance be increased in Linux?">How can 3ware and MegaRAID performance be increased in Linux?<i class="fas fa-angle-right fa-fw" aria-hidden=true></i></a></div></div><div id=comments><div id=giscus class=comment></div><noscript>Please enable JavaScript to view the comments powered by <a href=https://giscus.app>Giscus</a>.</noscript></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line itemscope itemtype=http://schema.org/CreativeWork>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title=回到顶部><i class="fas fa-arrow-up fa-fw" aria-hidden=true></i>
</a><a href=# id=view-comments class=fixed-button title=查看评论><i class="fas fa-comment fa-fw" aria-hidden=true></i></a></div><script type=text/javascript src=https://cdn.jsdelivr.net/npm/autocomplete.js@0.38.1/dist/autocomplete.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/algoliasearch@4.13.1/dist/algoliasearch-lite.umd.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"复制到剪贴板",maxShownLines:50},comment:{giscus:{category:"Announcements",categoryId:"R_kgDON6NYZA",darkTheme:"dark",emitMetadata:"0",inputPosition:"bottom",lang:"zh-CN",lazyLoading:!1,lightTheme:"light",mapping:"pathname",reactionsEnabled:"1",repo:"yangyingchao/giscus",repoId:""}},search:{algoliaAppID:null,algoliaIndex:"index.zh-cn",algoliaSearchKey:null,highlightTag:"em",maxResultLength:10,noResultsFound:"没有找到结果",snippetLength:30,type:"algolia"}}</script><script type=text/javascript src=/js/theme.min.js></script></body></html>