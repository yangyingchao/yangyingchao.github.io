<!doctype html><html lang=zh-cn dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Barriers in PostgresSQL | MyNotes</title><meta name=keywords content="pg,ipc,barriers"><meta name=description content="1 Barriers: 协调进程的同步屏障 1.1 静态参与 2 TODO: Barriers API 3 TODO: how it is used in hash jon… 简单总结一下 PG 中进程同步用到的屏障： https://github.com/postgres/postgres/blob/master/src/backend/storage/ipc/barrier.c 1 Barriers: 协调进程的同步屏障 来自维基百科[1"><meta name=author content="Yang, Ying-chao"><link rel=canonical href=https://yangyingchao.github.io/posts/barriers-in-postgressql/><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://yangyingchao.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://yangyingchao.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://yangyingchao.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://yangyingchao.github.io/apple-touch-icon.png><link rel=mask-icon href=https://yangyingchao.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Barriers in PostgresSQL"><meta property="og:description" content="1 Barriers: 协调进程的同步屏障 1.1 静态参与 2 TODO: Barriers API 3 TODO: how it is used in hash jon… 简单总结一下 PG 中进程同步用到的屏障： https://github.com/postgres/postgres/blob/master/src/backend/storage/ipc/barrier.c 1 Barriers: 协调进程的同步屏障 来自维基百科[1"><meta property="og:type" content="article"><meta property="og:url" content="https://yangyingchao.github.io/posts/barriers-in-postgressql/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-10-21T00:00:00+00:00"><meta property="article:modified_time" content="2023-10-21T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Barriers in PostgresSQL"><meta name=twitter:description content="1 Barriers: 协调进程的同步屏障 1.1 静态参与 2 TODO: Barriers API 3 TODO: how it is used in hash jon… 简单总结一下 PG 中进程同步用到的屏障： https://github.com/postgres/postgres/blob/master/src/backend/storage/ipc/barrier.c 1 Barriers: 协调进程的同步屏障 来自维基百科[1"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://yangyingchao.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Barriers in PostgresSQL","item":"https://yangyingchao.github.io/posts/barriers-in-postgressql/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Barriers in PostgresSQL","name":"Barriers in PostgresSQL","description":"1 Barriers: 协调进程的同步屏障 1.1 静态参与 2 TODO: Barriers API 3 TODO: how it is used in hash jon… 简单总结一下 PG 中进程同步用到的屏障： https://github.com/postgres/postgres/blob/master/src/backend/storage/ipc/barrier.c 1 Barriers: 协调进程的同步屏障 来自维基百科[1","keywords":["pg","ipc","barriers"],"articleBody":" 1 Barriers: 协调进程的同步屏障 1.1 静态参与 2 TODO: Barriers API 3 TODO: how it is used in hash jon… 简单总结一下 PG 中进程同步用到的屏障： https://github.com/postgres/postgres/blob/master/src/backend/storage/ipc/barrier.c\n1 Barriers: 协调进程的同步屏障 来自维基百科[1]：\n“在并行计算中，屏障是一种同步方法。在源代码中，对于一组线程或进程而言， 屏障意味着任何一个线程或进程必须在此处停止，并且在所有其他线程或进程到达该屏障之前无法继 续进行。”\n协调进程同步的屏障可以归纳为以下几点：\n并发性：多个进程同时执行可能导致数据竞争和冲突，因此需要采取措施来确保数据的一致性和正确性。 同步需求不明确：不同的进程可能对同步的时间和顺序有不同的要求，导致难以找到一种通用的同步机制来满足所有进程的需求。 通信开销：在进程间进行同步需要进行通信，而通信本身会带来开销，包括延迟和带宽消耗。 死锁：在复杂的同步机制中，可能存在死锁的风险，即进程互相等待对方释放资源，从而导致系统无法继续执行。 跨平台兼容性：在跨平台开发中，不同操作系统或编程语言的同步机制可能不兼容，限制了进程间的同步和协作。 该屏障的实现允许静态参与和动态参与两种方式：\n静态参与\n参与者集合在一开始就确定（事先已知） 阶段号被内部使用，但是并不一定需要客户端代码访问它， 只有当声明的参与者数量达到屏障时，阶段才会前进， 客户端代码应始终能够确定计算的当前阶段。 动态参与\n其中进程可以随时加入或离开 可以使用一个阶段号跟踪并行算法的进展情况， 当新参与者加入时，可能需要与多阶段算法的当前阶段同步 假设一个并行算法，它涉及到分开的计算阶段 A、B 和 C，每个阶段的输出在下一个阶段开始之前都是必需的。\n1.1 静态参与 在初始化为 4 个参与者的静态屏障的情况下，每个参与者都在阶段 A 上工作，然后调用 BarrierArriveAndWait 进行等待，直到所有 4 个参与者到达该点。当 BarrierArriveAndWait 返回 控制权时，每个参与者都可以在 B 上工作，以此类推。因为屏障知道要期望多少个参与者，所以计 算的阶段不需要标签或数字，因为每个进程的程序计数器都暗示了当前阶段。即使某些进程开始运行 阶段 A 较慢，其他参与者也在等待他们，并将耐心等待在屏障处。\n代码可以写成如下形式：\nperform_a(); BarrierArriveAndWait(\u0026barrier, ...); perform_b(); BarrierArriveAndWait(\u0026barrier, ...); perform_c(); BarrierArriveAndWait(\u0026barrier, ...); If the number of participants is not known up front, then a dynamic barrier is needed and the number should be set to zero at initialization. New complications arise because the number necessarily changes over time as participants attach and detach, and therefore phases B, C or even the end of processing may be reached before any given participant has started running and attached. Therefore the client code must perform an initial test of the phase number after attaching, because it needs to find out which phase of the algorithm has been reached by any participants that are already attached in order to synchronize with that work. Once the program counter or some other representation of current progress is synchronized with the barrier’s phase, normal control flow can be used just as in the static case. Our example could be written using a switch statement with cases that fall-through, as follows:\n如果事先不知道参与者的数量，那么就需要使用动态屏障，并在初始化时将数量设为零。由于参与者 的附加和解除附加使数量随时间而变化，因此在某个给定的参与者开始运行和附加之前，可能会到达 B、C 阶段甚至处理结束。因此，客户端代码在附加后必须对阶段号进行初始测试，因为它需要找出已 经附加的任何参与者所达到的算法阶段，以与该工作进行同步。一旦程序计数器或表示当前进度的其 他表示与屏障的阶段进行了同步，就可以像静态情况下一样使用正常的控制流。我们的示例可以使用 带有贯穿的 switch 语句来编写，如下所示：\nphase = BarrierAttach(\u0026barrier); switch (phase) { case PHASE_A: perform_a(); BarrierArriveAndWait(\u0026barrier, ...); case PHASE_B: perform_b(); BarrierArriveAndWait(\u0026barrier, ...); case PHASE_C: perform_c(); BarrierArriveAndWait(\u0026barrier, ...); } BarrierDetach(\u0026barrier); Static barriers behave similarly to POSIX’s pthread_barrier_t. Dynamic barriers behave similarly to Java’s java.util.concurrent.Phaser.\n静态屏障的行为类似于 POSIX 的 pthread_barrier _t。动态屏障的行为类似于 Java 的 java.util.concurrent.Phaser 。\n2 TODO: Barriers API 3 TODO: how it is used in hash jon… ","wordCount":"1322","inLanguage":"zh-cn","datePublished":"2023-10-21T00:00:00Z","dateModified":"2023-10-21T00:00:00Z","author":[{"@type":"Person","name":"Yang"},{"@type":"Person","name":"Ying-chao"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://yangyingchao.github.io/posts/barriers-in-postgressql/"},"publisher":{"@type":"Organization","name":"MyNotes","logo":{"@type":"ImageObject","url":"https://yangyingchao.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://yangyingchao.github.io accesskey=h title="MyNotes (Alt + H)">MyNotes</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://yangyingchao.github.io/ title=Home><span>Home</span></a></li><li><a href=https://yangyingchao.github.io/posts/ title=Archives><span>Archives</span></a></li><li><a href=https://yangyingchao.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://yangyingchao.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://yangyingchao.github.io/contact/ title="Contact me"><span>Contact me</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Barriers in PostgresSQL</h1><div class=post-meta><span title='2023-10-21 00:00:00 +0000 UTC'>October 21, 2023</span>&nbsp;·&nbsp;Yang, Ying-chao</div></header><div class=post-content><ul><li>1 <a href=#h:88e9d8e9-1ea1-450e-bd7c-cfc191923b9c>Barriers: 协调进程的同步屏障</a><ul><li>1.1 <a href=#h:2d66dbfb-2295-40bf-bab2-22f8c77a3414>静态参与</a></li></ul></li><li>2 <a href=#h:d5dd2d64-5c1c-470a-bc3b-d3a9acbd7356>TODO: Barriers API</a></li><li>3 <a href=#h:4733ab46-ff4d-47aa-93eb-44dcbfba482a>TODO: how it is used in hash jon…</a></li></ul><p>简单总结一下 PG 中进程同步用到的屏障：
<a href=https://github.com/postgres/postgres/blob/master/src/backend/storage/ipc/barrier.c>https://github.com/postgres/postgres/blob/master/src/backend/storage/ipc/barrier.c</a></p><h2 id=h:88e9d8e9-1ea1-450e-bd7c-cfc191923b9c>1 Barriers: 协调进程的同步屏障<a hidden class=anchor aria-hidden=true href=#h:88e9d8e9-1ea1-450e-bd7c-cfc191923b9c>#</a></h2><p>来自维基百科[1]：</p><blockquote><p>“在并行计算中，屏障是一种同步方法。在源代码中，对于一组线程或进程而言，
屏障意味着任何一个线程或进程必须在此处停止，并且在所有其他线程或进程到达该屏障之前无法继
续进行。”</p></blockquote><p>协调进程同步的屏障可以归纳为以下几点：</p><ol><li>并发性：多个进程同时执行可能导致数据竞争和冲突，因此需要采取措施来确保数据的一致性和正确性。</li><li>同步需求不明确：不同的进程可能对同步的时间和顺序有不同的要求，导致难以找到一种通用的同步机制来满足所有进程的需求。</li><li>通信开销：在进程间进行同步需要进行通信，而通信本身会带来开销，包括延迟和带宽消耗。</li><li>死锁：在复杂的同步机制中，可能存在死锁的风险，即进程互相等待对方释放资源，从而导致系统无法继续执行。</li><li>跨平台兼容性：在跨平台开发中，不同操作系统或编程语言的同步机制可能不兼容，限制了进程间的同步和协作。</li></ol><p>该屏障的实现允许静态参与和动态参与两种方式：</p><ul><li><p>静态参与</p><ul><li>参与者集合在一开始就确定（事先已知）</li><li>阶段号被内部使用，但是并不一定需要客户端代码访问它，</li><li>只有当声明的参与者数量达到屏障时，阶段才会前进，</li><li>客户端代码应始终能够确定计算的当前阶段。</li></ul></li><li><p>动态参与</p><ul><li>其中进程可以随时加入或离开</li><li>可以使用一个阶段号跟踪并行算法的进展情况，</li><li>当新参与者加入时，可能需要与多阶段算法的当前阶段同步</li></ul></li></ul><p>假设一个并行算法，它涉及到分开的计算阶段 A、B 和 C，每个阶段的输出在下一个阶段开始之前都是必需的。</p><h3 id=h:2d66dbfb-2295-40bf-bab2-22f8c77a3414>1.1 静态参与<a hidden class=anchor aria-hidden=true href=#h:2d66dbfb-2295-40bf-bab2-22f8c77a3414>#</a></h3><p>在初始化为 4 个参与者的静态屏障的情况下，每个参与者都在阶段 A 上工作，然后调用
BarrierArriveAndWait 进行等待，直到所有 4 个参与者到达该点。当 BarrierArriveAndWait 返回
控制权时，每个参与者都可以在 B 上工作，以此类推。因为屏障知道要期望多少个参与者，所以计
算的阶段不需要标签或数字，因为每个进程的程序计数器都暗示了当前阶段。即使某些进程开始运行
阶段 A 较慢，其他参与者也在等待他们，并将耐心等待在屏障处。</p><p>代码可以写成如下形式：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#00f>perform_a</span>();
</span></span><span style=display:flex><span><span style=color:#00f>BarrierArriveAndWait</span>(<span style=color:#666>&amp;</span>barrier, ...);
</span></span><span style=display:flex><span><span style=color:#00f>perform_b</span>();
</span></span><span style=display:flex><span><span style=color:#00f>BarrierArriveAndWait</span>(<span style=color:#666>&amp;</span>barrier, ...);
</span></span><span style=display:flex><span><span style=color:#00f>perform_c</span>();
</span></span><span style=display:flex><span><span style=color:#00f>BarrierArriveAndWait</span>(<span style=color:#666>&amp;</span>barrier, ...);
</span></span></code></pre></div><p>If the number of participants is not known up front, then a dynamic barrier
is needed and the number should be set to zero at initialization. New
complications arise because the number necessarily changes over time as
participants attach and detach, and therefore phases B, C or even the end
of processing may be reached before any given participant has started
running and attached. Therefore the client code must perform an initial
test of the phase number after attaching, because it needs to find out
which phase of the algorithm has been reached by any participants that are
already attached in order to synchronize with that work. Once the program
counter or some other representation of current progress is synchronized
with the barrier&rsquo;s phase, normal control flow can be used just as in the
static case. Our example could be written using a switch statement with
cases that fall-through, as follows:</p><p>如果事先不知道参与者的数量，那么就需要使用动态屏障，并在初始化时将数量设为零。由于参与者
的附加和解除附加使数量随时间而变化，因此在某个给定的参与者开始运行和附加之前，可能会到达
B、C 阶段甚至处理结束。因此，客户端代码在附加后必须对阶段号进行初始测试，因为它需要找出已
经附加的任何参与者所达到的算法阶段，以与该工作进行同步。一旦程序计数器或表示当前进度的其
他表示与屏障的阶段进行了同步，就可以像静态情况下一样使用正常的控制流。我们的示例可以使用
带有贯穿的 switch 语句来编写，如下所示：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>phase <span style=color:#666>=</span> <span style=color:#00f>BarrierAttach</span>(<span style=color:#666>&amp;</span>barrier);
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>switch</span> (phase)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>case</span> <span style=color:#a0a000>PHASE_A</span>:
</span></span><span style=display:flex><span>    <span style=color:#00f>perform_a</span>();
</span></span><span style=display:flex><span>    <span style=color:#00f>BarrierArriveAndWait</span>(<span style=color:#666>&amp;</span>barrier, ...);
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>case</span> <span style=color:#a0a000>PHASE_B</span>:
</span></span><span style=display:flex><span>    <span style=color:#00f>perform_b</span>();
</span></span><span style=display:flex><span>    <span style=color:#00f>BarrierArriveAndWait</span>(<span style=color:#666>&amp;</span>barrier, ...);
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>case</span> <span style=color:#a0a000>PHASE_C</span>:
</span></span><span style=display:flex><span>    <span style=color:#00f>perform_c</span>();
</span></span><span style=display:flex><span>    <span style=color:#00f>BarrierArriveAndWait</span>(<span style=color:#666>&amp;</span>barrier, ...);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#00f>BarrierDetach</span>(<span style=color:#666>&amp;</span>barrier);
</span></span></code></pre></div><p>Static barriers behave similarly to POSIX&rsquo;s pthread_barrier_t. Dynamic
barriers behave similarly to Java&rsquo;s java.util.concurrent.Phaser.</p><p>静态屏障的行为类似于 POSIX 的 <code>pthread_barrier</code> _t。动态屏障的行为类似于 Java 的 <code>java.util.concurrent.Phaser</code> 。</p><h2 id=h:d5dd2d64-5c1c-470a-bc3b-d3a9acbd7356>2 TODO: Barriers API<a hidden class=anchor aria-hidden=true href=#h:d5dd2d64-5c1c-470a-bc3b-d3a9acbd7356>#</a></h2><h2 id=h:4733ab46-ff4d-47aa-93eb-44dcbfba482a>3 TODO: how it is used in hash jon…<a hidden class=anchor aria-hidden=true href=#h:4733ab46-ff4d-47aa-93eb-44dcbfba482a>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://yangyingchao.github.io/tags/pg/>pg</a></li><li><a href=https://yangyingchao.github.io/tags/ipc/>ipc</a></li><li><a href=https://yangyingchao.github.io/tags/barriers/>barriers</a></li></ul></footer><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//disqus_yH1vi2Slvj.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://yangyingchao.github.io>MyNotes</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>