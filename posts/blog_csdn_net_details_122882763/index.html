<!doctype html><html lang=zh-cn dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>威胁建模框架与技术：从STRIDE到NIST-CSDN博客 | MyNotes</title><meta name=keywords content="threaten,model,stride,nist"><meta name=description content="1 简要介绍 2 威胁建模流程和步骤 3 威胁建模技术 3.1 数据流程图 3.2 过程流程图 3.3 攻击树 4 威胁建模框架和方法 4.1 STRIDE 威胁建模 4.2 DREAD 威胁建模 4.3 PASTA 威胁建模 4.4 VAST 威胁"><meta name=author content="Yang, Ying-chao"><link rel=canonical href=https://yangyingchao.github.io/posts/blog_csdn_net_details_122882763/><link crossorigin=anonymous href=/assets/css/stylesheet.6a98292fb8fa8cf0f3ba4042d4b75515c04267550f3ad49ff6271b5af9562443.css integrity="sha256-apgpL7j6jPDzukBC1LdVFcBCZ1UPOtSf9icbWvlWJEM=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://yangyingchao.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://yangyingchao.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://yangyingchao.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://yangyingchao.github.io/apple-touch-icon.png><link rel=mask-icon href=https://yangyingchao.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="威胁建模框架与技术：从STRIDE到NIST-CSDN博客"><meta property="og:description" content="1 简要介绍 2 威胁建模流程和步骤 3 威胁建模技术 3.1 数据流程图 3.2 过程流程图 3.3 攻击树 4 威胁建模框架和方法 4.1 STRIDE 威胁建模 4.2 DREAD 威胁建模 4.3 PASTA 威胁建模 4.4 VAST 威胁"><meta property="og:type" content="article"><meta property="og:url" content="https://yangyingchao.github.io/posts/blog_csdn_net_details_122882763/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-01-24T00:00:00+00:00"><meta property="article:modified_time" content="2025-01-24T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="威胁建模框架与技术：从STRIDE到NIST-CSDN博客"><meta name=twitter:description content="1 简要介绍 2 威胁建模流程和步骤 3 威胁建模技术 3.1 数据流程图 3.2 过程流程图 3.3 攻击树 4 威胁建模框架和方法 4.1 STRIDE 威胁建模 4.2 DREAD 威胁建模 4.3 PASTA 威胁建模 4.4 VAST 威胁"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://yangyingchao.github.io/posts/"},{"@type":"ListItem","position":3,"name":"威胁建模框架与技术：从STRIDE到NIST-CSDN博客","item":"https://yangyingchao.github.io/posts/blog_csdn_net_details_122882763/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"威胁建模框架与技术：从STRIDE到NIST-CSDN博客","name":"威胁建模框架与技术：从STRIDE到NIST-CSDN博客","description":"1 简要介绍 2 威胁建模流程和步骤 3 威胁建模技术 3.1 数据流程图 3.2 过程流程图 3.3 攻击树 4 威胁建模框架和方法 4.1 STRIDE 威胁建模 4.2 DREAD 威胁建模 4.3 PASTA 威胁建模 4.4 VAST 威胁","keywords":["threaten","model","stride","nist"],"articleBody":" 1 简要介绍 2 威胁建模流程和步骤 3 威胁建模技术 3.1 数据流程图 3.2 过程流程图 3.3 攻击树 4 威胁建模框架和方法 4.1 STRIDE 威胁建模 4.2 DREAD 威胁建模 4.3 PASTA 威胁建模 4.4 VAST 威胁建模 4.5 Trike 威胁建模 4.6 OCTAVE 威胁建模 4.7 NIST 威胁建模 5 威胁建模最佳实践 6 威胁建模工具 本文为摘录，原文为： https://blog.csdn.net/weixin_43965597/article/details/122882763\n1 简要介绍 了解威胁建模框架、方法和工具可以帮助更好地识别、量化和排序面临的威胁。 威胁建模是一个结构化的过程，IT 专业人员可以通过该过程识别潜在的安全威胁和漏洞， 量化每个威胁的严重性，并确定技术的优先级以缓解攻击并保护 IT 资产。威胁模型的重要之处在于它是系统的和结构化的。 威胁建模人员将执行一系列具体步骤，以全面了解他们试图保护的 IT 环境，识别漏洞和潜在攻击者。\n2 威胁建模流程和步骤 每种的威胁建模方法都包含一系列步骤，不同的建模方法的每个步骤存在着细微差别。首先，看一下所有这些方法共有的基本逻辑流程。 对威胁建模过程最简洁明了的概述指出，威胁模型的目的是回答四个问题：\n我们面对的是什么？ 可能会有哪些问题（威胁）？ 我们该怎么做？ 我们做得好吗？ 反过来，威胁建模过程应包括四个主要步骤，每个步骤都会为这些问题之一提供答案。\n分解应用程序或基础架构 确定威胁 确定对策和缓解措施 排序威胁 为了准确了解这些步骤中的每个步骤，我们需要讨论构成威胁建模基础的特定技术。\n3 威胁建模技术 上面列出的步骤中，最陌生的术语可能是分解（Decompose）。分解应用程序或基础架构意味着什么？\n广义上讲，分解应用程序包括 了解应用程序及其与外部实体的交互方式 。这涉及:\n创建用例，以了解应用程序的使用方式，\n确定入口点以查看潜在的攻击者可以在哪里与应用程序进行交互，\n确定资产（即攻击者可能会感兴趣的项目/区域），\n并标识表示应用程序将授予外部实体的访问权限的信任级别。\n（这里专门谈论应用程序安全性，但是显然，从广义上讲，这也适用于对基础结构的看法。）\n3.1 数据流程图 分解应用程序的一种技术是 构建数据流程图 。 这是 1970 年代开发的一种方法，以可视方式展示数据如何在应用程序或系统中移动，以及各个组件在何处更改或存储数据。\n其中 信任边界 是在 2000 年代初期添加进来的概念，特指数据流中的卡点，在该点上需要对数据进行验证， 然后数据才能被接收该数据的实体使用。信任边界是用数据流程图进行威胁建模的关键。\n下图是在线银行应用程序的数据流程图；虚线表示信任边界，数据可能会在信任边界被更改，因此需要采取安全措施。\n3.2 过程流程图 由于数据流程图是由系统工程师而不是安全专家开发的，因此它们包含了许多威胁建模不需要的开销。 数据流程图的一种替代方法是过程流程图。 两者在总体概念上相似，但后者更加精简，并且侧重于用户和执行代码在系统中的移动方式，更紧密地反映了攻击者的思维方式（例如下图）。\n3.3 攻击树 绘制攻击树也是一种威胁建模技术，当您确定要对应用程序或基础结构潜在威胁的阶段时，它就变得非常重要。 攻击树由 90 年代后期的信息安全传奇人物布鲁斯·施耐尔（Bruce Schneier）开创。\n它们由代表不同事件的一系列父节点和子节点组成，子节点是必须满足的条件才能使父节点为真。 根节点（图中的最高父节点）是攻击的总体目标。借助攻击树，威胁建模者可以看到必须组合哪些情况才能使威 胁成功。下图显示了一个简单的银行应用攻击树，说明了病毒可能成功感染文件的不同方式。\n下图是 Hackinthebox 从攻击者的角度构建的攻击树示例，可以帮助了解自己所面临的威胁。\n4 威胁建模框架和方法 威胁建模的各种结构化方法通常称为框架或方法论（本文中这两个术语基本上可以互换使用）。目前的威胁建模框架 和方法有很多，我们挑几个最流行的介绍如下：\n7 种顶级威胁建模方法\nSTRIDE DREAD PASTA VAST Trike OCTAVE NIST 4.1 STRIDE 威胁建模 如上所述，STRIDE 是威胁建模的祖父，最早于 90 年代末在 Microsoft 开发。\nSTRIDE 代表六种威胁，每种都对 CIA 三要素构成威胁，具体如下：\nSpoofing 欺骗或冒充他人或计算机，影响真实性 Tampering 篡改数据，这会破坏完整性 Repudiation 抵赖，或无法将执行的操作关联到操作者，违反了不可抵赖性 Information Disclosure 信息泄露，违反机密性 Denial of Service 拒绝服务，这违反了可用性 Elevation of Privilege 特权提升，违反授权 4.2 DREAD 威胁建模 DREAD 被认为是 STRIDE 模型的一个附加组件，该模型使建模人员可以在确定威胁后对其进行排名。\n对于每个潜在威胁，DREAD 代表六个问题,这些问题中的每一个都得到 1-3 分的评分：\nDamage 潜在损害：如果利用漏洞，造成的损害有多大？ Reproducibility 重现性：重现攻击有多容易？ Exploitability 可利用性：发动攻击有多容易？ Affexted users 受影响的用户：大概影响了多少用户？ Discoverability 可发现性：查找漏洞有多容易？ 4.3 PASTA 威胁建模 PASTA 代表攻击模拟和威胁分析过程，它是一个七步骤过程，致力于使技术安全要求与业务目标保持一致。每个步骤 都非常复杂，由几个子步骤组成，但是总体顺序如下：\n定义目标\n定义技术范围\n应用程序分解\n威胁分析\n漏洞和弱点分析\n攻击建模\n风险与影响分析\n4.4 VAST 威胁建模 VAST 代表可视化，敏捷威胁建模。该模型是 ThreatModeler（自动威胁建模平台）的基础，该平台可以区分应用程序 和运营威胁模型。VAST 专为集成到围绕 devops 构建的工作流中而设计。\n4.5 Trike 威胁建模 Trike 是用于威胁建模和风险评估的框架的开源工具，它基于防御的角度，而不是试图模仿攻击者的思维过程。使用 Trike，您可以为要防御的系统建模，并通过 CRUD 的角度评估每个组件，也就是说，谁可以创建，读取，更新或删除 该实体。通过遍历数据流程图来识别威胁，每种威胁仅分为两类：拒绝服务或特权提升。\n4.6 OCTAVE 威胁建模 OCTAVE 代表“运营关键威胁，资产和脆弱性评估”，是卡耐基梅隆大学开发的一种威胁建模方法，其重点是组织风险而 不是技术风险。它包括三个阶段：\n建立基于资产的威胁配置文件\n识别基础架构漏洞\n制定安全策略和计划\n4.7 NIST 威胁建模 美国国家标准技术研究院拥有自己的以数据为中心的威胁建模方法，该方法包括四个步骤：\n系统和数据识别和表征\n识别并选择要包含在模型中的攻击媒介\n表征缓解攻击媒介的安全控件\n分析威胁模型\n该 NIST 草案还包括一个方法的具体应用实例。 如果您正在寻找威胁建模示例，那么这是一个很棒的文档，可以阅读该文档以了解流程如何工作。\n5 威胁建模最佳实践 无论选择哪种框架，都应遵循一些实践方法。但最重要的（通常也是很难做到的）是将威胁建模作为系统开发过程中 的优先事项。如果能在项目开发伊始就做到这一点，以后可以省去很多麻烦，因为安全性可以被深深“植入”到应用程 序或系统中。\n另一个最佳实践是不要将应用程序和系统彼此隔离。Michael Santarcangelo 写道： “如果各种威胁模型以相同的方 式相互连接，并且应用程序和组件作为 IT 系统的一部分进行交互，那么结果将是一个全面的攻击面，CISO 可以使用该 攻击面来理解整个企业的整体威胁组合。”\n6 威胁建模工具 需要指出的是，上面列出的两种方法（VAST 和 Trike）实际上是围绕特定的软件工具构建的。还有一些支持其他方法 的工具，例如，Microsoft 提供了免费的威胁建模工具，而 OWASP Foundation 也推出了自己的桌面和 web 版本的威胁建 模工具——Threat Dragon³。\n实际上，这里描述的许多方法都是概念性的，并未与任何软件联系在一起。攻击树或数据流程图可以用笔和纸绘制。 正如 Luca Bongiorni 的演讲所解释的那样，用于威胁建模的一些最受欢迎的工具是 Microsoft Visio 和 Excel。开始为 基础架构进行威胁建模的门槛很低，但回报却很高。\n参考资料：\n【1】最早的威胁建模论文：\nhttps://www.microsoft.com/security/blog/2009/08/27/the-threats-to-our-products/\n【2】Uncover Security Design Flaws Using The STRIDE Approach：\nhttps://docs.microsoft.com/en-us/archive/msdn-magazine/2006/november/uncover-security-design-flaws-using-the-stride-approach\n【3】OWASP 威胁建模工具：\nThreat Dragon：https://owasp.org/www-project-threat-dragon/\n","wordCount":"3017","inLanguage":"zh-cn","datePublished":"2025-01-24T00:00:00Z","dateModified":"2025-01-24T00:00:00Z","author":[{"@type":"Person","name":"Yang"},{"@type":"Person","name":"Ying-chao"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://yangyingchao.github.io/posts/blog_csdn_net_details_122882763/"},"publisher":{"@type":"Organization","name":"MyNotes","logo":{"@type":"ImageObject","url":"https://yangyingchao.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://yangyingchao.github.io accesskey=h title="MyNotes (Alt + H)">MyNotes</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://yangyingchao.github.io/ title=Home><span>Home</span></a></li><li><a href=https://yangyingchao.github.io/posts/ title=Archives><span>Archives</span></a></li><li><a href=https://yangyingchao.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://yangyingchao.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://yangyingchao.github.io/contact/ title="Contact me"><span>Contact me</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>威胁建模框架与技术：从STRIDE到NIST-CSDN博客</h1><div class=post-meta><span title='2025-01-24 00:00:00 +0000 UTC'>January 24, 2025</span>&nbsp;·&nbsp;Yang, Ying-chao</div></header><div class=post-content><ul><li>1 <a href=#%E7%AE%80%E8%A6%81%E4%BB%8B%E7%BB%8D>简要介绍</a></li><li>2 <a href=#%E5%A8%81%E8%83%81%E5%BB%BA%E6%A8%A1%E6%B5%81%E7%A8%8B%E5%92%8C%E6%AD%A5%E9%AA%A4>威胁建模流程和步骤</a></li><li>3 <a href=#%E5%A8%81%E8%83%81%E5%BB%BA%E6%A8%A1%E6%8A%80%E6%9C%AF>威胁建模技术</a><ul><li>3.1 <a href=#%E6%95%B0%E6%8D%AE%E6%B5%81%E7%A8%8B%E5%9B%BE>数据流程图</a></li><li>3.2 <a href=#%E8%BF%87%E7%A8%8B%E6%B5%81%E7%A8%8B%E5%9B%BE>过程流程图</a></li><li>3.3 <a href=#%E6%94%BB%E5%87%BB%E6%A0%91>攻击树</a></li></ul></li><li>4 <a href=#%E5%A8%81%E8%83%81%E5%BB%BA%E6%A8%A1%E6%A1%86%E6%9E%B6%E5%92%8C%E6%96%B9%E6%B3%95>威胁建模框架和方法</a><ul><li>4.1 <a href=#stride-%E5%A8%81%E8%83%81%E5%BB%BA%E6%A8%A1>STRIDE 威胁建模</a></li><li>4.2 <a href=#dread-%E5%A8%81%E8%83%81%E5%BB%BA%E6%A8%A1>DREAD 威胁建模</a></li><li>4.3 <a href=#pasta-%E5%A8%81%E8%83%81%E5%BB%BA%E6%A8%A1>PASTA 威胁建模</a></li><li>4.4 <a href=#vast-%E5%A8%81%E8%83%81%E5%BB%BA%E6%A8%A1>VAST 威胁建模</a></li><li>4.5 <a href=#trike-%E5%A8%81%E8%83%81%E5%BB%BA%E6%A8%A1>Trike 威胁建模</a></li><li>4.6 <a href=#octave-%E5%A8%81%E8%83%81%E5%BB%BA%E6%A8%A1>OCTAVE 威胁建模</a></li><li>4.7 <a href=#nist-%E5%A8%81%E8%83%81%E5%BB%BA%E6%A8%A1>NIST 威胁建模</a></li></ul></li><li>5 <a href=#%E5%A8%81%E8%83%81%E5%BB%BA%E6%A8%A1%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5>威胁建模最佳实践</a></li><li>6 <a href=#%E5%A8%81%E8%83%81%E5%BB%BA%E6%A8%A1%E5%B7%A5%E5%85%B7>威胁建模工具</a></li></ul><p>本文为摘录，原文为： <a href=https://blog.csdn.net/weixin_43965597/article/details/122882763>https://blog.csdn.net/weixin_43965597/article/details/122882763</a></p><h2 id=简要介绍>1 简要介绍<a hidden class=anchor aria-hidden=true href=#简要介绍>#</a></h2><p>了解威胁建模框架、方法和工具可以帮助更好地识别、量化和排序面临的威胁。
威胁建模是一个结构化的过程，IT 专业人员可以通过该过程识别潜在的安全威胁和漏洞，
量化每个威胁的严重性，并确定技术的优先级以缓解攻击并保护 IT 资产。威胁模型的重要之处在于它是系统的和结构化的。
威胁建模人员将执行一系列具体步骤，以全面了解他们试图保护的 IT 环境，识别漏洞和潜在攻击者。</p><h2 id=威胁建模流程和步骤>2 威胁建模流程和步骤<a hidden class=anchor aria-hidden=true href=#威胁建模流程和步骤>#</a></h2><p>每种的威胁建模方法都包含一系列步骤，不同的建模方法的每个步骤存在着细微差别。首先，看一下所有这些方法共有的基本逻辑流程。
对威胁建模过程最简洁明了的概述指出，威胁模型的目的是回答四个问题：</p><ol><li>我们面对的是什么？</li><li>可能会有哪些问题（威胁）？</li><li>我们该怎么做？</li><li>我们做得好吗？</li></ol><p>反过来，威胁建模过程应包括四个主要步骤，每个步骤都会为这些问题之一提供答案。</p><ol><li>分解应用程序或基础架构</li><li>确定威胁</li><li>确定对策和缓解措施</li><li>排序威胁</li></ol><p>为了准确了解这些步骤中的每个步骤，我们需要讨论构成威胁建模基础的特定技术。</p><h2 id=威胁建模技术>3 威胁建模技术<a hidden class=anchor aria-hidden=true href=#威胁建模技术>#</a></h2><p>上面列出的步骤中，最陌生的术语可能是分解（Decompose）。分解应用程序或基础架构意味着什么？</p><p>广义上讲，分解应用程序包括 <strong>了解应用程序及其与外部实体的交互方式</strong> 。这涉及:</p><ul><li><p>创建用例，以了解应用程序的使用方式，</p></li><li><p>确定入口点以查看潜在的攻击者可以在哪里与应用程序进行交互，</p></li><li><p>确定资产（即攻击者可能会感兴趣的项目/区域），</p></li><li><p>并标识表示应用程序将授予外部实体的访问权限的信任级别。</p><p>（这里专门谈论应用程序安全性，但是显然，从广义上讲，这也适用于对基础结构的看法。）</p></li></ul><h3 id=数据流程图>3.1 数据流程图<a hidden class=anchor aria-hidden=true href=#数据流程图>#</a></h3><p>分解应用程序的一种技术是 <strong>构建数据流程图</strong> 。
这是 1970 年代开发的一种方法，以可视方式展示数据如何在应用程序或系统中移动，以及各个组件在何处更改或存储数据。</p><p>其中 <strong>信任边界</strong> 是在 2000 年代初期添加进来的概念，特指数据流中的卡点，在该点上需要对数据进行验证，
然后数据才能被接收该数据的实体使用。信任边界是用数据流程图进行威胁建模的关键。</p><p>下图是在线银行应用程序的数据流程图；虚线表示信任边界，数据可能会在信任边界被更改，因此需要采取安全措施。</p><figure><img loading=lazy src=/ox-hugo/8325497b61e28beab395fc96f9ba1d7d.png width=800px></figure><h3 id=过程流程图>3.2 过程流程图<a hidden class=anchor aria-hidden=true href=#过程流程图>#</a></h3><p>由于数据流程图是由系统工程师而不是安全专家开发的，因此它们包含了许多威胁建模不需要的开销。
数据流程图的一种替代方法是过程流程图。
两者在总体概念上相似，但后者更加精简，并且侧重于用户和执行代码在系统中的移动方式，更紧密地反映了攻击者的思维方式（例如下图）。</p><figure><img loading=lazy src=/ox-hugo/9a09b62b7d0a725e2c07c462d7ae81fb.png width=800px></figure><h3 id=攻击树>3.3 攻击树<a hidden class=anchor aria-hidden=true href=#攻击树>#</a></h3><p>绘制攻击树也是一种威胁建模技术，当您确定要对应用程序或基础结构潜在威胁的阶段时，它就变得非常重要。
攻击树由 90 年代后期的信息安全传奇人物布鲁斯·施耐尔（Bruce Schneier）开创。</p><p>它们由代表不同事件的一系列父节点和子节点组成，子节点是必须满足的条件才能使父节点为真。
根节点（图中的最高父节点）是攻击的总体目标。借助攻击树，威胁建模者可以看到必须组合哪些情况才能使威
胁成功。下图显示了一个简单的银行应用攻击树，说明了病毒可能成功感染文件的不同方式。</p><figure><img loading=lazy src=/ox-hugo/feabf179c2185d2d36e0eaab59a163e8.png width=800px></figure><p>下图是 Hackinthebox 从攻击者的角度构建的攻击树示例，可以帮助了解自己所面临的威胁。</p><figure><img loading=lazy src=/ox-hugo/59f5072a0923be7c6d7c42aba495dea4.png width=800px></figure><h2 id=威胁建模框架和方法>4 威胁建模框架和方法<a hidden class=anchor aria-hidden=true href=#威胁建模框架和方法>#</a></h2><p>威胁建模的各种结构化方法通常称为框架或方法论（本文中这两个术语基本上可以互换使用）。目前的威胁建模框架
和方法有很多，我们挑几个最流行的介绍如下：</p><p>7 种顶级威胁建模方法</p><ol><li>STRIDE</li><li>DREAD</li><li>PASTA</li><li>VAST</li><li>Trike</li><li>OCTAVE</li><li>NIST</li></ol><h3 id=stride-威胁建模>4.1 STRIDE 威胁建模<a hidden class=anchor aria-hidden=true href=#stride-威胁建模>#</a></h3><p>如上所述，STRIDE 是威胁建模的祖父，最早于 90 年代末在 Microsoft 开发。</p><p>STRIDE 代表六种威胁，每种都对 CIA 三要素构成威胁，具体如下：</p><ol><li>Spoofing 欺骗或冒充他人或计算机，影响真实性</li><li>Tampering 篡改数据，这会破坏完整性</li><li>Repudiation 抵赖，或无法将执行的操作关联到操作者，违反了不可抵赖性</li><li>Information Disclosure 信息泄露，违反机密性</li><li>Denial of Service 拒绝服务，这违反了可用性</li><li>Elevation of Privilege 特权提升，违反授权</li></ol><h3 id=dread-威胁建模>4.2 DREAD 威胁建模<a hidden class=anchor aria-hidden=true href=#dread-威胁建模>#</a></h3><p>DREAD 被认为是 STRIDE 模型的一个附加组件，该模型使建模人员可以在确定威胁后对其进行排名。</p><p>对于每个潜在威胁，DREAD 代表六个问题,这些问题中的每一个都得到 1-3 分的评分：</p><ol><li>Damage 潜在损害：如果利用漏洞，造成的损害有多大？</li><li>Reproducibility 重现性：重现攻击有多容易？</li><li>Exploitability 可利用性：发动攻击有多容易？</li><li>Affexted users 受影响的用户：大概影响了多少用户？</li><li>Discoverability 可发现性：查找漏洞有多容易？</li></ol><h3 id=pasta-威胁建模>4.3 PASTA 威胁建模<a hidden class=anchor aria-hidden=true href=#pasta-威胁建模>#</a></h3><p>PASTA 代表攻击模拟和威胁分析过程，它是一个七步骤过程，致力于使技术安全要求与业务目标保持一致。每个步骤
都非常复杂，由几个子步骤组成，但是总体顺序如下：</p><ol><li><p>定义目标</p></li><li><p>定义技术范围</p></li><li><p>应用程序分解</p></li><li><p>威胁分析</p></li><li><p>漏洞和弱点分析</p></li><li><p>攻击建模</p></li><li><p>风险与影响分析</p></li></ol><h3 id=vast-威胁建模>4.4 VAST 威胁建模<a hidden class=anchor aria-hidden=true href=#vast-威胁建模>#</a></h3><p>VAST 代表可视化，敏捷威胁建模。该模型是 ThreatModeler（自动威胁建模平台）的基础，该平台可以区分应用程序
和运营威胁模型。VAST 专为集成到围绕 devops 构建的工作流中而设计。</p><h3 id=trike-威胁建模>4.5 Trike 威胁建模<a hidden class=anchor aria-hidden=true href=#trike-威胁建模>#</a></h3><p>Trike 是用于威胁建模和风险评估的框架的开源工具，它基于防御的角度，而不是试图模仿攻击者的思维过程。使用
Trike，您可以为要防御的系统建模，并通过 CRUD 的角度评估每个组件，也就是说，谁可以创建，读取，更新或删除
该实体。通过遍历数据流程图来识别威胁，每种威胁仅分为两类：拒绝服务或特权提升。</p><h3 id=octave-威胁建模>4.6 OCTAVE 威胁建模<a hidden class=anchor aria-hidden=true href=#octave-威胁建模>#</a></h3><p>OCTAVE 代表“运营关键威胁，资产和脆弱性评估”，是卡耐基梅隆大学开发的一种威胁建模方法，其重点是组织风险而
不是技术风险。它包括三个阶段：</p><ol><li><p>建立基于资产的威胁配置文件</p></li><li><p>识别基础架构漏洞</p></li><li><p>制定安全策略和计划</p></li></ol><h3 id=nist-威胁建模>4.7 NIST 威胁建模<a hidden class=anchor aria-hidden=true href=#nist-威胁建模>#</a></h3><p>美国国家标准技术研究院拥有自己的以数据为中心的威胁建模方法，该方法包括四个步骤：</p><ol><li><p>系统和数据识别和表征</p></li><li><p>识别并选择要包含在模型中的攻击媒介</p></li><li><p>表征缓解攻击媒介的安全控件</p></li><li><p>分析威胁模型</p></li></ol><p>该 NIST 草案还包括一个方法的具体应用实例。
如果您正在寻找威胁建模示例，那么这是一个很棒的文档，可以阅读该文档以了解流程如何工作。</p><h2 id=威胁建模最佳实践>5 威胁建模最佳实践<a hidden class=anchor aria-hidden=true href=#威胁建模最佳实践>#</a></h2><p>无论选择哪种框架，都应遵循一些实践方法。但最重要的（通常也是很难做到的）是将威胁建模作为系统开发过程中
的优先事项。如果能在项目开发伊始就做到这一点，以后可以省去很多麻烦，因为安全性可以被深深“植入”到应用程
序或系统中。</p><p>另一个最佳实践是不要将应用程序和系统彼此隔离。Michael Santarcangelo 写道： “如果各种威胁模型以相同的方
式相互连接，并且应用程序和组件作为 IT 系统的一部分进行交互，那么结果将是一个全面的攻击面，CISO 可以使用该
攻击面来理解整个企业的整体威胁组合。”</p><h2 id=威胁建模工具>6 威胁建模工具<a hidden class=anchor aria-hidden=true href=#威胁建模工具>#</a></h2><p>需要指出的是，上面列出的两种方法（VAST 和 Trike）实际上是围绕特定的软件工具构建的。还有一些支持其他方法
的工具，例如，Microsoft 提供了免费的威胁建模工具，而 OWASP Foundation 也推出了自己的桌面和 web 版本的威胁建
模工具——Threat Dragon³。</p><p>实际上，这里描述的许多方法都是概念性的，并未与任何软件联系在一起。攻击树或数据流程图可以用笔和纸绘制。
正如 Luca Bongiorni 的演讲所解释的那样，用于威胁建模的一些最受欢迎的工具是 Microsoft Visio 和 Excel。开始为
基础架构进行威胁建模的门槛很低，但回报却很高。</p><p>参考资料：</p><p>【1】最早的威胁建模论文：</p><p><a href=https://www.microsoft.com/security/blog/2009/08/27/the-threats-to-our-products/>https://www.microsoft.com/security/blog/2009/08/27/the-threats-to-our-products/</a></p><p>【2】Uncover Security Design Flaws Using The STRIDE Approach：</p><p><a href=https://docs.microsoft.com/en-us/archive/msdn-magazine/2006/november/uncover-security-design-flaws-using-the-stride-approach>https://docs.microsoft.com/en-us/archive/msdn-magazine/2006/november/uncover-security-design-flaws-using-the-stride-approach</a></p><p>【3】OWASP 威胁建模工具：</p><p>Threat Dragon：<a href=https://owasp.org/www-project-threat-dragon/>https://owasp.org/www-project-threat-dragon/</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://yangyingchao.github.io/tags/threaten/>threaten</a></li><li><a href=https://yangyingchao.github.io/tags/model/>model</a></li><li><a href=https://yangyingchao.github.io/tags/stride/>stride</a></li><li><a href=https://yangyingchao.github.io/tags/nist/>nist</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://yangyingchao.github.io>MyNotes</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>