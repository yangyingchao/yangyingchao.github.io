<!doctype html><html lang=zh-cn dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>产品特性 | StarRocks | MyNotes</title><meta name=keywords content="starrocks,database"><meta name=description content="1 MPP 分布式执行框架 2 全面向量化执行引擎 3 存储计算分离 4 CBO 优化器 5 可实时更新的列式存储引擎 6 智能的物化视图 7 数据湖分析 本文为摘录，原文为： https://docs.starrocks.io/zh/docs/introduction/Features/ 1"><meta name=author content="Yang, Ying-chao"><link rel=canonical href=https://yangyingchao.github.io/posts/docs_starrocks_io_features/><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://yangyingchao.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://yangyingchao.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://yangyingchao.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://yangyingchao.github.io/apple-touch-icon.png><link rel=mask-icon href=https://yangyingchao.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="产品特性 | StarRocks"><meta property="og:description" content="1 MPP 分布式执行框架 2 全面向量化执行引擎 3 存储计算分离 4 CBO 优化器 5 可实时更新的列式存储引擎 6 智能的物化视图 7 数据湖分析 本文为摘录，原文为： https://docs.starrocks.io/zh/docs/introduction/Features/ 1"><meta property="og:type" content="article"><meta property="og:url" content="https://yangyingchao.github.io/posts/docs_starrocks_io_features/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-01-02T00:00:00+00:00"><meta property="article:modified_time" content="2025-01-02T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="产品特性 | StarRocks"><meta name=twitter:description content="1 MPP 分布式执行框架 2 全面向量化执行引擎 3 存储计算分离 4 CBO 优化器 5 可实时更新的列式存储引擎 6 智能的物化视图 7 数据湖分析 本文为摘录，原文为： https://docs.starrocks.io/zh/docs/introduction/Features/ 1"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://yangyingchao.github.io/posts/"},{"@type":"ListItem","position":2,"name":"产品特性 | StarRocks","item":"https://yangyingchao.github.io/posts/docs_starrocks_io_features/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"产品特性 | StarRocks","name":"产品特性 | StarRocks","description":"1 MPP 分布式执行框架 2 全面向量化执行引擎 3 存储计算分离 4 CBO 优化器 5 可实时更新的列式存储引擎 6 智能的物化视图 7 数据湖分析 本文为摘录，原文为： https://docs.starrocks.io/zh/docs/introduction/Features/ 1","keywords":["starrocks","database"],"articleBody":" 1 MPP 分布式执行框架 2 全面向量化执行引擎 3 存储计算分离 4 CBO 优化器 5 可实时更新的列式存储引擎 6 智能的物化视图 7 数据湖分析 本文为摘录，原文为： https://docs.starrocks.io/zh/docs/introduction/Features/\n1 MPP 分布式执行框架 StarRocks 采用 MPP (Massively Parallel Processing) 分布式执行框架。在 MPP 执行框架中，一条查 询请求会被拆分成多个物理计算单元，在多机并行执行。每个执行节点拥有独享的资源（CPU、内存）。 MPP 执行框架能够使得单个查询请求可以充分利用所有执行节点的资源，所以单个查询的性能可以随着集 群的水平扩展而不断提升。\n如上图所示，StarRocks 会将一个查询在逻辑上切分为多个逻辑执行单元（Query Fragment）。按照每个 逻辑执行单元需要处理的计算量，每个逻辑执行单元会由一个或者多个物理执行单元来具体实现。物理执 行单元是最小的调度单位。一个物理执行单元会被调度到集群某个 BE 上执行。一个逻辑执行单元可以包 括一个或者多个执行算子，如图中的 Fragment 包括了 Scan，Project，Aggregate。每个物理执行单元只 处理部分数据。由于每个逻辑执行单元处理的复杂度不一样，所以每个逻辑执行单元的并行度是不一样的， 即，不同逻辑执行单元可以由不同数目的物理执行单元来具体执行，以提高资源使用率，提升查询速度。\n与很多数据分析系统采用的 Scatter-Gather 分布式执行框架不同，MPP 分布式执行框架可以利用更多的资 源处理查询请求。在 Scatter-Gather 框架中，只有 Gather 节点能处理最后一级的汇总计算。而在 MPP 框架中，数据会被 Shuffle 到多个节点，并且由多个节点来完成最后的汇总计算。在复杂计算时（比如高 基数 Group By，大表 Join 等操作），StarRocks 的 MPP 框架相对于 Scatter-Gather 模式的产品有明 显的性能优势。\n2 全面向量化执行引擎 StarRocks 通过实现全面向量化引擎，充分发挥了 CPU 的处理能力。全面向量化引擎按照列式的方式组织 和处理数据。StarRocks 的数据存储、内存中数据的组织方式，以及 SQL 算子的计算方式，都是列式实现 的。按列的数据组织也会更加充分的利用 CPU 的 Cache，按列计算会有更少的虚函数调用以及更少的分支 判断从而获得更加充分的 CPU 指令流水。\n另一方面，StarRocks 的全面向量化引擎通过向量化算法充分的利用 CPU 提供的 SIMD（Single Instruction Multiple Data）指令。这样 StarRocks 可以用更少的指令数目，完成更多的数据操作。经 过标准测试集的验证，StarRocks 的全面向量化引擎可以将执行算子的性能，整体提升 3~10 倍。\n除了使用向量化技术实现所有算子外，StarRocks 还在执行引擎中实现了其他的优化。比如 StarRocks 实 现了 Operation on Encoded Data 的技术。对于字符串字段的操作，StarRocks 在无需解码情况下就可以 直接基于编码字段完成算子执行，比如实现关联算子、聚合算子、表达式算子计算等。这可以极大的降低 SQL 在执行过程中的计算复杂度。通过这个优化手段，相关查询速度可以提升 2 倍以上。\n3 存储计算分离 StarRocks 3.0 版本支持了全新的存算分离模式，实现了计算与存储的完全解耦、计算节点弹性扩缩容、 高性能热数据缓存。存算分离模式下 StarRocks 具备灵活弹性、高性能、高可靠、低成本等特点。\n存算分离模式下，存储与计算解耦，各自独立服务，独立扩缩容，解决了在存算一体模式下的计算与存储 等比例扩缩容所带来的资源浪费问题。计算节点可以实现秒级的动态扩缩容，提升计算资源的利用率。\n存储层利用对象存储近乎无限的容量，以及数据高可用的特性实现数据的海量存储和持久化。支持包括 AWS S3，Azure Blob Storage，Google Cloud Storage，阿里云 OSS，腾讯云 COS，火山引擎 TOS，华为 云 OBS，以及各类兼容 S3 协议的对象存储，同时也支持 HDFS 存储。\n部署模式上用户可以选择基于公有云、私有云、本地机房部署。StarRocks 存算分离也支持基于 Kubernetes 部署，并提供了相应的 Operator 方便用户自动化部署。\nStarRocks 存算分离模式与存算一体模式功能保持一致，写入及热数据查询性能也与存算一体基本持平。 用户在存储分离模式下也可以实现数据更新、数据湖分析、物化视图加速等多种场景。\n4 CBO 优化器 在多表关联查询场景下，仅靠优秀的执行引擎没有办法获得最极致的执行性能。因为这类场景下，不同执 行计划的复杂度可能会相差几个数量级。查询中关联表的数目越大，可能的执行计划就越多，在众多的可 能中选择一个最优的计划，这是一个 NP-Hard 的问题。只有优秀的查询优化器，才能选择出相对最优的查 询计划，从而实现极致的多表分析性能。\nStarRocks 从零设计并实现了一款全新的，基于代价的优化器 CBO（Cost Based Optimizer）。该优化器 是 Cascades Like 的，在设计时，针对 StarRocks 的全面向量化执行引擎进行了深度定制，并进行了多 项优化和创新。该优化器内部实现了公共表达式复用，相关子查询重写，Lateral Join，Join Reorder， Join 分布式执行策略选择，低基数字典优化等重要功能和优化。目前，该优化器已可以完整支持 TPC-DS 99 条 SQL 语句。\n由于全新 CBO 的支持，StarRocks 能比同类产品更好地支持多表关联查询，特别是复杂的多表关联查询， 让全面向量化引擎能够发挥极致的性能。\n5 可实时更新的列式存储引擎 StarRocks 实现了列式存储引擎，数据以按列的方式进行存储。通过这样的方式，相同类型的数据连续存 放。一方面，数据可以使用更加高效的编码方式，获得更高的压缩比，降低存储成本。另一方面，也降低 了系统读取数据的 I/O 总量，提升了查询性能。此外，在大部分 OLAP 场景中，查询只会涉及部分列。相 对于行存，列存只需要读取部分列的数据，能够极大地降低磁盘 I/O 吞吐。\nStarRocks 能够支持秒级的导入延迟，提供准实时的服务能力。StarRocks 的存储引擎在数据导入时能够 保证每一次操作的 ACID。一个批次的导入数据生效是原子性的，要么全部导入成功，要么全部失败。并发 进行的各个事务相互之间互不影响，对外提供 Snapshot Isolation 的事务隔离级别。\nStarRocks 存储引擎不仅能够提供高效的 Partial Update 操作，也能高效处理 Upsert 类操作。使用 Delete-and-insert 的实现方式，通过主键索引快速过滤数据，避免读取时的 Sort 和 Merge 操作，同时 还可以充分利用其他二级索引，在大量更新的场景下，仍然可以保证查询的极速性能。\n6 智能的物化视图 StarRocks 支持用户使用物化视图（materialized view）进行查询加速和数仓分层。不同于一些同类产品 的物化视图需要手动和原表做数据同步，StarRocks 的物化视图可以自动根据原始表更新数据。只要原始 表数据发生变更，物化视图的更新也同步完成，不需要额外的维护操作就可以保证物化视图能够维持与原 表一致。不仅如此，物化视图的选择也是自动进行的。StarRocks 在进行查询规划时，如果有合适的物化 视图能够加速查询，StarRocks 自动进行查询改写(query rewrite)，将查询自动定位到最适合的物化视图 上进行查询加速。\nStarRocks 的物化视图可以按需灵活创建和删除。用户可以在使用过程中视实际使用情况来判断是否需要 创建或删除物化视图。StarRocks 会在后台自动完成物化视图的相关调整。\nStarRocks 的物化视图可以替代传统的 ETL 建模流程，用户无需在上游应用处做数据转换，可以在使用物 化视图时完成数据转换，简化了数据处理流程。\n例如图中，最底层 ODS 的湖上数据可以通过 External Catalog MV 来构建 DWD 层的 normalized table； 并且可以通过多表关联的物化视图来构建 DWS 层的宽表 (denormalized table)；最上层可以进一步构建 实时的物化视图来支撑高并发的查询，提供更加优异的查询性能。\n7 数据湖分析 StarRocks 不仅能高效的分析本地存储的数据，也可以作为计算引擎直接分析数据湖中的数据。用户可以 通过 StarRocks 提供的 External Catalog，轻松查询存储在 Apache Hive、Apache Iceberg、Apache Hudi、Delta Lake 等数据湖上的数据，无需进行数据迁移。支持的存储系统包括 HDFS、S3、OSS，支持的 文件格式包括 Parquet、ORC、CSV。\n如上图所示，在数据湖分析场景中，StarRocks 主要负责数据的计算分析，而数据湖则主要负责数据的存 储、组织和维护。使用数据湖的优势在于可以使用开放的存储格式和灵活多变的 schema 定义方式，可以 让 BI/AI/Adhoc/报表等业务有统一的 single source of truth。而 StarRocks 作为数据湖的计算引擎， 可以充分发挥向量化引擎和 CBO 的优势，大大提升了数据湖分析的性能。\n","wordCount":"3254","inLanguage":"zh-cn","datePublished":"2025-01-02T00:00:00Z","dateModified":"2025-01-02T00:00:00Z","author":[{"@type":"Person","name":"Yang"},{"@type":"Person","name":"Ying-chao"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://yangyingchao.github.io/posts/docs_starrocks_io_features/"},"publisher":{"@type":"Organization","name":"MyNotes","logo":{"@type":"ImageObject","url":"https://yangyingchao.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://yangyingchao.github.io accesskey=h title="MyNotes (Alt + H)">MyNotes</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://yangyingchao.github.io/ title=Home><span>Home</span></a></li><li><a href=https://yangyingchao.github.io/posts/ title=Archives><span>Archives</span></a></li><li><a href=https://yangyingchao.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://yangyingchao.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://yangyingchao.github.io/contact/ title="Contact me"><span>Contact me</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">产品特性 | StarRocks</h1><div class=post-meta><span title='2025-01-02 00:00:00 +0000 UTC'>January 2, 2025</span>&nbsp;·&nbsp;Yang, Ying-chao</div></header><div class=post-content><ul><li>1 <a href=#mpp-%E5%88%86%E5%B8%83%E5%BC%8F%E6%89%A7%E8%A1%8C%E6%A1%86%E6%9E%B6>MPP 分布式执行框架</a></li><li>2 <a href=#%E5%85%A8%E9%9D%A2%E5%90%91%E9%87%8F%E5%8C%96%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E>全面向量化执行引擎</a></li><li>3 <a href=#%E5%AD%98%E5%82%A8%E8%AE%A1%E7%AE%97%E5%88%86%E7%A6%BB>存储计算分离</a></li><li>4 <a href=#cbo-%E4%BC%98%E5%8C%96%E5%99%A8>CBO 优化器</a></li><li>5 <a href=#%E5%8F%AF%E5%AE%9E%E6%97%B6%E6%9B%B4%E6%96%B0%E7%9A%84%E5%88%97%E5%BC%8F%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E>可实时更新的列式存储引擎</a></li><li>6 <a href=#%E6%99%BA%E8%83%BD%E7%9A%84%E7%89%A9%E5%8C%96%E8%A7%86%E5%9B%BE>智能的物化视图</a></li><li>7 <a href=#%E6%95%B0%E6%8D%AE%E6%B9%96%E5%88%86%E6%9E%90>数据湖分析</a></li></ul><p>本文为摘录，原文为： <a href=https://docs.starrocks.io/zh/docs/introduction/Features/>https://docs.starrocks.io/zh/docs/introduction/Features/</a></p><h2 id=mpp-分布式执行框架>1 MPP 分布式执行框架<a hidden class=anchor aria-hidden=true href=#mpp-分布式执行框架>#</a></h2><p>StarRocks 采用 MPP (Massively Parallel Processing) 分布式执行框架。在 MPP 执行框架中，一条查
询请求会被拆分成多个物理计算单元，在多机并行执行。每个执行节点拥有独享的资源（CPU、内存）。
MPP 执行框架能够使得单个查询请求可以充分利用所有执行节点的资源，所以单个查询的性能可以随着集
群的水平扩展而不断提升。</p><figure><img loading=lazy src=/ox-hugo/1.1-3-mpp-4e71d2992c780d0e208a849750b88f76.png></figure><p>如上图所示，StarRocks 会将一个查询在逻辑上切分为多个逻辑执行单元（Query Fragment）。按照每个
逻辑执行单元需要处理的计算量，每个逻辑执行单元会由一个或者多个物理执行单元来具体实现。物理执
行单元是最小的调度单位。一个物理执行单元会被调度到集群某个 BE 上执行。一个逻辑执行单元可以包
括一个或者多个执行算子，如图中的 Fragment 包括了 Scan，Project，Aggregate。每个物理执行单元只
处理部分数据。由于每个逻辑执行单元处理的复杂度不一样，所以每个逻辑执行单元的并行度是不一样的，
即，不同逻辑执行单元可以由不同数目的物理执行单元来具体执行，以提高资源使用率，提升查询速度。</p><figure><img loading=lazy src=/ox-hugo/1.1-4-mpp-5e90a2b69a04d566fb226e9b6f35726c.png></figure><p>与很多数据分析系统采用的 Scatter-Gather 分布式执行框架不同，MPP 分布式执行框架可以利用更多的资
源处理查询请求。在 Scatter-Gather 框架中，只有 Gather 节点能处理最后一级的汇总计算。而在 MPP
框架中，数据会被 Shuffle 到多个节点，并且由多个节点来完成最后的汇总计算。在复杂计算时（比如高
基数 Group By，大表 Join 等操作），StarRocks 的 MPP 框架相对于 Scatter-Gather 模式的产品有明
显的性能优势。</p><h2 id=全面向量化执行引擎>2 全面向量化执行引擎<a hidden class=anchor aria-hidden=true href=#全面向量化执行引擎>#</a></h2><p>StarRocks 通过实现全面向量化引擎，充分发挥了 CPU 的处理能力。全面向量化引擎按照列式的方式组织
和处理数据。StarRocks 的数据存储、内存中数据的组织方式，以及 SQL 算子的计算方式，都是列式实现
的。按列的数据组织也会更加充分的利用 CPU 的 Cache，按列计算会有更少的虚函数调用以及更少的分支
判断从而获得更加充分的 CPU 指令流水。</p><p>另一方面，StarRocks 的全面向量化引擎通过向量化算法充分的利用 CPU 提供的 SIMD（Single
Instruction Multiple Data）指令。这样 StarRocks 可以用更少的指令数目，完成更多的数据操作。经
过标准测试集的验证，StarRocks 的全面向量化引擎可以将执行算子的性能，整体提升 3~10 倍。</p><p>除了使用向量化技术实现所有算子外，StarRocks 还在执行引擎中实现了其他的优化。比如 StarRocks 实
现了 Operation on Encoded Data 的技术。对于字符串字段的操作，StarRocks 在无需解码情况下就可以
直接基于编码字段完成算子执行，比如实现关联算子、聚合算子、表达式算子计算等。这可以极大的降低
SQL 在执行过程中的计算复杂度。通过这个优化手段，相关查询速度可以提升 2 倍以上。</p><h2 id=存储计算分离>3 存储计算分离<a hidden class=anchor aria-hidden=true href=#存储计算分离>#</a></h2><p>StarRocks 3.0 版本支持了全新的存算分离模式，实现了计算与存储的完全解耦、计算节点弹性扩缩容、
高性能热数据缓存。存算分离模式下 StarRocks 具备灵活弹性、高性能、高可靠、低成本等特点。</p><figure><img loading=lazy src=/ox-hugo/share_data_arch-36623ac2dd77e06b5d8efb2a20971ac7.png></figure><p>存算分离模式下，存储与计算解耦，各自独立服务，独立扩缩容，解决了在存算一体模式下的计算与存储
等比例扩缩容所带来的资源浪费问题。计算节点可以实现秒级的动态扩缩容，提升计算资源的利用率。</p><p>存储层利用对象存储近乎无限的容量，以及数据高可用的特性实现数据的海量存储和持久化。支持包括
AWS S3，Azure Blob Storage，Google Cloud Storage，阿里云 OSS，腾讯云 COS，火山引擎 TOS，华为
云 OBS，以及各类兼容 S3 协议的对象存储，同时也支持 HDFS 存储。</p><p>部署模式上用户可以选择基于公有云、私有云、本地机房部署。StarRocks 存算分离也支持基于
Kubernetes 部署，并提供了相应的 Operator 方便用户自动化部署。</p><p>StarRocks 存算分离模式与存算一体模式功能保持一致，写入及热数据查询性能也与存算一体基本持平。
用户在存储分离模式下也可以实现数据更新、数据湖分析、物化视图加速等多种场景。</p><h2 id=cbo-优化器>4 CBO 优化器<a hidden class=anchor aria-hidden=true href=#cbo-优化器>#</a></h2><figure><img loading=lazy src=/ox-hugo/1.1-5-cbo-9c0501b7304c015c0bb7d1e4bb050c4c.png></figure><p>在多表关联查询场景下，仅靠优秀的执行引擎没有办法获得最极致的执行性能。因为这类场景下，不同执
行计划的复杂度可能会相差几个数量级。查询中关联表的数目越大，可能的执行计划就越多，在众多的可
能中选择一个最优的计划，这是一个 NP-Hard 的问题。只有优秀的查询优化器，才能选择出相对最优的查
询计划，从而实现极致的多表分析性能。</p><p>StarRocks 从零设计并实现了一款全新的，基于代价的优化器 CBO（Cost Based Optimizer）。该优化器
是 Cascades Like 的，在设计时，针对 StarRocks 的全面向量化执行引擎进行了深度定制，并进行了多
项优化和创新。该优化器内部实现了公共表达式复用，相关子查询重写，Lateral Join，Join Reorder，
Join 分布式执行策略选择，低基数字典优化等重要功能和优化。目前，该优化器已可以完整支持 TPC-DS
99 条 SQL 语句。</p><p>由于全新 CBO 的支持，StarRocks 能比同类产品更好地支持多表关联查询，特别是复杂的多表关联查询，
让全面向量化引擎能够发挥极致的性能。</p><h2 id=可实时更新的列式存储引擎>5 可实时更新的列式存储引擎<a hidden class=anchor aria-hidden=true href=#可实时更新的列式存储引擎>#</a></h2><p>StarRocks 实现了列式存储引擎，数据以按列的方式进行存储。通过这样的方式，相同类型的数据连续存
放。一方面，数据可以使用更加高效的编码方式，获得更高的压缩比，降低存储成本。另一方面，也降低
了系统读取数据的 I/O 总量，提升了查询性能。此外，在大部分 OLAP 场景中，查询只会涉及部分列。相
对于行存，列存只需要读取部分列的数据，能够极大地降低磁盘 I/O 吞吐。</p><p>StarRocks 能够支持秒级的导入延迟，提供准实时的服务能力。StarRocks 的存储引擎在数据导入时能够
保证每一次操作的 ACID。一个批次的导入数据生效是原子性的，要么全部导入成功，要么全部失败。并发
进行的各个事务相互之间互不影响，对外提供 Snapshot Isolation 的事务隔离级别。</p><figure><img loading=lazy src=/ox-hugo/1.1-6-realtime-64610eff65f57901b981c2cc025e7189.png></figure><p>StarRocks 存储引擎不仅能够提供高效的 Partial Update 操作，也能高效处理 Upsert 类操作。使用
Delete-and-insert 的实现方式，通过主键索引快速过滤数据，避免读取时的 Sort 和 Merge 操作，同时
还可以充分利用其他二级索引，在大量更新的场景下，仍然可以保证查询的极速性能。</p><h2 id=智能的物化视图>6 智能的物化视图<a hidden class=anchor aria-hidden=true href=#智能的物化视图>#</a></h2><figure><img loading=lazy src=/ox-hugo/1.1-7-mv-7fb0ae6f680ae698965d29b4a7a6911d.png></figure><p>StarRocks 支持用户使用物化视图（materialized view）进行查询加速和数仓分层。不同于一些同类产品
的物化视图需要手动和原表做数据同步，StarRocks 的物化视图可以自动根据原始表更新数据。只要原始
表数据发生变更，物化视图的更新也同步完成，不需要额外的维护操作就可以保证物化视图能够维持与原
表一致。不仅如此，物化视图的选择也是自动进行的。StarRocks 在进行查询规划时，如果有合适的物化
视图能够加速查询，StarRocks 自动进行查询改写(query rewrite)，将查询自动定位到最适合的物化视图
上进行查询加速。</p><p>StarRocks 的物化视图可以按需灵活创建和删除。用户可以在使用过程中视实际使用情况来判断是否需要
创建或删除物化视图。StarRocks 会在后台自动完成物化视图的相关调整。</p><p>StarRocks 的物化视图可以替代传统的 ETL 建模流程，用户无需在上游应用处做数据转换，可以在使用物
化视图时完成数据转换，简化了数据处理流程。</p><p>例如图中，最底层 ODS 的湖上数据可以通过 External Catalog MV 来构建 DWD 层的 normalized table；
并且可以通过多表关联的物化视图来构建 DWS 层的宽表 (denormalized table)；最上层可以进一步构建
实时的物化视图来支撑高并发的查询，提供更加优异的查询性能。</p><h2 id=数据湖分析>7 数据湖分析<a hidden class=anchor aria-hidden=true href=#数据湖分析>#</a></h2><figure><img loading=lazy src=/ox-hugo/1.1-8-dla-f6fb2e38076e0e148ec52f484e595206.png></figure><p>StarRocks 不仅能高效的分析本地存储的数据，也可以作为计算引擎直接分析数据湖中的数据。用户可以
通过 StarRocks 提供的 External Catalog，轻松查询存储在 Apache Hive、Apache Iceberg、Apache
Hudi、Delta Lake 等数据湖上的数据，无需进行数据迁移。支持的存储系统包括 HDFS、S3、OSS，支持的
文件格式包括 Parquet、ORC、CSV。</p><p>如上图所示，在数据湖分析场景中，StarRocks 主要负责数据的计算分析，而数据湖则主要负责数据的存
储、组织和维护。使用数据湖的优势在于可以使用开放的存储格式和灵活多变的 schema 定义方式，可以
让 BI/AI/Adhoc/报表等业务有统一的 single source of truth。而 StarRocks 作为数据湖的计算引擎，
可以充分发挥向量化引擎和 CBO 的优势，大大提升了数据湖分析的性能。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://yangyingchao.github.io/tags/starrocks/>starrocks</a></li><li><a href=https://yangyingchao.github.io/tags/database/>database</a></li></ul></footer><script src=https://giscus.app/client.js data-repo=yangyingchao/giscus data-repo-id=R_kgDON6NYZA data-category=Announcements data-category-id=DIC_kwDON6NYZM4CnANs data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=zh-CN crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2025 <a href=https://yangyingchao.github.io>MyNotes</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>