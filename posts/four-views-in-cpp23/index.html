<!doctype html><html lang=zh-cn dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Spans, string_view, and Ranges - Four View types (C++17 to C++23) - C++ Stories | MyNotes</title><meta name=keywords content="views,cpp"><meta name=description content="1 String View (C++17) SVG Image 1.1 string_view vs const string & 2 Span (C++20) 3 Range Views (C++20) 4 MD Span (C++23) 5 Comparing Spans to Range Views 6 Summary 本文为摘录，原文为： https://www.cppstories.com/2023/four-views-in-cpp23/ 在本博客文章中，我们将探讨现代 C++中引入的几种不同的视"><meta name=author content="Yang Yingchao"><link rel=canonical href=https://yangyingchao.github.io/posts/four-views-in-cpp23/><link crossorigin=anonymous href=/assets/css/stylesheet.6a98292fb8fa8cf0f3ba4042d4b75515c04267550f3ad49ff6271b5af9562443.css integrity="sha256-apgpL7j6jPDzukBC1LdVFcBCZ1UPOtSf9icbWvlWJEM=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://yangyingchao.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://yangyingchao.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://yangyingchao.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://yangyingchao.github.io/apple-touch-icon.png><link rel=mask-icon href=https://yangyingchao.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Spans, string_view, and Ranges - Four View types (C++17 to C++23) - C++ Stories"><meta property="og:description" content="1 String View (C++17) SVG Image 1.1 string_view vs const string & 2 Span (C++20) 3 Range Views (C++20) 4 MD Span (C++23) 5 Comparing Spans to Range Views 6 Summary 本文为摘录，原文为： https://www.cppstories.com/2023/four-views-in-cpp23/ 在本博客文章中，我们将探讨现代 C++中引入的几种不同的视"><meta property="og:type" content="article"><meta property="og:url" content="https://yangyingchao.github.io/posts/four-views-in-cpp23/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-10-10T00:00:00+00:00"><meta property="article:modified_time" content="2023-10-10T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Spans, string_view, and Ranges - Four View types (C++17 to C++23) - C++ Stories"><meta name=twitter:description content="1 String View (C++17) SVG Image 1.1 string_view vs const string & 2 Span (C++20) 3 Range Views (C++20) 4 MD Span (C++23) 5 Comparing Spans to Range Views 6 Summary 本文为摘录，原文为： https://www.cppstories.com/2023/four-views-in-cpp23/ 在本博客文章中，我们将探讨现代 C++中引入的几种不同的视"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://yangyingchao.github.io/posts/"},{"@type":"ListItem","position":3,"name":"Spans, string_view, and Ranges - Four View types (C++17 to C++23) - C++ Stories","item":"https://yangyingchao.github.io/posts/four-views-in-cpp23/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Spans, string_view, and Ranges - Four View types (C++17 to C++23) - C++ Stories","name":"Spans, string_view, and Ranges - Four View types (C\u002b\u002b17 to C\u002b\u002b23) - C\u002b\u002b Stories","description":"1 String View (C++17) SVG Image 1.1 string_view vs const string \u0026amp; 2 Span (C++20) 3 Range Views (C++20) 4 MD Span (C++23) 5 Comparing Spans to Range Views 6 Summary 本文为摘录，原文为： https://www.cppstories.com/2023/four-views-in-cpp23/ 在本博客文章中，我们将探讨现代 C++中引入的几种不同的视","keywords":["views","cpp"],"articleBody":" 1 String View (C++17) SVG Image 1.1 string_view vs const string \u0026 2 Span (C++20) 3 Range Views (C++20) 4 MD Span (C++23) 5 Comparing Spans to Range Views 6 Summary 本文为摘录，原文为： https://www.cppstories.com/2023/four-views-in-cpp23/\n在本博客文章中，我们将探讨现代 C++中引入的几种不同的视图/引用类型。第一种是 C++17 中新增的 string_view 。 C++20 引入了 std::span 和 ranges 视图。最后新增的是来自 C++23 的 std::mdspan 。\n1 String View (C++17) SVG Image std::string_view 是一个指向字符串的非拥有引用。 提供了一种面向对象的方式来表示字符串和子字符串， 不需要复制或分配 std::string 带来的开销。 特别适用于需要临时视图的场景，大大提高了字符串处理代码的性能和表达能力。 视图对象不允许修改原始字符串中的字符。 以下是一个基本的示例：\n#include #include #include void find_word(std::string_view text, std::string_view word) { size_t pos = text.find(word); if (pos != std::string_view::npos) std::cout \u003c\u003c std::format(\"单词在位置{}处找到\\n\", pos); else std::cout \u003c\u003c \"单词未找到\\n\"; } int main() { std::string str = \"The quick brown fox jumps over the lazy dog\"; std::string_view sv = str; find_word(sv, \"quick\"); find_word(sv, \"lazy\"); find_word(sv, \"hello\"); } 1.1 string_view vs const string \u0026 std::string const\u0026 requires the data to be in a std::string, and not a raw C array, a char const* returned by a C API, a std::vector produced by some deserialization engine, etc. The avoided format conversion avoids copying bytes, and (if the string is longer than the SBO¹ for the particular std::string implementation) avoids a memory allocation.\nstd::string const\u0026 要求数据在 std::string 中，而不是在原始的 C 数组，由 C API 返回的 char const*=，由某些反序列化引擎产生的 =std::vector 等中。避免格式转换可以避免字节的 复制，并且（如果字符串比特定的 std::string 实现的 SBO¹更长）还可以避免内存分配。\n2 Span (C++20) C++20 将 string_view 进一步通过 std::span 类型实现更通用。它作为对一系列连续对象的非 拥有、轻量级引用。它在需要处理数组或向量的一部分而无需拥有数据所有权的函数中特别有用。\n#include #include #include void print(std::span\u003cconst int\u003e sp) { for (int i : sp) std::cout \u003c\u003c i \u003c\u003c \" \"; std::cout \u003c\u003c '\\n'; } int main() { int arr[] = {1, 2, 3, 4, 5}; std::span sp(arr, 5); std::vector nums { 10, 11, 12, 13 }; print(sp); print(nums); } 3 Range Views (C++20) C++20 中与 std::span 同时引入的 Range Views（区间视图）为处理数据范围提供了高级可组合 的抽象。Range Views 实现了惰性求值 (lazy evaluation)，这允许操作（如过滤、转换或连接等） 以可读、声明式的方式表示，而不会立即求值，通常会提高性能表现。\n#include #include #include int main() { std::vector nums = {1, 2, 3, 4, 5, 6}; auto even_nums = nums | std::views::filter([](int n) { return n % 2 == 0; }); for (int n : even_nums) std::cout \u003c\u003c n \u003c\u003c \" \"; } 4 MD Span (C++23) C++23 中的 std::mdspan 类型是一个多维度的 span。它将 span 的概念扩展到多维数据，这在数 值和科学计算中非常有价值。在这个 C++标准中，我们还对[]运算符进行了更改，我们可以编写 mat[i,j]来访问其元素（请参见多维子脚本运算符-P2128 中的更改）。\n下面，您可以找到一个简单的 mdspan 示例，用于测试给定矩阵是否是方形和单位矩阵：\n#include #include #include #include int isIdentity(std::mdspan\u003cint, std::extents\u003cint, std::dynamic_extent, std::dynamic_extent\u003e\u003e matrix) { int rows = matrix.extent(0); int cols = matrix.extent(1); if (rows != cols) return false; for (int i = 0; i \u003c rows; ++i) if (matrix[i, i] != 1) return false; return true; } int main() { std::vector\u003cint\u003e matrix_data = {1, 0, 0, 0, 1, 0, 0, 0, 1}; std::mdspan matrix = std::mdspan(matrix_data.data(), 3, 3); std::cout \u003c\u003c isIdentity(matrix) \u003c\u003c '\\n'; std::mdspan matrix2 = std::mdspan(matrix_data.data(), 3, 2); std::cout \u003c\u003c isIdentity(matrix2) \u003c\u003c '\\n'; } 5 Comparing Spans to Range Views 尽管 std::span 和 Range Views 都是用于操作序列的现代机制，但它们有着不同的目的。\nstd::span 旨在提供对连续对象序列的直接、有限和安全的访问。它简单而又强大，适用于需要 访问数据块但不需要所有权语义的功能。\nRange Views 旨在操作和组合序列。它们不要求数据是连续的，允许在范围上进行延迟、串联的 操作，这可以导致更富有表现力的代码和潜在的更好性能。\n实质上，std::span 是一种用于安全的、连续数据访问的简单工具，而 Range Views 则提供了一种 更高级的、功能性的容器操作方法。\n6 Summary 在这篇短文中，我们回顾了最近的 C++ 修订，并了解了视图类型背后的一些基础知识。在 C++ 中，我 们有三种不同的引用/视图对象类型：\nC++17 引入了 string_view ，用于高效的字符串处理，只能进行只读访问， C++20 中的 std::span 允许处理数据序列并公开读或写访问权限， C++23 中的 std::mdspan 是 span 的多维版本。 此外，作为最后一种类型，我提到了范围视图，它是对集合的高级抽象。虽然其他三种需要连续序列，但范围视图更加灵活。\n下面是一个简单的表格，总结了上述内容：\n(*) 尽管你可以通过视图进行写入，但这可能不是最佳方法。 (*) mdspan 还提供了一些关于内存布局的额外选项，并且还可以使用步长参数。 在这个文本中，我还展示了一些基本的示例，但请记住这只是冰山一角，并且请继续关注更多关于这些方便类型的文章。\nhttps://www.cppstories.com/2023/four-views-in-cpp23/\n","wordCount":"1567","inLanguage":"zh-cn","datePublished":"2023-10-10T00:00:00Z","dateModified":"2023-10-10T00:00:00Z","author":[{"@type":"Person","name":"Yang Yingchao"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://yangyingchao.github.io/posts/four-views-in-cpp23/"},"publisher":{"@type":"Organization","name":"MyNotes","logo":{"@type":"ImageObject","url":"https://yangyingchao.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://yangyingchao.github.io accesskey=h title="MyNotes (Alt + H)">MyNotes</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://yangyingchao.github.io/ title=Home><span>Home</span></a></li><li><a href=https://yangyingchao.github.io/posts/ title=Archives><span>Archives</span></a></li><li><a href=https://yangyingchao.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://yangyingchao.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://yangyingchao.github.io/contact/ title="Contact me"><span>Contact me</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Spans, string_view, and Ranges - Four View types (C++17 to C++23) - C++ Stories</h1><div class=post-meta><span title='2023-10-10 00:00:00 +0000 UTC'>October 10, 2023</span>&nbsp;·&nbsp;Yang Yingchao</div></header><div class=post-content><ul><li>1 <a href=#h:fac5fec9-45cc-4f3d-852b-d06a6b989983>String View (C++17) SVG Image</a><ul><li>1.1 <a href=#h:b9c83c11-bb0b-4c53-83e8-cefa5214d4c2><code>string_view</code> vs <code>const string &</code></a></li></ul></li><li>2 <a href=#h:e386b658-db23-445a-ab6a-06bb367950ac>Span (C++20)</a></li><li>3 <a href=#h:faf47418-f580-4b64-9f0d-16b18af5671e>Range Views (C++20)</a></li><li>4 <a href=#h:ae160436-19fe-4900-bddf-a4c4e00ccebc>MD Span (C++23)</a></li><li>5 <a href=#h:5ebc8985-1155-4cf3-a4ac-588b2b331ebe>Comparing Spans to Range Views</a></li><li>6 <a href=#h:adcb85b9-4fa7-45fa-860b-9c99c7000414>Summary</a></li></ul><p>本文为摘录，原文为： <a href=https://www.cppstories.com/2023/four-views-in-cpp23/>https://www.cppstories.com/2023/four-views-in-cpp23/</a></p><p>在本博客文章中，我们将探讨现代 C++中引入的几种不同的视图/引用类型。第一种是 C++17 中新增的 <code>string_view</code> 。
C++20 引入了 <code>std::span</code> 和 <code>ranges</code> 视图。最后新增的是来自 C++23 的 <code>std::mdspan</code> 。</p><h2 id=h:fac5fec9-45cc-4f3d-852b-d06a6b989983>1 String View (C++17) SVG Image<a hidden class=anchor aria-hidden=true href=#h:fac5fec9-45cc-4f3d-852b-d06a6b989983>#</a></h2><ul><li><code>std::string_view</code> 是一个指向字符串的非拥有引用。</li><li>提供了一种面向对象的方式来表示字符串和子字符串，</li><li>不需要复制或分配 std::string 带来的开销。</li><li>特别适用于需要临时视图的场景，大大提高了字符串处理代码的性能和表达能力。</li><li>视图对象不允许修改原始字符串中的字符。</li></ul><p>以下是一个基本的示例：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#bc7a00>#include</span> <span style=color:#bc7a00>&lt;format&gt;</span><span style=color:#bc7a00>
</span></span></span><span style=display:flex><span><span style=color:#bc7a00>#include</span> <span style=color:#bc7a00>&lt;iostream&gt;</span><span style=color:#bc7a00>
</span></span></span><span style=display:flex><span><span style=color:#bc7a00>#include</span> <span style=color:#bc7a00>&lt;string_view&gt;</span><span style=color:#bc7a00>
</span></span></span><span style=display:flex><span><span style=color:#bc7a00></span><span style=color:#b00040>void</span> <span style=color:#00f>find_word</span>(std<span style=color:#666>::</span>string_view text, std<span style=color:#666>::</span>string_view word) {
</span></span><span style=display:flex><span>    size_t pos <span style=color:#666>=</span> text.find(word);
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>if</span> (pos <span style=color:#666>!=</span> std<span style=color:#666>::</span>string_view<span style=color:#666>::</span>npos)
</span></span><span style=display:flex><span>        std<span style=color:#666>::</span>cout <span style=color:#666>&lt;&lt;</span> std<span style=color:#666>::</span>format(<span style=color:#ba2121>&#34;单词在位置{}处找到</span><span style=color:#b62;font-weight:700>\n</span><span style=color:#ba2121>&#34;</span>, pos);
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>else</span>
</span></span><span style=display:flex><span>        std<span style=color:#666>::</span>cout <span style=color:#666>&lt;&lt;</span> <span style=color:#ba2121>&#34;单词未找到</span><span style=color:#b62;font-weight:700>\n</span><span style=color:#ba2121>&#34;</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#b00040>int</span> <span style=color:#00f>main</span>() {
</span></span><span style=display:flex><span>    std<span style=color:#666>::</span>string str <span style=color:#666>=</span> <span style=color:#ba2121>&#34;The quick brown fox jumps over the lazy dog&#34;</span>;
</span></span><span style=display:flex><span>    std<span style=color:#666>::</span>string_view sv <span style=color:#666>=</span> str;
</span></span><span style=display:flex><span>    find_word(sv, <span style=color:#ba2121>&#34;quick&#34;</span>);
</span></span><span style=display:flex><span>    find_word(sv, <span style=color:#ba2121>&#34;lazy&#34;</span>);
</span></span><span style=display:flex><span>    find_word(sv, <span style=color:#ba2121>&#34;hello&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=h:b9c83c11-bb0b-4c53-83e8-cefa5214d4c2>1.1 <code>string_view</code> vs <code>const string &</code><a hidden class=anchor aria-hidden=true href=#h:b9c83c11-bb0b-4c53-83e8-cefa5214d4c2>#</a></h3><p><code>std::string const&</code> requires the data to be in a std::string, and not a raw C array, a
<code>char const*</code> returned by a C API, a <code>std::vector&lt;char></code> produced by some deserialization
engine, etc. The avoided format conversion avoids copying bytes, and (if the string is
longer than the SBO¹ for the particular <code>std::string</code> implementation) avoids a memory
allocation.</p><p><code>std::string const&</code> 要求数据在 <code>std::string</code> 中，而不是在原始的 C 数组，由 C API 返回的
<code>char const*=，由某些反序列化引擎产生的 =std::vector&lt;char></code> 等中。避免格式转换可以避免字节的
复制，并且（如果字符串比特定的 <code>std::string</code> 实现的 SBO¹更长）还可以避免内存分配。</p><h2 id=h:e386b658-db23-445a-ab6a-06bb367950ac>2 Span (C++20)<a hidden class=anchor aria-hidden=true href=#h:e386b658-db23-445a-ab6a-06bb367950ac>#</a></h2><p>C++20 将 <code>string_view</code> 进一步通过 <code>std::span</code> 类型实现更通用。它作为对一系列连续对象的非
拥有、轻量级引用。它在需要处理数组或向量的一部分而无需拥有数据所有权的函数中特别有用。</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#bc7a00>#include</span> <span style=color:#bc7a00>&lt;iostream&gt;</span><span style=color:#bc7a00>
</span></span></span><span style=display:flex><span><span style=color:#bc7a00>#include</span> <span style=color:#bc7a00>&lt;span&gt;</span><span style=color:#bc7a00>
</span></span></span><span style=display:flex><span><span style=color:#bc7a00>#include</span> <span style=color:#bc7a00>&lt;vector&gt;</span><span style=color:#bc7a00>
</span></span></span><span style=display:flex><span><span style=color:#bc7a00></span>
</span></span><span style=display:flex><span><span style=color:#b00040>void</span> <span style=color:#00f>print</span>(std<span style=color:#666>::</span>span<span style=color:#666>&lt;</span><span style=color:green;font-weight:700>const</span> <span style=color:#b00040>int</span><span style=color:#666>&gt;</span> sp) {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>for</span> (<span style=color:#b00040>int</span> <span style=color:#a0a000>i</span> : sp)
</span></span><span style=display:flex><span>        std<span style=color:#666>::</span>cout <span style=color:#666>&lt;&lt;</span> i <span style=color:#666>&lt;&lt;</span> <span style=color:#ba2121>&#34; &#34;</span>;
</span></span><span style=display:flex><span>    std<span style=color:#666>::</span>cout <span style=color:#666>&lt;&lt;</span> <span style=color:#ba2121>&#39;\n&#39;</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#b00040>int</span> <span style=color:#00f>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#b00040>int</span> arr[] <span style=color:#666>=</span> {<span style=color:#666>1</span>, <span style=color:#666>2</span>, <span style=color:#666>3</span>, <span style=color:#666>4</span>, <span style=color:#666>5</span>};
</span></span><span style=display:flex><span>    std<span style=color:#666>::</span>span sp(arr, <span style=color:#666>5</span>);
</span></span><span style=display:flex><span>    std<span style=color:#666>::</span>vector nums { <span style=color:#666>10</span>, <span style=color:#666>11</span>, <span style=color:#666>12</span>, <span style=color:#666>13</span> };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    print(sp);
</span></span><span style=display:flex><span>    print(nums);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=h:faf47418-f580-4b64-9f0d-16b18af5671e>3 Range Views (C++20)<a hidden class=anchor aria-hidden=true href=#h:faf47418-f580-4b64-9f0d-16b18af5671e>#</a></h2><p>C++20 中与 <code>std::span</code> 同时引入的 Range Views（区间视图）为处理数据范围提供了高级可组合
的抽象。Range Views 实现了惰性求值 (lazy evaluation)，这允许操作（如过滤、转换或连接等）
以可读、声明式的方式表示，而不会立即求值，通常会提高性能表现。</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#bc7a00>#include</span> <span style=color:#bc7a00>&lt;iostream&gt;</span><span style=color:#bc7a00>
</span></span></span><span style=display:flex><span><span style=color:#bc7a00>#include</span> <span style=color:#bc7a00>&lt;ranges&gt;</span><span style=color:#bc7a00>
</span></span></span><span style=display:flex><span><span style=color:#bc7a00>#include</span> <span style=color:#bc7a00>&lt;vector&gt;</span><span style=color:#bc7a00>
</span></span></span><span style=display:flex><span><span style=color:#bc7a00></span>
</span></span><span style=display:flex><span><span style=color:#b00040>int</span> <span style=color:#00f>main</span>() {
</span></span><span style=display:flex><span>    std<span style=color:#666>::</span>vector nums <span style=color:#666>=</span> {<span style=color:#666>1</span>, <span style=color:#666>2</span>, <span style=color:#666>3</span>, <span style=color:#666>4</span>, <span style=color:#666>5</span>, <span style=color:#666>6</span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>auto</span> even_nums <span style=color:#666>=</span> nums <span style=color:#666>|</span> std<span style=color:#666>::</span>views<span style=color:#666>::</span>filter([](<span style=color:#b00040>int</span> n) {
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>return</span> n <span style=color:#666>%</span> <span style=color:#666>2</span> <span style=color:#666>==</span> <span style=color:#666>0</span>;
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>for</span> (<span style=color:#b00040>int</span> <span style=color:#a0a000>n</span> : even_nums)
</span></span><span style=display:flex><span>        std<span style=color:#666>::</span>cout <span style=color:#666>&lt;&lt;</span> n <span style=color:#666>&lt;&lt;</span> <span style=color:#ba2121>&#34; &#34;</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=h:ae160436-19fe-4900-bddf-a4c4e00ccebc>4 MD Span (C++23)<a hidden class=anchor aria-hidden=true href=#h:ae160436-19fe-4900-bddf-a4c4e00ccebc>#</a></h2><p>C++23 中的 <code>std::mdspan</code> 类型是一个多维度的 span。它将 span 的概念扩展到多维数据，这在数
值和科学计算中非常有价值。在这个 C++标准中，我们还对[]运算符进行了更改，我们可以编写
mat[i,j]来访问其元素（请参见多维子脚本运算符-P2128 中的更改）。</p><p>下面，您可以找到一个简单的 mdspan 示例，用于测试给定矩阵是否是方形和单位矩阵：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#bc7a00>#include</span> <span style=color:#bc7a00>&lt;vector&gt;</span><span style=color:#bc7a00>
</span></span></span><span style=display:flex><span><span style=color:#bc7a00>#include</span> <span style=color:#bc7a00>&lt;https://raw.githubusercontent.com/kokkos/mdspan/single-header/mdspan.hpp&gt;</span><span style=color:#bc7a00>
</span></span></span><span style=display:flex><span><span style=color:#bc7a00>#include</span> <span style=color:#bc7a00>&lt;algorithm&gt;</span><span style=color:#bc7a00>
</span></span></span><span style=display:flex><span><span style=color:#bc7a00>#include</span> <span style=color:#bc7a00>&lt;iostream&gt;</span><span style=color:#bc7a00>
</span></span></span><span style=display:flex><span><span style=color:#bc7a00></span>
</span></span><span style=display:flex><span><span style=color:#b00040>int</span> <span style=color:#00f>isIdentity</span>(std<span style=color:#666>::</span>mdspan<span style=color:#666>&lt;</span><span style=color:#b00040>int</span>, std<span style=color:#666>::</span>extents<span style=color:#666>&lt;</span><span style=color:#b00040>int</span>, std<span style=color:#666>::</span>dynamic_extent, std<span style=color:#666>::</span>dynamic_extent<span style=color:#666>&gt;&gt;</span> matrix) {
</span></span><span style=display:flex><span>    <span style=color:#b00040>int</span> rows <span style=color:#666>=</span> matrix.extent(<span style=color:#666>0</span>);
</span></span><span style=display:flex><span>    <span style=color:#b00040>int</span> cols <span style=color:#666>=</span> matrix.extent(<span style=color:#666>1</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>if</span> (rows <span style=color:#666>!=</span> cols)
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>return</span> <span style=color:green>false</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>for</span> (<span style=color:#b00040>int</span> i <span style=color:#666>=</span> <span style=color:#666>0</span>; i <span style=color:#666>&lt;</span> rows; <span style=color:#666>++</span>i)
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>if</span> (matrix[i, i] <span style=color:#666>!=</span> <span style=color:#666>1</span>)
</span></span><span style=display:flex><span>            <span style=color:green;font-weight:700>return</span> <span style=color:green>false</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>return</span> <span style=color:green>true</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#b00040>int</span> <span style=color:#00f>main</span>() {
</span></span><span style=display:flex><span>    std<span style=color:#666>::</span>vector<span style=color:#666>&lt;</span><span style=color:#b00040>int</span><span style=color:#666>&gt;</span> matrix_data <span style=color:#666>=</span> {<span style=color:#666>1</span>, <span style=color:#666>0</span>, <span style=color:#666>0</span>, <span style=color:#666>0</span>, <span style=color:#666>1</span>, <span style=color:#666>0</span>, <span style=color:#666>0</span>, <span style=color:#666>0</span>, <span style=color:#666>1</span>};
</span></span><span style=display:flex><span>    std<span style=color:#666>::</span>mdspan matrix <span style=color:#666>=</span> std<span style=color:#666>::</span>mdspan(matrix_data.data(), <span style=color:#666>3</span>, <span style=color:#666>3</span>);
</span></span><span style=display:flex><span>    std<span style=color:#666>::</span>cout <span style=color:#666>&lt;&lt;</span> isIdentity(matrix) <span style=color:#666>&lt;&lt;</span> <span style=color:#ba2121>&#39;\n&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    std<span style=color:#666>::</span>mdspan matrix2 <span style=color:#666>=</span> std<span style=color:#666>::</span>mdspan(matrix_data.data(), <span style=color:#666>3</span>, <span style=color:#666>2</span>);
</span></span><span style=display:flex><span>    std<span style=color:#666>::</span>cout <span style=color:#666>&lt;&lt;</span> isIdentity(matrix2) <span style=color:#666>&lt;&lt;</span> <span style=color:#ba2121>&#39;\n&#39;</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=h:5ebc8985-1155-4cf3-a4ac-588b2b331ebe>5 Comparing Spans to Range Views<a hidden class=anchor aria-hidden=true href=#h:5ebc8985-1155-4cf3-a4ac-588b2b331ebe>#</a></h2><p>尽管 std::span 和 Range Views 都是用于操作序列的现代机制，但它们有着不同的目的。</p><ul><li><p><code>std::span</code> 旨在提供对连续对象序列的直接、有限和安全的访问。它简单而又强大，适用于需要
访问数据块但不需要所有权语义的功能。</p></li><li><p><code>Range Views</code> 旨在操作和组合序列。它们不要求数据是连续的，允许在范围上进行延迟、串联的
操作，这可以导致更富有表现力的代码和潜在的更好性能。</p></li></ul><p>实质上，std::span 是一种用于安全的、连续数据访问的简单工具，而 Range Views 则提供了一种
更高级的、功能性的容器操作方法。</p><h2 id=h:adcb85b9-4fa7-45fa-860b-9c99c7000414>6 Summary<a hidden class=anchor aria-hidden=true href=#h:adcb85b9-4fa7-45fa-860b-9c99c7000414>#</a></h2><p>在这篇短文中，我们回顾了最近的 C++ 修订，并了解了视图类型背后的一些基础知识。在 C++ 中，我
们有三种不同的引用/视图对象类型：</p><ul><li>C++17 引入了 <code>string_view</code> ，用于高效的字符串处理，只能进行只读访问，</li><li>C++20 中的 <code>std::span</code> 允许处理数据序列并公开读或写访问权限，</li><li>C++23 中的 <code>std::mdspan</code> 是 span 的多维版本。</li></ul><p>此外，作为最后一种类型，我提到了范围视图，它是对集合的高级抽象。虽然其他三种需要连续序列，但范围视图更加灵活。</p><p>下面是一个简单的表格，总结了上述内容：</p><figure><img loading=lazy src=/ox-hugo/fourviews_table.png width=800px></figure><ul><li>(*) 尽管你可以通过视图进行写入，但这可能不是最佳方法。</li><li>(*) mdspan 还提供了一些关于内存布局的额外选项，并且还可以使用步长参数。</li></ul><p>在这个文本中，我还展示了一些基本的示例，但请记住这只是冰山一角，并且请继续关注更多关于这些方便类型的文章。</p><p><a href=https://www.cppstories.com/2023/four-views-in-cpp23/>https://www.cppstories.com/2023/four-views-in-cpp23/</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://yangyingchao.github.io/tags/views/>views</a></li><li><a href=https://yangyingchao.github.io/tags/cpp/>cpp</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://yangyingchao.github.io>MyNotes</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>