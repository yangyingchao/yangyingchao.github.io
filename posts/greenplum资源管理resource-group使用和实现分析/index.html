<!doctype html><html lang=zh-cn dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Greenplum 资源管理——Resource Group使用和实现分析 | MyNotes</title><meta name=keywords content="gpdb,resource,group"><meta name=description content="1 Resource Group 简介 2 Resource Group 使用 2.1 创建资源组 2.2 将资源组分配给角色 2.3 修改资源组配置 2.4 删除资源组 2.5 取消资源组中的正在运行或已排队的事务 3 Resource Group 监控 3.1 查看资源组"><meta name=author content><link rel=canonical href=https://yangyingchao.github.io/posts/greenplum%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86resource-group%E4%BD%BF%E7%94%A8%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://yangyingchao.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://yangyingchao.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://yangyingchao.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://yangyingchao.github.io/apple-touch-icon.png><link rel=mask-icon href=https://yangyingchao.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Greenplum 资源管理——Resource Group使用和实现分析"><meta property="og:description" content="1 Resource Group 简介 2 Resource Group 使用 2.1 创建资源组 2.2 将资源组分配给角色 2.3 修改资源组配置 2.4 删除资源组 2.5 取消资源组中的正在运行或已排队的事务 3 Resource Group 监控 3.1 查看资源组"><meta property="og:type" content="article"><meta property="og:url" content="https://yangyingchao.github.io/posts/greenplum%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86resource-group%E4%BD%BF%E7%94%A8%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/"><meta property="article:section" content="posts"><meta name=twitter:card content="summary"><meta name=twitter:title content="Greenplum 资源管理——Resource Group使用和实现分析"><meta name=twitter:description content="1 Resource Group 简介 2 Resource Group 使用 2.1 创建资源组 2.2 将资源组分配给角色 2.3 修改资源组配置 2.4 删除资源组 2.5 取消资源组中的正在运行或已排队的事务 3 Resource Group 监控 3.1 查看资源组"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://yangyingchao.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Greenplum 资源管理——Resource Group使用和实现分析","item":"https://yangyingchao.github.io/posts/greenplum%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86resource-group%E4%BD%BF%E7%94%A8%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Greenplum 资源管理——Resource Group使用和实现分析","name":"Greenplum 资源管理——Resource Group使用和实现分析","description":"1 Resource Group 简介 2 Resource Group 使用 2.1 创建资源组 2.2 将资源组分配给角色 2.3 修改资源组配置 2.4 删除资源组 2.5 取消资源组中的正在运行或已排队的事务 3 Resource Group 监控 3.1 查看资源组","keywords":["gpdb","resource","group"],"articleBody":" 1 Resource Group 简介 2 Resource Group 使用 2.1 创建资源组 2.2 将资源组分配给角色 2.3 修改资源组配置 2.4 删除资源组 2.5 取消资源组中的正在运行或已排队的事务 3 Resource Group 监控 3.1 查看资源组限制 3.2 查看资源组查询状态和 CPU/ 内存使用情况 3.3 查看每个主机的资源组 CPU/ 内存使用情况 3.4 查看每个 segment 的资源组 CPU/ 内存使用情况 3.5 查看分配给角色的资源组 3.6 查看资源组的运行和待定查询 4 Resource Group 实现分析 4.1 并发限制 4.2 CPU 限制 4.3 内存限制 4.4 Resource Group 监控 5 常见问题 5.1 Resource Group 是如何利用操作系统的 cgroup 能力的？ 5.2 Resource Group 是如何进行事务级别的资源限制的？ 5.3 Resource Group 的各种操作加不加锁，加什么锁？ 5.4 数据库基于 cgroup 对资源组进行限制，如果某个数据库节点故障，跨机迁移到其他节点，而 cgroup 的配置和路径结构无法迁移，会不会导致对应机器上的 resource group 功能失效？ 5.5 为什么资源组的 CPU 使用率高于配置的 CPU_RATE_LIMIT ？ 5.6 Resource Group 在部署上有什么要求？ 6 总结 本文为摘录，原文为： https://blog.csdn.net/u013970710/article/details/115433014\nGreenplum 是一款广泛应用的开源 MPP 数据库的产品，兼容 PostgreSQL 生态，被广泛应用与大数据的存储与分析。\nResource Group 是 Greenplum 的一种资源管理方式。 Resource Group 由 GP5 开始被支持，相比于早期的 Resource Queue 的 资源管理方式，具有支持更细粒度的资源管理、 支持组内资源共享等优点。本文会介绍 Resource Group 的使用方式，从源码 角度分析它的实现，以及介绍一些使用中遇到的高频问题。\n1 Resource Group 简介 Resource Group 是 Greenplum 的一种资源管理方式，能够细粒度定义对不同数据库角色（用户）的资源使用限制，支持通过 SQL 语句的方式进行配置。 Resource Group 支持进行三种类型的资源限制：并发限制、 CPU 限制、内存限制。\n超级用户可以通过 SQL 在数据库内定义多个资源组，并设置每个资源组的资源限制。在一个数据库中，每个资源组可以关联一 个或多个数据库用户，而每个数据库用户只能归属于单个资源组。资源组支持的资源限制配置如下：\nCONCURRENCY 资源组中允许的最大并发事务数，包括活动和空闲事务。 CPU_RATE_LIMIT 此资源组可用的 CPU 资源百分比。 CPUSET 为该资源组保留的 CPU 核心数。 MEMORY_LIMIT 该资源组可用的内存资源百分比。 MEMORY_SHARED_QUOTA 提交到该资源组的事务之间共享的内存资源百分比。 MEMORY_SPILL_RATIO 内存密集型事务的内存使用阈值。当事务达到此阈值时，它将溢出到磁盘。 CONCURRENCY 代表最大并发事务数； CPU_RATE_LIMIT 代表以百分比形式限制 CPU 使用，各个资源组设置的 CPU_RATE_LIMIT 之和不超过 100% ； CPUSET 代表以 CPU 核的形式限制 CPU ，设置具体使用哪几个 CPU 逻辑核； MEMORY_LIMIT 代表资源组最多能占用的集群可用内存的百分比， 由 MEMORY_LIMIT 设定的部分属于资源组的固定份额， 而各个资源组 MEMORY_LIMIT 之和低于 100% 的部分，被划分所有资源组的共享内存池； Bad boy… MEMORY_SHARED_QUOTA 代表资源组内用于各个事务共享的内存比例； MEMORY_SPILL_RATIO 代表溢出到磁盘的内存使用阈值。 CREATE RESOURCE GROUP rgroup1 WITH ( CONCURRENCY=10, CPU_RATE_LIMIT=20, MEMORY_LIMIT=25, MEMORY_SHARED_QUOTA=20, MEMORY_SPILL_RATIO=20 ); 除了 Resource Group ，GP 早期还支持 Resource Queue 的资源管理方式， Resource Queue 通过指定 MEMORY_LIMIT 、 ACTIVE_STATEMENTS 、PRIORITY 、MAX_COST 字段，配置对于各个资源队列的内存、 CPU 、并发限制， Resource Group 相对 Resource queue 存在以下优势：\n特性 Resource Groups Resource Queues CPU 管理 细粒度（Cgroup） 基于粗粒度的优先级 内存限制 细粒度 粗粒度 并发控制 事务级别 语句级别 管理 DDL Utility 语句 是 否 segment 级别监控 是 否 组内内存共享 是 否 Resource Group 通过 Master 上的并发锁实现对并发的限制，通过 cgroup 实现对 cpu 的限制，支持对内存基于 vmtracker 和 cgroup 进行两种方式的限制。\n2 Resource Group 使用 2.1 创建资源组 使用 CREATE RESOURCE GROUP 命令创建新资源组。\n为角色创建资源组时，必须提供 CPU_RATE_LIMIT 或 CPUSET 和 MEMORY_LIMIT 限制值。这些限制标识要分配给此资源组的数据 库资源的百分比。例如，要创建名为 rgroup1 的资源组，其 CPU 限制为 20 ，内存限制为 25 ：\nCREATE RESOURCE GROUP rgroup1 WITH (CPU_RATE_LIMIT=20, MEMORY_LIMIT=25); CPU 限制为 20 由 rgroup1 分配到的每个角色共享。同样，内存限制为 25 由 rgroup1 分配到的每个角色共享。rgroup1 使用 默认的 MEMORY_AUDITOR vmtracker 和默认的 CONCURRENCY 设置为 20 。\n数据库包含两个默认资源组： admin_group 和 default_group 。启用资源组时，将为未明确分配资源组的任何角色分配角色功 能的默认组。 SUPERUSER 角色分配了 admin_group ，非管理员角色分配了名为 default_group 的组。\n使用以下资源限制创建默认资源组 admin_group 和 default_group ：\n限制类型 admin_group default_group CONCURRENCY 10 20 CPU_RATE_LIMIT 10 30 CPUSET -1 -1 MEMORY_LIMIT 10 30 MEMORY_SHARED_QUOTA 50 50 MEMORY_SPILL_RATIO 20 20 MEMORY_AUDITOR vmtracker vmtracker 默认资源组 admin_group 和 default_group 的 CPU_RATE_LIMIT 和 MEMORY_LIMIT 值对分段主机上的总百分比有贡献。\n2.2 将资源组分配给角色 Greenplum 资源组可用于分配给一个或多个角色（用户）。使用 CREATE ROLE 或 ALTER ROLE 命令的 RESOURCE GROUP 子句将资 源组分配给数据库角色。如果未为角色指定资源组，则会为角色分配角色功能的默认组。 SUPERUSER 角色分配了 admin_group ，非管理员角色分配了名为 default_group 的组。\n使用 ALTER ROLE 或 CREATE ROLE 命令将资源组分配给角色。例如：\nALTER ROLE bill RESOURCE GROUP rg_light; CREATE ROLE mary RESOURCE GROUP exec; 用户可以将资源组分配给一个或多个角色。如果已定义角色层次结构，则将资源组分配给父角色不会向下传播到该角色组的成员。\n如果要从角色中删除资源组分配并将角色分配为默认组，请将角色的组名称分配更改为 NONE 。例如：\nALTER ROLE mary RESOURCE GROUP NONE; 2.3 修改资源组配置 ALTER RESOURCE GROUP 命令可以修改资源组配置。要更改资源组的限制，请指定组所需的新值。例如：\nALTER RESOURCE GROUP rg_role_light SET CONCURRENCY 7; ALTER RESOURCE GROUP exec SET MEMORY_LIMIT 25; ALTER RESOURCE GROUP rgroup1 SET CPUSET '2,4'; 注意 : 用户无法将 admin_group 的 CONCURRENCY 值设置或更改为 0 。\n2.4 删除资源组 DROP RESOURCE GROUP 命令会删除资源组。要删除角色的资源组，不能将该组分配给任何角色，也不能在资源组中激活或等待任何事务。\nDROP RESOURCE GROUP exec; 2.5 取消资源组中的正在运行或已排队的事务 在某些情况下，用户可能希望取消资源组中的正在运行或排队的事务。例如，用户可能希望删除在资源组队列中等待但尚未执行 的查询。或者，用户可能希望停止执行时间太长的正在运行的查询，或者在事务中处于空闲状态并占用其他用户所需的资源组事 务插槽的查询。\n要取消正在运行或排队的事务，必须首先确定与事务关联的进程 ID （pid ）。获得进程 ID 后，可以调用 pg_cancel_backend() 来结束该进程。\n例如，要查看与当前活动或在所有资源组中等待的所有语句关联的进程信息，请运行以下查询。如果查询未返回任何结果，则任 何资源组中都没有正在运行或排队的事务。\nSELECT rolname, g.rsgname, procpid, waiting, current_query, datname FROM pg_roles, gp_toolkit.gp_resgroup_status g, pg_stat_activity WHERE pg_roles.rolresgroup=g.groupid AND pg_stat_activity.usename=pg_roles.rolname; 示例部分查询输出：\nrolname | rsgname | procpid | waiting | current_query | datname ---------+----------+---------+---------+-----------------------+--------- sammy | rg_light | 31861 | f | \u003cIDLE\u003e in transaction | testdb billy | rg_light | 31905 | t | SELECT * FROM topten; | testdb 使用此输出来标识要取消的事务的进程 ID （procpid ），然后取消该进程。例如，要取消上面示例输出中标识的待处理查询：\nSELECT pg_cancel_backend(31905); 用户可以在 pg_cancel_backend() 的第二个参数中提供可选消息，以向用户指示进程被取消的原因。\n3 Resource Group 监控 本节主要介绍如何通过系统视图监控集群的资源组，包括各个资源组的配置，各个资源组的资源使用情况等。\n以下是资源组相关的监控项的含义：\nrsgname 资源组名 groupid 资源组 oid cpu 当前资源组的 cpu 利用率 memory_used 当前资源组实际使用的内存总量 memory_available 当前资源组可用的内存总量 memory_quota_used 当前资源组固定份额部分实际使用的内存总量 memory_quota_available 当前资源组固定份额部分可用的内存总量 memory_quota_granted 当前资源组固定份额部分的总体分配量 memory_shared_used 当前资源组共享部分实际使用的内存总量 memory_shared_available 当前资源组共享部分可用的内存总量 memory_shared_granted 当前资源组共享部分的总体分配量 正常情况下，各个资源组监控项有以下关系：\nmemory_used = memory_quota_used + memory_shared_used available = memory_quota_granted + memory_shared_granted - memory_used memory_quota_granted = memory_quota_used + memory_quota_available memory_shared_granted = memory_shared_used + memory_shared_available 3.1 查看资源组限制 gp_resgroup_config 系统视图显示所有的资源组配置。\nSELECT * FROM gp_toolkit.gp_resgroup_config; 3.2 查看资源组查询状态和 CPU/ 内存使用情况 gp_resgroup_status 系统视图可以查看资源组的状态和活动。该视图显示正在运行和排队的事务数。它还显示资源组的实时 CPU 和内存使用情况。\nSELECT * FROM gp_toolkit.gp_resgroup_status; 3.3 查看每个主机的资源组 CPU/ 内存使用情况 通过 gp_resgroup_status_per_host 系统视图，用户可以基于每个主机查看资源组的实时 CPU 和内存使用情况。\nSELECT * FROM gp_toolkit.gp_resgroup_status_per_host; 3.4 查看每个 segment 的资源组 CPU/ 内存使用情况 通过 gp_resgroup_status_per_segment 系统视图，用户可以按每个 segment ，每个主机查看资源组的实时 CPU 和内存使用情 况。\nSELECT * FROM gp_toolkit.gp_resgroup_status_per_segment; 3.5 查看分配给角色的资源组 要查看资源组到角色的分配，请对 pg_roles 和 pg_resgroup 系统表执行以下查询：\nSELECT rolname, rsgname FROM pg_roles, pg_resgroup WHERE pg_roles.rolresgroup=pg_resgroup.oid; 3.6 查看资源组的运行和待定查询 要查看资源组的运行查询，挂起的查询以及挂起的查询排队的时间，请检查 pg_stat_activity 系统表：\nSELECT current_query, waiting, rsgname, rsgqueueduration FROM pg_stat_activity; 4 Resource Group 实现分析 Greenplum 数据库是 MPP 架构，整体分为一个或多个 Master ，以及多个 segment ，数据在多个 segment 之间可以随机、哈 希、复制分布。在 Greenplum 中， Resource Group 的资源限制级别是事务级别。 Resource Group 会在各个 group 内部将资 源划分成并发量数目的 slot ，而每个事务在运行前排队等待获取 slot 。\n如上文所述， Resource Group 支持对并发、 CPU 和内存进行限制，本节会详细介绍对这几类资源进行限制的实现细节，以及 介绍对于资源组的监控是如何实现的。\nResource Group 的代码主要位于如下的路径和文件中：\nsrc/backend/utils/resgroup src/backend/utils/ressource_manager src/backend/commands/resgroupcmds.c 4.1 并发限制 Resource Group 通过 Master 上的并发锁实现对并发的限制。用户连接到数据库集群时，首先会连接到 Master 节点，在开启事务时，会尝试获取 slot 。\nstatic ResGroupSlotData * groupGetSlot(ResGroupData *group) { ResGroupSlotData\t*slot; ResGroupCaps\t*caps; int32\tslotMemQuota; Assert(LWLockHeldExclusiveByMe(ResGroupLock)); Assert(Gp_role == GP_ROLE_DISPATCH); Assert(groupIsNotDropped(group)); caps = \u0026group-\u003ecaps; /* First check if the concurrency limit is reached */ if (group-\u003enRunning \u003e= caps-\u003econcurrency) return NULL; slotMemQuota = groupReserveMemQuota(group); if (slotMemQuota \u003c 0) return NULL; /* Now actually get a free slot */ slot = slotpoolAllocSlot(); Assert(!slotIsInUse(slot)); initSlot(slot, group, slotMemQuota); group-\u003enRunning++; return slot; } Master 上通过比较资源组当前运行的事务数 group-\u003enRunning ，与设定的并发数 concurrency ，保证限制实际运行的并发数 不高于设定值。 Greenplum 是多进程模型，各个资源组的计数量 group-\u003enRunning 放在共享内存中，在 slot 的获取过程中， 会获取 ResGroupLock 类型的排他锁，以保证并发安全。\n4.2 CPU 限制 Resource Group 通过 cgroup 实现对 cpu 的限制。在 resource group 创建或者修改时（比如 initCpu ），数据库会在操作 系统 cgroup 路径下，创建与 resource group oid 同名的 cgroup 路径，即做对应挂载。并根据设置的 CPU 配置，更新对应 cgroup 子路径下的 cpu.cfs_period_us 、cpu.cfs_quota_us 、cpu.shares 文件。\n而在开始事务时，数据库会将当前进程关联到对应的 cgroup 子节点下，具体逻辑如下：\nvoid ResGroupOps_AssignGroup(Oid group, ResGroupCaps *caps, int pid) { bool oldViaCpuset = oldCaps.cpuRateLimit == CPU_RATE_LIMIT_DISABLED; bool curViaCpuset = caps ? caps-\u003ecpuRateLimit == CPU_RATE_LIMIT_DISABLED : false; /* needn't write to file if the pid has already been written in. * Unless it has not been writtien or the group has changed or * cpu control mechanism has changed */ if (IsUnderPostmaster \u0026\u0026 group == currentGroupIdInCGroup \u0026\u0026 caps != NULL \u0026\u0026 oldViaCpuset == curViaCpuset) return; writeInt64(group, BASETYPE_GPDB, RESGROUP_COMP_TYPE_CPU, \"cgroup.procs\", pid); writeInt64(group, BASETYPE_GPDB, RESGROUP_COMP_TYPE_CPUACCT, \"cgroup.procs\", pid); if (gp_resource_group_enable_cgroup_cpuset) { if (caps == NULL || !curViaCpuset) { /* add pid to default group */ writeInt64(DEFAULT_CPUSET_GROUP_ID, BASETYPE_GPDB, RESGROUP_COMP_TYPE_CPUSET, \"cgroup.procs\", pid); } else { writeInt64(group, BASETYPE_GPDB, RESGROUP_COMP_TYPE_CPUSET, \"cgroup.procs\", pid); } } /* * Do not assign the process to cgroup/memory for now. */ currentGroupIdInCGroup = group; if (caps != NULL) { oldCaps.cpuRateLimit = caps-\u003ecpuRateLimit; StrNCpy(oldCaps.cpuset, caps-\u003ecpuset, sizeof(oldCaps.cpuset)); } } 数据库会将对应进程的 pid 写进子路径的 cgroup.procs 文件里，从而利用操作系统的 cgroup 能力对进程的 cpu 使用进行限 制。\n4.3 内存限制 支持对内存基于 vmtracker 和 cgroup 进行两种方式的限制。在使用 cgroup 做内存限制的时候，它的应用原理与 CPU 限制类 似：为每个资源组创建一个 cgroup 子节点，在资源组创建和修改时，修改对应 cgroup 的内存管理配置文件 memory.limit_in_bytes 、 memory.usage_in_bytes ；事务运行时通过 pid 与对应 cgroup 关联，支持内存的限制。\n而基于 vmtracker 进行内存限制时，则完全是由数据库本身进行高并发场景下的内存审计和分配，这里以内存统计量的修改为 例：\nstatic int32 groupIncMemUsage(ResGroupData *group, ResGroupSlotData *slot, int32 chunks) { int32\tslotMemUsage;\t/* the memory current slot has been used */ int32\tsharedMemUsage;\t/* the total shared memory usage, sum of group share and global share */ int32\tglobalOveruse = 0;\t/* the total over used chunks of global share*/ /* Add the chunks to memUsage in slot */ slotMemUsage = pg_atomic_add_fetch_u32((pg_atomic_uint32 *) \u0026slot-\u003ememUsage, chunks); /* Check whether shared memory should be added */ sharedMemUsage = slotMemUsage - slot-\u003ememQuota; if (sharedMemUsage \u003e 0) { /* Decide how many chunks should be counted as shared memory */ int32 deltaSharedMemUsage = Min(sharedMemUsage, chunks); /* Add these chunks to memSharedUsage in group, * and record the old value*/ int32 oldSharedUsage = pg_atomic_fetch_add_u32((pg_atomic_uint32 *) \u0026group-\u003ememSharedUsage, deltaSharedMemUsage); /* the free space of group share */ int32 oldSharedFree = Max(0, group-\u003ememSharedGranted - oldSharedUsage); /* Calculate the global over used chunks */ int32 deltaGlobalSharedMemUsage = Max(0, deltaSharedMemUsage - oldSharedFree); /* freeChunks -= deltaGlobalSharedMemUsage and get the new value */ int32 newFreeChunks = pg_atomic_sub_fetch_u32((pg_atomic_uint32 *) \u0026pResGroupControl-\u003efreeChunks, deltaGlobalSharedMemUsage); /* calculate the total over used chunks of global share */ globalOveruse = Max(0, 0 - newFreeChunks); } /* Add the chunks to memUsage in group */ pg_atomic_add_fetch_u32((pg_atomic_uint32 *) \u0026group-\u003ememUsage, chunks); return globalOveruse; } 在进行内存限制时，对于某个 slot 的内存请求，首先会通过原子相加的方式从资源组的固定份额部分获取内存；而如果所需要 的内存超过固定份额的内存量，会尝试从资源组内的共享内存部分获取；如果依然无法获取到内存，则会尝试从全局的共享内存 获取。如果从全局共享内存依然无法获取到内存，则会返回 Out of Memory 错误。\n4.4 Resource Group 监控 在进行监控时， QD 会把资源组查询 query 分发到各个 segment 上，然后再在 master 进行汇总，返回集群整体的资源利用情 况。\nGreenplum 支持多种对资源组的监控方式，除了直接的资源组监控视图之外，还支持对 segment 、机器层级的资源组监控。这 些不同层级的资源组监控视图往往是通过对系统表和系统函数进行联合查询得到的，比如：\nCREATE VIEW gp_toolkit.gp_resgroup_status AS SELECT r.rsgname, s.* FROM pg_resgroup_get_status(null) AS s, pg_resgroup AS r WHERE s.groupid = r.oid; 所以，我们介绍最基本的资源监控函数 pg_resgroup_get_status 的实现方式。\nstatic void getResUsage(ResGroupStatCtx *ctx, Oid inGroupId) { int64 *usages; TimestampTz *timestamps; int i, j; usages = palloc(sizeof(*usages) * ctx-\u003enGroups); timestamps = palloc(sizeof(*timestamps) * ctx-\u003enGroups); for (j = 0; j \u003c ctx-\u003enGroups; j++) { ResGroupStat *row = \u0026ctx-\u003egroups[j]; Oid groupId = DatumGetObjectId(row-\u003egroupId); usages[j] = ResGroupOps_GetCpuUsage(groupId); timestamps[j] = GetCurrentTimestamp(); } if (Gp_role == GP_ROLE_DISPATCH) { CdbPgResults cdb_pgresults = {NULL, 0}; StringInfoData buffer; initStringInfo(\u0026buffer); appendStringInfo(\u0026buffer, \"SELECT groupid, cpu_usage, memory_usage \" \"FROM pg_resgroup_get_status(%d)\", inGroupId); CdbDispatchCommand(buffer.data, DF_WITH_SNAPSHOT, \u0026cdb_pgresults); if (cdb_pgresults.numResults == 0) elog(ERROR, \"pg_resgroup_get_status() didn't get back any resource statistic from the segDBs\"); for (i = 0; i \u003c cdb_pgresults.numResults; i++) { struct pg_result *pg_result = cdb_pgresults.pg_results[i]; /* * Any error here should have propagated into errbuf, so we shouldn't * ever see anything other that tuples_ok here. But, check to be * sure. */ if (PQresultStatus(pg_result) != PGRES_TUPLES_OK) { cdbdisp_clearCdbPgResults(\u0026cdb_pgresults); elog(ERROR, \"pg_resgroup_get_status(): resultStatus not tuples_Ok\"); } Assert(PQntuples(pg_result) == ctx-\u003enGroups); for (j = 0; j \u003c ctx-\u003enGroups; j++) { const char *result; ResGroupStat *row = \u0026ctx-\u003egroups[j]; Oid groupId = pg_atoi(PQgetvalue(pg_result, j, 0), sizeof(Oid), 0); Assert(groupId == row-\u003egroupId); if (row-\u003ememUsage-\u003elen == 0) { Datum d = ResGroupGetStat(groupId, RES_GROUP_STAT_MEM_USAGE); row-\u003egroupId = groupId; appendStringInfo(row-\u003ememUsage, \"{\\\"%d\\\":%s\", GpIdentity.segindex, DatumGetCString(d)); appendStringInfo(row-\u003ecpuUsage, \"{\"); calcCpuUsage(row-\u003ecpuUsage, usages[j], timestamps[j], ResGroupOps_GetCpuUsage(groupId), GetCurrentTimestamp()); } result = PQgetvalue(pg_result, j, 1); appendStringInfo(row-\u003ecpuUsage, \", %s\", result); result = PQgetvalue(pg_result, j, 2); appendStringInfo(row-\u003ememUsage, \", %s\", result); if (i == cdb_pgresults.numResults - 1) { appendStringInfoChar(row-\u003ecpuUsage, '}'); appendStringInfoChar(row-\u003ememUsage, '}'); } } } cdbdisp_clearCdbPgResults(\u0026cdb_pgresults); } else { pg_usleep(300000); for (j = 0; j \u003c ctx-\u003enGroups; j++) { ResGroupStat *row = \u0026ctx-\u003egroups[j]; Oid groupId = DatumGetObjectId(row-\u003egroupId); Datum d = ResGroupGetStat(groupId, RES_GROUP_STAT_MEM_USAGE); appendStringInfo(row-\u003ememUsage, \"\\\"%d\\\":%s\", GpIdentity.segindex, DatumGetCString(d)); calcCpuUsage(row-\u003ecpuUsage, usages[j], timestamps[j], ResGroupOps_GetCpuUsage(groupId), GetCurrentTimestamp()); } } } 结合这段代码我们看到， Master 节点（ Gp_role = GP_ROLE_DISPATCH ）在接收到查询资源状态的 SQL 之后，首先会将一个 相同的状态查询 SQL （ =SELECT groupid, cpu_usage, memory_usage FROM pg_resgroup_get_status ），分发给所有的 segment 节点。 Master 节点收到各个节点出来的结果之后，会进行排序汇总，然后返回最终结果。\n而在各个节点真实计算的时候，对于内存消耗的计算，会返回实时统计的内存统计结果。\n而对于 cpu 的计算，会在一开始先调用 ResGroupOps_GetCpuUsage 计算一次 cpu 使用量，通过读取磁盘上 cgroup 对应节点的 cpu 统计结果。然后 sleep 300000 us ，重新调用 ResGroupOps_GetCpuUsage 再计算一次 cpu 使用量，通过两次结果的差值返 回 cpu 的统计结果。\nstatic void calcCpuUsage(StringInfoData *str, int64 usageBegin, TimestampTz timestampBegin, int64 usageEnd, TimestampTz timestampEnd) { int64 duration; long secs; int usecs; int64 usage; usage = usageEnd - usageBegin; TimestampDifference(timestampBegin, timestampEnd, \u0026secs, \u0026usecs); duration = secs * 1000000 + usecs; appendStringInfo(str, \"\\\"%d\\\":%.2f\", GpIdentity.segindex, ResGroupOps_ConvertCpuUsageToPercent(usage, duration)); } 5 常见问题 5.1 Resource Group 是如何利用操作系统的 cgroup 能力的？ 答：对于每个资源组，数据库会在系统的 cgroup 路径下创建一个以资源组 oid 命名的子路径，即做对应的 cgroup 挂载。创建资源组或者修改资源组配置的时候，数据库会对应修改对应子节点的 cgroup 配置。实 际执行事务时，数据库会将对应进程的 pid 写入对应的 cgroup 路径下，从而纳入 cgroup 的限制中。\n5.2 Resource Group 是如何进行事务级别的资源限制的？ 答：数据库对于每个资源组，根据并发限制，将资源划分成多个 slot 。\n对于每个事务，在开启事务 (startTransaction) 的时候， QD 都会尝试获取一个 slot 。如果获取不到就会 一直等待其他事务完成执行并释放 slot 。\n5.3 Resource Group 的各种操作加不加锁，加什么锁？ 资源组的创建和修改都会加 ResGroupLock 类型的 exclusive lock ，而 backend 获取 slot 来执行事务的时候也会获取 ResGroupLock 的 exclusive lock ，所以资源组相关的变更，会与对应资源组内的事务执行相互阻塞。另外， Resource Group 配置修改的时候，还会对相关系统表加 AccessExclusiveLock 。\n5.4 数据库基于 cgroup 对资源组进行限制，如果某个数据库节点故障，跨机迁移到其他节点，而 cgroup 的配置和路径结构无法迁移，会不会导致对应机器上的 resource group 功能失效？ 答：不会。在数据库节点初始化的时候 (initPostgres) ，会进行资源组的检测，如果系统表中的资源组 配置在 cgroup 路径中不存在，会重新创建对应的 cgroup 挂载。\n同理，如果你配置好了 ResourceGroup 之后，直接把你机器上的对应 oid 的 cgroup 子路径删掉，重启下数 据库就会恢复正常的状态。\n5.5 为什么资源组的 CPU 使用率高于配置的 CPU_RATE_LIMIT ？ 答：资源组可能存在 CPU 抢占的情况：当其他资源组空闲时，忙碌的资源组可以使用比其 CPU_RATE_LIMIT 更多的 CPU 。在这种情况下，数据库将空闲资源组的 CPU 资源分配给更繁忙的资源组。\n5.6 Resource Group 在部署上有什么要求？ 答：\n安装并开启 cgroup ； cgroup 做好初始化挂载，初始化配置举例： group gpdb { perm { task { uid = gpadmin; gid = gpadmin; } admin { uid = gpadmin; gid = gpadmin; } } cpu { } cpuacct { } cpuset { } memory { } } 实际使用时要根据自身情况（系统用户名）修改配置；\ncpu 和 cpuset 对应的路径必须分开挂载。 6 总结 资源管理对于数据库集群的多租户管理、资源细粒度分配具有很重要的价值。 Resource Group 巧妙地基 于操作系统的 cgroup 隔离能力和 PostgreSQL 本身的基于 MemoryContext 的内存管理能力，以很少的代码量 实现了完备的资源管理功能。在 GP5 之后， Resource Group 主键替代 Resource Queue 成为主流的资源管理 方式， Greenplum 社区也把 Resource Group 当做主要去维护和优化的资源管理方式。\n对 Greenplum 内存管理感兴趣的话，可以参考一下文章：基于 MemoryContext 的内存管理\n对另外一种资源管理方式感兴趣的话，可以参考下文章： Greenplum 资源管理—— Resource Queue 使用和实现分析\n","wordCount":"5930","inLanguage":"zh-cn","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://yangyingchao.github.io/posts/greenplum%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86resource-group%E4%BD%BF%E7%94%A8%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/"},"publisher":{"@type":"Organization","name":"MyNotes","logo":{"@type":"ImageObject","url":"https://yangyingchao.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://yangyingchao.github.io accesskey=h title="MyNotes (Alt + H)">MyNotes</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://yangyingchao.github.io/ title=Home><span>Home</span></a></li><li><a href=https://yangyingchao.github.io/posts/ title=Archives><span>Archives</span></a></li><li><a href=https://yangyingchao.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://yangyingchao.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://yangyingchao.github.io/contact/ title="Contact me"><span>Contact me</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Greenplum 资源管理——Resource Group使用和实现分析</h1><div class=post-meta></div></header><div class=post-content><ul><li>1 <a href=#h:6543d92b-650b-4a86-a5f4-d93974938e1e>Resource Group 简介</a></li><li>2 <a href=#h:87ff1e45-30e4-4099-aad9-e1064281c0be>Resource Group 使用</a><ul><li>2.1 <a href=#h:1c08605f-36f7-4a1a-87cc-037efa150149>创建资源组</a></li><li>2.2 <a href=#h:70a522e2-3bb5-48ac-85cb-397ab7c54842>将资源组分配给角色</a></li><li>2.3 <a href=#h:56b07b4f-c8cd-4a61-bb05-a0aa53c4e729>修改资源组配置</a></li><li>2.4 <a href=#h:e0d0a541-5d0d-4bda-9e66-3f90d4d32462>删除资源组</a></li><li>2.5 <a href=#h:3305964b-23b6-44fd-9dbc-bb12603f1ef4>取消资源组中的正在运行或已排队的事务</a></li></ul></li><li>3 <a href=#h:44d4e11a-9bbe-4e4b-b53c-ae006a8a6f40>Resource Group 监控</a><ul><li>3.1 <a href=#h:0ad80fcc-a86a-4d19-9709-45bdbafa50a8>查看资源组限制</a></li><li>3.2 <a href=#h:632da5d7-0508-4e3e-8b29-94f5b789fbbb>查看资源组查询状态和 CPU/ 内存使用情况</a></li><li>3.3 <a href=#h:cb00d02d-61d4-4228-afca-7e142d2a349e>查看每个主机的资源组 CPU/ 内存使用情况</a></li><li>3.4 <a href=#h:c0b260c5-68c3-428f-972a-20eb9a3f274a>查看每个 segment 的资源组 CPU/ 内存使用情况</a></li><li>3.5 <a href=#h:b9c1e5c1-8c90-4224-bd01-3b6de293e9e6>查看分配给角色的资源组</a></li><li>3.6 <a href=#h:b163affe-2a54-40b0-845f-e40858e66496>查看资源组的运行和待定查询</a></li></ul></li><li>4 <a href=#h:3ae3d47a-5c9e-4b2a-a623-026e4c4f83d1>Resource Group 实现分析</a><ul><li>4.1 <a href=#h:ec7e1268-e7ff-4c64-871d-14a2293b643b>并发限制</a></li><li>4.2 <a href=#h:2198a469-e00c-4b27-864d-8656dd1f6fa6>CPU 限制</a></li><li>4.3 <a href=#h:fcfdc2a3-257b-4933-a006-936a2a2bed67>内存限制</a></li><li>4.4 <a href=#h:8ecbe497-b8b4-45c7-a5e6-dc2f77ec5d96>Resource Group 监控</a></li></ul></li><li>5 <a href=#h:e568b217-3c31-4927-9089-767c8315acf6>常见问题</a><ul><li>5.1 <a href=#h:c00cc42c-b314-4054-bba3-36cde40afb7a>Resource Group 是如何利用操作系统的 cgroup 能力的？</a></li><li>5.2 <a href=#h:37c03467-dd66-447b-a12c-461c8efda2d5>Resource Group 是如何进行事务级别的资源限制的？</a></li><li>5.3 <a href=#h:6748afca-9c0f-40bc-bea4-11c1644d4fd1>Resource Group 的各种操作加不加锁，加什么锁？</a></li><li>5.4 <a href=#h:b4a09810-858a-4dc0-b9a6-e3b6287399d0>数据库基于 cgroup 对资源组进行限制，如果某个数据库节点故障，跨机迁移到其他节点，而 cgroup 的配置和路径结构无法迁移，会不会导致对应机器上的 resource group 功能失效？</a></li><li>5.5 <a href=#h:56086067-6fa2-4b51-8470-01255694316b>为什么资源组的 CPU 使用率高于配置的 CPU_RATE_LIMIT ？</a></li><li>5.6 <a href=#h:c21e8b97-177d-4ea2-bbc4-4a2ec11f70b6>Resource Group 在部署上有什么要求？</a></li></ul></li><li>6 <a href=#h:eec633c6-3777-4c48-bb09-3dc52d9653ff>总结</a></li></ul><p>本文为摘录，原文为： <a href=https://blog.csdn.net/u013970710/article/details/115433014>https://blog.csdn.net/u013970710/article/details/115433014</a></p><p>Greenplum 是一款广泛应用的开源 MPP 数据库的产品，兼容 PostgreSQL 生态，被广泛应用与大数据的存储与分析。</p><p>Resource Group 是 Greenplum 的一种资源管理方式。 Resource Group 由 GP5 开始被支持，相比于早期的 Resource Queue 的
资源管理方式，具有支持更细粒度的资源管理、 支持组内资源共享等优点。本文会介绍 Resource Group 的使用方式，从源码
角度分析它的实现，以及介绍一些使用中遇到的高频问题。</p><h2 id=h:6543d92b-650b-4a86-a5f4-d93974938e1e>1 Resource Group 简介<a hidden class=anchor aria-hidden=true href=#h:6543d92b-650b-4a86-a5f4-d93974938e1e>#</a></h2><p>Resource Group 是 Greenplum 的一种资源管理方式，能够细粒度定义对不同数据库角色（用户）的资源使用限制，支持通过
SQL 语句的方式进行配置。 Resource Group 支持进行三种类型的资源限制：并发限制、 CPU 限制、内存限制。</p><p>超级用户可以通过 SQL 在数据库内定义多个资源组，并设置每个资源组的资源限制。在一个数据库中，每个资源组可以关联一
个或多个数据库用户，而每个数据库用户只能归属于单个资源组。资源组支持的资源限制配置如下：</p><table><thead><tr><th>CONCURRENCY</th><th>资源组中允许的最大并发事务数，包括活动和空闲事务。</th></tr></thead><tbody><tr><td>CPU_RATE_LIMIT</td><td>此资源组可用的 CPU 资源百分比。</td></tr><tr><td>CPUSET</td><td>为该资源组保留的 CPU 核心数。</td></tr><tr><td>MEMORY_LIMIT</td><td>该资源组可用的内存资源百分比。</td></tr><tr><td>MEMORY_SHARED_QUOTA</td><td>提交到该资源组的事务之间共享的内存资源百分比。</td></tr><tr><td>MEMORY_SPILL_RATIO</td><td>内存密集型事务的内存使用阈值。当事务达到此阈值时，它将溢出到磁盘。</td></tr></tbody></table><ul><li><code>CONCURRENCY</code> 代表最大并发事务数；</li><li><code>CPU_RATE_LIMIT</code> 代表以百分比形式限制 CPU 使用，各个资源组设置的 <code>CPU_RATE_LIMIT</code> 之和不超过 <code>100%</code> ；</li><li><code>CPUSET</code> 代表以 CPU 核的形式限制 CPU ，设置具体使用哪几个 CPU 逻辑核；</li><li><code>MEMORY_LIMIT</code> 代表资源组最多能占用的集群可用内存的百分比，<ul><li>由 MEMORY_LIMIT 设定的部分属于资源组的固定份额，</li><li>而各个资源组 MEMORY_LIMIT 之和低于 100% 的部分，被划分所有资源组的共享内存池；</li><li>Bad boy…</li></ul></li><li><strong>MEMORY_SHARED_QUOTA</strong> 代表资源组内用于各个事务共享的内存比例；</li><li><strong>MEMORY_SPILL_RATIO</strong> 代表溢出到磁盘的内存使用阈值。</li></ul><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:green;font-weight:700>CREATE</span><span style=color:#bbb> </span>RESOURCE<span style=color:#bbb> </span><span style=color:green;font-weight:700>GROUP</span><span style=color:#bbb> </span>rgroup1<span style=color:#bbb> </span><span style=color:green;font-weight:700>WITH</span><span style=color:#bbb> </span>(<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>CONCURRENCY<span style=color:#666>=</span><span style=color:#666>10</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>CPU_RATE_LIMIT<span style=color:#666>=</span><span style=color:#666>20</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>MEMORY_LIMIT<span style=color:#666>=</span><span style=color:#666>25</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>MEMORY_SHARED_QUOTA<span style=color:#666>=</span><span style=color:#666>20</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>MEMORY_SPILL_RATIO<span style=color:#666>=</span><span style=color:#666>20</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>);<span style=color:#bbb>
</span></span></span></code></pre></div><p>除了 Resource Group ，GP 早期还支持 Resource Queue 的资源管理方式， Resource Queue 通过指定 MEMORY_LIMIT 、
ACTIVE_STATEMENTS 、PRIORITY 、MAX_COST 字段，配置对于各个资源队列的内存、 CPU 、并发限制， Resource Group 相对
Resource queue 存在以下优势：</p><table><thead><tr><th>特性</th><th>Resource Groups</th><th>Resource Queues</th></tr></thead><tbody><tr><td>CPU 管理</td><td>细粒度（Cgroup）</td><td>基于粗粒度的优先级</td></tr><tr><td>内存限制</td><td>细粒度</td><td>粗粒度</td></tr><tr><td>并发控制</td><td>事务级别</td><td>语句级别</td></tr><tr><td>管理 DDL Utility 语句</td><td>是</td><td>否</td></tr><tr><td>segment 级别监控</td><td>是</td><td>否</td></tr><tr><td>组内内存共享</td><td>是</td><td>否</td></tr></tbody></table><p>Resource Group 通过 Master 上的并发锁实现对并发的限制，通过 cgroup 实现对 cpu 的限制，支持对内存基于 vmtracker
和 cgroup 进行两种方式的限制。</p><h2 id=h:87ff1e45-30e4-4099-aad9-e1064281c0be>2 Resource Group 使用<a hidden class=anchor aria-hidden=true href=#h:87ff1e45-30e4-4099-aad9-e1064281c0be>#</a></h2><h3 id=h:1c08605f-36f7-4a1a-87cc-037efa150149>2.1 创建资源组<a hidden class=anchor aria-hidden=true href=#h:1c08605f-36f7-4a1a-87cc-037efa150149>#</a></h3><p>使用 <code>CREATE RESOURCE GROUP</code> 命令创建新资源组。</p><p>为角色创建资源组时，必须提供 CPU_RATE_LIMIT 或 CPUSET 和 MEMORY_LIMIT 限制值。这些限制标识要分配给此资源组的数据
库资源的百分比。例如，要创建名为 rgroup1 的资源组，其 CPU 限制为 20 ，内存限制为 25 ：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:green;font-weight:700>CREATE</span><span style=color:#bbb> </span>RESOURCE<span style=color:#bbb> </span><span style=color:green;font-weight:700>GROUP</span><span style=color:#bbb> </span>rgroup1<span style=color:#bbb> </span><span style=color:green;font-weight:700>WITH</span><span style=color:#bbb> </span>(CPU_RATE_LIMIT<span style=color:#666>=</span><span style=color:#666>20</span>,<span style=color:#bbb> </span>MEMORY_LIMIT<span style=color:#666>=</span><span style=color:#666>25</span>);<span style=color:#bbb>
</span></span></span></code></pre></div><p>CPU 限制为 20 由 rgroup1 分配到的每个角色共享。同样，内存限制为 25 由 rgroup1 分配到的每个角色共享。rgroup1 使用
默认的 MEMORY_AUDITOR vmtracker 和默认的 CONCURRENCY 设置为 20 。</p><p>数据库包含两个默认资源组： admin_group 和 default_group 。启用资源组时，将为未明确分配资源组的任何角色分配角色功
能的默认组。 SUPERUSER 角色分配了 admin_group ，非管理员角色分配了名为 default_group 的组。</p><p>使用以下资源限制创建默认资源组 admin_group 和 default_group ：</p><table><thead><tr><th>限制类型</th><th>admin_group</th><th>default_group</th></tr></thead><tbody><tr><td>CONCURRENCY</td><td>10</td><td>20</td></tr><tr><td>CPU_RATE_LIMIT</td><td>10</td><td>30</td></tr><tr><td>CPUSET</td><td>-1</td><td>-1</td></tr><tr><td>MEMORY_LIMIT</td><td>10</td><td>30</td></tr><tr><td>MEMORY_SHARED_QUOTA</td><td>50</td><td>50</td></tr><tr><td>MEMORY_SPILL_RATIO</td><td>20</td><td>20</td></tr><tr><td>MEMORY_AUDITOR</td><td>vmtracker</td><td>vmtracker</td></tr></tbody></table><p>默认资源组 admin_group 和 default_group 的 CPU_RATE_LIMIT 和 MEMORY_LIMIT 值对分段主机上的总百分比有贡献。</p><h3 id=h:70a522e2-3bb5-48ac-85cb-397ab7c54842>2.2 将资源组分配给角色<a hidden class=anchor aria-hidden=true href=#h:70a522e2-3bb5-48ac-85cb-397ab7c54842>#</a></h3><p>Greenplum 资源组可用于分配给一个或多个角色（用户）。使用 CREATE ROLE 或 ALTER ROLE 命令的 RESOURCE GROUP 子句将资
源组分配给数据库角色。如果未为角色指定资源组，则会为角色分配角色功能的默认组。 SUPERUSER 角色分配了 admin_group
，非管理员角色分配了名为 default_group 的组。</p><p>使用 ALTER ROLE 或 CREATE ROLE 命令将资源组分配给角色。例如：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:green;font-weight:700>ALTER</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>ROLE</span><span style=color:#bbb> </span>bill<span style=color:#bbb> </span>RESOURCE<span style=color:#bbb> </span><span style=color:green;font-weight:700>GROUP</span><span style=color:#bbb> </span>rg_light;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>CREATE</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>ROLE</span><span style=color:#bbb> </span>mary<span style=color:#bbb> </span>RESOURCE<span style=color:#bbb> </span><span style=color:green;font-weight:700>GROUP</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>exec</span>;<span style=color:#bbb>
</span></span></span></code></pre></div><p>用户可以将资源组分配给一个或多个角色。如果已定义角色层次结构，则将资源组分配给父角色不会向下传播到该角色组的成员。</p><p>如果要从角色中删除资源组分配并将角色分配为默认组，请将角色的组名称分配更改为 NONE 。例如：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>ALTER ROLE mary RESOURCE GROUP NONE;
</span></span></code></pre></div><h3 id=h:56b07b4f-c8cd-4a61-bb05-a0aa53c4e729>2.3 修改资源组配置<a hidden class=anchor aria-hidden=true href=#h:56b07b4f-c8cd-4a61-bb05-a0aa53c4e729>#</a></h3><p><code>ALTER RESOURCE GROUP</code> 命令可以修改资源组配置。要更改资源组的限制，请指定组所需的新值。例如：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:green;font-weight:700>ALTER</span><span style=color:#bbb> </span>RESOURCE<span style=color:#bbb> </span><span style=color:green;font-weight:700>GROUP</span><span style=color:#bbb> </span>rg_role_light<span style=color:#bbb> </span><span style=color:green;font-weight:700>SET</span><span style=color:#bbb> </span>CONCURRENCY<span style=color:#bbb> </span><span style=color:#666>7</span>;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>ALTER</span><span style=color:#bbb> </span>RESOURCE<span style=color:#bbb> </span><span style=color:green;font-weight:700>GROUP</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>exec</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>SET</span><span style=color:#bbb> </span>MEMORY_LIMIT<span style=color:#bbb> </span><span style=color:#666>25</span>;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>ALTER</span><span style=color:#bbb> </span>RESOURCE<span style=color:#bbb> </span><span style=color:green;font-weight:700>GROUP</span><span style=color:#bbb> </span>rgroup1<span style=color:#bbb> </span><span style=color:green;font-weight:700>SET</span><span style=color:#bbb> </span>CPUSET<span style=color:#bbb> </span><span style=color:#ba2121>&#39;2,4&#39;</span>;<span style=color:#bbb>
</span></span></span></code></pre></div><p>注意 : 用户无法将 admin_group 的 CONCURRENCY 值设置或更改为 0 。</p><h3 id=h:e0d0a541-5d0d-4bda-9e66-3f90d4d32462>2.4 删除资源组<a hidden class=anchor aria-hidden=true href=#h:e0d0a541-5d0d-4bda-9e66-3f90d4d32462>#</a></h3><p>DROP RESOURCE GROUP 命令会删除资源组。要删除角色的资源组，不能将该组分配给任何角色，也不能在资源组中激活或等待任何事务。</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:green;font-weight:700>DROP</span><span style=color:#bbb> </span>RESOURCE<span style=color:#bbb> </span><span style=color:green;font-weight:700>GROUP</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>exec</span>;<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=h:3305964b-23b6-44fd-9dbc-bb12603f1ef4>2.5 取消资源组中的正在运行或已排队的事务<a hidden class=anchor aria-hidden=true href=#h:3305964b-23b6-44fd-9dbc-bb12603f1ef4>#</a></h3><p>在某些情况下，用户可能希望取消资源组中的正在运行或排队的事务。例如，用户可能希望删除在资源组队列中等待但尚未执行
的查询。或者，用户可能希望停止执行时间太长的正在运行的查询，或者在事务中处于空闲状态并占用其他用户所需的资源组事
务插槽的查询。</p><p>要取消正在运行或排队的事务，必须首先确定与事务关联的进程 ID （pid ）。获得进程 ID 后，可以调用
<code>pg_cancel_backend()</code> 来结束该进程。</p><p>例如，要查看与当前活动或在所有资源组中等待的所有语句关联的进程信息，请运行以下查询。如果查询未返回任何结果，则任
何资源组中都没有正在运行或排队的事务。</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:green;font-weight:700>SELECT</span><span style=color:#bbb> </span>rolname,<span style=color:#bbb> </span><span style=color:green;font-weight:700>g</span>.rsgname,<span style=color:#bbb> </span>procpid,<span style=color:#bbb> </span>waiting,<span style=color:#bbb> </span>current_query,<span style=color:#bbb> </span>datname<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>FROM</span><span style=color:#bbb> </span>pg_roles,<span style=color:#bbb> </span>gp_toolkit.gp_resgroup_status<span style=color:#bbb> </span><span style=color:green;font-weight:700>g</span>,<span style=color:#bbb> </span>pg_stat_activity<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>WHERE</span><span style=color:#bbb> </span>pg_roles.rolresgroup<span style=color:#666>=</span><span style=color:green;font-weight:700>g</span>.groupid<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>AND</span><span style=color:#bbb> </span>pg_stat_activity.usename<span style=color:#666>=</span>pg_roles.rolname;<span style=color:#bbb>
</span></span></span></code></pre></div><p>示例部分查询输出：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#bbb> </span>rolname<span style=color:#bbb> </span><span style=color:#666>|</span><span style=color:#bbb> </span>rsgname<span style=color:#bbb>  </span><span style=color:#666>|</span><span style=color:#bbb> </span>procpid<span style=color:#bbb> </span><span style=color:#666>|</span><span style=color:#bbb> </span>waiting<span style=color:#bbb> </span><span style=color:#666>|</span><span style=color:#bbb>     </span>current_query<span style=color:#bbb>     </span><span style=color:#666>|</span><span style=color:#bbb> </span>datname<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#408080;font-style:italic>---------+----------+---------+---------+-----------------------+---------
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span><span style=color:#bbb>  </span>sammy<span style=color:#bbb>  </span><span style=color:#666>|</span><span style=color:#bbb> </span>rg_light<span style=color:#bbb> </span><span style=color:#666>|</span><span style=color:#bbb>  </span><span style=color:#666>31861</span><span style=color:#bbb>  </span><span style=color:#666>|</span><span style=color:#bbb>    </span>f<span style=color:#bbb>    </span><span style=color:#666>|</span><span style=color:#bbb> </span><span style=color:#666>&lt;</span>IDLE<span style=color:#666>&gt;</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>in</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>transaction</span><span style=color:#bbb> </span><span style=color:#666>|</span><span style=color:#bbb> </span>testdb<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>billy<span style=color:#bbb>  </span><span style=color:#666>|</span><span style=color:#bbb> </span>rg_light<span style=color:#bbb> </span><span style=color:#666>|</span><span style=color:#bbb>  </span><span style=color:#666>31905</span><span style=color:#bbb>  </span><span style=color:#666>|</span><span style=color:#bbb>    </span>t<span style=color:#bbb>    </span><span style=color:#666>|</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>SELECT</span><span style=color:#bbb> </span><span style=color:#666>*</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>FROM</span><span style=color:#bbb> </span>topten;<span style=color:#bbb> </span><span style=color:#666>|</span><span style=color:#bbb> </span>testdb<span style=color:#bbb>
</span></span></span></code></pre></div><p>使用此输出来标识要取消的事务的进程 ID （procpid ），然后取消该进程。例如，要取消上面示例输出中标识的待处理查询：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:green;font-weight:700>SELECT</span><span style=color:#bbb> </span>pg_cancel_backend(<span style=color:#666>31905</span>);<span style=color:#bbb>
</span></span></span></code></pre></div><p>用户可以在 pg_cancel_backend() 的第二个参数中提供可选消息，以向用户指示进程被取消的原因。</p><h2 id=h:44d4e11a-9bbe-4e4b-b53c-ae006a8a6f40>3 Resource Group 监控<a hidden class=anchor aria-hidden=true href=#h:44d4e11a-9bbe-4e4b-b53c-ae006a8a6f40>#</a></h2><p>本节主要介绍如何通过系统视图监控集群的资源组，包括各个资源组的配置，各个资源组的资源使用情况等。</p><p>以下是资源组相关的监控项的含义：</p><table><thead><tr><th>rsgname</th><th>资源组名</th></tr></thead><tbody><tr><td>groupid</td><td>资源组 oid</td></tr><tr><td>cpu</td><td>当前资源组的 cpu 利用率</td></tr><tr><td>memory_used</td><td>当前资源组实际使用的内存总量</td></tr><tr><td>memory_available</td><td>当前资源组可用的内存总量</td></tr><tr><td>memory_quota_used</td><td>当前资源组固定份额部分实际使用的内存总量</td></tr><tr><td>memory_quota_available</td><td>当前资源组固定份额部分可用的内存总量</td></tr><tr><td>memory_quota_granted</td><td>当前资源组固定份额部分的总体分配量</td></tr><tr><td>memory_shared_used</td><td>当前资源组共享部分实际使用的内存总量</td></tr><tr><td>memory_shared_available</td><td>当前资源组共享部分可用的内存总量</td></tr><tr><td>memory_shared_granted</td><td>当前资源组共享部分的总体分配量</td></tr></tbody></table><p>正常情况下，各个资源组监控项有以下关系：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cfg data-lang=cfg><span style=display:flex><span><span style=color:#7d9029>memory_used</span> <span style=color:#666>=</span> <span style=color:#ba2121>memory_quota_used + memory_shared_used</span>
</span></span><span style=display:flex><span><span style=color:#7d9029>available</span> <span style=color:#666>=</span> <span style=color:#ba2121>memory_quota_granted + memory_shared_granted - memory_used</span>
</span></span><span style=display:flex><span><span style=color:#7d9029>memory_quota_granted</span> <span style=color:#666>=</span> <span style=color:#ba2121>memory_quota_used + memory_quota_available</span>
</span></span><span style=display:flex><span><span style=color:#7d9029>memory_shared_granted</span> <span style=color:#666>=</span> <span style=color:#ba2121>memory_shared_used + memory_shared_available</span>
</span></span></code></pre></div><h3 id=h:0ad80fcc-a86a-4d19-9709-45bdbafa50a8>3.1 查看资源组限制<a hidden class=anchor aria-hidden=true href=#h:0ad80fcc-a86a-4d19-9709-45bdbafa50a8>#</a></h3><p><code>gp_resgroup_config</code> 系统视图显示所有的资源组配置。</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:green;font-weight:700>SELECT</span><span style=color:#bbb> </span><span style=color:#666>*</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>FROM</span><span style=color:#bbb> </span>gp_toolkit.gp_resgroup_config;<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=h:632da5d7-0508-4e3e-8b29-94f5b789fbbb>3.2 查看资源组查询状态和 CPU/ 内存使用情况<a hidden class=anchor aria-hidden=true href=#h:632da5d7-0508-4e3e-8b29-94f5b789fbbb>#</a></h3><p>gp_resgroup_status 系统视图可以查看资源组的状态和活动。该视图显示正在运行和排队的事务数。它还显示资源组的实时 CPU 和内存使用情况。</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:green;font-weight:700>SELECT</span><span style=color:#bbb> </span><span style=color:#666>*</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>FROM</span><span style=color:#bbb> </span>gp_toolkit.gp_resgroup_status;<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=h:cb00d02d-61d4-4228-afca-7e142d2a349e>3.3 查看每个主机的资源组 CPU/ 内存使用情况<a hidden class=anchor aria-hidden=true href=#h:cb00d02d-61d4-4228-afca-7e142d2a349e>#</a></h3><p>通过 gp_resgroup_status_per_host 系统视图，用户可以基于每个主机查看资源组的实时 CPU 和内存使用情况。</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:green;font-weight:700>SELECT</span><span style=color:#bbb> </span><span style=color:#666>*</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>FROM</span><span style=color:#bbb> </span>gp_toolkit.gp_resgroup_status_per_host;<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=h:c0b260c5-68c3-428f-972a-20eb9a3f274a>3.4 查看每个 segment 的资源组 CPU/ 内存使用情况<a hidden class=anchor aria-hidden=true href=#h:c0b260c5-68c3-428f-972a-20eb9a3f274a>#</a></h3><p>通过 gp_resgroup_status_per_segment 系统视图，用户可以按每个 segment ，每个主机查看资源组的实时 CPU 和内存使用情
况。</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:green;font-weight:700>SELECT</span><span style=color:#bbb> </span><span style=color:#666>*</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>FROM</span><span style=color:#bbb> </span>gp_toolkit.gp_resgroup_status_per_segment;<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=h:b9c1e5c1-8c90-4224-bd01-3b6de293e9e6>3.5 查看分配给角色的资源组<a hidden class=anchor aria-hidden=true href=#h:b9c1e5c1-8c90-4224-bd01-3b6de293e9e6>#</a></h3><p>要查看资源组到角色的分配，请对 pg_roles 和 pg_resgroup 系统表执行以下查询：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:green;font-weight:700>SELECT</span><span style=color:#bbb> </span>rolname,<span style=color:#bbb> </span>rsgname<span style=color:#bbb> </span><span style=color:green;font-weight:700>FROM</span><span style=color:#bbb> </span>pg_roles,<span style=color:#bbb> </span>pg_resgroup<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>WHERE</span><span style=color:#bbb> </span>pg_roles.rolresgroup<span style=color:#666>=</span>pg_resgroup.oid;<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=h:b163affe-2a54-40b0-845f-e40858e66496>3.6 查看资源组的运行和待定查询<a hidden class=anchor aria-hidden=true href=#h:b163affe-2a54-40b0-845f-e40858e66496>#</a></h3><p>要查看资源组的运行查询，挂起的查询以及挂起的查询排队的时间，请检查 pg_stat_activity 系统表：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:green;font-weight:700>SELECT</span><span style=color:#bbb> </span>current_query,<span style=color:#bbb> </span>waiting,<span style=color:#bbb> </span>rsgname,<span style=color:#bbb> </span>rsgqueueduration<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>FROM</span><span style=color:#bbb> </span>pg_stat_activity;<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=h:3ae3d47a-5c9e-4b2a-a623-026e4c4f83d1>4 Resource Group 实现分析<a hidden class=anchor aria-hidden=true href=#h:3ae3d47a-5c9e-4b2a-a623-026e4c4f83d1>#</a></h2><p>Greenplum 数据库是 MPP 架构，整体分为一个或多个 Master ，以及多个 segment ，数据在多个 segment 之间可以随机、哈
希、复制分布。在 Greenplum 中， Resource Group 的资源限制级别是事务级别。 Resource Group 会在各个 group 内部将资
源划分成并发量数目的 slot ，而每个事务在运行前排队等待获取 slot 。</p><figure><img loading=lazy src=/ox-hugo/7205cbeb232654c223dd9cbe0b417729.png width=800px></figure><p>如上文所述， Resource Group 支持对并发、 CPU 和内存进行限制，本节会详细介绍对这几类资源进行限制的实现细节，以及
介绍对于资源组的监控是如何实现的。</p><p>Resource Group 的代码主要位于如下的路径和文件中：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>src/backend/utils/resgroup
</span></span><span style=display:flex><span>src/backend/utils/ressource_manager
</span></span><span style=display:flex><span>src/backend/commands/resgroupcmds.c
</span></span></code></pre></div><h3 id=h:ec7e1268-e7ff-4c64-871d-14a2293b643b>4.1 并发限制<a hidden class=anchor aria-hidden=true href=#h:ec7e1268-e7ff-4c64-871d-14a2293b643b>#</a></h3><p>Resource Group 通过 Master 上的并发锁实现对并发的限制。用户连接到数据库集群时，首先会连接到
Master 节点，在开启事务时，会尝试获取 slot 。</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:green;font-weight:700>static</span> ResGroupSlotData <span style=color:#666>*</span>
</span></span><span style=display:flex><span><span style=color:#00f>groupGetSlot</span>(ResGroupData <span style=color:#666>*</span>group)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>        ResGroupSlotData	<span style=color:#666>*</span>slot;
</span></span><span style=display:flex><span>        ResGroupCaps		<span style=color:#666>*</span>caps;
</span></span><span style=display:flex><span>        int32				slotMemQuota;
</span></span><span style=display:flex><span>        <span style=color:#00f>Assert</span>(<span style=color:#00f>LWLockHeldExclusiveByMe</span>(ResGroupLock));
</span></span><span style=display:flex><span>        <span style=color:#00f>Assert</span>(Gp_role <span style=color:#666>==</span> GP_ROLE_DISPATCH);
</span></span><span style=display:flex><span>        <span style=color:#00f>Assert</span>(<span style=color:#00f>groupIsNotDropped</span>(group));
</span></span><span style=display:flex><span>        caps <span style=color:#666>=</span> <span style=color:#666>&amp;</span>group<span style=color:#666>-&gt;</span>caps;
</span></span><span style=display:flex><span>        <span style=color:#408080;font-style:italic>/* First check if the concurrency limit is reached */</span>
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>if</span> (group<span style=color:#666>-&gt;</span>nRunning <span style=color:#666>&gt;=</span> caps<span style=color:#666>-&gt;</span>concurrency)
</span></span><span style=display:flex><span>                <span style=color:green;font-weight:700>return</span> <span style=color:green>NULL</span>;
</span></span><span style=display:flex><span>        slotMemQuota <span style=color:#666>=</span> <span style=color:#00f>groupReserveMemQuota</span>(group);
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>if</span> (slotMemQuota <span style=color:#666>&lt;</span> <span style=color:#666>0</span>)
</span></span><span style=display:flex><span>                <span style=color:green;font-weight:700>return</span> <span style=color:green>NULL</span>;
</span></span><span style=display:flex><span>        <span style=color:#408080;font-style:italic>/* Now actually get a free slot */</span>
</span></span><span style=display:flex><span>        slot <span style=color:#666>=</span> <span style=color:#00f>slotpoolAllocSlot</span>();
</span></span><span style=display:flex><span>        <span style=color:#00f>Assert</span>(<span style=color:#666>!</span><span style=color:#00f>slotIsInUse</span>(slot));
</span></span><span style=display:flex><span>        <span style=color:#00f>initSlot</span>(slot, group, slotMemQuota);
</span></span><span style=display:flex><span>        group<span style=color:#666>-&gt;</span>nRunning<span style=color:#666>++</span>;
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>return</span> slot;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Master 上通过比较资源组当前运行的事务数 group->nRunning ，与设定的并发数 concurrency ，保证限制实际运行的并发数
不高于设定值。 Greenplum 是多进程模型，各个资源组的计数量 group->nRunning 放在共享内存中，在 slot 的获取过程中，
会获取 ResGroupLock 类型的排他锁，以保证并发安全。</p><h3 id=h:2198a469-e00c-4b27-864d-8656dd1f6fa6>4.2 CPU 限制<a hidden class=anchor aria-hidden=true href=#h:2198a469-e00c-4b27-864d-8656dd1f6fa6>#</a></h3><p>Resource Group 通过 cgroup 实现对 cpu 的限制。在 resource group 创建或者修改时（比如 initCpu ），数据库会在操作
系统 cgroup 路径下，创建与 resource group oid 同名的 cgroup 路径，即做对应挂载。并根据设置的 CPU 配置，更新对应
cgroup 子路径下的 cpu.cfs_period_us 、cpu.cfs_quota_us 、cpu.shares 文件。</p><p>而在开始事务时，数据库会将当前进程关联到对应的 cgroup 子节点下，具体逻辑如下：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#b00040>void</span>
</span></span><span style=display:flex><span><span style=color:#00f>ResGroupOps_AssignGroup</span>(Oid group, ResGroupCaps <span style=color:#666>*</span>caps, <span style=color:#b00040>int</span> pid)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>        <span style=color:#b00040>bool</span> oldViaCpuset <span style=color:#666>=</span> oldCaps.cpuRateLimit <span style=color:#666>==</span> CPU_RATE_LIMIT_DISABLED;
</span></span><span style=display:flex><span>        <span style=color:#b00040>bool</span> curViaCpuset <span style=color:#666>=</span> caps <span style=color:#666>?</span> caps<span style=color:#666>-&gt;</span>cpuRateLimit <span style=color:#666>==</span> <span style=color:#a0a000>CPU_RATE_LIMIT_DISABLED</span> : <span style=color:green>false</span>;
</span></span><span style=display:flex><span>        <span style=color:#408080;font-style:italic>/* needn&#39;t write to file if the pid has already been written in.
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>         * Unless it has not been writtien or the group has changed or
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>         * cpu control mechanism has changed */</span>
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>if</span> (IsUnderPostmaster <span style=color:#666>&amp;&amp;</span>
</span></span><span style=display:flex><span>                group <span style=color:#666>==</span> currentGroupIdInCGroup <span style=color:#666>&amp;&amp;</span>
</span></span><span style=display:flex><span>                caps <span style=color:#666>!=</span> <span style=color:green>NULL</span> <span style=color:#666>&amp;&amp;</span>
</span></span><span style=display:flex><span>                oldViaCpuset <span style=color:#666>==</span> curViaCpuset)
</span></span><span style=display:flex><span>                <span style=color:green;font-weight:700>return</span>;
</span></span><span style=display:flex><span>        <span style=color:#00f>writeInt64</span>(group, BASETYPE_GPDB, RESGROUP_COMP_TYPE_CPU,
</span></span><span style=display:flex><span>                           <span style=color:#ba2121>&#34;cgroup.procs&#34;</span>, pid);
</span></span><span style=display:flex><span>        <span style=color:#00f>writeInt64</span>(group, BASETYPE_GPDB, RESGROUP_COMP_TYPE_CPUACCT,
</span></span><span style=display:flex><span>                           <span style=color:#ba2121>&#34;cgroup.procs&#34;</span>, pid);
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>if</span> (gp_resource_group_enable_cgroup_cpuset)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>                <span style=color:green;font-weight:700>if</span> (caps <span style=color:#666>==</span> <span style=color:green>NULL</span> <span style=color:#666>||</span> <span style=color:#666>!</span>curViaCpuset)
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                        <span style=color:#408080;font-style:italic>/* add pid to default group */</span>
</span></span><span style=display:flex><span>                        <span style=color:#00f>writeInt64</span>(DEFAULT_CPUSET_GROUP_ID, BASETYPE_GPDB,
</span></span><span style=display:flex><span>                                           RESGROUP_COMP_TYPE_CPUSET, <span style=color:#ba2121>&#34;cgroup.procs&#34;</span>, pid);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:green;font-weight:700>else</span>
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                        <span style=color:#00f>writeInt64</span>(group, BASETYPE_GPDB,
</span></span><span style=display:flex><span>                                           RESGROUP_COMP_TYPE_CPUSET, <span style=color:#ba2121>&#34;cgroup.procs&#34;</span>, pid);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#408080;font-style:italic>/*
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>         * Do not assign the process to cgroup/memory for now.
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>         */</span>
</span></span><span style=display:flex><span>        currentGroupIdInCGroup <span style=color:#666>=</span> group;
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>if</span> (caps <span style=color:#666>!=</span> <span style=color:green>NULL</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>                oldCaps.cpuRateLimit <span style=color:#666>=</span> caps<span style=color:#666>-&gt;</span>cpuRateLimit;
</span></span><span style=display:flex><span>                <span style=color:#00f>StrNCpy</span>(oldCaps.cpuset, caps<span style=color:#666>-&gt;</span>cpuset, <span style=color:green;font-weight:700>sizeof</span>(oldCaps.cpuset));
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>数据库会将对应进程的 pid 写进子路径的 cgroup.procs 文件里，从而利用操作系统的 cgroup 能力对进程的 cpu 使用进行限
制。</p><h3 id=h:fcfdc2a3-257b-4933-a006-936a2a2bed67>4.3 内存限制<a hidden class=anchor aria-hidden=true href=#h:fcfdc2a3-257b-4933-a006-936a2a2bed67>#</a></h3><p>支持对内存基于 vmtracker 和 cgroup 进行两种方式的限制。在使用 cgroup 做内存限制的时候，它的应用原理与 CPU 限制类
似：为每个资源组创建一个 cgroup 子节点，在资源组创建和修改时，修改对应 cgroup 的内存管理配置文件
memory.limit_in_bytes 、 memory.usage_in_bytes ；事务运行时通过 pid 与对应 cgroup 关联，支持内存的限制。</p><p>而基于 vmtracker 进行内存限制时，则完全是由数据库本身进行高并发场景下的内存审计和分配，这里以内存统计量的修改为
例：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:green;font-weight:700>static</span> int32
</span></span><span style=display:flex><span><span style=color:#00f>groupIncMemUsage</span>(ResGroupData <span style=color:#666>*</span>group, ResGroupSlotData <span style=color:#666>*</span>slot, int32 chunks)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>        int32			slotMemUsage;	<span style=color:#408080;font-style:italic>/* the memory current slot has been used */</span>
</span></span><span style=display:flex><span>        int32			sharedMemUsage;	<span style=color:#408080;font-style:italic>/* the total shared memory usage,
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>                                                                                sum of group share and global share */</span>
</span></span><span style=display:flex><span>        int32			globalOveruse <span style=color:#666>=</span> <span style=color:#666>0</span>;	<span style=color:#408080;font-style:italic>/* the total over used chunks of global share*/</span>
</span></span><span style=display:flex><span>        <span style=color:#408080;font-style:italic>/* Add the chunks to memUsage in slot */</span>
</span></span><span style=display:flex><span>        slotMemUsage <span style=color:#666>=</span> <span style=color:#00f>pg_atomic_add_fetch_u32</span>((pg_atomic_uint32 <span style=color:#666>*</span>) <span style=color:#666>&amp;</span>slot<span style=color:#666>-&gt;</span>memUsage,
</span></span><span style=display:flex><span>                                                                                   chunks);
</span></span><span style=display:flex><span>        <span style=color:#408080;font-style:italic>/* Check whether shared memory should be added */</span>
</span></span><span style=display:flex><span>        sharedMemUsage <span style=color:#666>=</span> slotMemUsage <span style=color:#666>-</span> slot<span style=color:#666>-&gt;</span>memQuota;
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>if</span> (sharedMemUsage <span style=color:#666>&gt;</span> <span style=color:#666>0</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>                <span style=color:#408080;font-style:italic>/* Decide how many chunks should be counted as shared memory */</span>
</span></span><span style=display:flex><span>                int32 deltaSharedMemUsage <span style=color:#666>=</span> <span style=color:#00f>Min</span>(sharedMemUsage, chunks);
</span></span><span style=display:flex><span>                <span style=color:#408080;font-style:italic>/* Add these chunks to memSharedUsage in group,
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>                 * and record the old value*/</span>
</span></span><span style=display:flex><span>                int32 oldSharedUsage <span style=color:#666>=</span> <span style=color:#00f>pg_atomic_fetch_add_u32</span>((pg_atomic_uint32 <span style=color:#666>*</span>)
</span></span><span style=display:flex><span>                                                                                                           <span style=color:#666>&amp;</span>group<span style=color:#666>-&gt;</span>memSharedUsage,
</span></span><span style=display:flex><span>                                                                                                           deltaSharedMemUsage);
</span></span><span style=display:flex><span>                <span style=color:#408080;font-style:italic>/* the free space of group share */</span>
</span></span><span style=display:flex><span>                int32 oldSharedFree <span style=color:#666>=</span> <span style=color:#00f>Max</span>(<span style=color:#666>0</span>, group<span style=color:#666>-&gt;</span>memSharedGranted <span style=color:#666>-</span> oldSharedUsage);
</span></span><span style=display:flex><span>                <span style=color:#408080;font-style:italic>/* Calculate the global over used chunks */</span>
</span></span><span style=display:flex><span>                int32 deltaGlobalSharedMemUsage <span style=color:#666>=</span> <span style=color:#00f>Max</span>(<span style=color:#666>0</span>, deltaSharedMemUsage <span style=color:#666>-</span> oldSharedFree);
</span></span><span style=display:flex><span>                <span style=color:#408080;font-style:italic>/* freeChunks -= deltaGlobalSharedMemUsage and get the new value */</span>
</span></span><span style=display:flex><span>                int32 newFreeChunks <span style=color:#666>=</span> <span style=color:#00f>pg_atomic_sub_fetch_u32</span>((pg_atomic_uint32 <span style=color:#666>*</span>)
</span></span><span style=display:flex><span>                                                                                                          <span style=color:#666>&amp;</span>pResGroupControl<span style=color:#666>-&gt;</span>freeChunks,
</span></span><span style=display:flex><span>                                                                                                          deltaGlobalSharedMemUsage);
</span></span><span style=display:flex><span>                <span style=color:#408080;font-style:italic>/* calculate the total over used chunks of global share */</span>
</span></span><span style=display:flex><span>                globalOveruse <span style=color:#666>=</span> <span style=color:#00f>Max</span>(<span style=color:#666>0</span>, <span style=color:#666>0</span> <span style=color:#666>-</span> newFreeChunks);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#408080;font-style:italic>/* Add the chunks to memUsage in group */</span>
</span></span><span style=display:flex><span>        <span style=color:#00f>pg_atomic_add_fetch_u32</span>((pg_atomic_uint32 <span style=color:#666>*</span>) <span style=color:#666>&amp;</span>group<span style=color:#666>-&gt;</span>memUsage,
</span></span><span style=display:flex><span>                                                        chunks);
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>return</span> globalOveruse;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在进行内存限制时，对于某个 slot 的内存请求，首先会通过原子相加的方式从资源组的固定份额部分获取内存；而如果所需要
的内存超过固定份额的内存量，会尝试从资源组内的共享内存部分获取；如果依然无法获取到内存，则会尝试从全局的共享内存
获取。如果从全局共享内存依然无法获取到内存，则会返回 Out of Memory 错误。</p><h3 id=h:8ecbe497-b8b4-45c7-a5e6-dc2f77ec5d96>4.4 Resource Group 监控<a hidden class=anchor aria-hidden=true href=#h:8ecbe497-b8b4-45c7-a5e6-dc2f77ec5d96>#</a></h3><p>在进行监控时， QD 会把资源组查询 query 分发到各个 segment 上，然后再在 master 进行汇总，返回集群整体的资源利用情
况。</p><p>Greenplum 支持多种对资源组的监控方式，除了直接的资源组监控视图之外，还支持对 segment 、机器层级的资源组监控。这
些不同层级的资源组监控视图往往是通过对系统表和系统函数进行联合查询得到的，比如：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:green;font-weight:700>CREATE</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>VIEW</span><span style=color:#bbb> </span>gp_toolkit.gp_resgroup_status<span style=color:#bbb> </span><span style=color:green;font-weight:700>AS</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>SELECT</span><span style=color:#bbb> </span>r.rsgname,<span style=color:#bbb> </span>s.<span style=color:#666>*</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>FROM</span><span style=color:#bbb> </span>pg_resgroup_get_status(<span style=color:green;font-weight:700>null</span>)<span style=color:#bbb> </span><span style=color:green;font-weight:700>AS</span><span style=color:#bbb> </span>s,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>         </span>pg_resgroup<span style=color:#bbb> </span><span style=color:green;font-weight:700>AS</span><span style=color:#bbb> </span>r<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>WHERE</span><span style=color:#bbb> </span>s.groupid<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span>r.oid;<span style=color:#bbb>
</span></span></span></code></pre></div><p>所以，我们介绍最基本的资源监控函数 pg_resgroup_get_status 的实现方式。</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:green;font-weight:700>static</span> <span style=color:#b00040>void</span>
</span></span><span style=display:flex><span><span style=color:#00f>getResUsage</span>(ResGroupStatCtx <span style=color:#666>*</span>ctx, Oid inGroupId)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>        int64 <span style=color:#666>*</span>usages;
</span></span><span style=display:flex><span>        TimestampTz <span style=color:#666>*</span>timestamps;
</span></span><span style=display:flex><span>        <span style=color:#b00040>int</span> i, j;
</span></span><span style=display:flex><span>        usages <span style=color:#666>=</span> <span style=color:#00f>palloc</span>(<span style=color:green;font-weight:700>sizeof</span>(<span style=color:#666>*</span>usages) <span style=color:#666>*</span> ctx<span style=color:#666>-&gt;</span>nGroups);
</span></span><span style=display:flex><span>        timestamps <span style=color:#666>=</span> <span style=color:#00f>palloc</span>(<span style=color:green;font-weight:700>sizeof</span>(<span style=color:#666>*</span>timestamps) <span style=color:#666>*</span> ctx<span style=color:#666>-&gt;</span>nGroups);
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>for</span> (j <span style=color:#666>=</span> <span style=color:#666>0</span>; j <span style=color:#666>&lt;</span> ctx<span style=color:#666>-&gt;</span>nGroups; j<span style=color:#666>++</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>                ResGroupStat <span style=color:#666>*</span>row <span style=color:#666>=</span> <span style=color:#666>&amp;</span>ctx<span style=color:#666>-&gt;</span>groups[j];
</span></span><span style=display:flex><span>                Oid groupId <span style=color:#666>=</span> <span style=color:#00f>DatumGetObjectId</span>(row<span style=color:#666>-&gt;</span>groupId);
</span></span><span style=display:flex><span>                usages[j] <span style=color:#666>=</span> <span style=color:#00f>ResGroupOps_GetCpuUsage</span>(groupId);
</span></span><span style=display:flex><span>                timestamps[j] <span style=color:#666>=</span> <span style=color:#00f>GetCurrentTimestamp</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>if</span> (Gp_role <span style=color:#666>==</span> GP_ROLE_DISPATCH)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>                CdbPgResults cdb_pgresults <span style=color:#666>=</span> {<span style=color:green>NULL</span>, <span style=color:#666>0</span>};
</span></span><span style=display:flex><span>                StringInfoData buffer;
</span></span><span style=display:flex><span>                <span style=color:#00f>initStringInfo</span>(<span style=color:#666>&amp;</span>buffer);
</span></span><span style=display:flex><span>                <span style=color:#00f>appendStringInfo</span>(<span style=color:#666>&amp;</span>buffer,
</span></span><span style=display:flex><span>                                                 <span style=color:#ba2121>&#34;SELECT groupid, cpu_usage, memory_usage &#34;</span>
</span></span><span style=display:flex><span>                                                 <span style=color:#ba2121>&#34;FROM pg_resgroup_get_status(%d)&#34;</span>,
</span></span><span style=display:flex><span>                                                 inGroupId);
</span></span><span style=display:flex><span>                <span style=color:#00f>CdbDispatchCommand</span>(buffer.data, DF_WITH_SNAPSHOT, <span style=color:#666>&amp;</span>cdb_pgresults);
</span></span><span style=display:flex><span>                <span style=color:green;font-weight:700>if</span> (cdb_pgresults.numResults <span style=color:#666>==</span> <span style=color:#666>0</span>)
</span></span><span style=display:flex><span>                        <span style=color:#00f>elog</span>(ERROR, <span style=color:#ba2121>&#34;pg_resgroup_get_status() didn&#39;t get back any resource statistic from the segDBs&#34;</span>);
</span></span><span style=display:flex><span>                <span style=color:green;font-weight:700>for</span> (i <span style=color:#666>=</span> <span style=color:#666>0</span>; i <span style=color:#666>&lt;</span> cdb_pgresults.numResults; i<span style=color:#666>++</span>)
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                        <span style=color:green;font-weight:700>struct</span> pg_result <span style=color:#666>*</span>pg_result <span style=color:#666>=</span> cdb_pgresults.pg_results[i];
</span></span><span style=display:flex><span>                        <span style=color:#408080;font-style:italic>/*
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>                         * Any error here should have propagated into errbuf, so we shouldn&#39;t
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>                         * ever see anything other that tuples_ok here.  But, check to be
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>                         * sure.
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>                         */</span>
</span></span><span style=display:flex><span>                        <span style=color:green;font-weight:700>if</span> (<span style=color:#00f>PQresultStatus</span>(pg_result) <span style=color:#666>!=</span> PGRES_TUPLES_OK)
</span></span><span style=display:flex><span>                        {
</span></span><span style=display:flex><span>                                <span style=color:#00f>cdbdisp_clearCdbPgResults</span>(<span style=color:#666>&amp;</span>cdb_pgresults);
</span></span><span style=display:flex><span>                                <span style=color:#00f>elog</span>(ERROR, <span style=color:#ba2121>&#34;pg_resgroup_get_status(): resultStatus not tuples_Ok&#34;</span>);
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                        <span style=color:#00f>Assert</span>(<span style=color:#00f>PQntuples</span>(pg_result) <span style=color:#666>==</span> ctx<span style=color:#666>-&gt;</span>nGroups);
</span></span><span style=display:flex><span>                        <span style=color:green;font-weight:700>for</span> (j <span style=color:#666>=</span> <span style=color:#666>0</span>; j <span style=color:#666>&lt;</span> ctx<span style=color:#666>-&gt;</span>nGroups; j<span style=color:#666>++</span>)
</span></span><span style=display:flex><span>                        {
</span></span><span style=display:flex><span>                                <span style=color:green;font-weight:700>const</span> <span style=color:#b00040>char</span> <span style=color:#666>*</span>result;
</span></span><span style=display:flex><span>                                ResGroupStat <span style=color:#666>*</span>row <span style=color:#666>=</span> <span style=color:#666>&amp;</span>ctx<span style=color:#666>-&gt;</span>groups[j];
</span></span><span style=display:flex><span>                                Oid groupId <span style=color:#666>=</span> <span style=color:#00f>pg_atoi</span>(<span style=color:#00f>PQgetvalue</span>(pg_result, j, <span style=color:#666>0</span>),
</span></span><span style=display:flex><span>                                                                          <span style=color:green;font-weight:700>sizeof</span>(Oid), <span style=color:#666>0</span>);
</span></span><span style=display:flex><span>                                <span style=color:#00f>Assert</span>(groupId <span style=color:#666>==</span> row<span style=color:#666>-&gt;</span>groupId);
</span></span><span style=display:flex><span>                                <span style=color:green;font-weight:700>if</span> (row<span style=color:#666>-&gt;</span>memUsage<span style=color:#666>-&gt;</span>len <span style=color:#666>==</span> <span style=color:#666>0</span>)
</span></span><span style=display:flex><span>                                {
</span></span><span style=display:flex><span>                                        Datum d <span style=color:#666>=</span> <span style=color:#00f>ResGroupGetStat</span>(groupId, RES_GROUP_STAT_MEM_USAGE);
</span></span><span style=display:flex><span>                                        row<span style=color:#666>-&gt;</span>groupId <span style=color:#666>=</span> groupId;
</span></span><span style=display:flex><span>                                        <span style=color:#00f>appendStringInfo</span>(row<span style=color:#666>-&gt;</span>memUsage, <span style=color:#ba2121>&#34;{</span><span style=color:#b62;font-weight:700>\&#34;</span><span style=color:#ba2121>%d</span><span style=color:#b62;font-weight:700>\&#34;</span><span style=color:#ba2121>:%s&#34;</span>,
</span></span><span style=display:flex><span>                                                                         GpIdentity.segindex, <span style=color:#00f>DatumGetCString</span>(d));
</span></span><span style=display:flex><span>                                        <span style=color:#00f>appendStringInfo</span>(row<span style=color:#666>-&gt;</span>cpuUsage, <span style=color:#ba2121>&#34;{&#34;</span>);
</span></span><span style=display:flex><span>                                        <span style=color:#00f>calcCpuUsage</span>(row<span style=color:#666>-&gt;</span>cpuUsage, usages[j], timestamps[j],
</span></span><span style=display:flex><span>                                                                 <span style=color:#00f>ResGroupOps_GetCpuUsage</span>(groupId),
</span></span><span style=display:flex><span>                                                                 <span style=color:#00f>GetCurrentTimestamp</span>());
</span></span><span style=display:flex><span>                                }
</span></span><span style=display:flex><span>                                result <span style=color:#666>=</span> <span style=color:#00f>PQgetvalue</span>(pg_result, j, <span style=color:#666>1</span>);
</span></span><span style=display:flex><span>                                <span style=color:#00f>appendStringInfo</span>(row<span style=color:#666>-&gt;</span>cpuUsage, <span style=color:#ba2121>&#34;, %s&#34;</span>, result);
</span></span><span style=display:flex><span>                                result <span style=color:#666>=</span> <span style=color:#00f>PQgetvalue</span>(pg_result, j, <span style=color:#666>2</span>);
</span></span><span style=display:flex><span>                                <span style=color:#00f>appendStringInfo</span>(row<span style=color:#666>-&gt;</span>memUsage, <span style=color:#ba2121>&#34;, %s&#34;</span>, result);
</span></span><span style=display:flex><span>                                <span style=color:green;font-weight:700>if</span> (i <span style=color:#666>==</span> cdb_pgresults.numResults <span style=color:#666>-</span> <span style=color:#666>1</span>)
</span></span><span style=display:flex><span>                                {
</span></span><span style=display:flex><span>                                        <span style=color:#00f>appendStringInfoChar</span>(row<span style=color:#666>-&gt;</span>cpuUsage, <span style=color:#ba2121>&#39;}&#39;</span>);
</span></span><span style=display:flex><span>                                        <span style=color:#00f>appendStringInfoChar</span>(row<span style=color:#666>-&gt;</span>memUsage, <span style=color:#ba2121>&#39;}&#39;</span>);
</span></span><span style=display:flex><span>                                }
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#00f>cdbdisp_clearCdbPgResults</span>(<span style=color:#666>&amp;</span>cdb_pgresults);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>else</span>
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>                <span style=color:#00f>pg_usleep</span>(<span style=color:#666>300000</span>);
</span></span><span style=display:flex><span>                <span style=color:green;font-weight:700>for</span> (j <span style=color:#666>=</span> <span style=color:#666>0</span>; j <span style=color:#666>&lt;</span> ctx<span style=color:#666>-&gt;</span>nGroups; j<span style=color:#666>++</span>)
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                        ResGroupStat <span style=color:#666>*</span>row <span style=color:#666>=</span> <span style=color:#666>&amp;</span>ctx<span style=color:#666>-&gt;</span>groups[j];
</span></span><span style=display:flex><span>                        Oid groupId <span style=color:#666>=</span> <span style=color:#00f>DatumGetObjectId</span>(row<span style=color:#666>-&gt;</span>groupId);
</span></span><span style=display:flex><span>                        Datum d <span style=color:#666>=</span> <span style=color:#00f>ResGroupGetStat</span>(groupId, RES_GROUP_STAT_MEM_USAGE);
</span></span><span style=display:flex><span>                        <span style=color:#00f>appendStringInfo</span>(row<span style=color:#666>-&gt;</span>memUsage, <span style=color:#ba2121>&#34;</span><span style=color:#b62;font-weight:700>\&#34;</span><span style=color:#ba2121>%d</span><span style=color:#b62;font-weight:700>\&#34;</span><span style=color:#ba2121>:%s&#34;</span>,
</span></span><span style=display:flex><span>                                                         GpIdentity.segindex, <span style=color:#00f>DatumGetCString</span>(d));
</span></span><span style=display:flex><span>                        <span style=color:#00f>calcCpuUsage</span>(row<span style=color:#666>-&gt;</span>cpuUsage, usages[j], timestamps[j],
</span></span><span style=display:flex><span>                                                 <span style=color:#00f>ResGroupOps_GetCpuUsage</span>(groupId),
</span></span><span style=display:flex><span>                                                 <span style=color:#00f>GetCurrentTimestamp</span>());
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>结合这段代码我们看到， Master 节点（ Gp_role <code>= GP_ROLE_DISPATCH ）在接收到查询资源状态的 SQL 之后，首先会将一个 相同的状态查询 SQL （ =SELECT groupid, cpu_usage, memory_usage FROM pg_resgroup_get_status</code> ），分发给所有的
segment 节点。 Master 节点收到各个节点出来的结果之后，会进行排序汇总，然后返回最终结果。</p><p>而在各个节点真实计算的时候，对于内存消耗的计算，会返回实时统计的内存统计结果。</p><p>而对于 cpu 的计算，会在一开始先调用 ResGroupOps_GetCpuUsage 计算一次 cpu 使用量，通过读取磁盘上 cgroup 对应节点的
cpu 统计结果。然后 sleep 300000 us ，重新调用 ResGroupOps_GetCpuUsage 再计算一次 cpu 使用量，通过两次结果的差值返
回 cpu 的统计结果。</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:green;font-weight:700>static</span> <span style=color:#b00040>void</span>
</span></span><span style=display:flex><span><span style=color:#00f>calcCpuUsage</span>(StringInfoData <span style=color:#666>*</span>str,
</span></span><span style=display:flex><span>                         int64 usageBegin, TimestampTz timestampBegin,
</span></span><span style=display:flex><span>                         int64 usageEnd, TimestampTz timestampEnd)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>        int64 duration;
</span></span><span style=display:flex><span>        <span style=color:#b00040>long</span> secs;
</span></span><span style=display:flex><span>        <span style=color:#b00040>int</span> usecs;
</span></span><span style=display:flex><span>        int64 usage;
</span></span><span style=display:flex><span>        usage <span style=color:#666>=</span> usageEnd <span style=color:#666>-</span> usageBegin;
</span></span><span style=display:flex><span>        <span style=color:#00f>TimestampDifference</span>(timestampBegin, timestampEnd, <span style=color:#666>&amp;</span>secs, <span style=color:#666>&amp;</span>usecs);
</span></span><span style=display:flex><span>        duration <span style=color:#666>=</span> secs <span style=color:#666>*</span> <span style=color:#666>1000000</span> <span style=color:#666>+</span> usecs;
</span></span><span style=display:flex><span>        <span style=color:#00f>appendStringInfo</span>(str, <span style=color:#ba2121>&#34;</span><span style=color:#b62;font-weight:700>\&#34;</span><span style=color:#ba2121>%d</span><span style=color:#b62;font-weight:700>\&#34;</span><span style=color:#ba2121>:%.2f&#34;</span>,
</span></span><span style=display:flex><span>                                         GpIdentity.segindex,
</span></span><span style=display:flex><span>                                         <span style=color:#00f>ResGroupOps_ConvertCpuUsageToPercent</span>(usage, duration));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=h:e568b217-3c31-4927-9089-767c8315acf6>5 常见问题<a hidden class=anchor aria-hidden=true href=#h:e568b217-3c31-4927-9089-767c8315acf6>#</a></h2><h3 id=h:c00cc42c-b314-4054-bba3-36cde40afb7a>5.1 Resource Group 是如何利用操作系统的 cgroup 能力的？<a hidden class=anchor aria-hidden=true href=#h:c00cc42c-b314-4054-bba3-36cde40afb7a>#</a></h3><p>答：对于每个资源组，数据库会在系统的 cgroup 路径下创建一个以资源组 oid 命名的子路径，即做对应的
cgroup 挂载。创建资源组或者修改资源组配置的时候，数据库会对应修改对应子节点的 cgroup 配置。实
际执行事务时，数据库会将对应进程的 pid 写入对应的 cgroup 路径下，从而纳入 cgroup 的限制中。</p><h3 id=h:37c03467-dd66-447b-a12c-461c8efda2d5>5.2 Resource Group 是如何进行事务级别的资源限制的？<a hidden class=anchor aria-hidden=true href=#h:37c03467-dd66-447b-a12c-461c8efda2d5>#</a></h3><p>答：数据库对于每个资源组，根据并发限制，将资源划分成多个 slot 。</p><p>对于每个事务，在开启事务 (startTransaction) 的时候， QD 都会尝试获取一个 slot 。如果获取不到就会
一直等待其他事务完成执行并释放 slot 。</p><h3 id=h:6748afca-9c0f-40bc-bea4-11c1644d4fd1>5.3 Resource Group 的各种操作加不加锁，加什么锁？<a hidden class=anchor aria-hidden=true href=#h:6748afca-9c0f-40bc-bea4-11c1644d4fd1>#</a></h3><p>资源组的创建和修改都会加 ResGroupLock 类型的 exclusive lock ，而 backend 获取 slot 来执行事务的时候也会获取
ResGroupLock 的 exclusive lock ，所以资源组相关的变更，会与对应资源组内的事务执行相互阻塞。另外， Resource Group
配置修改的时候，还会对相关系统表加 AccessExclusiveLock 。</p><h3 id=h:b4a09810-858a-4dc0-b9a6-e3b6287399d0>5.4 数据库基于 cgroup 对资源组进行限制，如果某个数据库节点故障，跨机迁移到其他节点，而 cgroup 的配置和路径结构无法迁移，会不会导致对应机器上的 resource group 功能失效？<a hidden class=anchor aria-hidden=true href=#h:b4a09810-858a-4dc0-b9a6-e3b6287399d0>#</a></h3><p>答：不会。在数据库节点初始化的时候 (initPostgres) ，会进行资源组的检测，如果系统表中的资源组
配置在 cgroup 路径中不存在，会重新创建对应的 cgroup 挂载。</p><p>同理，如果你配置好了 ResourceGroup 之后，直接把你机器上的对应 oid 的 cgroup 子路径删掉，重启下数
据库就会恢复正常的状态。</p><h3 id=h:56086067-6fa2-4b51-8470-01255694316b>5.5 为什么资源组的 CPU 使用率高于配置的 CPU_RATE_LIMIT ？<a hidden class=anchor aria-hidden=true href=#h:56086067-6fa2-4b51-8470-01255694316b>#</a></h3><p>答：资源组可能存在 CPU 抢占的情况：当其他资源组空闲时，忙碌的资源组可以使用比其
CPU_RATE_LIMIT 更多的 CPU 。在这种情况下，数据库将空闲资源组的 CPU 资源分配给更繁忙的资源组。</p><h3 id=h:c21e8b97-177d-4ea2-bbc4-4a2ec11f70b6>5.6 Resource Group 在部署上有什么要求？<a hidden class=anchor aria-hidden=true href=#h:c21e8b97-177d-4ea2-bbc4-4a2ec11f70b6>#</a></h3><p>答：</p><ol><li>安装并开启 cgroup ；</li><li>cgroup 做好初始化挂载，初始化配置举例：</li></ol><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>group gpdb {
</span></span><span style=display:flex><span>     perm {
</span></span><span style=display:flex><span>         task {
</span></span><span style=display:flex><span>             uid = gpadmin;
</span></span><span style=display:flex><span>             gid = gpadmin;
</span></span><span style=display:flex><span>         }
</span></span><span style=display:flex><span>         admin {
</span></span><span style=display:flex><span>             uid = gpadmin;
</span></span><span style=display:flex><span>             gid = gpadmin;
</span></span><span style=display:flex><span>         }
</span></span><span style=display:flex><span>     }
</span></span><span style=display:flex><span>     cpu {
</span></span><span style=display:flex><span>     }
</span></span><span style=display:flex><span>     cpuacct {
</span></span><span style=display:flex><span>     }
</span></span><span style=display:flex><span>     cpuset {
</span></span><span style=display:flex><span>     }
</span></span><span style=display:flex><span>     memory {
</span></span><span style=display:flex><span>     }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>实际使用时要根据自身情况（系统用户名）修改配置；</p><ol><li>cpu 和 cpuset 对应的路径必须分开挂载。</li></ol><h2 id=h:eec633c6-3777-4c48-bb09-3dc52d9653ff>6 总结<a hidden class=anchor aria-hidden=true href=#h:eec633c6-3777-4c48-bb09-3dc52d9653ff>#</a></h2><p>资源管理对于数据库集群的多租户管理、资源细粒度分配具有很重要的价值。 Resource Group 巧妙地基
于操作系统的 cgroup 隔离能力和 PostgreSQL 本身的基于 MemoryContext 的内存管理能力，以很少的代码量
实现了完备的资源管理功能。在 GP5 之后， Resource Group 主键替代 Resource Queue 成为主流的资源管理
方式， Greenplum 社区也把 Resource Group 当做主要去维护和优化的资源管理方式。</p><p>对 Greenplum 内存管理感兴趣的话，可以参考一下文章：基于 MemoryContext 的内存管理</p><p>对另外一种资源管理方式感兴趣的话，可以参考下文章： Greenplum 资源管理—— Resource Queue 使用和实现分析</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://yangyingchao.github.io/tags/gpdb/>gpdb</a></li><li><a href=https://yangyingchao.github.io/tags/resource/>resource</a></li><li><a href=https://yangyingchao.github.io/tags/group/>group</a></li></ul></footer><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//disqus_yH1vi2Slvj.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://yangyingchao.github.io>MyNotes</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>