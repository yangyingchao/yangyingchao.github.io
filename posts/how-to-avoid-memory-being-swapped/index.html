<!doctype html><html lang=zh-cn dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>how to avoid memory being swapped (locking memory pages) | MyNotes</title><meta name=keywords content="memory,mlock,swap,lock"><meta name=description content="1 mlockall() 2 how to do this after program started and program does not call mlockall() ? 本文为摘录，原文为： https://stackoverflow.com/questions/12520499/linux-how-to-lock-the-pages-of-a-process-in-memory 1 mlockall() from manpage: mlockall() and munlockall() mlockall() locks all pages mapped into the address space of the calling process. This in‐ cludes the pages of the code, data, and stack segment, as well as shared libraries, user space kernel"><meta name=author content="Yang, Ying-chao"><link rel=canonical href=https://yangyingchao.github.io/posts/how-to-avoid-memory-being-swapped/><link crossorigin=anonymous href=/assets/css/stylesheet.6a98292fb8fa8cf0f3ba4042d4b75515c04267550f3ad49ff6271b5af9562443.css integrity="sha256-apgpL7j6jPDzukBC1LdVFcBCZ1UPOtSf9icbWvlWJEM=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://yangyingchao.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://yangyingchao.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://yangyingchao.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://yangyingchao.github.io/apple-touch-icon.png><link rel=mask-icon href=https://yangyingchao.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="how to avoid memory being swapped (locking memory pages)"><meta property="og:description" content="1 mlockall() 2 how to do this after program started and program does not call mlockall() ? 本文为摘录，原文为： https://stackoverflow.com/questions/12520499/linux-how-to-lock-the-pages-of-a-process-in-memory 1 mlockall() from manpage: mlockall() and munlockall() mlockall() locks all pages mapped into the address space of the calling process. This in‐ cludes the pages of the code, data, and stack segment, as well as shared libraries, user space kernel"><meta property="og:type" content="article"><meta property="og:url" content="https://yangyingchao.github.io/posts/how-to-avoid-memory-being-swapped/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-12-16T00:00:00+00:00"><meta property="article:modified_time" content="2023-12-16T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="how to avoid memory being swapped (locking memory pages)"><meta name=twitter:description content="1 mlockall() 2 how to do this after program started and program does not call mlockall() ? 本文为摘录，原文为： https://stackoverflow.com/questions/12520499/linux-how-to-lock-the-pages-of-a-process-in-memory 1 mlockall() from manpage: mlockall() and munlockall() mlockall() locks all pages mapped into the address space of the calling process. This in‐ cludes the pages of the code, data, and stack segment, as well as shared libraries, user space kernel"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://yangyingchao.github.io/posts/"},{"@type":"ListItem","position":3,"name":"how to avoid memory being swapped (locking memory pages)","item":"https://yangyingchao.github.io/posts/how-to-avoid-memory-being-swapped/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"how to avoid memory being swapped (locking memory pages)","name":"how to avoid memory being swapped (locking memory pages)","description":"1 mlockall() 2 how to do this after program started and program does not call mlockall() ? 本文为摘录，原文为： https://stackoverflow.com/questions/12520499/linux-how-to-lock-the-pages-of-a-process-in-memory 1 mlockall() from manpage: mlockall() and munlockall() mlockall() locks all pages mapped into the address space of the calling process. This in‐ cludes the pages of the code, data, and stack segment, as well as shared libraries, user space kernel","keywords":["memory","mlock","swap","lock"],"articleBody":" 1 mlockall() 2 how to do this after program started and program does not call mlockall() ? 本文为摘录，原文为： https://stackoverflow.com/questions/12520499/linux-how-to-lock-the-pages-of-a-process-in-memory\n1 mlockall() from manpage:\nmlockall() and munlockall() mlockall() locks all pages mapped into the address space of the calling process. This in‐ cludes the pages of the code, data, and stack segment, as well as shared libraries, user space kernel data, shared memory, and memory-mapped files. All mapped pages are guaranteed to be resident in RAM when the call returns successfully; the pages are guaranteed to stay in RAM until later unlocked. The flags argument is constructed as the bitwise OR of one or more of the following constants: MCL_CURRENT Lock all pages which are currently mapped into the address space of the process. MCL_FUTURE Lock all pages which will become mapped into the address space of the process in the future. These could be, for instance, new pages required by a growing heap and stack as well as new memory-mapped files or shared memory regions. MCL_ONFAULT (since Linux 4.4) Used together with MCL_CURRENT, MCL_FUTURE, or both. Mark all current (with MCL_CUR‐ RENT) or future (with MCL_FUTURE) mappings to lock pages when they are faulted in. When used with MCL_CURRENT, all present pages are locked, but mlockall() will not fault in non-present pages. When used with MCL_FUTURE, all future mappings will be marked to lock pages when they are faulted in, but they will not be populated by the lock when the mapping is created. MCL_ONFAULT must be used with either MCL_CURRENT or MCL_FUTURE or both. If MCL_FUTURE has been specified, then a later system call (e.g., mmap(2), sbrk(2), mal‐ loc(3)), may fail if it would cause the number of locked bytes to exceed the permitted maximum (see below). In the same circumstances, stack growth may likewise fail: the kernel will deny stack expansion and deliver a SIGSEGV signal to the process. munlockall() unlocks all pages mapped into the address space of the calling process. 2 how to do this after program started and program does not call mlockall() ? Make a GDB command file that contains something like this:\ncall mlockall(3) detach Then on the command line, find the PID of the process you want to mlock. Type:\ngdb --pid [PID] --batch -x [command file] If you get fancy with pgrep that could be:\ngdb --pid $(pgrep sshd) --batch -x [command file] ","wordCount":"413","inLanguage":"zh-cn","datePublished":"2023-12-16T00:00:00Z","dateModified":"2023-12-16T00:00:00Z","author":[{"@type":"Person","name":"Yang"},{"@type":"Person","name":"Ying-chao"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://yangyingchao.github.io/posts/how-to-avoid-memory-being-swapped/"},"publisher":{"@type":"Organization","name":"MyNotes","logo":{"@type":"ImageObject","url":"https://yangyingchao.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://yangyingchao.github.io accesskey=h title="MyNotes (Alt + H)">MyNotes</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://yangyingchao.github.io/ title=Home><span>Home</span></a></li><li><a href=https://yangyingchao.github.io/posts/ title=Archives><span>Archives</span></a></li><li><a href=https://yangyingchao.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://yangyingchao.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://yangyingchao.github.io/contact/ title="Contact me"><span>Contact me</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>how to avoid memory being swapped (locking memory pages)</h1><div class=post-meta><span title='2023-12-16 00:00:00 +0000 UTC'>December 16, 2023</span>&nbsp;·&nbsp;Yang, Ying-chao</div></header><div class=post-content><ul><li>1 <a href=#h:a69e195a-92fb-405b-9b6c-ec86c0015e47>mlockall()</a></li><li>2 <a href=#h:694a46e8-f346-48c2-a21e-a71751c8643d>how to do this after program started and program does not call <code>mlockall()</code> ?</a></li></ul><p>本文为摘录，原文为： <a href=https://stackoverflow.com/questions/12520499/linux-how-to-lock-the-pages-of-a-process-in-memory>https://stackoverflow.com/questions/12520499/linux-how-to-lock-the-pages-of-a-process-in-memory</a></p><h2 id=h:a69e195a-92fb-405b-9b6c-ec86c0015e47>1 mlockall()<a hidden class=anchor aria-hidden=true href=#h:a69e195a-92fb-405b-9b6c-ec86c0015e47>#</a></h2><p>from manpage:</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>
</span></span><span style=display:flex><span>mlockall() and munlockall()
</span></span><span style=display:flex><span>    mlockall() locks all pages mapped into the address space of the  calling  process.   This  in‐
</span></span><span style=display:flex><span>    cludes the pages of the code, data, and stack segment, as well as shared libraries, user space
</span></span><span style=display:flex><span>    kernel data, shared memory, and memory-mapped files.  All mapped pages are  guaranteed  to  be
</span></span><span style=display:flex><span>    resident  in  RAM  when the call returns successfully; the pages are guaranteed to stay in RAM
</span></span><span style=display:flex><span>    until later unlocked.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    The flags argument is constructed as the bitwise OR of one or more of the following constants:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    MCL_CURRENT
</span></span><span style=display:flex><span>           Lock all pages which are currently mapped into the address space of the process.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    MCL_FUTURE
</span></span><span style=display:flex><span>           Lock all pages which will become mapped into the address space of the  process  in  the
</span></span><span style=display:flex><span>           future.   These  could be, for instance, new pages required by a growing heap and stack
</span></span><span style=display:flex><span>           as well as new memory-mapped files or shared memory regions.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    MCL_ONFAULT (since Linux 4.4)
</span></span><span style=display:flex><span>           Used together with MCL_CURRENT, MCL_FUTURE, or both.  Mark all current  (with  MCL_CUR‐
</span></span><span style=display:flex><span>           RENT)  or  future  (with  MCL_FUTURE)  mappings to lock pages when they are faulted in.
</span></span><span style=display:flex><span>           When used with MCL_CURRENT, all present pages are locked, but mlockall() will not fault
</span></span><span style=display:flex><span>           in non-present pages.  When used with MCL_FUTURE, all future mappings will be marked to
</span></span><span style=display:flex><span>           lock pages when they are faulted in, but they will not be populated by  the  lock  when
</span></span><span style=display:flex><span>           the mapping is created.  MCL_ONFAULT must be used with either MCL_CURRENT or MCL_FUTURE
</span></span><span style=display:flex><span>           or both.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    If MCL_FUTURE has been specified, then a later  system  call  (e.g.,  mmap(2),  sbrk(2),  mal‐
</span></span><span style=display:flex><span>    loc(3)), may fail if it would cause the number of locked bytes to exceed the permitted maximum
</span></span><span style=display:flex><span>    (see below).  In the same circumstances, stack growth may likewise fail: the kernel will  deny
</span></span><span style=display:flex><span>    stack expansion and deliver a SIGSEGV signal to the process.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>munlockall() unlocks all pages mapped into the address space of the calling process.
</span></span></code></pre></div><h2 id=h:694a46e8-f346-48c2-a21e-a71751c8643d>2 how to do this after program started and program does not call <code>mlockall()</code> ?<a hidden class=anchor aria-hidden=true href=#h:694a46e8-f346-48c2-a21e-a71751c8643d>#</a></h2><p>Make a GDB command file that contains something like this:</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>call mlockall<span style=color:#666>(</span>3<span style=color:#666>)</span>
</span></span><span style=display:flex><span>detach
</span></span></code></pre></div><p>Then on the command line, find the PID of the process you want to mlock. Type:</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>gdb --pid <span style=color:#666>[</span>PID<span style=color:#666>]</span> --batch -x <span style=color:#666>[</span><span style=color:green>command</span> file<span style=color:#666>]</span>
</span></span></code></pre></div><p>If you get fancy with <code>pgrep</code> that could be:</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>gdb --pid <span style=color:green;font-weight:700>$(</span>pgrep sshd<span style=color:green;font-weight:700>)</span> --batch -x <span style=color:#666>[</span><span style=color:green>command</span> file<span style=color:#666>]</span>
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://yangyingchao.github.io/tags/memory/>memory</a></li><li><a href=https://yangyingchao.github.io/tags/mlock/>mlock</a></li><li><a href=https://yangyingchao.github.io/tags/swap/>swap</a></li><li><a href=https://yangyingchao.github.io/tags/lock/>lock</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://yangyingchao.github.io>MyNotes</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>