<!doctype html><html lang=zh-cn dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>how to avoid memory being swapped (locking memory pages) | MyNotes</title><meta name=keywords content="memory,mlock,swap,lock,mlockall"><meta name=description content="1 mlockall() 2 how to do this after program started and program does not call mlockall() ? 3 内核实现 3.1 mlockall() 3.2 内存区域标记 4 Swap 4.1 Swap info 4.2 Locks 4.3 fork 时候复制 swap… 4.4 进程退出时候清理 swap 。。。 5 RLIMIT_MEMLOCK 本文为摘录，"><meta name=author content="Yang, Ying-chao"><link rel=canonical href=https://yangyingchao.github.io/posts/how-to-avoid-memory-being-swapped/><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://yangyingchao.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://yangyingchao.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://yangyingchao.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://yangyingchao.github.io/apple-touch-icon.png><link rel=mask-icon href=https://yangyingchao.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="how to avoid memory being swapped (locking memory pages)"><meta property="og:description" content="1 mlockall() 2 how to do this after program started and program does not call mlockall() ? 3 内核实现 3.1 mlockall() 3.2 内存区域标记 4 Swap 4.1 Swap info 4.2 Locks 4.3 fork 时候复制 swap… 4.4 进程退出时候清理 swap 。。。 5 RLIMIT_MEMLOCK 本文为摘录，"><meta property="og:type" content="article"><meta property="og:url" content="https://yangyingchao.github.io/posts/how-to-avoid-memory-being-swapped/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-12-16T00:00:00+00:00"><meta property="article:modified_time" content="2023-12-16T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="how to avoid memory being swapped (locking memory pages)"><meta name=twitter:description content="1 mlockall() 2 how to do this after program started and program does not call mlockall() ? 3 内核实现 3.1 mlockall() 3.2 内存区域标记 4 Swap 4.1 Swap info 4.2 Locks 4.3 fork 时候复制 swap… 4.4 进程退出时候清理 swap 。。。 5 RLIMIT_MEMLOCK 本文为摘录，"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://yangyingchao.github.io/posts/"},{"@type":"ListItem","position":2,"name":"how to avoid memory being swapped (locking memory pages)","item":"https://yangyingchao.github.io/posts/how-to-avoid-memory-being-swapped/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"how to avoid memory being swapped (locking memory pages)","name":"how to avoid memory being swapped (locking memory pages)","description":"1 mlockall() 2 how to do this after program started and program does not call mlockall() ? 3 内核实现 3.1 mlockall() 3.2 内存区域标记 4 Swap 4.1 Swap info 4.2 Locks 4.3 fork 时候复制 swap… 4.4 进程退出时候清理 swap 。。。 5 RLIMIT_MEMLOCK 本文为摘录，","keywords":["memory","mlock","swap","lock","mlockall"],"articleBody":" 1 mlockall() 2 how to do this after program started and program does not call mlockall() ? 3 内核实现 3.1 mlockall() 3.2 内存区域标记 4 Swap 4.1 Swap info 4.2 Locks 4.3 fork 时候复制 swap… 4.4 进程退出时候清理 swap 。。。 5 RLIMIT_MEMLOCK 本文为摘录，原文为： https://stackoverflow.com/questions/12520499/linux-how-to-lock-the-pages-of-a-process-in-memory\n1 mlockall() from manpage:\nmlockall() and munlockall() mlockall() locks all pages mapped into the address space of the calling process. This in‐ cludes the pages of the code, data, and stack segment, as well as shared libraries, user space kernel data, shared memory, and memory-mapped files. All mapped pages are guaranteed to be resident in RAM when the call returns successfully; the pages are guaranteed to stay in RAM until later unlocked. The flags argument is constructed as the bitwise OR of one or more of the following constants: MCL_CURRENT Lock all pages which are currently mapped into the address space of the process. MCL_FUTURE Lock all pages which will become mapped into the address space of the process in the future. These could be, for instance, new pages required by a growing heap and stack as well as new memory-mapped files or shared memory regions. MCL_ONFAULT (since Linux 4.4) Used together with MCL_CURRENT, MCL_FUTURE, or both. Mark all current (with MCL_CUR‐ RENT) or future (with MCL_FUTURE) mappings to lock pages when they are faulted in. When used with MCL_CURRENT, all present pages are locked, but mlockall() will not fault in non-present pages. When used with MCL_FUTURE, all future mappings will be marked to lock pages when they are faulted in, but they will not be populated by the lock when the mapping is created. MCL_ONFAULT must be used with either MCL_CURRENT or MCL_FUTURE or both. If MCL_FUTURE has been specified, then a later system call (e.g., mmap(2), sbrk(2), mal‐ loc(3)), may fail if it would cause the number of locked bytes to exceed the permitted maximum (see below). In the same circumstances, stack growth may likewise fail: the kernel will deny stack expansion and deliver a SIGSEGV signal to the process. munlockall() unlocks all pages mapped into the address space of the calling process. 2 how to do this after program started and program does not call mlockall() ? Make a GDB command file that contains something like this:\ncall mlockall(3) detach Then on the command line, find the PID of the process you want to mlock. Type:\ngdb --pid [PID] --batch -x [command file] If you get fancy with pgrep that could be:\ngdb --pid $(pgrep sshd) --batch -x [command file] 3 内核实现 3.1 mlockall() SYSCALL_DEFINE1(mlockall, int, flags) { unsigned long lock_limit; int ret; if (!flags || (flags \u0026 ~(MCL_CURRENT | MCL_FUTURE | MCL_ONFAULT)) || flags == MCL_ONFAULT) return -EINVAL; if (!can_do_mlock()) return -EPERM; lock_limit = rlimit(RLIMIT_MEMLOCK); lock_limit \u003e\u003e= PAGE_SHIFT; if (mmap_write_lock_killable(current-\u003emm)) return -EINTR; ret = -ENOMEM; if (!(flags \u0026 MCL_CURRENT) || (current-\u003emm-\u003etotal_vm \u003c= lock_limit) || capable(CAP_IPC_LOCK)) ret = apply_mlockall_flags(flags); mmap_write_unlock(current-\u003emm); if (!ret \u0026\u0026 (flags \u0026 MCL_CURRENT)) mm_populate(0, TASK_SIZE); return ret; } 3.1.1 EPERM 的情况 当可执行程序拥有 CAP_IPC_LOCK 时候，可以有权限执行 mlock, 否则的话，下列情况会返回 EPERM:\nRLIMIT_MEMLOCK 为 0 时候： bool can_do_mlock(void) { if (rlimit(RLIMIT_MEMLOCK) != 0) return true; if (capable(CAP_IPC_LOCK)) return true; return false; } MCL_CURRENT 被设置，并且当前进程已使用的内存超过了 RLIMIT_MEMLOCK . 3.2 内存区域标记 4 Swap 4.1 Swap info class swap_info_struct { + unsigned flags + short prio + struct list + struct avail_lists + signed type + unsigned max + unsigned swap_map + struct cluster_info + struct free_clusters + unsigned lowest_bit + unsigned highest_bit + unsigned pages + unsigned inuse_pages + unsigned cluster_next + unsigned cluster_nr + struct percpu_cluster + struct curr_swap_extent + struct first_swap_extent + struct bdev + struct swap_file + unsigned old_block_size + spinlock_t lock + spinlock_t cont_lock + struct discard_work + struct discard_clusters } class swap_cluster_info { + spinlock_t lock + unsigned data + unsigned flags } swap_info_struct *-- swap_cluster_info class swap_cluster_list { + struct head + struct tail } swap_info_struct *-- swap_cluster_list class swap_extent { + struct list + unsigned start_page + unsigned nr_pages + sector_t start_block } swap_info_struct *-- swap_extent note left of swap_extent 一个交换区范围 (swap extent range) 将交换文件的 PAGE_SIZE 大小的页的范围映射到磁盘块的范围上。 交换区范围列表映射整个交换文件。 end note class block_device { + dev_t bd_dev + int bd_openers + struct bd_inode + struct bd_super + struct bd_mutex + void bd_claiming + void bd_holder + int bd_holders + bool bd_write_holder + struct bd_holder_disks + struct bd_contains + unsigned bd_block_size + u8 bd_partno + struct bd_part + unsigned bd_part_count + int bd_invalidated + struct bd_disk + struct bd_queue + struct bd_bdi + struct bd_list + unsigned bd_private + int bd_fsfreeze_count + struct bd_fsfreeze_mutex } swap_info_struct *-- block_device class file { + union f_u + struct f_path + struct f_inode + const f_op + spinlock_t f_lock + enum f_write_hint + atomic_long_t f_count + unsigned f_flags + fmode_t f_mode + struct f_pos_lock + loff_t f_pos + struct f_owner + const f_cred + struct f_ra + u64 f_version + void f_security + void private_data + struct f_ep_links + struct f_tfile_llink + struct f_mapping + errseq_t f_wb_err } swap_info_struct *-- file class address_space { + struct host + struct i_pages + atomic_t i_mmap_writable + struct i_mmap + struct i_mmap_rwsem + unsigned nrpages + unsigned nrexceptional + unsigned writeback_index + const a_ops + unsigned flags + spinlock_t private_lock + gfp_t gfp_mask + struct private_list + void private_data + errseq_t wb_err } file *-- address_space class inode { + umode_t i_mode + unsigned i_opflags + kuid_t i_uid + kgid_t i_gid + unsigned i_flags + struct i_acl + struct i_default_acl + const i_op + struct i_sb + struct i_mapping + void i_security + unsigned i_ino + dev_t i_rdev + loff_t i_size + struct i_atime + void i_private } address_space *-- inode /* * MAX_SWAPFILES defines the maximum number of swaptypes: things which can * be swapped to. The swap type and the offset into that swap type are * encoded into pte's and into pgoff_t's in the swapcache. Using five bits * for the type means that the maximum number of swapcache pages is 27 bits * on 32-bit-pgoff_t architectures. And that assumes that the architecture packs * the type/offset into the pte as 5/27 as well. */ /* * MAX_SWAPFILES 定义了最大的swaptypes数量：可以被交换到的东西。交换类型和交换类型中的偏移量都被编码到 * pte和swapcache中的pgoff_t中。对于类型使用五位意味着在32位pgoff_t架构上，swapcache页面的最大数量为27 * 位。并且这假设架构也将类型/偏移量打包到pte中，比例为5/27。 */ #define MAX_SWAPFILES \\ ((1 \u003c\u003c MAX_SWAPFILES_SHIFT) - SWP_DEVICE_NUM - \\ SWP_MIGRATION_NUM - SWP_HWPOISON_NUM) struct swap_info_struct *swap_info[MAX_SWAPFILES]; 最多 MAX_SWAPFILES 个 swap 设备。\n4.2 Locks 4.2.1 全局锁 DEFINE_SPINLOCK(swap_lock); 4.2.2 粗粒度锁 4.2.3 细粒度锁 4.3 fork 时候复制 swap… 14.74% 0.00% xxxxsql [kernel.kallsyms] [k] entry_SYSCALL_64_after_hwframe | ---entry_SYSCALL_64_after_hwframe do_syscall_64 | |--7.61%--__x64_sys_exit_group | do_group_exit | | | --7.61%--do_exit | | | --7.46%--mmput | | | --7.45%--exit_mmap | | | --6.37%--unmap_vmas | | | --6.33%--unmap_page_range | | | |--0.98%--free_swap_and_cache | | | --0.76%--tlb_flush_mmu | |--3.40%--_do_fork | | | --3.38%--copy_process | | | --3.15%--dup_mm | | | --2.42%--copy_page_range | | | --2.35%--copy_pte_range.isra.97 | | | --0.98%--swap_duplicate | | | --0.83%--__swap_duplicate 4.3.1 swap_duplicate 将 swap entry 的引用计数增加 1。 返回 0 : 表示成功 返回 -ENOMEM 如果需要 swap_count_continuation 但无法原子地分配， 如果 __swap_duplicate() 因其他原因失败（ -EINVAL 或 -ENOENT ），如页表条目损坏，则返回 0，就像它成功一样。 /* * Increase reference count of swap entry by 1. * Returns 0 for success, or -ENOMEM if a swap_count_continuation is required * but could not be atomically allocated. Returns 0, just as if it succeeded, * if __swap_duplicate() fails for another reason (-EINVAL or -ENOENT), which * might occur if a page table entry has got corrupted. */ int swap_duplicate(swp_entry_t entry) { int err = 0; while (!err \u0026\u0026 __swap_duplicate(entry, 1) == -ENOMEM) err = add_swap_count_continuation(entry, GFP_ATOMIC); return err; } 4.4 进程退出时候清理 swap 。。。 5 RLIMIT_MEMLOCK ","wordCount":"1588","inLanguage":"zh-cn","datePublished":"2023-12-16T00:00:00Z","dateModified":"2023-12-16T00:00:00Z","author":[{"@type":"Person","name":"Yang"},{"@type":"Person","name":"Ying-chao"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://yangyingchao.github.io/posts/how-to-avoid-memory-being-swapped/"},"publisher":{"@type":"Organization","name":"MyNotes","logo":{"@type":"ImageObject","url":"https://yangyingchao.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://yangyingchao.github.io accesskey=h title="MyNotes (Alt + H)">MyNotes</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://yangyingchao.github.io/ title=Home><span>Home</span></a></li><li><a href=https://yangyingchao.github.io/posts/ title=Archives><span>Archives</span></a></li><li><a href=https://yangyingchao.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://yangyingchao.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://yangyingchao.github.io/contact/ title="Contact me"><span>Contact me</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">how to avoid memory being swapped (locking memory pages)</h1><div class=post-meta><span title='2023-12-16 00:00:00 +0000 UTC'>December 16, 2023</span>&nbsp;·&nbsp;Yang, Ying-chao</div></header><div class=post-content><ul><li>1 <a href=#h:a69e195a-92fb-405b-9b6c-ec86c0015e47>mlockall()</a></li><li>2 <a href=#h:694a46e8-f346-48c2-a21e-a71751c8643d>how to do this after program started and program does not call <code>mlockall()</code> ?</a></li><li>3 <a href=#h:a99f5c47-b061-4e47-a7f0-51dcf4e3b852>内核实现</a><ul><li>3.1 <a href=#h:6ff510c5-4a77-4766-b6ec-49b25660504a>mlockall()</a></li><li>3.2 <a href=#h:75a484c0-9716-44e8-8811-9041f9878f19>内存区域标记</a></li></ul></li><li>4 <a href=#h:7ad9b325-1adc-4075-ac3b-3e92208ae6a6>Swap</a><ul><li>4.1 <a href=#h:ddbd6d4f-ac07-456e-a148-dcdeac5f975d>Swap info</a></li><li>4.2 <a href=#h:1fe99bb1-aeb0-4a49-9efe-56e123310ee6>Locks</a></li><li>4.3 <a href=#h:36e44df6-8e26-4bd4-bfc8-80df31b3614b>fork 时候复制 swap…</a></li><li>4.4 <a href=#h:cb155170-b5a3-421f-9f98-090780fbf82a>进程退出时候清理 swap 。。。</a></li></ul></li><li>5 <a href=#h:e5964c54-29f4-42fa-af12-10ca1093f20b>RLIMIT_MEMLOCK</a></li></ul><p>本文为摘录，原文为： <a href=https://stackoverflow.com/questions/12520499/linux-how-to-lock-the-pages-of-a-process-in-memory>https://stackoverflow.com/questions/12520499/linux-how-to-lock-the-pages-of-a-process-in-memory</a></p><h2 id=h:a69e195a-92fb-405b-9b6c-ec86c0015e47>1 mlockall()<a hidden class=anchor aria-hidden=true href=#h:a69e195a-92fb-405b-9b6c-ec86c0015e47>#</a></h2><p>from manpage:</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>
</span></span><span style=display:flex><span>mlockall() and munlockall()
</span></span><span style=display:flex><span>    mlockall() locks all pages mapped into the address space of the  calling  process.   This  in‐
</span></span><span style=display:flex><span>    cludes the pages of the code, data, and stack segment, as well as shared libraries, user space
</span></span><span style=display:flex><span>    kernel data, shared memory, and memory-mapped files.  All mapped pages are  guaranteed  to  be
</span></span><span style=display:flex><span>    resident  in  RAM  when the call returns successfully; the pages are guaranteed to stay in RAM
</span></span><span style=display:flex><span>    until later unlocked.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    The flags argument is constructed as the bitwise OR of one or more of the following constants:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    MCL_CURRENT
</span></span><span style=display:flex><span>           Lock all pages which are currently mapped into the address space of the process.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    MCL_FUTURE
</span></span><span style=display:flex><span>           Lock all pages which will become mapped into the address space of the  process  in  the
</span></span><span style=display:flex><span>           future.   These  could be, for instance, new pages required by a growing heap and stack
</span></span><span style=display:flex><span>           as well as new memory-mapped files or shared memory regions.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    MCL_ONFAULT (since Linux 4.4)
</span></span><span style=display:flex><span>           Used together with MCL_CURRENT, MCL_FUTURE, or both.  Mark all current  (with  MCL_CUR‐
</span></span><span style=display:flex><span>           RENT)  or  future  (with  MCL_FUTURE)  mappings to lock pages when they are faulted in.
</span></span><span style=display:flex><span>           When used with MCL_CURRENT, all present pages are locked, but mlockall() will not fault
</span></span><span style=display:flex><span>           in non-present pages.  When used with MCL_FUTURE, all future mappings will be marked to
</span></span><span style=display:flex><span>           lock pages when they are faulted in, but they will not be populated by  the  lock  when
</span></span><span style=display:flex><span>           the mapping is created.  MCL_ONFAULT must be used with either MCL_CURRENT or MCL_FUTURE
</span></span><span style=display:flex><span>           or both.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    If MCL_FUTURE has been specified, then a later  system  call  (e.g.,  mmap(2),  sbrk(2),  mal‐
</span></span><span style=display:flex><span>    loc(3)), may fail if it would cause the number of locked bytes to exceed the permitted maximum
</span></span><span style=display:flex><span>    (see below).  In the same circumstances, stack growth may likewise fail: the kernel will  deny
</span></span><span style=display:flex><span>    stack expansion and deliver a SIGSEGV signal to the process.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>munlockall() unlocks all pages mapped into the address space of the calling process.
</span></span></code></pre></div><h2 id=h:694a46e8-f346-48c2-a21e-a71751c8643d>2 how to do this after program started and program does not call <code>mlockall()</code> ?<a hidden class=anchor aria-hidden=true href=#h:694a46e8-f346-48c2-a21e-a71751c8643d>#</a></h2><p>Make a GDB command file that contains something like this:</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>call mlockall<span style=color:#666>(</span>3<span style=color:#666>)</span>
</span></span><span style=display:flex><span>detach
</span></span></code></pre></div><p>Then on the command line, find the PID of the process you want to mlock. Type:</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>gdb --pid <span style=color:#666>[</span>PID<span style=color:#666>]</span> --batch -x <span style=color:#666>[</span><span style=color:green>command</span> file<span style=color:#666>]</span>
</span></span></code></pre></div><p>If you get fancy with <code>pgrep</code> that could be:</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>gdb --pid <span style=color:green;font-weight:700>$(</span>pgrep sshd<span style=color:green;font-weight:700>)</span> --batch -x <span style=color:#666>[</span><span style=color:green>command</span> file<span style=color:#666>]</span>
</span></span></code></pre></div><h2 id=h:a99f5c47-b061-4e47-a7f0-51dcf4e3b852>3 内核实现<a hidden class=anchor aria-hidden=true href=#h:a99f5c47-b061-4e47-a7f0-51dcf4e3b852>#</a></h2><h3 id=h:6ff510c5-4a77-4766-b6ec-49b25660504a>3.1 mlockall()<a hidden class=anchor aria-hidden=true href=#h:6ff510c5-4a77-4766-b6ec-49b25660504a>#</a></h3><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#00f>SYSCALL_DEFINE1</span>(mlockall, <span style=color:#b00040>int</span>, flags)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#b00040>unsigned</span> <span style=color:#b00040>long</span> lock_limit;
</span></span><span style=display:flex><span>    <span style=color:#b00040>int</span> ret;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>if</span> (<span style=color:#666>!</span>flags <span style=color:#666>||</span> (flags <span style=color:#666>&amp;</span> <span style=color:#666>~</span>(MCL_CURRENT <span style=color:#666>|</span> MCL_FUTURE <span style=color:#666>|</span> MCL_ONFAULT)) <span style=color:#666>||</span>
</span></span><span style=display:flex><span>        flags <span style=color:#666>==</span> MCL_ONFAULT)
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>return</span> <span style=color:#666>-</span>EINVAL;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>if</span> (<span style=color:#666>!</span><span style=color:#00f>can_do_mlock</span>())
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>return</span> <span style=color:#666>-</span>EPERM;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    lock_limit <span style=color:#666>=</span> <span style=color:#00f>rlimit</span>(RLIMIT_MEMLOCK);
</span></span><span style=display:flex><span>    lock_limit <span style=color:#666>&gt;&gt;=</span> PAGE_SHIFT;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>if</span> (<span style=color:#00f>mmap_write_lock_killable</span>(current<span style=color:#666>-&gt;</span>mm))
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>return</span> <span style=color:#666>-</span>EINTR;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    ret <span style=color:#666>=</span> <span style=color:#666>-</span>ENOMEM;
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>if</span> (<span style=color:#666>!</span>(flags <span style=color:#666>&amp;</span> MCL_CURRENT) <span style=color:#666>||</span> (current<span style=color:#666>-&gt;</span>mm<span style=color:#666>-&gt;</span>total_vm <span style=color:#666>&lt;=</span> lock_limit) <span style=color:#666>||</span>
</span></span><span style=display:flex><span>        <span style=color:#00f>capable</span>(CAP_IPC_LOCK))
</span></span><span style=display:flex><span>        ret <span style=color:#666>=</span> <span style=color:#00f>apply_mlockall_flags</span>(flags);
</span></span><span style=display:flex><span>    <span style=color:#00f>mmap_write_unlock</span>(current<span style=color:#666>-&gt;</span>mm);
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>if</span> (<span style=color:#666>!</span>ret <span style=color:#666>&amp;&amp;</span> (flags <span style=color:#666>&amp;</span> MCL_CURRENT))
</span></span><span style=display:flex><span>        <span style=color:#00f>mm_populate</span>(<span style=color:#666>0</span>, TASK_SIZE);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>return</span> ret;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=h:d9c66345-c146-46da-968a-1daaea8804cf>3.1.1 EPERM 的情况<a hidden class=anchor aria-hidden=true href=#h:d9c66345-c146-46da-968a-1daaea8804cf>#</a></h4><p>当可执行程序拥有 <code>CAP_IPC_LOCK</code> 时候，可以有权限执行 mlock, 否则的话，下列情况会返回 EPERM:</p><ol><li>RLIMIT_MEMLOCK 为 0 时候：<div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#b00040>bool</span> <span style=color:#00f>can_do_mlock</span>(<span style=color:#b00040>void</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>if</span> (<span style=color:#00f>rlimit</span>(RLIMIT_MEMLOCK) <span style=color:#666>!=</span> <span style=color:#666>0</span>)
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>return</span> <span style=color:green>true</span>;
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>if</span> (<span style=color:#00f>capable</span>(CAP_IPC_LOCK))
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>return</span> <span style=color:green>true</span>;
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>return</span> <span style=color:green>false</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><code>MCL_CURRENT</code> 被设置，并且当前进程已使用的内存超过了 <code>RLIMIT_MEMLOCK</code> .</li></ol><h3 id=h:75a484c0-9716-44e8-8811-9041f9878f19>3.2 内存区域标记<a hidden class=anchor aria-hidden=true href=#h:75a484c0-9716-44e8-8811-9041f9878f19>#</a></h3><h2 id=h:7ad9b325-1adc-4075-ac3b-3e92208ae6a6>4 Swap<a hidden class=anchor aria-hidden=true href=#h:7ad9b325-1adc-4075-ac3b-3e92208ae6a6>#</a></h2><h3 id=h:ddbd6d4f-ac07-456e-a148-dcdeac5f975d>4.1 Swap info<a hidden class=anchor aria-hidden=true href=#h:ddbd6d4f-ac07-456e-a148-dcdeac5f975d>#</a></h3><pre tabindex=0><code class=language-plantuml data-lang=plantuml>class swap_info_struct {
    + unsigned flags
    + short prio
    + struct list
    + struct avail_lists
    + signed type
    + unsigned max
    + unsigned swap_map
    + struct cluster_info
    + struct free_clusters
    + unsigned lowest_bit
    + unsigned highest_bit
    + unsigned pages
    + unsigned inuse_pages
    + unsigned cluster_next
    + unsigned cluster_nr
    + struct percpu_cluster
    + struct curr_swap_extent
    + struct first_swap_extent
    + struct bdev
    + struct swap_file
    + unsigned old_block_size
    + spinlock_t lock
    + spinlock_t cont_lock
    + struct discard_work
    + struct discard_clusters
}


class swap_cluster_info {
+ spinlock_t lock
+ unsigned data
+ unsigned flags
}


swap_info_struct *-- swap_cluster_info


class swap_cluster_list {
+ struct head
+ struct tail
}

swap_info_struct *-- swap_cluster_list

class swap_extent {
+ struct list
+ unsigned start_page
+ unsigned nr_pages
+ sector_t start_block
}


swap_info_struct *-- swap_extent

note left of swap_extent
一个交换区范围 (swap extent range) 将交换文件的
PAGE_SIZE 大小的页的范围映射到磁盘块的范围上。
交换区范围列表映射整个交换文件。

end note


class block_device {
+ dev_t bd_dev
+ int bd_openers
+ struct bd_inode
+ struct bd_super
+ struct bd_mutex
+ void bd_claiming
+ void bd_holder
+ int bd_holders
+ bool bd_write_holder
+ struct bd_holder_disks
+ struct bd_contains
+ unsigned bd_block_size
+ u8 bd_partno
+ struct bd_part
+ unsigned bd_part_count
+ int bd_invalidated
+ struct bd_disk
+ struct bd_queue
+ struct bd_bdi
+ struct bd_list
+ unsigned bd_private
+ int bd_fsfreeze_count
+ struct bd_fsfreeze_mutex
}

swap_info_struct *-- block_device

class file {
+ union f_u
+ struct f_path
+ struct f_inode
+ const f_op
+ spinlock_t f_lock
+ enum f_write_hint
+ atomic_long_t f_count
+ unsigned f_flags
+ fmode_t f_mode
+ struct f_pos_lock
+ loff_t f_pos
+ struct f_owner
+ const f_cred
+ struct f_ra
+ u64 f_version
+ void f_security
+ void private_data
+ struct f_ep_links
+ struct f_tfile_llink
+ struct f_mapping
+ errseq_t f_wb_err
}

swap_info_struct *-- file

class address_space {
+ struct host
+ struct i_pages
+ atomic_t i_mmap_writable
+ struct i_mmap
+ struct i_mmap_rwsem
+ unsigned nrpages
+ unsigned nrexceptional
+ unsigned writeback_index
+ const a_ops
+ unsigned flags
+ spinlock_t private_lock
+ gfp_t gfp_mask
+ struct private_list
+ void private_data
+ errseq_t wb_err
}

file *-- address_space

class inode {
+ umode_t i_mode
+ unsigned i_opflags
+ kuid_t i_uid
+ kgid_t i_gid
+ unsigned i_flags
+ struct i_acl
+ struct i_default_acl
+ const i_op
+ struct i_sb
+ struct i_mapping
+ void i_security
+ unsigned i_ino
+ dev_t i_rdev
+ loff_t i_size
+ struct i_atime
+ void i_private
}

address_space *-- inode
</code></pre><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#408080;font-style:italic>/*
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic> * MAX_SWAPFILES defines the maximum number of swaptypes: things which can
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic> * be swapped to.  The swap type and the offset into that swap type are
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic> * encoded into pte&#39;s and into pgoff_t&#39;s in the swapcache.  Using five bits
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic> * for the type means that the maximum number of swapcache pages is 27 bits
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic> * on 32-bit-pgoff_t architectures.  And that assumes that the architecture packs
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic> * the type/offset into the pte as 5/27 as well.
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>*/</span>
</span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>/*
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic> * MAX_SWAPFILES 定义了最大的swaptypes数量：可以被交换到的东西。交换类型和交换类型中的偏移量都被编码到
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic> * pte和swapcache中的pgoff_t中。对于类型使用五位意味着在32位pgoff_t架构上，swapcache页面的最大数量为27
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic> * 位。并且这假设架构也将类型/偏移量打包到pte中，比例为5/27。
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic> */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#bc7a00>#define MAX_SWAPFILES                              \
</span></span></span><span style=display:flex><span><span style=color:#bc7a00>    ((1 &lt;&lt; MAX_SWAPFILES_SHIFT) - SWP_DEVICE_NUM - \
</span></span></span><span style=display:flex><span><span style=color:#bc7a00>    SWP_MIGRATION_NUM - SWP_HWPOISON_NUM)
</span></span></span><span style=display:flex><span><span style=color:#bc7a00></span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>struct</span> swap_info_struct <span style=color:#666>*</span>swap_info[MAX_SWAPFILES];
</span></span></code></pre></div><p>最多 <code>MAX_SWAPFILES</code> 个 swap 设备。</p><h3 id=h:1fe99bb1-aeb0-4a49-9efe-56e123310ee6>4.2 Locks<a hidden class=anchor aria-hidden=true href=#h:1fe99bb1-aeb0-4a49-9efe-56e123310ee6>#</a></h3><h4 id=h:4542388b-4a23-4f9a-afc5-7d3afbbaf6c5>4.2.1 全局锁<a hidden class=anchor aria-hidden=true href=#h:4542388b-4a23-4f9a-afc5-7d3afbbaf6c5>#</a></h4><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#00f>DEFINE_SPINLOCK</span>(swap_lock);
</span></span></code></pre></div><h4 id=h:35cfd6f1-394c-4a8f-8883-aff2964a9ff3>4.2.2 粗粒度锁<a hidden class=anchor aria-hidden=true href=#h:35cfd6f1-394c-4a8f-8883-aff2964a9ff3>#</a></h4><h4 id=h:aef166e9-9c66-4f62-8668-78d4e76aeaf9>4.2.3 细粒度锁<a hidden class=anchor aria-hidden=true href=#h:aef166e9-9c66-4f62-8668-78d4e76aeaf9>#</a></h4><h3 id=h:36e44df6-8e26-4bd4-bfc8-80df31b3614b>4.3 fork 时候复制 swap…<a hidden class=anchor aria-hidden=true href=#h:36e44df6-8e26-4bd4-bfc8-80df31b3614b>#</a></h3><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>14.74%     0.00%  xxxxsql  [kernel.kallsyms]         [k] entry_SYSCALL_64_after_hwframe
</span></span><span style=display:flex><span>        |
</span></span><span style=display:flex><span>        ---entry_SYSCALL_64_after_hwframe
</span></span><span style=display:flex><span>           do_syscall_64
</span></span><span style=display:flex><span>           |
</span></span><span style=display:flex><span>           |--7.61%--__x64_sys_exit_group
</span></span><span style=display:flex><span>           |          do_group_exit
</span></span><span style=display:flex><span>           |          |
</span></span><span style=display:flex><span>           |           --7.61%--do_exit
</span></span><span style=display:flex><span>           |                     |
</span></span><span style=display:flex><span>           |                      --7.46%--mmput
</span></span><span style=display:flex><span>           |                                |
</span></span><span style=display:flex><span>           |                                 --7.45%--exit_mmap
</span></span><span style=display:flex><span>           |                                           |
</span></span><span style=display:flex><span>           |                                            --6.37%--unmap_vmas
</span></span><span style=display:flex><span>           |                                                      |
</span></span><span style=display:flex><span>           |                                                       --6.33%--unmap_page_range
</span></span><span style=display:flex><span>           |                                                                 |
</span></span><span style=display:flex><span>           |                                                                 |--0.98%--free_swap_and_cache
</span></span><span style=display:flex><span>           |                                                                 |
</span></span><span style=display:flex><span>           |                                                                  --0.76%--tlb_flush_mmu
</span></span><span style=display:flex><span>           |
</span></span><span style=display:flex><span>           |--3.40%--_do_fork
</span></span><span style=display:flex><span>           |          |
</span></span><span style=display:flex><span>           |           --3.38%--copy_process
</span></span><span style=display:flex><span>           |                     |
</span></span><span style=display:flex><span>           |                      --3.15%--dup_mm
</span></span><span style=display:flex><span>           |                                |
</span></span><span style=display:flex><span>           |                                 --2.42%--copy_page_range
</span></span><span style=display:flex><span>           |                                           |
</span></span><span style=display:flex><span>           |                                            --2.35%--copy_pte_range.isra.97
</span></span><span style=display:flex><span>           |                                                      |
</span></span><span style=display:flex><span>           |                                                       --0.98%--swap_duplicate
</span></span><span style=display:flex><span>           |                                                                 |
</span></span><span style=display:flex><span>           |                                                                  --0.83%--__swap_duplicate
</span></span></code></pre></div><h4 id=h:b1a19790-e8c8-4c2a-a0a1-13fad351664e>4.3.1 <code>swap_duplicate</code><a hidden class=anchor aria-hidden=true href=#h:b1a19790-e8c8-4c2a-a0a1-13fad351664e>#</a></h4><ul><li>将 swap entry 的引用计数增加 1。</li><li>返回 <code>0</code> : 表示成功</li><li>返回 <code>-ENOMEM</code>
如果需要 <code>swap_count_continuation</code> 但无法原子地分配，</li><li>如果 <code>__swap_duplicate()</code> 因其他原因失败（ <code>-EINVAL</code> 或 <code>-ENOENT</code> ），如页表条目损坏，则返回 0，就像它成功一样。</li></ul><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>/*
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic> * Increase reference count of swap entry by 1.
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic> * Returns 0 for success, or -ENOMEM if a swap_count_continuation is required
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic> * but could not be atomically allocated.  Returns 0, just as if it succeeded,
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic> * if __swap_duplicate() fails for another reason (-EINVAL or -ENOENT), which
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic> * might occur if a page table entry has got corrupted.
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic> */</span>
</span></span><span style=display:flex><span><span style=color:#b00040>int</span> <span style=color:#00f>swap_duplicate</span>(<span style=color:#b00040>swp_entry_t</span> entry)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#b00040>int</span> err <span style=color:#666>=</span> <span style=color:#666>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>while</span> (<span style=color:#666>!</span>err <span style=color:#666>&amp;&amp;</span> <span style=color:#00f>__swap_duplicate</span>(entry, <span style=color:#666>1</span>) <span style=color:#666>==</span> <span style=color:#666>-</span>ENOMEM)
</span></span><span style=display:flex><span>        err <span style=color:#666>=</span> <span style=color:#00f>add_swap_count_continuation</span>(entry, GFP_ATOMIC);
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>return</span> err;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=h:cb155170-b5a3-421f-9f98-090780fbf82a>4.4 进程退出时候清理 swap 。。。<a hidden class=anchor aria-hidden=true href=#h:cb155170-b5a3-421f-9f98-090780fbf82a>#</a></h3><h2 id=h:e5964c54-29f4-42fa-af12-10ca1093f20b>5 RLIMIT_MEMLOCK<a hidden class=anchor aria-hidden=true href=#h:e5964c54-29f4-42fa-af12-10ca1093f20b>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://yangyingchao.github.io/tags/memory/>memory</a></li><li><a href=https://yangyingchao.github.io/tags/mlock/>mlock</a></li><li><a href=https://yangyingchao.github.io/tags/swap/>swap</a></li><li><a href=https://yangyingchao.github.io/tags/lock/>lock</a></li><li><a href=https://yangyingchao.github.io/tags/mlockall/>mlockall</a></li></ul></footer><script src=https://giscus.app/client.js data-repo=yangyingchao/giscus data-repo-id=R_kgDON6NYZA data-category=Announcements data-category-id=DIC_kwDON6NYZM4CnANs data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=zh-CN crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2025 <a href=https://yangyingchao.github.io>MyNotes</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>