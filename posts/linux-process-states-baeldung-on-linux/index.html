<!doctype html><html lang=zh-cn><head><title>Linux Process States · MyNotes</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="yyc"><meta name=description content="1 The Linux Process States 1.1 Running or Runnable State (R) 1.2 Sleeping State: Interruptible (S) and Uninterruptible (D) 1.3 Stopped State (T) 1.4 Zombie State (Z) 2 Checking Process State 2.1 Displaying Process State Using ps 2.2 Using the top Command 2.3 The /proc Pseudo File 3 Summary 本文为摘录，原文为： https://www.baeldung.com/linux/process-states 1 The Linux Process States 链接到标题"><meta name=keywords content="blog,developer,personal"><meta name=twitter:card content="summary"><meta name=twitter:title content="Linux Process States"><meta name=twitter:description content="1 The Linux Process States 1.1 Running or Runnable State (R) 1.2 Sleeping State: Interruptible (S) and Uninterruptible (D) 1.3 Stopped State (T) 1.4 Zombie State (Z) 2 Checking Process State 2.1 Displaying Process State Using ps 2.2 Using the top Command 2.3 The /proc Pseudo File 3 Summary 本文为摘录，原文为： https://www.baeldung.com/linux/process-states 1 The Linux Process States 链接到标题"><meta property="og:title" content="Linux Process States"><meta property="og:description" content="1 The Linux Process States 1.1 Running or Runnable State (R) 1.2 Sleeping State: Interruptible (S) and Uninterruptible (D) 1.3 Stopped State (T) 1.4 Zombie State (Z) 2 Checking Process State 2.1 Displaying Process State Using ps 2.2 Using the top Command 2.3 The /proc Pseudo File 3 Summary 本文为摘录，原文为： https://www.baeldung.com/linux/process-states 1 The Linux Process States 链接到标题"><meta property="og:type" content="article"><meta property="og:url" content="https://yangyingchao.github.io/posts/linux-process-states-baeldung-on-linux/"><meta property="article:section" content="posts"><link rel=canonical href=https://yangyingchao.github.io/posts/linux-process-states-baeldung-on-linux/><link rel=preload href="/fonts/forkawesome-webfont.woff2?v=1.2.0" as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.135e22c97ff685fe983fc60048e309ced8f00d8d38f536aa67dba8a13a03dfa4.css integrity="sha256-E14iyX/2hf6YP8YASOMJztjwDY049TaqZ9uooToD36Q=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.a00e6364bacbc8266ad1cc81230774a1397198f8cfb7bcba29b7d6fcb54ce57f.css integrity="sha256-oA5jZLrLyCZq0cyBIwd0oTlxmPjPt7y6KbfW/LVM5X8=" crossorigin=anonymous media=screen><link rel=icon type=image/svg+xml href=/images/favicon.svg sizes=any><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5></head><body class="preload-transitions colorscheme-auto"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=/>MyNotes</a>
<input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/posts/>Blog</a></li><li class=navigation-item><a class=navigation-link href=/tags/>Tags</a></li><li class=navigation-item><a class=navigation-link href=/contact/>Contact me</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://yangyingchao.github.io/posts/linux-process-states-baeldung-on-linux/>Linux Process States</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa fa-calendar" aria-hidden=true></i>
<time datetime=0001-01-01T00:00:00Z>January 1, 0001</time></span>
<span class=reading-time><i class="fa fa-clock-o" aria-hidden=true></i>
阅读时间：3 分钟</span></div><div class=tags><i class="fa fa-tag" aria-hidden=true></i>
<span class=tag><a href=/tags/process/>process</a></span>
<span class=separator>•</span>
<span class=tag><a href=/tags/status/>status</a></span>
<span class=separator>•</span>
<span class=tag><a href=/tags/linux/>linux</a></span></div></div></header><div class=post-content><ul><li>1 <a href=#h:e18e2a33-c94e-4632-9c81-2b7c968471ca>The Linux Process States</a><ul><li>1.1 <a href=#h:82e9a258-9ef3-4b9f-a6e0-43780e2f7c6b>Running or Runnable State (R)</a></li><li>1.2 <a href=#h:af5ed80e-75ba-46bf-bd3c-fc469ce02284>Sleeping State: Interruptible (S) and Uninterruptible (D)</a></li><li>1.3 <a href=#h:928eb1a4-c3a7-45e7-a8d8-031aefe9d89e>Stopped State (T)</a></li><li>1.4 <a href=#h:fc7301f8-68e6-4139-9663-7ea505a75521>Zombie State (Z)</a></li></ul></li><li>2 <a href=#h:0985a112-1b62-4921-9635-078e0ca52dca>Checking Process State</a><ul><li>2.1 <a href=#h:d36c6068-e0db-468a-8b7f-349412d139f2>Displaying Process State Using ps</a></li><li>2.2 <a href=#h:4aa374a8-e81e-499a-aa03-63c5e0949411>Using the top Command</a></li><li>2.3 <a href=#h:5838f424-949c-4b9c-9c93-e77715bfe95c>The /proc Pseudo File</a></li></ul></li><li>3 <a href=#h:3fbb304e-adb8-4e74-94f9-e6a5944f1b26>Summary</a></li></ul><p>本文为摘录，原文为： <a href=https://www.baeldung.com/linux/process-states class=external-link target=_blank rel=noopener>https://www.baeldung.com/linux/process-states</a></p><h2 id=h:e18e2a33-c94e-4632-9c81-2b7c968471ca>1 The Linux Process States
<a class=heading-link href=#h:e18e2a33-c94e-4632-9c81-2b7c968471ca><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h2><ul><li>Running or Runnable (R)</li><li>Uninterruptible Sleep (D)</li><li>Interruptable Sleep (S)</li><li>Stopped (T)</li><li>Zombie (Z)</li></ul><p>状态机如下：</p><p></p><figure><img src=/ox-hugo/screenshot@2023-02-15_17:52:09.png width=800px></figure><p>For any Linux process, their starting point is the moment they are created. For example, a parent
process can initiate a child process using the fork() system call. Once it starts, the process
goes into the running or runnable state. While the process is running, it could come into a code
path that requires it to wait for particular resources or signals before proceeding. While waiting
for the resources, the process would voluntarily give up the CPU cycles by going into one of the
two sleeping states.</p><p>Additionally, we could suspend a running process and put it into the stopped state. Usually, this
is done by sending the SIGSTOP signal to the process. A process in this state will continue to
exist until it is killed or resumed with SIGCONT. Finally, the process completes its lifecycle
when it’s terminated and placed into a zombie state until its parent process clears it off the
process table.</p><h3 id=h:82e9a258-9ef3-4b9f-a6e0-43780e2f7c6b>1.1 Running or Runnable State (R)
<a class=heading-link href=#h:82e9a258-9ef3-4b9f-a6e0-43780e2f7c6b><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h3><p>When a new process is started, it’ll be placed into the running or runnable state. In the running
state, the process takes up a CPU core to execute its code and logic. However, the thread
scheduling algorithm might force a running process to give up its execution right. This is to
ensure each process can have a fair share of CPU resources. In this case, the process will be
placed into a run queue, and its state is now a runnable state waiting for its turn to execute.</p><p>Although the running and runnable states are distinct, they are collectively grouped into a single
state denoted by the character <code>R</code>.</p><h3 id=h:af5ed80e-75ba-46bf-bd3c-fc469ce02284>1.2 Sleeping State: Interruptible (S) and Uninterruptible (D)
<a class=heading-link href=#h:af5ed80e-75ba-46bf-bd3c-fc469ce02284><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h3><p>During process execution, it might come across a portion of its code where it needs to request
external resources. Mainly, the request for these resources is IO-based such as to read a file
from disk or make a network request. Since the process couldn’t proceed without the resources, it
would stall and do nothing. In events like these, they should give up their CPU cycles to other
tasks that are ready to run, and hence they go into a sleeping state.</p><p>There are two different sleeping states:</p><ul><li>the uninterruptible sleeping state (D) and</li><li>the interruptible sleepingstate (S)</li></ul><p>The <code>uninterruptible sleeping state (D)</code> will only wait for the resources to be available before
it transit into a runnable state, and it doesn’t react to any signals. On the other hand, the
<code>interruptible sleeping state (S)</code> will react to signals and the availability of resources.</p><h3 id=h:928eb1a4-c3a7-45e7-a8d8-031aefe9d89e>1.3 Stopped State (T)
<a class=heading-link href=#h:928eb1a4-c3a7-45e7-a8d8-031aefe9d89e><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h3><p>From a running or runnable state, we could put a process into the stopped state (T) using the
<code>SIGSTOP</code> or <code>SIGTSTP</code> signals. The difference between both signals is that we send the SIGSTOP
is programmatic, such as running <code>kill -STOP {pid}</code>. Additionally, the process cannot ignore this
signal and will go into the stopped state. On the other hand, we send the SIGTSTP signal using the
keyboard CTRL + Z. Unlike SIGSTOP, the process can optionally ignore this signal and continue to
execute upon receiving SIGTSTP.</p><p>While in this state, we could bring back the process into a running or runnable state by sending
the SIGCONT signal.</p><h3 id=h:fc7301f8-68e6-4139-9663-7ea505a75521>1.4 Zombie State (Z)
<a class=heading-link href=#h:fc7301f8-68e6-4139-9663-7ea505a75521><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h3><p>When a process has completed its execution or is terminated, it’ll send the SIGCHLD signal to the
parent process and go into the zombie state. The zombie process, also known as a defunct process,
will remain in this state until the parent process clears it off from the process table. To clear
the terminated child process off the process table, the parent process must read the exit value of
the child process using the wait() or waitpid() system calls.</p><h2 id=h:0985a112-1b62-4921-9635-078e0ca52dca>2 Checking Process State
<a class=heading-link href=#h:0985a112-1b62-4921-9635-078e0ca52dca><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h2><p>There are multiple ways to check the state of a process is in Linux. For example, we can use
command-line tools like ps and top to check the state of processes. Alternatively, we can consult
the pseudo status file for a particular PID.</p><h3 id=h:d36c6068-e0db-468a-8b7f-349412d139f2>2.1 Displaying Process State Using ps
<a class=heading-link href=#h:d36c6068-e0db-468a-8b7f-349412d139f2><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h3><p>To display process state using ps, let’s run the ps command to include a column that tells us the state of the process:</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:navy;font-weight:700>$</span> ps a
</span></span><span style=display:flex><span><span style=color:#888>    PID TTY      STAT   TIME COMMAND
</span></span></span><span style=display:flex><span><span style=color:#888>   2234 tty2     Ssl+   0:00 /usr/lib/gdm3/gdm-x-session --run-script env GNOME_SHELL_SESSION_MODE=ubuntu /usr/bin/gnome-session --systemd --session=ubuntu
</span></span></span><span style=display:flex><span><span style=color:#888>   2237 tty2     Rl+    0:07 /usr/lib/xorg/Xorg vt2 -displayfd 3 -auth /run/user/1000/gdm/Xauthority -background none -noreset -keeptty -verbose 3
</span></span></span><span style=display:flex><span><span style=color:#888>   2287 tty2     Sl+    0:00 /usr/libexec/gnome-session-binary --systemd --systemd --session=ubuntu
</span></span></span><span style=display:flex><span><span style=color:#888>   2982 pts/0    Ss     0:00 bash
</span></span></span><span style=display:flex><span><span style=color:#888>   3467 pts/0    R+     0:00 ps a
</span></span></span></code></pre></div><p>The first letter of the value under the STAT column indicates the state that the process is
in. For example, the process with PID 2234 is currently in an interruptible sleeping state, as
denoted by the character S. Besides that, we can also observe that process 2237 is currently in
the running or runnable state.</p><p>Additionally, we can see that there are additional characters besides each of the state
characters. These characters indicate several attributes of the state of the process. For example,
the lower capital letter s means the process is the session leader. For a comprehensive list of
the meaning of each of the characters, we can find it on the official man page.</p><h3 id=h:4aa374a8-e81e-499a-aa03-63c5e0949411>2.2 Using the top Command
<a class=heading-link href=#h:4aa374a8-e81e-499a-aa03-63c5e0949411><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h3><p>In Linux, the top command-line tool displays the process details in a real-time fashion. It shows
different aspects of the system, such as memory and CPU usage of individual processes. To see the
process state, let’s run top in the terminal:</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:#888>Tasks: 183 total,   1 running, 182 sleeping,   0 stopped,   0 zombie
</span></span></span><span style=display:flex><span><span style=color:#888></span><span style=color:navy;font-weight:700>%</span>Cpu<span style=color:#666>(</span>s<span style=color:#666>)</span>:  0.7 us,  1.1 sy,  0.0 ni, 97.1 id,  0.4 wa,  0.0 hi,  0.7 si,  0.0 st
</span></span><span style=display:flex><span><span style=color:#888>MiB Mem :   3936.4 total,   1925.0 free,    850.6 used,   1160.8 buff/cache
</span></span></span><span style=display:flex><span><span style=color:#888>MiB Swap:   2048.0 total,   2048.0 free,      0.0 used.   2834.2 avail Mem
</span></span></span><span style=display:flex><span><span style=color:#888>    PID USER  PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND
</span></span></span><span style=display:flex><span><span style=color:#888>   2237 bob   20   0  252252  81740  49204 S   2.3   2.0   0:09.37 Xorg
</span></span></span><span style=display:flex><span><span style=color:#888>   2519 bob   20   0 3428664 375256 125080 S   2.0   9.3   0:19.57 gnome-shell
</span></span></span><span style=display:flex><span><span style=color:#888>   2909 bob   20   0  966852  49944  37308 S   1.0   1.2   0:02.28 gnome-terminal-
</span></span></span><span style=display:flex><span><span style=color:#888>      1 root  20   0  103500  13312   8620 S   0.7   0.3   0:04.44 systemd
</span></span></span><span style=display:flex><span><span style=color:#888>   3588 bob   20   0   20600   3936   3380 R   0.3   0.1   0:00.01 top
</span></span></span><span style=display:flex><span><span style=color:#888>      2 root  20   0       0      0      0 S   0.0   0.0   0:00.00 kthreadd
</span></span></span><span style=display:flex><span><span style=color:#888>      3 root   0 -20       0      0      0 I   0.0   0.0   0:00.00 rcu_gp
</span></span></span></code></pre></div><p>At the bottom section of the output of the top command, we can find the S column, which shows the state of each process.
Contrary to the ps command, the top command displays the state of each process without additional process attributes.</p><h3 id=h:5838f424-949c-4b9c-9c93-e77715bfe95c>2.3 The /proc Pseudo File
<a class=heading-link href=#h:5838f424-949c-4b9c-9c93-e77715bfe95c><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h3><p>The /proc pseudo filesystem contains all the information about the processes in our system. Hence,
we could directly read the state of a process through this pseudo filesystem. The downside of this
approach is we’ll first need to know the PID of the process before we can read its state.</p><p>To obtain the state of a process, we can extract the value from its pseudo status file under /proc/{pid}/status. For
example, we can get the state of the process with PID 2519 by reading the file /proc/2519/status:</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:navy;font-weight:700>$</span> cat /proc/2519/status | grep State
</span></span><span style=display:flex><span><span style=color:#888>State:  S (sleeping)
</span></span></span></code></pre></div><h2 id=h:3fbb304e-adb8-4e74-94f9-e6a5944f1b26>3 Summary
<a class=heading-link href=#h:3fbb304e-adb8-4e74-94f9-e6a5944f1b26><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h2><p>In this tutorial, we’ve looked at the lifecycle of a Linux process. Furthermore, we’ve learned how
we can model a Linux process lifecycle as a finite state machine. Then, we’ve looked at the five
different states as a Linux process undergoes the entire lifecycle. Finally, we ended the article
with demonstrations on getting the Linux process state using various tools such as ps, top, and
the /proc pseudo-file.</p></div><footer></footer></article></section></div><footer class=footer><section class=container>©
2023
yyc
·
技术支持 <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/ target=_blank rel=noopener>Coder</a>.</section></footer></main><script src=/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script></body></html>