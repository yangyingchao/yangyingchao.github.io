<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>Linux Process States - 杂七杂八随手记</title><meta name=renderer content="webkit"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv=cache-control content="no-transform"><meta http-equiv=cache-control content="no-siteapp"><meta name=theme-color content="#f8f5ec"><meta name=msapplication-navbutton-color content="#f8f5ec"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="#f8f5ec"><meta name=author content="yyc"><meta name=description content="Table of Contents 1 The Linux Process States 1.1 Running or Runnable State (R) 1.2 Sleeping State: Interruptible (S) and Uninterruptible (D) 1.3 Stopped State (T) 1.4 Zombie State (Z) 2 Checking Process State 2.1 Displaying Process State Using ps 2.2 Using the top Command 2.3 The /proc Pseudo File 3 Summary 1 The Linux Process States Running or Runnable (R) Uninterruptible Sleep (D) Interruptable Sleep (S) Stopped (T) Zombie"><meta name=keywords content="Hugo,theme,even"><meta name=generator content="Hugo 0.115.0 with theme even"><link rel=canonical href=https://yangyingchao.github.io/posts/linux-process-states-baeldung-on-linux/><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/manifest.json><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link href=/sass/main.min.154ed883776547b0e136be39b3037f61350da06f888d0868d1756a9463cd9520.css rel=stylesheet><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin=anonymous><meta property="og:title" content="Linux Process States"><meta property="og:description" content="Table of Contents 1 The Linux Process States 1.1 Running or Runnable State (R) 1.2 Sleeping State: Interruptible (S) and Uninterruptible (D) 1.3 Stopped State (T) 1.4 Zombie State (Z) 2 Checking Process State 2.1 Displaying Process State Using ps 2.2 Using the top Command 2.3 The /proc Pseudo File 3 Summary 1 The Linux Process States Running or Runnable (R) Uninterruptible Sleep (D) Interruptable Sleep (S) Stopped (T) Zombie"><meta property="og:type" content="article"><meta property="og:url" content="https://yangyingchao.github.io/posts/linux-process-states-baeldung-on-linux/"><meta property="article:section" content="posts"><meta itemprop=name content="Linux Process States"><meta itemprop=description content="Table of Contents 1 The Linux Process States 1.1 Running or Runnable State (R) 1.2 Sleeping State: Interruptible (S) and Uninterruptible (D) 1.3 Stopped State (T) 1.4 Zombie State (Z) 2 Checking Process State 2.1 Displaying Process State Using ps 2.2 Using the top Command 2.3 The /proc Pseudo File 3 Summary 1 The Linux Process States Running or Runnable (R) Uninterruptible Sleep (D) Interruptable Sleep (S) Stopped (T) Zombie"><meta itemprop=wordCount content="1412"><meta itemprop=keywords content="process,status,linux,"><meta name=twitter:card content="summary"><meta name=twitter:title content="Linux Process States"><meta name=twitter:description content="Table of Contents 1 The Linux Process States 1.1 Running or Runnable State (R) 1.2 Sleeping State: Interruptible (S) and Uninterruptible (D) 1.3 Stopped State (T) 1.4 Zombie State (Z) 2 Checking Process State 2.1 Displaying Process State Using ps 2.2 Using the top Command 2.3 The /proc Pseudo File 3 Summary 1 The Linux Process States Running or Runnable (R) Uninterruptible Sleep (D) Interruptable Sleep (S) Stopped (T) Zombie"><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]--></head><body><div id=mobile-navbar class=mobile-navbar><div class=mobile-header-logo><a href=/ class=logo>Even</a></div><div class=mobile-navbar-icon><span></span>
<span></span>
<span></span></div></div><nav id=mobile-menu class="mobile-menu slideout-menu"><ul class=mobile-menu-list><a href=/><li class=mobile-menu-item>Home</li></a><a href=/post/><li class=mobile-menu-item>Archives</li></a><a href=/tags/><li class=mobile-menu-item>Tags</li></a><a href=/categories/><li class=mobile-menu-item>Categories</li></a></ul></nav><div class=container id=mobile-panel><header id=header class=header><div class=logo-wrapper><a href=/ class=logo>Even</a></div><nav class=site-navbar><ul id=menu class=menu><li class=menu-item><a class=menu-item-link href=/>Home</a></li><li class=menu-item><a class=menu-item-link href=/post/>Archives</a></li><li class=menu-item><a class=menu-item-link href=/tags/>Tags</a></li><li class=menu-item><a class=menu-item-link href=/categories/>Categories</a></li></ul></nav></header><main id=main class=main><div class=content-wrapper><div id=content class=content><article class=post><div class=post-content><div class="ox-hugo-toc toc has-section-numbers"><div class=heading>Table of Contents</div><ul><li><span class=section-num>1</span> <a href=#h:e18e2a33-c94e-4632-9c81-2b7c968471ca>The Linux Process States</a><ul><li><span class=section-num>1.1</span> <a href=#h:82e9a258-9ef3-4b9f-a6e0-43780e2f7c6b>Running or Runnable State (R)</a></li><li><span class=section-num>1.2</span> <a href=#h:af5ed80e-75ba-46bf-bd3c-fc469ce02284>Sleeping State: Interruptible (S) and Uninterruptible (D)</a></li><li><span class=section-num>1.3</span> <a href=#h:928eb1a4-c3a7-45e7-a8d8-031aefe9d89e>Stopped State (T)</a></li><li><span class=section-num>1.4</span> <a href=#h:fc7301f8-68e6-4139-9663-7ea505a75521>Zombie State (Z)</a></li></ul></li><li><span class=section-num>2</span> <a href=#h:0985a112-1b62-4921-9635-078e0ca52dca>Checking Process State</a><ul><li><span class=section-num>2.1</span> <a href=#h:d36c6068-e0db-468a-8b7f-349412d139f2>Displaying Process State Using ps</a></li><li><span class=section-num>2.2</span> <a href=#h:4aa374a8-e81e-499a-aa03-63c5e0949411>Using the top Command</a></li><li><span class=section-num>2.3</span> <a href=#h:5838f424-949c-4b9c-9c93-e77715bfe95c>The /proc Pseudo File</a></li></ul></li><li><span class=section-num>3</span> <a href=#h:3fbb304e-adb8-4e74-94f9-e6a5944f1b26>Summary</a></li></ul></div><h2 id=h:e18e2a33-c94e-4632-9c81-2b7c968471ca><span class=section-num>1</span> The Linux Process States</h2><ul><li>Running or Runnable (R)</li><li>Uninterruptible Sleep (D)</li><li>Interruptable Sleep (S)</li><li>Stopped (T)</li><li>Zombie (Z)</li></ul><p>状态机如下：</p><p><a id=figure--fig:screenshot@2023-02-15-17:52:09></a></p><figure><img src=/ox-hugo/screenshot@2023-02-15_17:52:09.png width=800px></figure><p>For any Linux process, their starting point is the moment they are created. For example, a parent
process can initiate a child process using the fork() system call. Once it starts, the process
goes into the running or runnable state. While the process is running, it could come into a code
path that requires it to wait for particular resources or signals before proceeding. While waiting
for the resources, the process would voluntarily give up the CPU cycles by going into one of the
two sleeping states.</p><p>Additionally, we could suspend a running process and put it into the stopped state. Usually, this
is done by sending the SIGSTOP signal to the process. A process in this state will continue to
exist until it is killed or resumed with SIGCONT. Finally, the process completes its lifecycle
when it’s terminated and placed into a zombie state until its parent process clears it off the
process table.</p><h3 id=h:82e9a258-9ef3-4b9f-a6e0-43780e2f7c6b><span class=section-num>1.1</span> Running or Runnable State (R)</h3><p>When a new process is started, it’ll be placed into the running or runnable state. In the running
state, the process takes up a CPU core to execute its code and logic. However, the thread
scheduling algorithm might force a running process to give up its execution right. This is to
ensure each process can have a fair share of CPU resources. In this case, the process will be
placed into a run queue, and its state is now a runnable state waiting for its turn to execute.</p><p>Although the running and runnable states are distinct, they are collectively grouped into a single
state denoted by the character <code>R</code>.</p><h3 id=h:af5ed80e-75ba-46bf-bd3c-fc469ce02284><span class=section-num>1.2</span> Sleeping State: Interruptible (S) and Uninterruptible (D)</h3><p>During process execution, it might come across a portion of its code where it needs to request
external resources. Mainly, the request for these resources is IO-based such as to read a file
from disk or make a network request. Since the process couldn’t proceed without the resources, it
would stall and do nothing. In events like these, they should give up their CPU cycles to other
tasks that are ready to run, and hence they go into a sleeping state.</p><p>There are two different sleeping states:</p><ul><li>the uninterruptible sleeping state (D) and</li><li>the interruptible sleepingstate (S)</li></ul><p>The <code>uninterruptible sleeping state (D)</code> will only wait for the resources to be available before
it transit into a runnable state, and it doesn’t react to any signals. On the other hand, the
<code>interruptible sleeping state (S)</code> will react to signals and the availability of resources.</p><h3 id=h:928eb1a4-c3a7-45e7-a8d8-031aefe9d89e><span class=section-num>1.3</span> Stopped State (T)</h3><p>From a running or runnable state, we could put a process into the stopped state (T) using the
<code>SIGSTOP</code> or <code>SIGTSTP</code> signals. The difference between both signals is that we send the SIGSTOP
is programmatic, such as running <code>kill -STOP {pid}</code>. Additionally, the process cannot ignore this
signal and will go into the stopped state. On the other hand, we send the SIGTSTP signal using the
keyboard CTRL + Z. Unlike SIGSTOP, the process can optionally ignore this signal and continue to
execute upon receiving SIGTSTP.</p><p>While in this state, we could bring back the process into a running or runnable state by sending
the SIGCONT signal.</p><h3 id=h:fc7301f8-68e6-4139-9663-7ea505a75521><span class=section-num>1.4</span> Zombie State (Z)</h3><p>When a process has completed its execution or is terminated, it’ll send the SIGCHLD signal to the
parent process and go into the zombie state. The zombie process, also known as a defunct process,
will remain in this state until the parent process clears it off from the process table. To clear
the terminated child process off the process table, the parent process must read the exit value of
the child process using the wait() or waitpid() system calls.</p><h2 id=h:0985a112-1b62-4921-9635-078e0ca52dca><span class=section-num>2</span> Checking Process State</h2><p>There are multiple ways to check the state of a process is in Linux. For example, we can use
command-line tools like ps and top to check the state of processes. Alternatively, we can consult
the pseudo status file for a particular PID.</p><h3 id=h:d36c6068-e0db-468a-8b7f-349412d139f2><span class=section-num>2.1</span> Displaying Process State Using ps</h3><p>To display process state using ps, let’s run the ps command to include a column that tells us the state of the process:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-console data-lang=console><span class=line><span class=cl><span class=gp>$</span> ps a
</span></span><span class=line><span class=cl><span class=go>    PID TTY      STAT   TIME COMMAND
</span></span></span><span class=line><span class=cl><span class=go>   2234 tty2     Ssl+   0:00 /usr/lib/gdm3/gdm-x-session --run-script env GNOME_SHELL_SESSION_MODE=ubuntu /usr/bin/gnome-session --systemd --session=ubuntu
</span></span></span><span class=line><span class=cl><span class=go>   2237 tty2     Rl+    0:07 /usr/lib/xorg/Xorg vt2 -displayfd 3 -auth /run/user/1000/gdm/Xauthority -background none -noreset -keeptty -verbose 3
</span></span></span><span class=line><span class=cl><span class=go>   2287 tty2     Sl+    0:00 /usr/libexec/gnome-session-binary --systemd --systemd --session=ubuntu
</span></span></span><span class=line><span class=cl><span class=go>   2982 pts/0    Ss     0:00 bash
</span></span></span><span class=line><span class=cl><span class=go>   3467 pts/0    R+     0:00 ps a
</span></span></span></code></pre></td></tr></table></div></div><p>The first letter of the value under the STAT column indicates the state that the process is
in. For example, the process with PID 2234 is currently in an interruptible sleeping state, as
denoted by the character S. Besides that, we can also observe that process 2237 is currently in
the running or runnable state.</p><p>Additionally, we can see that there are additional characters besides each of the state
characters. These characters indicate several attributes of the state of the process. For example,
the lower capital letter s means the process is the session leader. For a comprehensive list of
the meaning of each of the characters, we can find it on the official man page.</p><h3 id=h:4aa374a8-e81e-499a-aa03-63c5e0949411><span class=section-num>2.2</span> Using the top Command</h3><p>In Linux, the top command-line tool displays the process details in a real-time fashion. It shows
different aspects of the system, such as memory and CPU usage of individual processes. To see the
process state, let’s run top in the terminal:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-console data-lang=console><span class=line><span class=cl><span class=go>Tasks: 183 total,   1 running, 182 sleeping,   0 stopped,   0 zombie
</span></span></span><span class=line><span class=cl><span class=go></span><span class=gp>%</span>Cpu<span class=o>(</span>s<span class=o>)</span>:  0.7 us,  1.1 sy,  0.0 ni, 97.1 id,  0.4 wa,  0.0 hi,  0.7 si,  0.0 st
</span></span><span class=line><span class=cl><span class=go>MiB Mem :   3936.4 total,   1925.0 free,    850.6 used,   1160.8 buff/cache
</span></span></span><span class=line><span class=cl><span class=go>MiB Swap:   2048.0 total,   2048.0 free,      0.0 used.   2834.2 avail Mem
</span></span></span><span class=line><span class=cl><span class=go>    PID USER  PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND
</span></span></span><span class=line><span class=cl><span class=go>   2237 bob   20   0  252252  81740  49204 S   2.3   2.0   0:09.37 Xorg
</span></span></span><span class=line><span class=cl><span class=go>   2519 bob   20   0 3428664 375256 125080 S   2.0   9.3   0:19.57 gnome-shell
</span></span></span><span class=line><span class=cl><span class=go>   2909 bob   20   0  966852  49944  37308 S   1.0   1.2   0:02.28 gnome-terminal-
</span></span></span><span class=line><span class=cl><span class=go>      1 root  20   0  103500  13312   8620 S   0.7   0.3   0:04.44 systemd
</span></span></span><span class=line><span class=cl><span class=go>   3588 bob   20   0   20600   3936   3380 R   0.3   0.1   0:00.01 top
</span></span></span><span class=line><span class=cl><span class=go>      2 root  20   0       0      0      0 S   0.0   0.0   0:00.00 kthreadd
</span></span></span><span class=line><span class=cl><span class=go>      3 root   0 -20       0      0      0 I   0.0   0.0   0:00.00 rcu_gp
</span></span></span></code></pre></td></tr></table></div></div><p>At the bottom section of the output of the top command, we can find the S column, which shows the state of each process.
Contrary to the ps command, the top command displays the state of each process without additional process attributes.</p><h3 id=h:5838f424-949c-4b9c-9c93-e77715bfe95c><span class=section-num>2.3</span> The /proc Pseudo File</h3><p>The /proc pseudo filesystem contains all the information about the processes in our system. Hence,
we could directly read the state of a process through this pseudo filesystem. The downside of this
approach is we’ll first need to know the PID of the process before we can read its state.</p><p>To obtain the state of a process, we can extract the value from its pseudo status file under /proc/{pid}/status. For
example, we can get the state of the process with PID 2519 by reading the file /proc/2519/status:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-console data-lang=console><span class=line><span class=cl><span class=gp>$</span> cat /proc/2519/status <span class=p>|</span> grep State
</span></span><span class=line><span class=cl><span class=go>State:  S (sleeping)
</span></span></span></code></pre></td></tr></table></div></div><h2 id=h:3fbb304e-adb8-4e74-94f9-e6a5944f1b26><span class=section-num>3</span> Summary</h2><p>In this tutorial, we’ve looked at the lifecycle of a Linux process. Furthermore, we’ve learned how
we can model a Linux process lifecycle as a finite state machine. Then, we’ve looked at the five
different states as a Linux process undergoes the entire lifecycle. Finally, we ended the article
with demonstrations on getting the Linux process state using various tools such as ps, top, and
the /proc pseudo-file.</p></div></article></div></div></main><footer id=footer class=footer><div class=social-links><a href=mailto:yang.yingchao@qq.com class="iconfont icon-email" title=email></a>
<a href=http://localhost:1313 class="iconfont icon-stack-overflow" title=stack-overflow></a>
<a href=https://github.com/yangyingchao/ class="iconfont icon-github" title=github></a>
<a href=https://yangyingchao.github.io/index.xml type=application/rss+xml class="iconfont icon-rss" title=rss></a></div><div class=copyright><span class=power-by>由 <a class=hexo-link href=https://gohugo.io>Hugo</a> 强力驱动</span>
<span class=division>|</span>
<span class=theme-info>主题 -
<a class=theme-link href=https://github.com/olOwOlo/hugo-theme-even>Even</a></span>
<span class=copyright-year>&copy;
2017 -
2023<span class=heart><i class="iconfont icon-heart"></i></span><span>yyc</span></span></div></footer><div class=back-to-top id=back-to-top><i class="iconfont icon-up"></i></div></div><script src=https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin=anonymous></script>
<script type=text/javascript src=/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js></script></body></html>