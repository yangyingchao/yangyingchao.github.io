<!doctype html><html lang=zh-cn dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Linux Process States | MyNotes</title><meta name=keywords content="process,status,linux"><meta name=description content="1 The Linux Process States 1.1 Running or Runnable State (R) 1.2 Sleeping State: Interruptible (S) and Uninterruptible (D) 1.3 Stopped State (T) 1.4 Zombie State (Z) 2 Checking Process State 2.1 Displaying Process State Using ps 2.2 Using the top Command 2.3 The /proc Pseudo File 3 Summary 本文为摘录，原文为： https://www.baeldung.com/linux/process-states 1 The Linux Process States Running or Runnable (R) Uninterruptible"><meta name=author content><link rel=canonical href=https://yangyingchao.github.io/posts/linux-process-states-baeldung-on-linux/><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://yangyingchao.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://yangyingchao.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://yangyingchao.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://yangyingchao.github.io/apple-touch-icon.png><link rel=mask-icon href=https://yangyingchao.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Linux Process States"><meta property="og:description" content="1 The Linux Process States 1.1 Running or Runnable State (R) 1.2 Sleeping State: Interruptible (S) and Uninterruptible (D) 1.3 Stopped State (T) 1.4 Zombie State (Z) 2 Checking Process State 2.1 Displaying Process State Using ps 2.2 Using the top Command 2.3 The /proc Pseudo File 3 Summary 本文为摘录，原文为： https://www.baeldung.com/linux/process-states 1 The Linux Process States Running or Runnable (R) Uninterruptible"><meta property="og:type" content="article"><meta property="og:url" content="https://yangyingchao.github.io/posts/linux-process-states-baeldung-on-linux/"><meta property="article:section" content="posts"><meta name=twitter:card content="summary"><meta name=twitter:title content="Linux Process States"><meta name=twitter:description content="1 The Linux Process States 1.1 Running or Runnable State (R) 1.2 Sleeping State: Interruptible (S) and Uninterruptible (D) 1.3 Stopped State (T) 1.4 Zombie State (Z) 2 Checking Process State 2.1 Displaying Process State Using ps 2.2 Using the top Command 2.3 The /proc Pseudo File 3 Summary 本文为摘录，原文为： https://www.baeldung.com/linux/process-states 1 The Linux Process States Running or Runnable (R) Uninterruptible"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://yangyingchao.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Linux Process States","item":"https://yangyingchao.github.io/posts/linux-process-states-baeldung-on-linux/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Linux Process States","name":"Linux Process States","description":"1 The Linux Process States 1.1 Running or Runnable State (R) 1.2 Sleeping State: Interruptible (S) and Uninterruptible (D) 1.3 Stopped State (T) 1.4 Zombie State (Z) 2 Checking Process State 2.1 Displaying Process State Using ps 2.2 Using the top Command 2.3 The /proc Pseudo File 3 Summary 本文为摘录，原文为： https://www.baeldung.com/linux/process-states 1 The Linux Process States Running or Runnable (R) Uninterruptible","keywords":["process","status","linux"],"articleBody":" 1 The Linux Process States 1.1 Running or Runnable State (R) 1.2 Sleeping State: Interruptible (S) and Uninterruptible (D) 1.3 Stopped State (T) 1.4 Zombie State (Z) 2 Checking Process State 2.1 Displaying Process State Using ps 2.2 Using the top Command 2.3 The /proc Pseudo File 3 Summary 本文为摘录，原文为： https://www.baeldung.com/linux/process-states\n1 The Linux Process States Running or Runnable (R) Uninterruptible Sleep (D) Interruptable Sleep (S) Stopped (T) Zombie (Z) 状态机如下：\nFor any Linux process, their starting point is the moment they are created. For example, a parent process can initiate a child process using the fork() system call. Once it starts, the process goes into the running or runnable state. While the process is running, it could come into a code path that requires it to wait for particular resources or signals before proceeding. While waiting for the resources, the process would voluntarily give up the CPU cycles by going into one of the two sleeping states.\nAdditionally, we could suspend a running process and put it into the stopped state. Usually, this is done by sending the SIGSTOP signal to the process. A process in this state will continue to exist until it is killed or resumed with SIGCONT. Finally, the process completes its lifecycle when it’s terminated and placed into a zombie state until its parent process clears it off the process table.\n1.1 Running or Runnable State (R) When a new process is started, it’ll be placed into the running or runnable state. In the running state, the process takes up a CPU core to execute its code and logic. However, the thread scheduling algorithm might force a running process to give up its execution right. This is to ensure each process can have a fair share of CPU resources. In this case, the process will be placed into a run queue, and its state is now a runnable state waiting for its turn to execute.\nAlthough the running and runnable states are distinct, they are collectively grouped into a single state denoted by the character R.\n1.2 Sleeping State: Interruptible (S) and Uninterruptible (D) During process execution, it might come across a portion of its code where it needs to request external resources. Mainly, the request for these resources is IO-based such as to read a file from disk or make a network request. Since the process couldn’t proceed without the resources, it would stall and do nothing. In events like these, they should give up their CPU cycles to other tasks that are ready to run, and hence they go into a sleeping state.\nThere are two different sleeping states:\nthe uninterruptible sleeping state (D) and the interruptible sleepingstate (S) The uninterruptible sleeping state (D) will only wait for the resources to be available before it transit into a runnable state, and it doesn’t react to any signals. On the other hand, the interruptible sleeping state (S) will react to signals and the availability of resources.\n1.3 Stopped State (T) From a running or runnable state, we could put a process into the stopped state (T) using the SIGSTOP or SIGTSTP signals. The difference between both signals is that we send the SIGSTOP is programmatic, such as running kill -STOP {pid}. Additionally, the process cannot ignore this signal and will go into the stopped state. On the other hand, we send the SIGTSTP signal using the keyboard CTRL + Z. Unlike SIGSTOP, the process can optionally ignore this signal and continue to execute upon receiving SIGTSTP.\nWhile in this state, we could bring back the process into a running or runnable state by sending the SIGCONT signal.\n1.4 Zombie State (Z) When a process has completed its execution or is terminated, it’ll send the SIGCHLD signal to the parent process and go into the zombie state. The zombie process, also known as a defunct process, will remain in this state until the parent process clears it off from the process table. To clear the terminated child process off the process table, the parent process must read the exit value of the child process using the wait() or waitpid() system calls.\n2 Checking Process State There are multiple ways to check the state of a process is in Linux. For example, we can use command-line tools like ps and top to check the state of processes. Alternatively, we can consult the pseudo status file for a particular PID.\n2.1 Displaying Process State Using ps To display process state using ps, let’s run the ps command to include a column that tells us the state of the process:\n$ ps a PID TTY STAT TIME COMMAND 2234 tty2 Ssl+ 0:00 /usr/lib/gdm3/gdm-x-session --run-script env GNOME_SHELL_SESSION_MODE=ubuntu /usr/bin/gnome-session --systemd --session=ubuntu 2237 tty2 Rl+ 0:07 /usr/lib/xorg/Xorg vt2 -displayfd 3 -auth /run/user/1000/gdm/Xauthority -background none -noreset -keeptty -verbose 3 2287 tty2 Sl+ 0:00 /usr/libexec/gnome-session-binary --systemd --systemd --session=ubuntu 2982 pts/0 Ss 0:00 bash 3467 pts/0 R+ 0:00 ps a The first letter of the value under the STAT column indicates the state that the process is in. For example, the process with PID 2234 is currently in an interruptible sleeping state, as denoted by the character S. Besides that, we can also observe that process 2237 is currently in the running or runnable state.\nAdditionally, we can see that there are additional characters besides each of the state characters. These characters indicate several attributes of the state of the process. For example, the lower capital letter s means the process is the session leader. For a comprehensive list of the meaning of each of the characters, we can find it on the official man page.\n2.2 Using the top Command In Linux, the top command-line tool displays the process details in a real-time fashion. It shows different aspects of the system, such as memory and CPU usage of individual processes. To see the process state, let’s run top in the terminal:\nTasks: 183 total, 1 running, 182 sleeping, 0 stopped, 0 zombie %Cpu(s): 0.7 us, 1.1 sy, 0.0 ni, 97.1 id, 0.4 wa, 0.0 hi, 0.7 si, 0.0 st MiB Mem : 3936.4 total, 1925.0 free, 850.6 used, 1160.8 buff/cache MiB Swap: 2048.0 total, 2048.0 free, 0.0 used. 2834.2 avail Mem PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 2237 bob 20 0 252252 81740 49204 S 2.3 2.0 0:09.37 Xorg 2519 bob 20 0 3428664 375256 125080 S 2.0 9.3 0:19.57 gnome-shell 2909 bob 20 0 966852 49944 37308 S 1.0 1.2 0:02.28 gnome-terminal- 1 root 20 0 103500 13312 8620 S 0.7 0.3 0:04.44 systemd 3588 bob 20 0 20600 3936 3380 R 0.3 0.1 0:00.01 top 2 root 20 0 0 0 0 S 0.0 0.0 0:00.00 kthreadd 3 root 0 -20 0 0 0 I 0.0 0.0 0:00.00 rcu_gp At the bottom section of the output of the top command, we can find the S column, which shows the state of each process. Contrary to the ps command, the top command displays the state of each process without additional process attributes.\n2.3 The /proc Pseudo File The /proc pseudo filesystem contains all the information about the processes in our system. Hence, we could directly read the state of a process through this pseudo filesystem. The downside of this approach is we’ll first need to know the PID of the process before we can read its state.\nTo obtain the state of a process, we can extract the value from its pseudo status file under /proc/{pid}/status. For example, we can get the state of the process with PID 2519 by reading the file /proc/2519/status:\n$ cat /proc/2519/status | grep State State: S (sleeping) 3 Summary In this tutorial, we’ve looked at the lifecycle of a Linux process. Furthermore, we’ve learned how we can model a Linux process lifecycle as a finite state machine. Then, we’ve looked at the five different states as a Linux process undergoes the entire lifecycle. Finally, we ended the article with demonstrations on getting the Linux process state using various tools such as ps, top, and the /proc pseudo-file.\n","wordCount":"1399","inLanguage":"zh-cn","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://yangyingchao.github.io/posts/linux-process-states-baeldung-on-linux/"},"publisher":{"@type":"Organization","name":"MyNotes","logo":{"@type":"ImageObject","url":"https://yangyingchao.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://yangyingchao.github.io accesskey=h title="MyNotes (Alt + H)">MyNotes</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://yangyingchao.github.io/ title=Home><span>Home</span></a></li><li><a href=https://yangyingchao.github.io/posts/ title=Archives><span>Archives</span></a></li><li><a href=https://yangyingchao.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://yangyingchao.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://yangyingchao.github.io/contact/ title="Contact me"><span>Contact me</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Linux Process States</h1><div class=post-meta></div></header><div class=post-content><ul><li>1 <a href=#h:e18e2a33-c94e-4632-9c81-2b7c968471ca>The Linux Process States</a><ul><li>1.1 <a href=#h:82e9a258-9ef3-4b9f-a6e0-43780e2f7c6b>Running or Runnable State (R)</a></li><li>1.2 <a href=#h:af5ed80e-75ba-46bf-bd3c-fc469ce02284>Sleeping State: Interruptible (S) and Uninterruptible (D)</a></li><li>1.3 <a href=#h:928eb1a4-c3a7-45e7-a8d8-031aefe9d89e>Stopped State (T)</a></li><li>1.4 <a href=#h:fc7301f8-68e6-4139-9663-7ea505a75521>Zombie State (Z)</a></li></ul></li><li>2 <a href=#h:0985a112-1b62-4921-9635-078e0ca52dca>Checking Process State</a><ul><li>2.1 <a href=#h:d36c6068-e0db-468a-8b7f-349412d139f2>Displaying Process State Using ps</a></li><li>2.2 <a href=#h:4aa374a8-e81e-499a-aa03-63c5e0949411>Using the top Command</a></li><li>2.3 <a href=#h:5838f424-949c-4b9c-9c93-e77715bfe95c>The /proc Pseudo File</a></li></ul></li><li>3 <a href=#h:3fbb304e-adb8-4e74-94f9-e6a5944f1b26>Summary</a></li></ul><p>本文为摘录，原文为： <a href=https://www.baeldung.com/linux/process-states>https://www.baeldung.com/linux/process-states</a></p><h2 id=h:e18e2a33-c94e-4632-9c81-2b7c968471ca>1 The Linux Process States<a hidden class=anchor aria-hidden=true href=#h:e18e2a33-c94e-4632-9c81-2b7c968471ca>#</a></h2><ul><li>Running or Runnable (R)</li><li>Uninterruptible Sleep (D)</li><li>Interruptable Sleep (S)</li><li>Stopped (T)</li><li>Zombie (Z)</li></ul><p>状态机如下：</p><p></p><figure><img loading=lazy src=/ox-hugo/screenshot@2023-02-15_17:52:09.png width=800px></figure><p>For any Linux process, their starting point is the moment they are created. For example, a parent
process can initiate a child process using the fork() system call. Once it starts, the process
goes into the running or runnable state. While the process is running, it could come into a code
path that requires it to wait for particular resources or signals before proceeding. While waiting
for the resources, the process would voluntarily give up the CPU cycles by going into one of the
two sleeping states.</p><p>Additionally, we could suspend a running process and put it into the stopped state. Usually, this
is done by sending the SIGSTOP signal to the process. A process in this state will continue to
exist until it is killed or resumed with SIGCONT. Finally, the process completes its lifecycle
when it’s terminated and placed into a zombie state until its parent process clears it off the
process table.</p><h3 id=h:82e9a258-9ef3-4b9f-a6e0-43780e2f7c6b>1.1 Running or Runnable State (R)<a hidden class=anchor aria-hidden=true href=#h:82e9a258-9ef3-4b9f-a6e0-43780e2f7c6b>#</a></h3><p>When a new process is started, it’ll be placed into the running or runnable state. In the running
state, the process takes up a CPU core to execute its code and logic. However, the thread
scheduling algorithm might force a running process to give up its execution right. This is to
ensure each process can have a fair share of CPU resources. In this case, the process will be
placed into a run queue, and its state is now a runnable state waiting for its turn to execute.</p><p>Although the running and runnable states are distinct, they are collectively grouped into a single
state denoted by the character <code>R</code>.</p><h3 id=h:af5ed80e-75ba-46bf-bd3c-fc469ce02284>1.2 Sleeping State: Interruptible (S) and Uninterruptible (D)<a hidden class=anchor aria-hidden=true href=#h:af5ed80e-75ba-46bf-bd3c-fc469ce02284>#</a></h3><p>During process execution, it might come across a portion of its code where it needs to request
external resources. Mainly, the request for these resources is IO-based such as to read a file
from disk or make a network request. Since the process couldn’t proceed without the resources, it
would stall and do nothing. In events like these, they should give up their CPU cycles to other
tasks that are ready to run, and hence they go into a sleeping state.</p><p>There are two different sleeping states:</p><ul><li>the uninterruptible sleeping state (D) and</li><li>the interruptible sleepingstate (S)</li></ul><p>The <code>uninterruptible sleeping state (D)</code> will only wait for the resources to be available before
it transit into a runnable state, and it doesn’t react to any signals. On the other hand, the
<code>interruptible sleeping state (S)</code> will react to signals and the availability of resources.</p><h3 id=h:928eb1a4-c3a7-45e7-a8d8-031aefe9d89e>1.3 Stopped State (T)<a hidden class=anchor aria-hidden=true href=#h:928eb1a4-c3a7-45e7-a8d8-031aefe9d89e>#</a></h3><p>From a running or runnable state, we could put a process into the stopped state (T) using the
<code>SIGSTOP</code> or <code>SIGTSTP</code> signals. The difference between both signals is that we send the SIGSTOP
is programmatic, such as running <code>kill -STOP {pid}</code>. Additionally, the process cannot ignore this
signal and will go into the stopped state. On the other hand, we send the SIGTSTP signal using the
keyboard CTRL + Z. Unlike SIGSTOP, the process can optionally ignore this signal and continue to
execute upon receiving SIGTSTP.</p><p>While in this state, we could bring back the process into a running or runnable state by sending
the SIGCONT signal.</p><h3 id=h:fc7301f8-68e6-4139-9663-7ea505a75521>1.4 Zombie State (Z)<a hidden class=anchor aria-hidden=true href=#h:fc7301f8-68e6-4139-9663-7ea505a75521>#</a></h3><p>When a process has completed its execution or is terminated, it’ll send the SIGCHLD signal to the
parent process and go into the zombie state. The zombie process, also known as a defunct process,
will remain in this state until the parent process clears it off from the process table. To clear
the terminated child process off the process table, the parent process must read the exit value of
the child process using the wait() or waitpid() system calls.</p><h2 id=h:0985a112-1b62-4921-9635-078e0ca52dca>2 Checking Process State<a hidden class=anchor aria-hidden=true href=#h:0985a112-1b62-4921-9635-078e0ca52dca>#</a></h2><p>There are multiple ways to check the state of a process is in Linux. For example, we can use
command-line tools like ps and top to check the state of processes. Alternatively, we can consult
the pseudo status file for a particular PID.</p><h3 id=h:d36c6068-e0db-468a-8b7f-349412d139f2>2.1 Displaying Process State Using ps<a hidden class=anchor aria-hidden=true href=#h:d36c6068-e0db-468a-8b7f-349412d139f2>#</a></h3><p>To display process state using ps, let’s run the ps command to include a column that tells us the state of the process:</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:navy;font-weight:700>$</span> ps a
</span></span><span style=display:flex><span><span style=color:#888>    PID TTY      STAT   TIME COMMAND
</span></span></span><span style=display:flex><span><span style=color:#888>   2234 tty2     Ssl+   0:00 /usr/lib/gdm3/gdm-x-session --run-script env GNOME_SHELL_SESSION_MODE=ubuntu /usr/bin/gnome-session --systemd --session=ubuntu
</span></span></span><span style=display:flex><span><span style=color:#888>   2237 tty2     Rl+    0:07 /usr/lib/xorg/Xorg vt2 -displayfd 3 -auth /run/user/1000/gdm/Xauthority -background none -noreset -keeptty -verbose 3
</span></span></span><span style=display:flex><span><span style=color:#888>   2287 tty2     Sl+    0:00 /usr/libexec/gnome-session-binary --systemd --systemd --session=ubuntu
</span></span></span><span style=display:flex><span><span style=color:#888>   2982 pts/0    Ss     0:00 bash
</span></span></span><span style=display:flex><span><span style=color:#888>   3467 pts/0    R+     0:00 ps a
</span></span></span></code></pre></div><p>The first letter of the value under the STAT column indicates the state that the process is
in. For example, the process with PID 2234 is currently in an interruptible sleeping state, as
denoted by the character S. Besides that, we can also observe that process 2237 is currently in
the running or runnable state.</p><p>Additionally, we can see that there are additional characters besides each of the state
characters. These characters indicate several attributes of the state of the process. For example,
the lower capital letter s means the process is the session leader. For a comprehensive list of
the meaning of each of the characters, we can find it on the official man page.</p><h3 id=h:4aa374a8-e81e-499a-aa03-63c5e0949411>2.2 Using the top Command<a hidden class=anchor aria-hidden=true href=#h:4aa374a8-e81e-499a-aa03-63c5e0949411>#</a></h3><p>In Linux, the top command-line tool displays the process details in a real-time fashion. It shows
different aspects of the system, such as memory and CPU usage of individual processes. To see the
process state, let’s run top in the terminal:</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:#888>Tasks: 183 total,   1 running, 182 sleeping,   0 stopped,   0 zombie
</span></span></span><span style=display:flex><span><span style=color:#888></span><span style=color:navy;font-weight:700>%</span>Cpu<span style=color:#666>(</span>s<span style=color:#666>)</span>:  0.7 us,  1.1 sy,  0.0 ni, 97.1 id,  0.4 wa,  0.0 hi,  0.7 si,  0.0 st
</span></span><span style=display:flex><span><span style=color:#888>MiB Mem :   3936.4 total,   1925.0 free,    850.6 used,   1160.8 buff/cache
</span></span></span><span style=display:flex><span><span style=color:#888>MiB Swap:   2048.0 total,   2048.0 free,      0.0 used.   2834.2 avail Mem
</span></span></span><span style=display:flex><span><span style=color:#888>    PID USER  PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND
</span></span></span><span style=display:flex><span><span style=color:#888>   2237 bob   20   0  252252  81740  49204 S   2.3   2.0   0:09.37 Xorg
</span></span></span><span style=display:flex><span><span style=color:#888>   2519 bob   20   0 3428664 375256 125080 S   2.0   9.3   0:19.57 gnome-shell
</span></span></span><span style=display:flex><span><span style=color:#888>   2909 bob   20   0  966852  49944  37308 S   1.0   1.2   0:02.28 gnome-terminal-
</span></span></span><span style=display:flex><span><span style=color:#888>      1 root  20   0  103500  13312   8620 S   0.7   0.3   0:04.44 systemd
</span></span></span><span style=display:flex><span><span style=color:#888>   3588 bob   20   0   20600   3936   3380 R   0.3   0.1   0:00.01 top
</span></span></span><span style=display:flex><span><span style=color:#888>      2 root  20   0       0      0      0 S   0.0   0.0   0:00.00 kthreadd
</span></span></span><span style=display:flex><span><span style=color:#888>      3 root   0 -20       0      0      0 I   0.0   0.0   0:00.00 rcu_gp
</span></span></span></code></pre></div><p>At the bottom section of the output of the top command, we can find the S column, which shows the state of each process.
Contrary to the ps command, the top command displays the state of each process without additional process attributes.</p><h3 id=h:5838f424-949c-4b9c-9c93-e77715bfe95c>2.3 The /proc Pseudo File<a hidden class=anchor aria-hidden=true href=#h:5838f424-949c-4b9c-9c93-e77715bfe95c>#</a></h3><p>The /proc pseudo filesystem contains all the information about the processes in our system. Hence,
we could directly read the state of a process through this pseudo filesystem. The downside of this
approach is we’ll first need to know the PID of the process before we can read its state.</p><p>To obtain the state of a process, we can extract the value from its pseudo status file under /proc/{pid}/status. For
example, we can get the state of the process with PID 2519 by reading the file /proc/2519/status:</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:navy;font-weight:700>$</span> cat /proc/2519/status | grep State
</span></span><span style=display:flex><span><span style=color:#888>State:  S (sleeping)
</span></span></span></code></pre></div><h2 id=h:3fbb304e-adb8-4e74-94f9-e6a5944f1b26>3 Summary<a hidden class=anchor aria-hidden=true href=#h:3fbb304e-adb8-4e74-94f9-e6a5944f1b26>#</a></h2><p>In this tutorial, we’ve looked at the lifecycle of a Linux process. Furthermore, we’ve learned how
we can model a Linux process lifecycle as a finite state machine. Then, we’ve looked at the five
different states as a Linux process undergoes the entire lifecycle. Finally, we ended the article
with demonstrations on getting the Linux process state using various tools such as ps, top, and
the /proc pseudo-file.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://yangyingchao.github.io/tags/process/>process</a></li><li><a href=https://yangyingchao.github.io/tags/status/>status</a></li><li><a href=https://yangyingchao.github.io/tags/linux/>linux</a></li></ul></footer><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//disqus_yH1vi2Slvj.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://yangyingchao.github.io>MyNotes</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>