<!doctype html><html lang=zh-cn dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Bash Mapfile Builtin Command Help and Examples | MyNotes</title><meta name=keywords content="bash,mapfile"><meta name=description content="1 语法 1.1 选项 1.2 注意事项 1.3 退出状态 2 示例 2.1 使用进程替换 (process substitution) 的 mapfile 3 Process substitution 本文为摘录，原文为： https://www.computerhope.com/unix/bash/mapfile.htm 1 语法 mapfile [-n count] [-O origin] [-s count] [-t] [-u fd] [-C callback [-c quantum]] [array] 1.1 选项 mapfile 内建命令"><meta name=author content="Yang, Ying-chao"><link rel=canonical href=https://yangyingchao.github.io/posts/mapfile/><link crossorigin=anonymous href=/assets/css/stylesheet.6a98292fb8fa8cf0f3ba4042d4b75515c04267550f3ad49ff6271b5af9562443.css integrity="sha256-apgpL7j6jPDzukBC1LdVFcBCZ1UPOtSf9icbWvlWJEM=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://yangyingchao.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://yangyingchao.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://yangyingchao.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://yangyingchao.github.io/apple-touch-icon.png><link rel=mask-icon href=https://yangyingchao.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Bash Mapfile Builtin Command Help and Examples"><meta property="og:description" content="1 语法 1.1 选项 1.2 注意事项 1.3 退出状态 2 示例 2.1 使用进程替换 (process substitution) 的 mapfile 3 Process substitution 本文为摘录，原文为： https://www.computerhope.com/unix/bash/mapfile.htm 1 语法 mapfile [-n count] [-O origin] [-s count] [-t] [-u fd] [-C callback [-c quantum]] [array] 1.1 选项 mapfile 内建命令"><meta property="og:type" content="article"><meta property="og:url" content="https://yangyingchao.github.io/posts/mapfile/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-10-19T00:00:00+00:00"><meta property="article:modified_time" content="2023-10-19T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Bash Mapfile Builtin Command Help and Examples"><meta name=twitter:description content="1 语法 1.1 选项 1.2 注意事项 1.3 退出状态 2 示例 2.1 使用进程替换 (process substitution) 的 mapfile 3 Process substitution 本文为摘录，原文为： https://www.computerhope.com/unix/bash/mapfile.htm 1 语法 mapfile [-n count] [-O origin] [-s count] [-t] [-u fd] [-C callback [-c quantum]] [array] 1.1 选项 mapfile 内建命令"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://yangyingchao.github.io/posts/"},{"@type":"ListItem","position":3,"name":"Bash Mapfile Builtin Command Help and Examples","item":"https://yangyingchao.github.io/posts/mapfile/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Bash Mapfile Builtin Command Help and Examples","name":"Bash Mapfile Builtin Command Help and Examples","description":"1 语法 1.1 选项 1.2 注意事项 1.3 退出状态 2 示例 2.1 使用进程替换 (process substitution) 的 mapfile 3 Process substitution 本文为摘录，原文为： https://www.computerhope.com/unix/bash/mapfile.htm 1 语法 mapfile [-n count] [-O origin] [-s count] [-t] [-u fd] [-C callback [-c quantum]] [array] 1.1 选项 mapfile 内建命令","keywords":["bash","mapfile"],"articleBody":" 1 语法 1.1 选项 1.2 注意事项 1.3 退出状态 2 示例 2.1 使用进程替换 (process substitution) 的 mapfile 3 Process substitution 本文为摘录，原文为： https://www.computerhope.com/unix/bash/mapfile.htm\n1 语法 mapfile [-n count] [-O origin] [-s count] [-t] [-u fd] [-C callback [-c quantum]] [array] 1.1 选项 mapfile 内建命令接受以下选项：\n-n count 读取最多 count 行。如果 count 为零，则复制所有可用的行。 -O origin 从索引号 origin 开始将行写入数组 array。默认值为零。 -s count 在写入数组之前丢弃 count 行。 -t 如果任何行以换行符结尾，则去除换行符。 -u fd 从文件描述符 fd 读取行，而不是标准输入。 -C callback 每次读取量子行时执行/评估一个函数/表达式 callback。默认量子值为 1，除非使用-c 另行指定。 -c quantum 指定函数/表达式 callback 在指定了-C 时执行/评估的行数量子。 array 要写入行的数组变量的名称。如果省略了 array，则默认变量 MAPFILE 是目标。 1.2 注意事项 命令名称 readarray 可以作为命令名称 mapfile 的别名使用，其操作没有任何差异。 如果指定了-u 选项，mapfile 将从文件描述符 fd 而不是标准输入中读取。 如果未指定 array，则默认变量 MAPFILE 将用作目标数组变量。 mapfile 命令不是非常可移植的。也就是说，如果你希望确保脚本可以在多种系统上运行，不建议使用 mapfile。它主要提供方便。相同的功能可以使用 read 循环实现，尽管通常 mapfile 的性能更好。\n1.3 退出状态 mapfile 命令返回 0 表示成功，或者 1 表示出现任何问题，例如提供了无效选项，目标变量是只读的或不是数组。\n2 示例 mapfile 命令逐行读取输入，并将每行放入数组变量中。我们提供多行输入。\n我们可以使用 printf 来实现。这是一种简单的打印带有换行符的文本的方法。\n在 printf 的格式字符串中，我们可以包含\"\\n\"（后面紧跟小写字母 n 的反斜杠），以创建换行符。 (\"\\n\"是一个元字符，是表示另一个字符的字符序列，无法直接输入，例如回车键。有关完整的 bash 元字符列表，请参见 bash 引用。)\n这个 printf 命令打印三行文本：\nprintf \"Line 1\\nLine 2\\nLine 3\\n\" Line 1 Line 2 Line 3 我们想使用 mapfile 将每行放入数组的一个元素中。\n默认情况下，mapfile 从标准输入读取数据，所以你可能会尝试像这样将 printf 的输出通过管道传递给 mapfile：\nprintf \"Line 1\\nLine 2\\nLine 3\\n\" | mapfile 你期望默认的数组变量 MAPFILE 包含这些行的值。但是如果你检查 MAPFILE 的值：\necho \"${MAPFILE[@]}\" [一个空行] 变量是空的。为什么呢？\n管道中的每个命令都在一个子 shell 中执行: 一个作为子进程执行的 bash 实例。每个子 shell 都 有自己的环境和词法作用域 - 构成管道中每个子 shell 环境的变量不会传递到其他子 shell 中。 换句话说，一个管道中的元素之间没有共享环境副作用。在上面的例子中，mapfile 正常工作，并设 置了 MAPFILE 的值，但是当命令的子 shell 终止时，变量 MAPFILE 消失了。\n你可以在一个包含 mapfile 命令的子 shell 中输出 MAPFILE 的值来验证这一点，方法是将两者都括在括号中：\nprintf \"Line 1\\nLine 2\\nLine 3\\n\" | (mapfile; echo \"${MAPFILE[@]}\") Line 1 Line 2 Line 3 在上述命令中，echo 打印数组变量 MAPFILE 的所有元素，以空格分隔。由于数据中的换行符，空格 出现在第 2 行和第 3 行的开头。我们用括号显式地创建了子 shell，以便保留 MAPFILE 的值足够 长的时间，以便我们看到这些值。\n我们可以通过使用 -t 来去除换行符来修复换行符：\nprintf \"Line 1\\nLine 2\\nLine 3\\n\" | (mapfile -t; echo \"${MAPFILE[@]}\") Line 1 Line 2 Line 3 （如果我们使用 printf，我们可以在输出中恢复换行符 - 我们将在后续示例中这样做。）\n所以，mapfile 是有效的，但是数组变量对于父 shell 不可访问。然而，通常情况下，你希望 MAPFILE 变量在后续的命令中持续存在。你可以通过进程替换来实现这一点。\n2.1 使用进程替换 (process substitution) 的 mapfile 通过进程替换，我们可以将输出重定向到 mapfile，而不使用管道。\nmapfile -t \u003c \u003c(printf \"Line 1\\nLine 2\\nLine 3\") 让我们分别解释一下这个命令的各个部分：\nmapfile -t : Mapfile 从标准输入获取输入，并从每行的末尾删除换行符(-t)。这通常是你想 要的：仅将行的文本存储在数组元素中，换行符被丢弃。\n\u003c : 第一个\u003c是一个重定向字符。它期望后面跟着一个文件名或文件描述符。该文件的内容将被 重定向到前一个命令的标准输入。\n\u003c( ... ) : 这些字符表示进程替换，它返回一个文件描述符。括号内的命令被执行，它们的输 出被分配给这个文件描述符。在任何 bash 命令中，你可以像文件名一样使用进程替换。\n当你运行整个命令时，mapfile 会安静地读取我们的三行文本，并将每一行放入默认数组变量 MAPFILE 的单独元素中。\n我们可以使用 printf 来打印数组的元素来验证这一点。\nprintf \"%s\" \"${MAPFILE[@]}\" 第一个参数\"%s\"是 printf 的格式字符串。第二个参数\"${MAPFILE[@]}“由 bash 展开。 数组 MAPFILE 的所有元素(”@\")被展开为单独的参数。（有关更多信息，请参见：在 bash 中引用数组元素。）\nLine 1Line2Line 3 如你所见，我们的三行文本被连续打印出来。这是因为我们用-t 删除了换行符，并且 printf 默认不输出换行符。\n要指定 printf 在每行之后打印一个换行符，可以在格式字符串中使用\\n：\nprintf \"%s\\n\" \"${MAPFILE[@]}\" Line 1 Line 2 Line 3 要访问数组的单个元素，请用索引数字替换@。编号是从零开始的，所以 0 是第一个元素的索引，1是第二个元素的索引，依此类推：\nprintf \"%s\\n\" \"${MAPFILE[0]}\" Line 1 printf \"%s\\n\" \"${MAPFILE[2]}\" Line 3 3 Process substitution Process substitution is supported on systems that support named pipes (FIFOs) or the /dev/fd method of naming open files. It takes the form of \u003c(list) or \u003e(list). The process list is run with its input or output connected to a FIFO or some file in /dev/fd. The name of this file is passed as an argument to the current command as the result of the expansion. If the \u003e(list) form is used, writing to the file provides input for list. If the \u003c(list) form is used, the file passed as an argument should be read to obtain the output of list.\nWhen available, process substitution is performed simultaneously with parameter and variable expansion, command substitution, and arithmetic expansion.\n进程替换在支持命名管道（FIFOs）或 /dev/fd 命名打开文件的系统上得到支持。 它具有 \u003c(list) 或 \u003e(list) 的形式。 进程列表与其输入或输出连接到 FIFO 或/dev/fd 中的某个文件，并作为扩展的结果将此文件的名称作为参数传递给当前命令。 如果使用了 \u003e(list) 形式，则写入该文件提供了 list 的输入。 如果使用了 \u003c(list) 形式，则应该读取作为参数传递的文件来获取 list 的输出。 如果可用，进程替换将与参数和变量扩展、命令替换和算术扩展同时进行。 ","wordCount":"2265","inLanguage":"zh-cn","datePublished":"2023-10-19T00:00:00Z","dateModified":"2023-10-19T00:00:00Z","author":[{"@type":"Person","name":"Yang"},{"@type":"Person","name":"Ying-chao"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://yangyingchao.github.io/posts/mapfile/"},"publisher":{"@type":"Organization","name":"MyNotes","logo":{"@type":"ImageObject","url":"https://yangyingchao.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://yangyingchao.github.io accesskey=h title="MyNotes (Alt + H)">MyNotes</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://yangyingchao.github.io/ title=Home><span>Home</span></a></li><li><a href=https://yangyingchao.github.io/posts/ title=Archives><span>Archives</span></a></li><li><a href=https://yangyingchao.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://yangyingchao.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://yangyingchao.github.io/contact/ title="Contact me"><span>Contact me</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Bash Mapfile Builtin Command Help and Examples</h1><div class=post-meta><span title='2023-10-19 00:00:00 +0000 UTC'>October 19, 2023</span>&nbsp;·&nbsp;Yang, Ying-chao</div></header><div class=post-content><ul><li>1 <a href=#h:11d958d0-32e8-40f0-8b56-88270fd85ed4>语法</a><ul><li>1.1 <a href=#h:7ebb0f59-ff05-4de9-9346-346ac68e6cff>选项</a></li><li>1.2 <a href=#h:1ce845c9-394e-41af-a4a7-b280e219050c>注意事项</a></li><li>1.3 <a href=#h:cc5aa7f0-644e-44cf-ba26-4c8948cde1ec>退出状态</a></li></ul></li><li>2 <a href=#h:dcb6eedc-6f65-46fb-9ff8-758618b0cbb1>示例</a><ul><li>2.1 <a href=#h:57b46aaf-3ca8-41dd-b037-b8dc76e09397>使用进程替换 (process substitution) 的 mapfile</a></li></ul></li><li>3 <a href=#h:09d65bb0-ed38-465f-95dd-da3cd65308a2>Process substitution</a></li></ul><p>本文为摘录，原文为： <a href=https://www.computerhope.com/unix/bash/mapfile.htm>https://www.computerhope.com/unix/bash/mapfile.htm</a></p><h2 id=h:11d958d0-32e8-40f0-8b56-88270fd85ed4>1 语法<a hidden class=anchor aria-hidden=true href=#h:11d958d0-32e8-40f0-8b56-88270fd85ed4>#</a></h2><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>mapfile [-n count] [-O origin] [-s count] [-t] [-u fd]
</span></span><span style=display:flex><span>        [-C callback [-c quantum]] [array]
</span></span></code></pre></div><h3 id=h:7ebb0f59-ff05-4de9-9346-346ac68e6cff>1.1 选项<a hidden class=anchor aria-hidden=true href=#h:7ebb0f59-ff05-4de9-9346-346ac68e6cff>#</a></h3><p>mapfile 内建命令接受以下选项：</p><ul><li><code>-n count</code> 读取最多 count 行。如果 count 为零，则复制所有可用的行。</li><li><code>-O origin</code> 从索引号 origin 开始将行写入数组 array。默认值为零。</li><li><code>-s count</code> 在写入数组之前丢弃 count 行。</li><li><code>-t</code> 如果任何行以换行符结尾，则去除换行符。</li><li><code>-u fd</code> 从文件描述符 fd 读取行，而不是标准输入。</li><li><code>-C callback</code> 每次读取量子行时执行/评估一个函数/表达式 callback。默认量子值为 1，除非使用-c 另行指定。</li><li><code>-c quantum</code> 指定函数/表达式 callback 在指定了-C 时执行/评估的行数量子。</li><li><code>array</code> 要写入行的数组变量的名称。如果省略了 array，则默认变量 MAPFILE 是目标。</li></ul><h3 id=h:1ce845c9-394e-41af-a4a7-b280e219050c>1.2 注意事项<a hidden class=anchor aria-hidden=true href=#h:1ce845c9-394e-41af-a4a7-b280e219050c>#</a></h3><ul><li>命令名称 readarray 可以作为命令名称 mapfile 的别名使用，其操作没有任何差异。</li><li>如果指定了-u 选项，mapfile 将从文件描述符 fd 而不是标准输入中读取。</li><li>如果未指定 array，则默认变量 MAPFILE 将用作目标数组变量。</li></ul><p>mapfile 命令不是非常可移植的。也就是说，如果你希望确保脚本可以在多种系统上运行，不建议使用 mapfile。它主要提供方便。相同的功能可以使用 read 循环实现，尽管通常 mapfile 的性能更好。</p><h3 id=h:cc5aa7f0-644e-44cf-ba26-4c8948cde1ec>1.3 退出状态<a hidden class=anchor aria-hidden=true href=#h:cc5aa7f0-644e-44cf-ba26-4c8948cde1ec>#</a></h3><p>mapfile 命令返回 0 表示成功，或者 1 表示出现任何问题，例如提供了无效选项，目标变量是只读的或不是数组。</p><h2 id=h:dcb6eedc-6f65-46fb-9ff8-758618b0cbb1>2 示例<a hidden class=anchor aria-hidden=true href=#h:dcb6eedc-6f65-46fb-9ff8-758618b0cbb1>#</a></h2><p>mapfile 命令逐行读取输入，并将每行放入数组变量中。我们提供多行输入。</p><p>我们可以使用 printf 来实现。这是一种简单的打印带有换行符的文本的方法。</p><p>在 printf 的格式字符串中，我们可以包含"\n"（后面紧跟小写字母 n 的反斜杠），以创建换行符。
("\n"是一个元字符，是表示另一个字符的字符序列，无法直接输入，例如回车键。有关完整的 bash
元字符列表，请参见 bash 引用。)</p><p>这个 printf 命令打印三行文本：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:green>printf</span> <span style=color:#ba2121>&#34;Line 1\nLine 2\nLine 3\n&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Line <span style=color:#666>1</span>
</span></span><span style=display:flex><span>Line <span style=color:#666>2</span>
</span></span><span style=display:flex><span>Line <span style=color:#666>3</span>
</span></span></code></pre></div><p>我们想使用 mapfile 将每行放入数组的一个元素中。</p><p>默认情况下，mapfile 从标准输入读取数据，所以你可能会尝试像这样将 printf 的输出通过管道传递给 mapfile：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:green>printf</span> <span style=color:#ba2121>&#34;Line 1\nLine 2\nLine 3\n&#34;</span> | mapfile
</span></span></code></pre></div><p>你期望默认的数组变量 MAPFILE 包含这些行的值。但是如果你检查 MAPFILE 的值：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:green>echo</span> <span style=color:#ba2121>&#34;</span><span style=color:#b68;font-weight:700>${</span><span style=color:#19177c>MAPFILE</span>[@]<span style=color:#b68;font-weight:700>}</span><span style=color:#ba2121>&#34;</span>
</span></span><span style=display:flex><span><span style=color:#666>[</span>一个空行<span style=color:#666>]</span>
</span></span></code></pre></div><p>变量是空的。为什么呢？</p><p>管道中的每个命令都在一个子 shell 中执行: 一个作为子进程执行的 bash 实例。每个子 shell 都
有自己的环境和词法作用域 - 构成管道中每个子 shell 环境的变量不会传递到其他子 shell 中。
换句话说，一个管道中的元素之间没有共享环境副作用。在上面的例子中，mapfile 正常工作，并设
置了 MAPFILE 的值，但是当命令的子 shell 终止时，变量 MAPFILE 消失了。</p><p>你可以在一个包含 mapfile 命令的子 shell 中输出 MAPFILE 的值来验证这一点，方法是将两者都括在括号中：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:green>printf</span> <span style=color:#ba2121>&#34;Line 1\nLine 2\nLine 3\n&#34;</span> | <span style=color:#666>(</span>mapfile; <span style=color:green>echo</span> <span style=color:#ba2121>&#34;</span><span style=color:#b68;font-weight:700>${</span><span style=color:#19177c>MAPFILE</span>[@]<span style=color:#b68;font-weight:700>}</span><span style=color:#ba2121>&#34;</span><span style=color:#666>)</span>
</span></span><span style=display:flex><span> Line <span style=color:#666>1</span>
</span></span><span style=display:flex><span> Line <span style=color:#666>2</span>
</span></span><span style=display:flex><span> Line <span style=color:#666>3</span>
</span></span></code></pre></div><p>在上述命令中，echo 打印数组变量 MAPFILE 的所有元素，以空格分隔。由于数据中的换行符，空格
出现在第 2 行和第 3 行的开头。我们用括号显式地创建了子 shell，以便保留 MAPFILE 的值足够
长的时间，以便我们看到这些值。</p><p>我们可以通过使用 <code>-t</code> 来去除换行符来修复换行符：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:green>printf</span> <span style=color:#ba2121>&#34;Line 1\nLine 2\nLine 3\n&#34;</span> | <span style=color:#666>(</span>mapfile -t; <span style=color:green>echo</span> <span style=color:#ba2121>&#34;</span><span style=color:#b68;font-weight:700>${</span><span style=color:#19177c>MAPFILE</span>[@]<span style=color:#b68;font-weight:700>}</span><span style=color:#ba2121>&#34;</span><span style=color:#666>)</span>
</span></span><span style=display:flex><span>Line <span style=color:#666>1</span> Line <span style=color:#666>2</span> Line <span style=color:#666>3</span>
</span></span></code></pre></div><p>（如果我们使用 printf，我们可以在输出中恢复换行符 - 我们将在后续示例中这样做。）</p><p>所以，mapfile 是有效的，但是数组变量对于父 shell 不可访问。然而，通常情况下，你希望
MAPFILE 变量在后续的命令中持续存在。你可以通过进程替换来实现这一点。</p><h3 id=h:57b46aaf-3ca8-41dd-b037-b8dc76e09397>2.1 使用进程替换 (process substitution) 的 mapfile<a hidden class=anchor aria-hidden=true href=#h:57b46aaf-3ca8-41dd-b037-b8dc76e09397>#</a></h3><p>通过进程替换，我们可以将输出重定向到 mapfile，而不使用管道。</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>mapfile -t &lt; &lt;<span style=color:#666>(</span><span style=color:green>printf</span> <span style=color:#ba2121>&#34;Line 1\nLine 2\nLine 3&#34;</span><span style=color:#666>)</span>
</span></span></code></pre></div><p>让我们分别解释一下这个命令的各个部分：</p><ul><li><p><code>mapfile -t</code> : Mapfile 从标准输入获取输入，并从每行的末尾删除换行符(-t)。这通常是你想
要的：仅将行的文本存储在数组元素中，换行符被丢弃。</p></li><li><p><code>&lt;</code> : 第一个&lt;是一个重定向字符。它期望后面跟着一个文件名或文件描述符。该文件的内容将被
重定向到前一个命令的标准输入。</p></li><li><p><code>&lt;( ... )</code> : 这些字符表示进程替换，它返回一个文件描述符。括号内的命令被执行，它们的输
出被分配给这个文件描述符。在任何 bash 命令中，你可以像文件名一样使用进程替换。</p></li></ul><p>当你运行整个命令时，mapfile 会安静地读取我们的三行文本，并将每一行放入默认数组变量 MAPFILE 的单独元素中。</p><p>我们可以使用 printf 来打印数组的元素来验证这一点。</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:green>printf</span> <span style=color:#ba2121>&#34;%s&#34;</span> <span style=color:#ba2121>&#34;</span><span style=color:#b68;font-weight:700>${</span><span style=color:#19177c>MAPFILE</span>[@]<span style=color:#b68;font-weight:700>}</span><span style=color:#ba2121>&#34;</span>
</span></span></code></pre></div><p>第一个参数"%s"是 printf 的格式字符串。第二个参数"${MAPFILE[@]}&ldquo;由 bash 展开。
数组 MAPFILE 的所有元素(&rdquo;@")被展开为单独的参数。（有关更多信息，请参见：在 bash 中引用数组元素。）</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>Line 1Line2Line <span style=color:#666>3</span>
</span></span></code></pre></div><p>如你所见，我们的三行文本被连续打印出来。这是因为我们用-t 删除了换行符，并且 printf 默认不输出换行符。</p><p>要指定 printf 在每行之后打印一个换行符，可以在格式字符串中使用\n：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:green>printf</span> <span style=color:#ba2121>&#34;%s\n&#34;</span> <span style=color:#ba2121>&#34;</span><span style=color:#b68;font-weight:700>${</span><span style=color:#19177c>MAPFILE</span>[@]<span style=color:#b68;font-weight:700>}</span><span style=color:#ba2121>&#34;</span>
</span></span><span style=display:flex><span>Line <span style=color:#666>1</span>
</span></span><span style=display:flex><span>Line <span style=color:#666>2</span>
</span></span><span style=display:flex><span>Line <span style=color:#666>3</span>
</span></span></code></pre></div><p>要访问数组的单个元素，请用索引数字替换@。编号是从零开始的，所以 0 是第一个元素的索引，1是第二个元素的索引，依此类推：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:green>printf</span> <span style=color:#ba2121>&#34;%s\n&#34;</span> <span style=color:#ba2121>&#34;</span><span style=color:#b68;font-weight:700>${</span><span style=color:#19177c>MAPFILE</span>[0]<span style=color:#b68;font-weight:700>}</span><span style=color:#ba2121>&#34;</span>
</span></span><span style=display:flex><span>Line <span style=color:#666>1</span>
</span></span><span style=display:flex><span><span style=color:green>printf</span> <span style=color:#ba2121>&#34;%s\n&#34;</span> <span style=color:#ba2121>&#34;</span><span style=color:#b68;font-weight:700>${</span><span style=color:#19177c>MAPFILE</span>[2]<span style=color:#b68;font-weight:700>}</span><span style=color:#ba2121>&#34;</span>
</span></span><span style=display:flex><span>Line <span style=color:#666>3</span>
</span></span></code></pre></div><h2 id=h:09d65bb0-ed38-465f-95dd-da3cd65308a2>3 Process substitution<a hidden class=anchor aria-hidden=true href=#h:09d65bb0-ed38-465f-95dd-da3cd65308a2>#</a></h2><p>Process substitution is supported on systems that support named pipes (FIFOs) or the
/dev/fd method of naming open files. It takes the form of &lt;(list) or >(list). The
process list is run with its input or output connected to a FIFO or some file in
/dev/fd. The name of this file is passed as an argument to the current command as the
result of the expansion. If the >(list) form is used, writing to the file provides
input for list. If the &lt;(list) form is used, the file passed as an argument should be
read to obtain the output of list.</p><p>When available, process substitution is performed simultaneously with parameter and
variable expansion, command substitution, and arithmetic expansion.</p><ul><li>进程替换在支持命名管道（FIFOs）或 /dev/fd 命名打开文件的系统上得到支持。</li><li>它具有 <code>&lt;(list)</code> 或 <code>>(list)</code> 的形式。</li><li>进程列表与其输入或输出连接到 FIFO 或/dev/fd 中的某个文件，并作为扩展的结果将此文件的名称作为参数传递给当前命令。</li><li>如果使用了 <code>>(list)</code> 形式，则写入该文件提供了 list 的输入。</li><li>如果使用了 <code>&lt;(list)</code> 形式，则应该读取作为参数传递的文件来获取 list 的输出。</li><li>如果可用，进程替换将与参数和变量扩展、命令替换和算术扩展同时进行。</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://yangyingchao.github.io/tags/bash/>bash</a></li><li><a href=https://yangyingchao.github.io/tags/mapfile/>mapfile</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://yangyingchao.github.io>MyNotes</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>