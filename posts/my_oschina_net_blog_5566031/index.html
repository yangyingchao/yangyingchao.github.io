<!doctype html><html lang=zh-cn dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>StarRocks 技术内幕 | 基于全局字典的极速字符串查询 | MyNotes</title><meta name=keywords content="starrocks,string,global,low,cardinality"><meta name=description content="1 为什么要引入低基数字典优化 2 为什么需要全局字典 3 如何高效构建全局字典 3.1 通常的分布式字典构建方式 3.2 StarRocks 全局字典的构建 4 如何高效使用全局字典 4.1 CBO"><meta name=author content="Yang, Ying-chao"><link rel=canonical href=https://yangyingchao.github.io/posts/my_oschina_net_blog_5566031/><link crossorigin=anonymous href=/assets/css/stylesheet.6a98292fb8fa8cf0f3ba4042d4b75515c04267550f3ad49ff6271b5af9562443.css integrity="sha256-apgpL7j6jPDzukBC1LdVFcBCZ1UPOtSf9icbWvlWJEM=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://yangyingchao.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://yangyingchao.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://yangyingchao.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://yangyingchao.github.io/apple-touch-icon.png><link rel=mask-icon href=https://yangyingchao.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="StarRocks 技术内幕 | 基于全局字典的极速字符串查询"><meta property="og:description" content="1 为什么要引入低基数字典优化 2 为什么需要全局字典 3 如何高效构建全局字典 3.1 通常的分布式字典构建方式 3.2 StarRocks 全局字典的构建 4 如何高效使用全局字典 4.1 CBO"><meta property="og:type" content="article"><meta property="og:url" content="https://yangyingchao.github.io/posts/my_oschina_net_blog_5566031/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-01-03T00:00:00+00:00"><meta property="article:modified_time" content="2025-01-03T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="StarRocks 技术内幕 | 基于全局字典的极速字符串查询"><meta name=twitter:description content="1 为什么要引入低基数字典优化 2 为什么需要全局字典 3 如何高效构建全局字典 3.1 通常的分布式字典构建方式 3.2 StarRocks 全局字典的构建 4 如何高效使用全局字典 4.1 CBO"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://yangyingchao.github.io/posts/"},{"@type":"ListItem","position":3,"name":"StarRocks 技术内幕 | 基于全局字典的极速字符串查询","item":"https://yangyingchao.github.io/posts/my_oschina_net_blog_5566031/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"StarRocks 技术内幕 | 基于全局字典的极速字符串查询","name":"StarRocks 技术内幕 | 基于全局字典的极速字符串查询","description":"1 为什么要引入低基数字典优化 2 为什么需要全局字典 3 如何高效构建全局字典 3.1 通常的分布式字典构建方式 3.2 StarRocks 全局字典的构建 4 如何高效使用全局字典 4.1 CBO","keywords":["starrocks","string","global","low","cardinality"],"articleBody":" 1 为什么要引入低基数字典优化 2 为什么需要全局字典 3 如何高效构建全局字典 3.1 通常的分布式字典构建方式 3.2 StarRocks 全局字典的构建 4 如何高效使用全局字典 4.1 CBO 优化器的紧密配合 4.2 全局字典的字符串函数优化 5 优化效果 6 总结 本文为摘录，原文为： https://segmentfault.com/a/1190000042326071\n作者：冯浩桉，StarRocks 核心研发工程师，StarRocks Committer\n在数据库和存储系统中，String 类型数据广泛存在。为了提升 String 的处理效率和节省存储资源，出现了很多针对 String 类型进行优化的技术手段，例如提升处 理效率的各类字典应用，提升存储效率的字典编码压缩技术。\n本文主要针对 StarRocks 基于全局字典做的低基数 String 查询优化，揭秘其技术内幕。\n1 为什么要引入低基数字典优化 我们先看下两个 SQL 的对比，表 Lineorder 是 SSB100G 数据集， lo_shippriority 为低基数 int 列， l_shipmode 为低基数 String 列\nmysql\u003e select count(cnt) from ( select count(*) cnt from lineorder group by lo_shippriority) tb; +------------+ | count(cnt) | +------------+ | 1 | +------------+ 1 row in set (3.51 sec) mysql\u003e select count(cnt) from ( select count(*) cnt from lineorder group by lo_shipmode) tb; +------------+ | count(cnt) | +------------+ | 7 | +------------+ 1 row in set (9.33 sec) 可以看到，处理相同数据量的情况下，String 类型的处理时间差不多是 int 类型的 3 倍。\n如果能使用整数类型来替代 String 类型进行数据处理，能够显著提升系统的性能！\n对于利用整型替代字符串进行处理，通常是使用字典编码进行优化。一个 SQL 从输入到输出结果，往往会经过这几个步骤， 几乎每一个阶段都可以使用字典优化：Scan，Filter，Agg，Join，Shuffle，Sort。\n以 Filter 和 Agg 为例：\nFilter (过滤操作)\n​ 对于 Filter 阶段来说，如果某一个列是用字典编码的，我们就可以直接使用编码之后的整数进行比较，而不是直接用 String 进行比较操作。大多数情况下，整数之间的 Compare 性能会高于字符串之间的性能。\nAgg (聚合操作)\n对于 Agg 操作，如果使用了字典编码，我们在聚合中可以使用编码之后的值作为聚合的 Key。如此一来，在聚合操作的 Hash 表构建和查找过程中，可以减少 Hash 表中 Key 的比较代价，同时也能够加快 Hash 值计算，节省内存空间，可以提升聚合操作的速度。\n因此如果我们使用字典的编码方式把字符串转变成整型，在 SQL 执行的很多阶段，都可以起到正向加速的效果。\n使用整型来替代 String 类型进行加速计算，业界通常使用的手段是使用字典优化。但是对于一个复杂系统来说，想要充分 利用字典优化，并不是一件容易的事情。\n2 为什么需要全局字典 在一个分布式执行引擎中，一个 SQL 的执行过程是复杂的。一个查询会存在多个执行阶段，可能会涉及到多个机器多个任务之 间的数据交换。如果想充分利用字典优化，那么需要考虑很多的情况:\n在执行过程中，字典要保证全局性 也就是说在不同的节点之间同样需要维护一个字典。字典数据始终贯穿 SQL 执行的整个生命周期，如果不是全局字典，那么 加速只能在局部进行。例如如果两个执行节点的字典编码不一致，那么在网络传输过程中需要同时把字典传给对端机器，或 者是需要提前把字典码转为字符串再通过网络发送。如果能保证一个字典的全局性，在网络传输中就可以直接使用字典码而 不再需要传输字典。\n查询规划器规划出使用全局字典最高效的方式 如果一个 SQL 在执行过程中没有网络 Shuffle，也不存在潜在应用字典优化的操作，那么不再采用字典优化。 例如 insert into t1 select * from t2 这样的 SQL，中间既不存在数据网络 Shuffle，也不存在可能会应用到低基数优化的算子。那 么这样的 SQL 就不适合使用低基数优化。\n对于一个复杂的、支持实时数据更新的分布式数据库，做到以上两点，并不容易。所以很多的分布式系统，只是用了字典来做局 部加速，并没有做全局加速。\n3 如何高效构建全局字典 为了充分利用字典加速，首先需要解决的问题就是全局字典构建和维护问题。\n3.1 通常的分布式字典构建方式 对于很多系统来说，通常构建全局字典的方式有两种：\n3.1.1 用户指定 Schema，用户在建表的时候，指定对应的列为低基数列 因为用户指定了低基数，那么可以在数据导入的时候，构建全局字典，因为知道了基数范围，全局字典很好维护，按着特定 的规则去生成就好了，存储的代价也不高。\n但是这么做，主要存在的问题在于：\n对用户不友好，需要用户指定 Schema，当基数存在变化，比如基数变高后，不方便维护 无法提升已经运行的系统的性能，必须得重建表并且重新导入数据后才能使用。 3.1.2 导入时候构建全局字典 导入数据时，通过中心节点维护全局字典。每次遇到新的的字符都要通过中心节点创建一个新的字典码。但是这么做的主要问题 是中心节点很容易会成为瓶颈。另外中心节点因为需要同时处理维护并发控制。\n因为维护和构建字典对于很多系统来说都是一个比较困难的事情，因此很多系统，只是在局部使用了局部字典来进行加速，并不 支持字典的全局加速。\n3.2 StarRocks 全局字典的构建 对于 StarRocks 的全局字典的构建，主要有以下考虑：\n自适应，不需要用户通过 Schema 指定特定低基数列，而是根据数据特性，自动选择优化策略。\n尽可能避免单点问题，比如数据导入的时候遇到新的字符串，先通过中心节点更新全局字典。\n3.2.1 数据存储上的字典优化 首先先来看下 StarRocks 的数据存储的结构。\nStarRocks 的基本存储单元为 Segment，每个 Segment 的存储结构如下图所示：\nStarRocks 的存储结构天然为低基数字符串做了字典编码。对于 Segment 上的低基数字符串列会有以下特点：\nFooter 上会存储有这个 Column 特有的字典信息，包括字典码跟原始字符串之间的映射关系；\nData page 上存储的不是原始字符串，而是整数类型的字典码(整型)。\n简单的示意图如下：\n当处理低基数 String column 的时候，直接使用编码后的字典码，而不是直接处理原始的 String 值。当需要原始的 String 值时，使用字典码就可以很方便地在这个列的字典信息里面拿到原始 String 值。这么做带来的明显好处是：\n减少了磁盘 IO。\n可以提前做一些过滤操作，提升处理速度。\n3.2.2 全局字典的构建 StarRocks 支持 CBO 优化器，并且存在一套统计信息机制，那么就可以通过统计信息来收集全局字典。我们通过统计信息，筛 选出潜在的低基数列，再从潜在的低基数列的元数据中读取字典信息，然后做去重/编码操作，就可以收集到全量的字典了。\n3.2.3 全局字典的正确性保证 对于低基数列来说，那么肯定会出现一种情况，在某次导入中导入了新的 String (这个 String 不在全局字典的集合内)，那么 这个时候，原先已经构建的全局字典就没有办法包含所有的字符串的值。因此 StarRocks 需要维护全局字典的有效性。\n全局字典可能失效只会出现在导入， StarRocks 支持了很多类型的数据导入方式，而所有的导入都有两个共同点\n导入产生新的 Segment。\n通过 Master FE 提交事务。\n对于低基数列，所有 Segment 中都必定存在局部字典信息，那么对于一个新的导入，在产生新的 Segment 时，会有几种情况。\n如果新生成的 Segment 没有了局部字典，那么说明这个列很可能是一个高基数列，此时不再适合全局字典优化；\n新生成的 Segment 有局部字典，而且局部字典中的所有 String 是全局字典的子集，这种情况下可以直接使用旧的字典；\n新生成的 Segment 有局部字典，而且局部字典所有的 String 值，部分不在全局字典里，此时全局字典失效已经生效，需要 重新生成全局字典。\n无论出现了上面的哪种情况，在向 FE 中心节点提交的时候，带上这个对应的信息，我们就都能保证全局字典的正确性。\n因为每次导入都是产生新的版本，而查询是支持 MVCC 的，每次查询都会带有一个固定的查询版本号。在某一时刻中，如果出现一个新的版本数据，那么对这个版本 出现之前的所有查询都是不可见的。因此我们查询中如果有新的导入，那么已发起的查询也是不受影响的。\n4 如何高效使用全局字典 4.1 CBO 优化器的紧密配合 对于一个简单的聚合 SQL 来说，其执行过程如下：\n因为 StarRocks 是个分布式系统，其数据分散在多个后端 BE 实例上，且存在多个副本。Segment 内的字典是一个局部的字典， 不能作为全局字典码使用。\n对于一个没有使用全局字典优化的 SQL，在 SCAN NODE 扫描 Segment 数据的过程中就需要将对应把局部的字典码(int)解码成 原始的 String 返回给上层节点。\n如果使用了全局字典优化，我们就不需要 SCAN NODE 节点就进行 Decoded，而是可以将原先的局部字典码(int)，直接映射到全 局字典中的字典码(int)，并在之后的计算处理过程中，均使用全局字典码进行处理。当遇到某些特殊的算子，或者是需要具体 的依赖字符串内部信息的时候，再按着全局字典的信息，Decoded 出原始的 String 值，这样可以充分利用到全局字典的加速。\n下图展示了 SCAN NODE 使用全局字典后，向上传递的数据使用了 int 编码：\n既然我们已经有了全局字典，那么接下来的问题就是更高效地使用好全局字典。\n当存在全局字典的时候，所需要做的比较关键的就是：\n将对 String 的操作转化为对 int 的操作时，从而提升处理的速度，节省对应的资源。\n当遇到无法使用 int 替代 String 的操作时，需要提前将字典码 Decoded 成 String。\n举个例子：\nlineitem 表中的 l_shipmode 是低基数 String 列\n4.1.1 case 1 select count(*) from lineitem group by l_shipmode; 对于这个 SQL 来说，我们需要的只是聚合之后的行数，因此在整个 SQL 的执行过程中，都可以使用 int 来替代 String 进行 处理，并不需要进行 Decoded。\n4.1.2 case 2 select count(*), l_shipmode from lineitem group by l_shipmode; 而对于这个 SQL，需要的不仅仅是聚合后的结果数，还有对应的字符串值。在这里我们需要在结果输出之前，进行 Decoded，将 int 值翻译成 String。\n对于第二条 SQL 来说，其执行过程如下所示：\n可以看到第二条 SQL 多了个 Decode 节点。\n对于低基数 String 列来说，聚合后的行数并不多，这个 Decode 的成本基本可以忽略不计，反而在之前的处理，使用 int 替 代 String 所带来的提升是巨大的。\n那么，对于查询规划器来说，要做的就是选择最合适的 Decode 时期，最大限度地提升性能。\n4.1.3 case 3 select * from lineitem； 对于上面的 SQL 来说，使用全局字典，反而会带来额外的解码的开销。对于这样的 SQL，我们的 CBO 优化器需要正确规划，并 且不会使用字典。\n4.2 全局字典的字符串函数优化 上面的 SQL 都是简单的例子。如果稍微对 SQL 进行一些改动，比如：\nselect count(*), l_shipmode from lineitem group by substr(l_shipmode, 1, 3); 在这个 SQL 中，需要对 String 列进行 substr 运算，并且按着运算后的值进行聚合，这么一看，那肯定是需要在聚合前，插 入一个 Decode 节点来把字典码转为具体的字符串值了，甚至在扫描数据的时候，就需要原始的 String 列了。\n对于这条 SQL 来说，使用 int 值替代 String 来进行聚合，所带来的提升是巨大的，我们应该发挥全局字典的最大价值。\n对于大多数的字符串函数来说，他们的计算往往有下面的一些特点:\n对于固定的输入，输出也是固定，最简单的比如 substring 函数, substring(\"abc\", 1, 2) 的结果一定是 “AB”；\n大部分 String 操作，都符合上面的定义。\n既然对于单个 String 的运算，输出是固定的，那么对于固定集合的 String 的运算，其结果集合也一定是固定的，比如对 {\"s1\", \"s2\", \"s11\" } 进行 substring (str, 1, 2) 运算，其结果也一定是 {\"s1\", \"s2\", \"s11\" } 。\n很明显，当有了低基数全局字典，全局字典里面的 String 取值，就是固定的集合。因此，我们将对单个 String 的操作，转化 为对 String 集合的操作，而这个操作，在 SQL 执行的过程中，只需要执行一次。\n以上面的 substr SQL 为例子，当低基数列 l_shipmode 存在全局字典时，我们运用 substr 对全局字典进行计算，计算的示意图如下：\n对于上图所示的全局字典来说，substring(“hello”, 1, 2) 和 substring(“world”, 1, 3)产生的结果集是 {“he”, “wo”}。我 们会把所有的输出都加入到一个新的字典中，与此同时，我们还得到了两个字典之间的转换关系。\n例如字典码 1 的输入在经过这个函数之后会变成新字典的字典码 1。\n有了这个映射关系，对输入的数据，进行 substring 操作，那就很简单了，因为我们输入的数据是全局字典码，并不是原始的 String，我们只需要按着 substring 中两个字典之间的转换关系，将对应的字典码通过映射输出成对应的新字典码，就完成了相 关函数的计算。\n对于这类的字符串函数，并不需要进行 Decode 获取原始 String 来调用函数处理，而且这种映射的方法，对于直接使用字符串 进行计算也有一定的性能提升，尤其是对复杂的表达式。\n5 优化效果 我们选取了几组典型的 SQL，对比了开启低基数下的性能。\nStarRocks 2.0+ 后的版本默认会开启低基数字典优化：\nset cbo_enable_low_cardinality_optimize = true; 对比 SQL：\nselect count(*),lo_shipmode from lineorder group by lo_shipmode; select count(distinct lo_shipmode) from lineorder; select count(*),lo_shipmode,lo_orderpriority from lineorder group by lo_shipmode,lo_orderpriority; select count(*),lo_shipmode,lo_orderpriority from lineorder group by lo_shipmode,lo_orderpriority,lo_shippriority; select count(*) from (select count(*) from lineorder_flat group by lo_shipmode,lo_orderpriority,p_category,s_nation,c_nation) t; select count(*) from (select count(*) from lineorder_flat group by lo_shipmode,lo_orderpriority,p_category,s_nation,c_nation,p_mfgr) t; select count(*) from (select count(*) from lineorder_flat group by substr(lo_shipmode,2),lower(lo_orderpriority),p_category,s_nation,c_nation,s_region,p_mfgr) t; select count(*),lo_shipmode,s_city from lineorder_flat group by lo_shipmode,s_city; select count(*) from lineorder_flat group by c_city,s_city; select count(*) from lineorder_flat group by c_city,s_city,c_nation,s_nation; select count(*) from lineorder_flat group by lo_shipmode,lo_orderdate; select count(*) from lineorder_flat group by lo_orderdate,s_nation,s_region; 对比结果：\n从效果上来看，开启低基数优化的 SQL 比没开启低基数优化的 SQL 平均快了 3 倍。\n6 总结 StarRocks 的低基数 String 优化，主要的特点有:\n全局的字典加速，作用于 SQL 执行的各个阶段。\n基于 CBO 优化器的，自适应选择全局字典的加速策略。\n无 Schema，自适应，用户不需要指定特定的低基数列。\n对用户透明，不需要重新导数据。\n高性能，业界领先水平。\n支持场景丰富，兼容大部分 String 处理逻辑。\n","wordCount":"4922","inLanguage":"zh-cn","datePublished":"2025-01-03T00:00:00Z","dateModified":"2025-01-03T00:00:00Z","author":[{"@type":"Person","name":"Yang"},{"@type":"Person","name":"Ying-chao"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://yangyingchao.github.io/posts/my_oschina_net_blog_5566031/"},"publisher":{"@type":"Organization","name":"MyNotes","logo":{"@type":"ImageObject","url":"https://yangyingchao.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://yangyingchao.github.io accesskey=h title="MyNotes (Alt + H)">MyNotes</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://yangyingchao.github.io/ title=Home><span>Home</span></a></li><li><a href=https://yangyingchao.github.io/posts/ title=Archives><span>Archives</span></a></li><li><a href=https://yangyingchao.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://yangyingchao.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://yangyingchao.github.io/contact/ title="Contact me"><span>Contact me</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>StarRocks 技术内幕 | 基于全局字典的极速字符串查询</h1><div class=post-meta><span title='2025-01-03 00:00:00 +0000 UTC'>January 3, 2025</span>&nbsp;·&nbsp;Yang, Ying-chao</div></header><div class=post-content><ul><li>1 <a href=#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%BC%95%E5%85%A5%E4%BD%8E%E5%9F%BA%E6%95%B0%E5%AD%97%E5%85%B8%E4%BC%98%E5%8C%96>为什么要引入低基数字典优化</a></li><li>2 <a href=#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%85%A8%E5%B1%80%E5%AD%97%E5%85%B8>为什么需要全局字典</a></li><li>3 <a href=#%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E6%9E%84%E5%BB%BA%E5%85%A8%E5%B1%80%E5%AD%97%E5%85%B8>如何高效构建全局字典</a><ul><li>3.1 <a href=#%E9%80%9A%E5%B8%B8%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%97%E5%85%B8%E6%9E%84%E5%BB%BA%E6%96%B9%E5%BC%8F>通常的分布式字典构建方式</a></li><li>3.2 <a href=#starrocks-%E5%85%A8%E5%B1%80%E5%AD%97%E5%85%B8%E7%9A%84%E6%9E%84%E5%BB%BA>StarRocks 全局字典的构建</a></li></ul></li><li>4 <a href=#%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E4%BD%BF%E7%94%A8%E5%85%A8%E5%B1%80%E5%AD%97%E5%85%B8>如何高效使用全局字典</a><ul><li>4.1 <a href=#cbo-%E4%BC%98%E5%8C%96%E5%99%A8%E7%9A%84%E7%B4%A7%E5%AF%86%E9%85%8D%E5%90%88>CBO 优化器的紧密配合</a></li><li>4.2 <a href=#%E5%85%A8%E5%B1%80%E5%AD%97%E5%85%B8%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0%E4%BC%98%E5%8C%96>全局字典的字符串函数优化</a></li></ul></li><li>5 <a href=#%E4%BC%98%E5%8C%96%E6%95%88%E6%9E%9C>优化效果</a></li><li>6 <a href=#%E6%80%BB%E7%BB%93>总结</a></li></ul><p>本文为摘录，原文为： <a href=https://segmentfault.com/a/1190000042326071>https://segmentfault.com/a/1190000042326071</a></p><p><code>作者：冯浩桉，StarRocks 核心研发工程师，StarRocks Committer</code></p><p>在数据库和存储系统中，String 类型数据广泛存在。为了提升 String 的处理效率和节省存储资源，出现了很多针对 String 类型进行优化的技术手段，例如提升处
理效率的各类字典应用，提升存储效率的字典编码压缩技术。</p><p>本文主要针对 StarRocks 基于全局字典做的低基数 String 查询优化，揭秘其技术内幕。</p><h2 id=为什么要引入低基数字典优化>1 为什么要引入低基数字典优化<a hidden class=anchor aria-hidden=true href=#为什么要引入低基数字典优化>#</a></h2><p>我们先看下两个 SQL 的对比，表 Lineorder 是 SSB100G 数据集， <code>lo_shippriority</code> 为低基数 int 列， <code>l_shipmode</code> 为低基数 String 列</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span>mysql<span style=color:#666>&gt;</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>select</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>count</span>(cnt)<span style=color:#bbb> </span><span style=color:green;font-weight:700>from</span><span style=color:#bbb> </span>(<span style=color:#bbb> </span><span style=color:green;font-weight:700>select</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>count</span>(<span style=color:#666>*</span>)<span style=color:#bbb> </span>cnt<span style=color:#bbb> </span><span style=color:green;font-weight:700>from</span><span style=color:#bbb> </span>lineorder<span style=color:#bbb> </span><span style=color:green;font-weight:700>group</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>by</span><span style=color:#bbb> </span>lo_shippriority)<span style=color:#bbb> </span>tb;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#666>+</span><span style=color:#408080;font-style:italic>------------+
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span><span style=color:#666>|</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>count</span>(cnt)<span style=color:#bbb> </span><span style=color:#666>|</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#666>+</span><span style=color:#408080;font-style:italic>------------+
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span><span style=color:#666>|</span><span style=color:#bbb>          </span><span style=color:#666>1</span><span style=color:#bbb> </span><span style=color:#666>|</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#666>+</span><span style=color:#408080;font-style:italic>------------+
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span><span style=color:#666>1</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>row</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>in</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>set</span><span style=color:#bbb> </span>(<span style=color:#666>3</span>.<span style=color:#666>51</span><span style=color:#bbb> </span>sec)<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>mysql<span style=color:#666>&gt;</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>select</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>count</span>(cnt)<span style=color:#bbb> </span><span style=color:green;font-weight:700>from</span><span style=color:#bbb> </span>(<span style=color:#bbb> </span><span style=color:green;font-weight:700>select</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>count</span>(<span style=color:#666>*</span>)<span style=color:#bbb> </span>cnt<span style=color:#bbb> </span><span style=color:green;font-weight:700>from</span><span style=color:#bbb> </span>lineorder<span style=color:#bbb> </span><span style=color:green;font-weight:700>group</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>by</span><span style=color:#bbb> </span>lo_shipmode)<span style=color:#bbb> </span>tb;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#666>+</span><span style=color:#408080;font-style:italic>------------+
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span><span style=color:#666>|</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>count</span>(cnt)<span style=color:#bbb> </span><span style=color:#666>|</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#666>+</span><span style=color:#408080;font-style:italic>------------+
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span><span style=color:#666>|</span><span style=color:#bbb>          </span><span style=color:#666>7</span><span style=color:#bbb> </span><span style=color:#666>|</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#666>+</span><span style=color:#408080;font-style:italic>------------+
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span><span style=color:#666>1</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>row</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>in</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>set</span><span style=color:#bbb> </span>(<span style=color:#666>9</span>.<span style=color:#666>33</span><span style=color:#bbb> </span>sec)<span style=color:#bbb>
</span></span></span></code></pre></div><p>可以看到，处理相同数据量的情况下，String 类型的处理时间差不多是 int 类型的 3 倍。</p><p>如果能使用整数类型来替代 String 类型进行数据处理，能够显著提升系统的性能！</p><p>对于利用整型替代字符串进行处理，通常是使用字典编码进行优化。一个 SQL 从输入到输出结果，往往会经过这几个步骤，
几乎每一个阶段都可以使用字典优化：Scan，Filter，Agg，Join，Shuffle，Sort。</p><p>以 Filter 和 Agg 为例：</p><ul><li><p>Filter (过滤操作)</p><figure><img loading=lazy src=/ox-hugo/347ac70abb2_f8b6b51c8af54d8d1e0ed1ca959a5c6e.png width=800px></figure></li></ul><p>​ 对于 Filter 阶段来说，如果某一个列是用字典编码的，我们就可以直接使用编码之后的整数进行比较，而不是直接用 String
进行比较操作。大多数情况下，整数之间的 Compare 性能会高于字符串之间的性能。</p><ul><li><p>Agg (聚合操作)</p><figure><img loading=lazy src=/ox-hugo/347ac70abb2_d9efa9be7a51c8e9f21d737efad4f4fe.jpeg width=800px></figure><p>对于 Agg 操作，如果使用了字典编码，我们在聚合中可以使用编码之后的值作为聚合的 Key。如此一来，在聚合操作的
Hash 表构建和查找过程中，可以减少 Hash 表中 Key 的比较代价，同时也能够加快 Hash 值计算，节省内存空间，可以提升聚合操作的速度。</p><p>因此如果我们使用字典的编码方式把字符串转变成整型，在 SQL 执行的很多阶段，都可以起到正向加速的效果。</p><p>使用整型来替代 String 类型进行加速计算，业界通常使用的手段是使用字典优化。但是对于一个复杂系统来说，想要充分
利用字典优化，并不是一件容易的事情。</p></li></ul><h2 id=为什么需要全局字典>2 为什么需要全局字典<a hidden class=anchor aria-hidden=true href=#为什么需要全局字典>#</a></h2><p>在一个分布式执行引擎中，一个 SQL 的执行过程是复杂的。一个查询会存在多个执行阶段，可能会涉及到多个机器多个任务之
间的数据交换。如果想充分利用字典优化，那么需要考虑很多的情况:</p><ul><li><p>在执行过程中，字典要保证全局性
也就是说在不同的节点之间同样需要维护一个字典。字典数据始终贯穿 SQL 执行的整个生命周期，如果不是全局字典，那么
加速只能在局部进行。例如如果两个执行节点的字典编码不一致，那么在网络传输过程中需要同时把字典传给对端机器，或
者是需要提前把字典码转为字符串再通过网络发送。如果能保证一个字典的全局性，在网络传输中就可以直接使用字典码而
不再需要传输字典。</p></li><li><p>查询规划器规划出使用全局字典最高效的方式
如果一个 SQL 在执行过程中没有网络 Shuffle，也不存在潜在应用字典优化的操作，那么不再采用字典优化。
例如 <code>insert into t1 select * from t2</code> 这样的 SQL，中间既不存在数据网络 Shuffle，也不存在可能会应用到低基数优化的算子。那
么这样的 SQL 就不适合使用低基数优化。</p></li></ul><p>对于一个复杂的、支持实时数据更新的分布式数据库，做到以上两点，并不容易。所以很多的分布式系统，只是用了字典来做局
部加速，并没有做全局加速。</p><figure><img loading=lazy src=/ox-hugo/347ac70abb2_8adc293a54bde3bc2f10c32358fb5682.png width=800px></figure><h2 id=如何高效构建全局字典>3 如何高效构建全局字典<a hidden class=anchor aria-hidden=true href=#如何高效构建全局字典>#</a></h2><p>为了充分利用字典加速，首先需要解决的问题就是全局字典构建和维护问题。</p><h3 id=通常的分布式字典构建方式>3.1 通常的分布式字典构建方式<a hidden class=anchor aria-hidden=true href=#通常的分布式字典构建方式>#</a></h3><p>对于很多系统来说，通常构建全局字典的方式有两种：</p><h4 id=用户指定-schema-用户在建表的时候-指定对应的列为低基数列>3.1.1 用户指定 Schema，用户在建表的时候，指定对应的列为低基数列<a hidden class=anchor aria-hidden=true href=#用户指定-schema-用户在建表的时候-指定对应的列为低基数列>#</a></h4><p>因为用户指定了低基数，那么可以在数据导入的时候，构建全局字典，因为知道了基数范围，全局字典很好维护，按着特定
的规则去生成就好了，存储的代价也不高。</p><p>但是这么做，主要存在的问题在于：</p><ul><li>对用户不友好，需要用户指定 Schema，当基数存在变化，比如基数变高后，不方便维护</li><li>无法提升已经运行的系统的性能，必须得重建表并且重新导入数据后才能使用。</li></ul><h4 id=导入时候构建全局字典>3.1.2 导入时候构建全局字典<a hidden class=anchor aria-hidden=true href=#导入时候构建全局字典>#</a></h4><p>导入数据时，通过中心节点维护全局字典。每次遇到新的的字符都要通过中心节点创建一个新的字典码。但是这么做的主要问题
是中心节点很容易会成为瓶颈。另外中心节点因为需要同时处理维护并发控制。</p><p>因为维护和构建字典对于很多系统来说都是一个比较困难的事情，因此很多系统，只是在局部使用了局部字典来进行加速，并不
支持字典的全局加速。</p><h3 id=starrocks-全局字典的构建>3.2 StarRocks 全局字典的构建<a hidden class=anchor aria-hidden=true href=#starrocks-全局字典的构建>#</a></h3><p>对于 StarRocks 的全局字典的构建，主要有以下考虑：</p><ul><li><p>自适应，不需要用户通过 Schema 指定特定低基数列，而是根据数据特性，自动选择优化策略。</p></li><li><p>尽可能避免单点问题，比如数据导入的时候遇到新的字符串，先通过中心节点更新全局字典。</p></li></ul><h4 id=数据存储上的字典优化>3.2.1 数据存储上的字典优化<a hidden class=anchor aria-hidden=true href=#数据存储上的字典优化>#</a></h4><p>首先先来看下 StarRocks 的数据存储的结构。</p><p>StarRocks 的基本存储单元为 Segment，每个 Segment 的存储结构如下图所示：</p><figure><img loading=lazy src=/ox-hugo/347ac70abb2_2c29ab820d61742525b464ea481883fe.png width=800px></figure><p>StarRocks 的存储结构天然为低基数字符串做了字典编码。对于 Segment 上的低基数字符串列会有以下特点：</p><ul><li><p>Footer 上会存储有这个 Column 特有的字典信息，包括字典码跟原始字符串之间的映射关系；</p></li><li><p>Data page 上存储的不是原始字符串，而是整数类型的字典码(整型)。</p></li></ul><p>简单的示意图如下：</p><figure><img loading=lazy src=/ox-hugo/347ac70abb2_c1fb6d14080a67f84dc2aabe20a1e148.png width=800px></figure><p>当处理低基数 String column 的时候，直接使用编码后的字典码，而不是直接处理原始的 String 值。当需要原始的 String
值时，使用字典码就可以很方便地在这个列的字典信息里面拿到原始 String 值。这么做带来的明显好处是：</p><ul><li><p>减少了磁盘 IO。</p></li><li><p>可以提前做一些过滤操作，提升处理速度。</p></li></ul><h4 id=全局字典的构建>3.2.2 全局字典的构建<a hidden class=anchor aria-hidden=true href=#全局字典的构建>#</a></h4><p>StarRocks 支持 CBO 优化器，并且存在一套统计信息机制，那么就可以通过统计信息来收集全局字典。我们通过统计信息，筛
选出潜在的低基数列，再从潜在的低基数列的元数据中读取字典信息，然后做去重/编码操作，就可以收集到全量的字典了。</p><h4 id=全局字典的正确性保证>3.2.3 全局字典的正确性保证<a hidden class=anchor aria-hidden=true href=#全局字典的正确性保证>#</a></h4><p>对于低基数列来说，那么肯定会出现一种情况，在某次导入中导入了新的 String (这个 String 不在全局字典的集合内)，那么
这个时候，原先已经构建的全局字典就没有办法包含所有的字符串的值。因此 StarRocks 需要维护全局字典的有效性。</p><p>全局字典可能失效只会出现在导入， StarRocks 支持了很多类型的数据导入方式，而所有的导入都有两个共同点</p><ul><li><p>导入产生新的 Segment。</p></li><li><p>通过 Master FE 提交事务。</p></li></ul><p>对于低基数列，所有 Segment 中都必定存在局部字典信息，那么对于一个新的导入，在产生新的 Segment 时，会有几种情况。</p><ul><li><p>如果新生成的 Segment 没有了局部字典，那么说明这个列很可能是一个高基数列，此时不再适合全局字典优化；</p></li><li><p>新生成的 Segment 有局部字典，而且局部字典中的所有 String 是全局字典的子集，这种情况下可以直接使用旧的字典；</p></li><li><p>新生成的 Segment 有局部字典，而且局部字典所有的 String 值，部分不在全局字典里，此时全局字典失效已经生效，需要
重新生成全局字典。</p></li></ul><p>无论出现了上面的哪种情况，在向 FE 中心节点提交的时候，带上这个对应的信息，我们就都能保证全局字典的正确性。</p><p>因为每次导入都是产生新的版本，而查询是支持 MVCC 的，每次查询都会带有一个固定的查询版本号。在某一时刻中，如果出现一个新的版本数据，那么对这个版本
出现之前的所有查询都是不可见的。因此我们查询中如果有新的导入，那么已发起的查询也是不受影响的。</p><h2 id=如何高效使用全局字典>4 如何高效使用全局字典<a hidden class=anchor aria-hidden=true href=#如何高效使用全局字典>#</a></h2><h3 id=cbo-优化器的紧密配合>4.1 CBO 优化器的紧密配合<a hidden class=anchor aria-hidden=true href=#cbo-优化器的紧密配合>#</a></h3><p>对于一个简单的聚合 SQL 来说，其执行过程如下：</p><figure><img loading=lazy src=/ox-hugo/347ac70abb2_fb6796e1d13e7375ced32b8a03236a6d.png></figure><p>因为 StarRocks 是个分布式系统，其数据分散在多个后端 BE 实例上，且存在多个副本。Segment 内的字典是一个局部的字典，
不能作为全局字典码使用。</p><p>对于一个没有使用全局字典优化的 SQL，在 SCAN NODE 扫描 Segment 数据的过程中就需要将对应把局部的字典码(int)解码成
原始的 String 返回给上层节点。</p><p>如果使用了全局字典优化，我们就不需要 SCAN NODE 节点就进行 Decoded，而是可以将原先的局部字典码(int)，直接映射到全
局字典中的字典码(int)，并在之后的计算处理过程中，均使用全局字典码进行处理。当遇到某些特殊的算子，或者是需要具体
的依赖字符串内部信息的时候，再按着全局字典的信息，Decoded 出原始的 String 值，这样可以充分利用到全局字典的加速。</p><p>下图展示了 SCAN NODE 使用全局字典后，向上传递的数据使用了 int 编码：</p><figure><img loading=lazy src=/ox-hugo/347ac70abb2_b6f7e5e8c1a2dd5ac1f63aeaab0ad5e2.jpeg width=800px></figure><p>既然我们已经有了全局字典，那么接下来的问题就是更高效地使用好全局字典。</p><p>当存在全局字典的时候，所需要做的比较关键的就是：</p><ul><li><p>将对 String 的操作转化为对 int 的操作时，从而提升处理的速度，节省对应的资源。</p></li><li><p>当遇到无法使用 int 替代 String 的操作时，需要提前将字典码 Decoded 成 String。</p></li></ul><p>举个例子：</p><p>lineitem 表中的 l_shipmode 是低基数 String 列</p><h4 id=case-1>4.1.1 case 1<a hidden class=anchor aria-hidden=true href=#case-1>#</a></h4><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:green;font-weight:700>select</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>count</span>(<span style=color:#666>*</span>)<span style=color:#bbb> </span><span style=color:green;font-weight:700>from</span><span style=color:#bbb> </span>lineitem<span style=color:#bbb> </span><span style=color:green;font-weight:700>group</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>by</span><span style=color:#bbb> </span>l_shipmode;<span style=color:#bbb>
</span></span></span></code></pre></div><p>对于这个 SQL 来说，我们需要的只是聚合之后的行数，因此在整个 SQL 的执行过程中，都可以使用 int 来替代 String 进行
处理，并不需要进行 Decoded。</p><figure><img loading=lazy src=/ox-hugo/347ac70abb2_e706b2a2f766822d4ec62cde08192149.png></figure><h4 id=case-2>4.1.2 case 2<a hidden class=anchor aria-hidden=true href=#case-2>#</a></h4><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:green;font-weight:700>select</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>count</span>(<span style=color:#666>*</span>),<span style=color:#bbb> </span>l_shipmode<span style=color:#bbb> </span><span style=color:green;font-weight:700>from</span><span style=color:#bbb> </span>lineitem<span style=color:#bbb> </span><span style=color:green;font-weight:700>group</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>by</span><span style=color:#bbb> </span>l_shipmode;<span style=color:#bbb>
</span></span></span></code></pre></div><p>而对于这个 SQL，需要的不仅仅是聚合后的结果数，还有对应的字符串值。在这里我们需要在结果输出之前，进行 Decoded，将
int 值翻译成 String。</p><p>对于第二条 SQL 来说，其执行过程如下所示：</p><figure><img loading=lazy src=/ox-hugo/347ac70abb2_d18ba0f85a95adfb0a6d50b29fa6b986.png></figure><p>可以看到第二条 SQL 多了个 Decode 节点。</p><p>对于低基数 String 列来说，聚合后的行数并不多，这个 Decode 的成本基本可以忽略不计，反而在之前的处理，使用 int 替
代 String 所带来的提升是巨大的。</p><p>那么，对于查询规划器来说，要做的就是选择最合适的 Decode 时期，最大限度地提升性能。</p><h4 id=case-3>4.1.3 case 3<a hidden class=anchor aria-hidden=true href=#case-3>#</a></h4><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:green;font-weight:700>select</span><span style=color:#bbb> </span><span style=color:#666>*</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>from</span><span style=color:#bbb> </span>lineitem<span>；</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>对于上面的 SQL 来说，使用全局字典，反而会带来额外的解码的开销。对于这样的 SQL，我们的 CBO 优化器需要正确规划，并
且不会使用字典。</p><h3 id=全局字典的字符串函数优化>4.2 全局字典的字符串函数优化<a hidden class=anchor aria-hidden=true href=#全局字典的字符串函数优化>#</a></h3><p>上面的 SQL 都是简单的例子。如果稍微对 SQL 进行一些改动，比如：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:green;font-weight:700>select</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>count</span>(<span style=color:#666>*</span>),<span style=color:#bbb> </span>l_shipmode<span style=color:#bbb> </span><span style=color:green;font-weight:700>from</span><span style=color:#bbb> </span>lineitem<span style=color:#bbb> </span><span style=color:green;font-weight:700>group</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>by</span><span style=color:#bbb> </span>substr(l_shipmode,<span style=color:#bbb> </span><span style=color:#666>1</span>,<span style=color:#bbb> </span><span style=color:#666>3</span>);<span style=color:#bbb>
</span></span></span></code></pre></div><p>在这个 SQL 中，需要对 String 列进行 substr 运算，并且按着运算后的值进行聚合，这么一看，那肯定是需要在聚合前，插
入一个 Decode 节点来把字典码转为具体的字符串值了，甚至在扫描数据的时候，就需要原始的 String 列了。</p><p>对于这条 SQL 来说，使用 int 值替代 String 来进行聚合，所带来的提升是巨大的，我们应该发挥全局字典的最大价值。</p><p>对于大多数的字符串函数来说，他们的计算往往有下面的一些特点:</p><ul><li><p>对于固定的输入，输出也是固定，最简单的比如 substring 函数, <code>substring("abc", 1, 2)</code> 的结果一定是 &ldquo;AB&rdquo;；</p></li><li><p>大部分 String 操作，都符合上面的定义。</p></li></ul><p>既然对于单个 String 的运算，输出是固定的，那么对于固定集合的 String 的运算，其结果集合也一定是固定的，比如对
<code>{"s1", "s2", "s11" }</code> 进行 <code>substring (str, 1, 2)</code> 运算，其结果也一定是 <code>{"s1", "s2", "s11" }</code> 。</p><p>很明显，当有了低基数全局字典，全局字典里面的 String 取值，就是固定的集合。因此，我们将对单个 String 的操作，转化
为对 String 集合的操作，而这个操作，在 SQL 执行的过程中，只需要执行一次。</p><p>以上面的 substr SQL 为例子，当低基数列 l_shipmode 存在全局字典时，我们运用 substr 对全局字典进行计算，计算的示意图如下：</p><figure><img loading=lazy src=/ox-hugo/347ac70abb2_90ac9dd0770b607431da71da8160dec1.png width=800px></figure><p>对于上图所示的全局字典来说，substring(&ldquo;hello&rdquo;, 1, 2) 和 substring(&ldquo;world&rdquo;, 1, 3)产生的结果集是 {&ldquo;he&rdquo;, &ldquo;wo&rdquo;}。我
们会把所有的输出都加入到一个新的字典中，与此同时，我们还得到了两个字典之间的转换关系。</p><p>例如字典码 1 的输入在经过这个函数之后会变成新字典的字典码 1。</p><p>有了这个映射关系，对输入的数据，进行 substring 操作，那就很简单了，因为我们输入的数据是全局字典码，并不是原始的
String，我们只需要按着 substring 中两个字典之间的转换关系，将对应的字典码通过映射输出成对应的新字典码，就完成了相
关函数的计算。</p><figure><img loading=lazy src=/ox-hugo/347ac70abb2_ce2a3281a4245d633864f36f9209ee31.png></figure><p>对于这类的字符串函数，并不需要进行 Decode 获取原始 String 来调用函数处理，而且这种映射的方法，对于直接使用字符串
进行计算也有一定的性能提升，尤其是对复杂的表达式。</p><h2 id=优化效果>5 优化效果<a hidden class=anchor aria-hidden=true href=#优化效果>#</a></h2><p>我们选取了几组典型的 SQL，对比了开启低基数下的性能。</p><p>StarRocks 2.0+ 后的版本默认会开启低基数字典优化：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:green;font-weight:700>set</span><span style=color:#bbb> </span>cbo_enable_low_cardinality_optimize<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>true</span>;<span style=color:#bbb>
</span></span></span></code></pre></div><p>对比 SQL：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:green;font-weight:700>select</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>count</span>(<span style=color:#666>*</span>),lo_shipmode<span style=color:#bbb> </span><span style=color:green;font-weight:700>from</span><span style=color:#bbb> </span>lineorder<span style=color:#bbb> </span><span style=color:green;font-weight:700>group</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>by</span><span style=color:#bbb> </span>lo_shipmode;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>select</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>count</span>(<span style=color:green;font-weight:700>distinct</span><span style=color:#bbb> </span>lo_shipmode)<span style=color:#bbb> </span><span style=color:green;font-weight:700>from</span><span style=color:#bbb> </span>lineorder;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>select</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>count</span>(<span style=color:#666>*</span>),lo_shipmode,lo_orderpriority<span style=color:#bbb> </span><span style=color:green;font-weight:700>from</span><span style=color:#bbb> </span>lineorder<span style=color:#bbb> </span><span style=color:green;font-weight:700>group</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>by</span><span style=color:#bbb> </span>lo_shipmode,lo_orderpriority;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>select</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>count</span>(<span style=color:#666>*</span>),lo_shipmode,lo_orderpriority<span style=color:#bbb> </span><span style=color:green;font-weight:700>from</span><span style=color:#bbb> </span>lineorder<span style=color:#bbb> </span><span style=color:green;font-weight:700>group</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>by</span><span style=color:#bbb> </span>lo_shipmode,lo_orderpriority,lo_shippriority;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>select</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>count</span>(<span style=color:#666>*</span>)<span style=color:#bbb> </span><span style=color:green;font-weight:700>from</span><span style=color:#bbb> </span>(<span style=color:green;font-weight:700>select</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>count</span>(<span style=color:#666>*</span>)<span style=color:#bbb> </span><span style=color:green;font-weight:700>from</span><span style=color:#bbb> </span>lineorder_flat<span style=color:#bbb> </span><span style=color:green;font-weight:700>group</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>by</span><span style=color:#bbb> </span>lo_shipmode,lo_orderpriority,p_category,s_nation,c_nation)<span style=color:#bbb> </span>t;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>select</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>count</span>(<span style=color:#666>*</span>)<span style=color:#bbb> </span><span style=color:green;font-weight:700>from</span><span style=color:#bbb> </span>(<span style=color:green;font-weight:700>select</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>count</span>(<span style=color:#666>*</span>)<span style=color:#bbb> </span><span style=color:green;font-weight:700>from</span><span style=color:#bbb> </span>lineorder_flat<span style=color:#bbb> </span><span style=color:green;font-weight:700>group</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>by</span><span style=color:#bbb> </span>lo_shipmode,lo_orderpriority,p_category,s_nation,c_nation,p_mfgr)<span style=color:#bbb> </span>t;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>select</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>count</span>(<span style=color:#666>*</span>)<span style=color:#bbb> </span><span style=color:green;font-weight:700>from</span><span style=color:#bbb> </span>(<span style=color:green;font-weight:700>select</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>count</span>(<span style=color:#666>*</span>)<span style=color:#bbb> </span><span style=color:green;font-weight:700>from</span><span style=color:#bbb> </span>lineorder_flat<span style=color:#bbb> </span><span style=color:green;font-weight:700>group</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>by</span><span style=color:#bbb> </span>substr(lo_shipmode,<span style=color:#666>2</span>),<span style=color:green;font-weight:700>lower</span>(lo_orderpriority),p_category,s_nation,c_nation,s_region,p_mfgr)<span style=color:#bbb> </span>t;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>select</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>count</span>(<span style=color:#666>*</span>),lo_shipmode,s_city<span style=color:#bbb> </span><span style=color:green;font-weight:700>from</span><span style=color:#bbb> </span>lineorder_flat<span style=color:#bbb> </span><span style=color:green;font-weight:700>group</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>by</span><span style=color:#bbb> </span>lo_shipmode,s_city;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>select</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>count</span>(<span style=color:#666>*</span>)<span style=color:#bbb> </span><span style=color:green;font-weight:700>from</span><span style=color:#bbb> </span>lineorder_flat<span style=color:#bbb> </span><span style=color:green;font-weight:700>group</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>by</span><span style=color:#bbb> </span>c_city,s_city;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>select</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>count</span>(<span style=color:#666>*</span>)<span style=color:#bbb> </span><span style=color:green;font-weight:700>from</span><span style=color:#bbb> </span>lineorder_flat<span style=color:#bbb> </span><span style=color:green;font-weight:700>group</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>by</span><span style=color:#bbb> </span>c_city,s_city,c_nation,s_nation;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>select</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>count</span>(<span style=color:#666>*</span>)<span style=color:#bbb> </span><span style=color:green;font-weight:700>from</span><span style=color:#bbb> </span>lineorder_flat<span style=color:#bbb> </span><span style=color:green;font-weight:700>group</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>by</span><span style=color:#bbb> </span>lo_shipmode,lo_orderdate;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>select</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>count</span>(<span style=color:#666>*</span>)<span style=color:#bbb> </span><span style=color:green;font-weight:700>from</span><span style=color:#bbb> </span>lineorder_flat<span style=color:#bbb> </span><span style=color:green;font-weight:700>group</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>by</span><span style=color:#bbb> </span>lo_orderdate,s_nation,s_region;<span style=color:#bbb>
</span></span></span></code></pre></div><p>对比结果：</p><figure><img loading=lazy src=/ox-hugo/347ac70abb2_65870f92ed27574701a34e9f323b293e.png width=800px></figure><p>从效果上来看，开启低基数优化的 SQL 比没开启低基数优化的 SQL 平均快了 3 倍。</p><h2 id=总结>6 总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h2><p>StarRocks 的低基数 String 优化，主要的特点有:</p><ul><li><p>全局的字典加速，作用于 SQL 执行的各个阶段。</p></li><li><p>基于 CBO 优化器的，自适应选择全局字典的加速策略。</p></li><li><p>无 Schema，自适应，用户不需要指定特定的低基数列。</p></li><li><p>对用户透明，不需要重新导数据。</p></li><li><p>高性能，业界领先水平。</p></li><li><p>支持场景丰富，兼容大部分 String 处理逻辑。</p></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://yangyingchao.github.io/tags/starrocks/>starrocks</a></li><li><a href=https://yangyingchao.github.io/tags/string/>string</a></li><li><a href=https://yangyingchao.github.io/tags/global/>global</a></li><li><a href=https://yangyingchao.github.io/tags/low/>low</a></li><li><a href=https://yangyingchao.github.io/tags/cardinality/>cardinality</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://yangyingchao.github.io>MyNotes</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>