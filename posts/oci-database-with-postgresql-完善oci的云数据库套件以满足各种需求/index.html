<!doctype html><html lang=zh-cn dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>OCI Database with PostgreSQL: 完善OCI的云数据库套件以满足各种需求 | MyNotes</title><meta name=keywords content="pg"><meta name=description content="1 为什么 OCI Database for PostgreSQL 脱颖而出 2 Vanilla PostgreSQL 的问题 3 OCI Database with PostgreSQL – 高级架构 3.1 数据库优化存储 (DbOS) 的优点 3.2 进一步的存储优化 3.3 结论 本文为摘录，原文为： https://mp.weixin.qq.com/s?__biz=MzI3OTM3MDkyNg==&amp;mid=2247497316&amp;idx=1&amp;sn=d08b84d63ab2e4b69949af9170762189&amp;chksm=eb4a7ba5dc3df2b3ca2b3721e5614ab5711be6e984ec44173035323953d193440240f8412591&amp;mpshare=1&amp;scene=1&amp;srcid=1208AtRH30qSa2LdMxzmf3sV&amp;sharer_shareinfo=9a0858a92025bbb0e8887abc9a5eee8a&amp;sharer_shareinfo_first=9a0858a92025bbb0e8887abc9a5eee8a#rd 对于希望在云中"><meta name=author content="Yang Yingchao"><link rel=canonical href=https://yangyingchao.github.io/posts/oci-database-with-postgresql-%E5%AE%8C%E5%96%84oci%E7%9A%84%E4%BA%91%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A5%97%E4%BB%B6%E4%BB%A5%E6%BB%A1%E8%B6%B3%E5%90%84%E7%A7%8D%E9%9C%80%E6%B1%82/><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://yangyingchao.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://yangyingchao.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://yangyingchao.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://yangyingchao.github.io/apple-touch-icon.png><link rel=mask-icon href=https://yangyingchao.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="OCI Database with PostgreSQL: 完善OCI的云数据库套件以满足各种需求"><meta property="og:description" content="1 为什么 OCI Database for PostgreSQL 脱颖而出 2 Vanilla PostgreSQL 的问题 3 OCI Database with PostgreSQL – 高级架构 3.1 数据库优化存储 (DbOS) 的优点 3.2 进一步的存储优化 3.3 结论 本文为摘录，原文为： https://mp.weixin.qq.com/s?__biz=MzI3OTM3MDkyNg==&amp;mid=2247497316&amp;idx=1&amp;sn=d08b84d63ab2e4b69949af9170762189&amp;chksm=eb4a7ba5dc3df2b3ca2b3721e5614ab5711be6e984ec44173035323953d193440240f8412591&amp;mpshare=1&amp;scene=1&amp;srcid=1208AtRH30qSa2LdMxzmf3sV&amp;sharer_shareinfo=9a0858a92025bbb0e8887abc9a5eee8a&amp;sharer_shareinfo_first=9a0858a92025bbb0e8887abc9a5eee8a#rd 对于希望在云中"><meta property="og:type" content="article"><meta property="og:url" content="https://yangyingchao.github.io/posts/oci-database-with-postgresql-%E5%AE%8C%E5%96%84oci%E7%9A%84%E4%BA%91%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A5%97%E4%BB%B6%E4%BB%A5%E6%BB%A1%E8%B6%B3%E5%90%84%E7%A7%8D%E9%9C%80%E6%B1%82/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-12-08T00:00:00+00:00"><meta property="article:modified_time" content="2023-12-08T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="OCI Database with PostgreSQL: 完善OCI的云数据库套件以满足各种需求"><meta name=twitter:description content="1 为什么 OCI Database for PostgreSQL 脱颖而出 2 Vanilla PostgreSQL 的问题 3 OCI Database with PostgreSQL – 高级架构 3.1 数据库优化存储 (DbOS) 的优点 3.2 进一步的存储优化 3.3 结论 本文为摘录，原文为： https://mp.weixin.qq.com/s?__biz=MzI3OTM3MDkyNg==&amp;mid=2247497316&amp;idx=1&amp;sn=d08b84d63ab2e4b69949af9170762189&amp;chksm=eb4a7ba5dc3df2b3ca2b3721e5614ab5711be6e984ec44173035323953d193440240f8412591&amp;mpshare=1&amp;scene=1&amp;srcid=1208AtRH30qSa2LdMxzmf3sV&amp;sharer_shareinfo=9a0858a92025bbb0e8887abc9a5eee8a&amp;sharer_shareinfo_first=9a0858a92025bbb0e8887abc9a5eee8a#rd 对于希望在云中"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://yangyingchao.github.io/posts/"},{"@type":"ListItem","position":2,"name":"OCI Database with PostgreSQL: 完善OCI的云数据库套件以满足各种需求","item":"https://yangyingchao.github.io/posts/oci-database-with-postgresql-%E5%AE%8C%E5%96%84oci%E7%9A%84%E4%BA%91%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A5%97%E4%BB%B6%E4%BB%A5%E6%BB%A1%E8%B6%B3%E5%90%84%E7%A7%8D%E9%9C%80%E6%B1%82/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"OCI Database with PostgreSQL: 完善OCI的云数据库套件以满足各种需求","name":"OCI Database with PostgreSQL: 完善OCI的云数据库套件以满足各种需求","description":"1 为什么 OCI Database for PostgreSQL 脱颖而出 2 Vanilla PostgreSQL 的问题 3 OCI Database with PostgreSQL – 高级架构 3.1 数据库优化存储 (DbOS) 的优点 3.2 进一步的存储优化 3.3 结论 本文为摘录，原文为： https://mp.weixin.qq.com/s?__biz=MzI3OTM3MDkyNg==\u0026amp;mid=2247497316\u0026amp;idx=1\u0026amp;sn=d08b84d63ab2e4b69949af9170762189\u0026amp;chksm=eb4a7ba5dc3df2b3ca2b3721e5614ab5711be6e984ec44173035323953d193440240f8412591\u0026amp;mpshare=1\u0026amp;scene=1\u0026amp;srcid=1208AtRH30qSa2LdMxzmf3sV\u0026amp;sharer_shareinfo=9a0858a92025bbb0e8887abc9a5eee8a\u0026amp;sharer_shareinfo_first=9a0858a92025bbb0e8887abc9a5eee8a#rd 对于希望在云中","keywords":["pg"],"articleBody":" 1 为什么 OCI Database for PostgreSQL 脱颖而出 2 Vanilla PostgreSQL 的问题 3 OCI Database with PostgreSQL – 高级架构 3.1 数据库优化存储 (DbOS) 的优点 3.2 进一步的存储优化 3.3 结论 本文为摘录，原文为： https://mp.weixin.qq.com/s?__biz=MzI3OTM3MDkyNg==\u0026mid=2247497316\u0026idx=1\u0026sn=d08b84d63ab2e4b69949af9170762189\u0026chksm=eb4a7ba5dc3df2b3ca2b3721e5614ab5711be6e984ec44173035323953d193440240f8412591\u0026mpshare=1\u0026scene=1\u0026srcid=1208AtRH30qSa2LdMxzmf3sV\u0026sharer_shareinfo=9a0858a92025bbb0e8887abc9a5eee8a\u0026sharer_shareinfo_first=9a0858a92025bbb0e8887abc9a5eee8a#rd\n对于希望在云中轻松扩展且无需更改应用程序的组织来说，OCI Database with PostgreSQL 数据库 是理想的解决方案。它提供完全的 PostgreSQL 兼容性，同时让用户利用 OCI 灵活、高性能、高可 用性的基础设施以及内置的安全性和简单的定价。此外，这种 OCI 实施还提供了卓越的可扩展性并 减少了管理需求。\n1 为什么 OCI Database for PostgreSQL 脱颖而出 性能提升高达 3 倍 数据库优化存储 将 SQL 事务处理引擎与存储层解耦 成本不到友商的一半 我们将开源 PostgreSQL 称为“Vanilla PostgreSQL”。\n2 Vanilla PostgreSQL 的问题 主要故障转移期间的数据丢失 - 非零 RPO 如图 2 所示，客户通常跨可用性域复制数据库实例。\n此复制是从 AD1 中的主数据库异步执行到 AD2 中的“副本”的。 副本数据库可能落后于主数据库。 如果主数据库发生故障并且副本被提升为新的主数据库，则可能会因滞后而丢失一些数据。 数据丢失量取决于升级的副本与旧主副本的落后程度。 vanilla PostgreSQL 中解决此问题的一个解决方案是同步复制功能，但由于性能开销巨大，因此不太受欢迎。\n手动升级和可管理性的复杂性： 尽管您可以在不同的可用性域中设置副本以实现高可用性，但将备用副本升级为主副本是一个手 动且复杂的过程。必须谨慎选择要升级的新候选节点，从而有效减少数据丢失，同样，将旧主节 点重新添加回集群需要更多手动步骤。例如，旧的主数据库可能有本地提交的多余事务，需要首 先使用 pg_rewind 等工具清除这些事务，然后才能重新加入集群。\n创建只读副本既昂贵又缓慢： 使用普通 PostgreSQL，创建新副本需要在主数据库上拍摄数据快照并赶上主数据库。对于可能达 到 TB 级的大型数据库，这是一项昂贵且缓慢的操作。为了能够处理应用程序的突发读取需求， 客户必须过度配置数据库资源。由于每个副本必须具有数据库的完整副本，因此运行多个副本的 存储成本可能会变得昂贵。\n3 OCI Database with PostgreSQL – 高级架构 在 OCI Database with PostgreSQL 数据库中，Oracle 将 复制和持久性问题推到了新的数据库优化存储(DbOS) 层:\n该层是专门为实现高规模、高可用性和高性能数据库服务而构建的。DbOS 提供高度耐用的网络附加存储， 其中数据块在三个可用性域区域中的多个可用性域之间复制。 在单 AD 区域中，数据跨多个故障域复制。集群中的所有 PostgreSQL 节点都访问相同的网络附加存 储。每个备用副本不再需要维护自己的数据库副本。主实例写入共享存储，而备用副本实例从同一共 享存储读取并服务用户查询。\n3.1 数据库优化存储 (DbOS) 的优点 持久性（零 RPO）： DbOS 在多可用性域区域中跨多个可用性域复制数据，并且可以在整个可用性域丢失的情况下幸存下来。 DbOS 使用基于仲裁的复制在幕后复制数据块。 如果主节点发生故障，数据库可以故障转移到使用复制的 DbOS 的其他数据库节点，并且这个新 升级的主 PostgreSQL 实例可以接管而不会丢失数据。之前在旧主数据库上提交的所有事务都存 在于新主数据库中。 由于 DbOS 层执行复制，因此无需仅仅为了持久性而运行多个副本实例。 例如，可以在没有任何副本的情况下使用 PostgreSQL 实例运行单节点 OCI 数据库，但仍然不会牺牲耐用性。 即使在这种单节点设置中，也保证您具有零 RPO。 高可用性 (99.99%)：\n使用 OCI Database with PostgreSQL 数据库，您可以在几分钟内自动将主数据库故障转移到集群中的另一个副本。 主故障转移速度很快，并且对应用程序几乎是透明的，因为恢复时间目标只需要几分钟。 为了透明地启用故障转移，主端点被设置为浮动 IP 地址，该地址会自动移动到新的主端点。 故障转移后，应用程序会自动重新建立与新主数据库的数据库连接，无需对应用程序进行任何配置更改。 与普通 PostgreSQL 不同，您在启动主故障转移时无需担心复制滞后和数据丢失。 您无需手动选择特定副本来减少数据丢失。集群中的所有实例共享相同的存储，因此在故障转 移时，新的主实例可以保证零数据丢失。 弹性：\n由于数据库存储在所有节点之间共享，因此您可以快速创建或删除副本，以满足用户查询工作负载需求。 与普通 PostgreSQL 不同，您不需要在主节点上拍摄数据快照并将其复制到副本节点来启动新的备用 PostgreSQL 实例。 可以像使用 PostgreSQL 在 OCI 数据库中启动计算实例一样快速地创建备用副本。 只读副本的水平扩展：\n由于副本节点与 PostgreSQL 共享 OCI 数据库中的数据库存储，因此无论数据库集群中的副本数量有多少，您只需要维护一份数据库副本。 与在云中运行普通 PostgreSQL 相比，带有 PostgreSQL 的 OCI 数据库可显着节省存储成本。 此外，OCI 的 PostgreSQL 服务提供按使用量付费的数据定价模型，并具有自动扩展功能，可降低您的成本。 低副本延迟：\n复制延迟是普通 PostgreSQL 只读副本设置的一个主要挑战。 由于副本必须重播并保存主副本所做的所有更改，因此很容易落后，尤其是在网络分区的情况下。 通过共享存储，副本的工作量显着减少。它只需要将更改应用于其缓存中的页面，并且不必保留这些更改。 使用这种架构，复制延迟通常以毫秒为单位，这使得读取查询能够近乎实时地执行或完成。 高效复制：\nOCI Database with PostgreSQL 在存储层执行复制。 因此，主实例不需要将预写日志 (WAL) 记录物理传送到所有副本。 相反，它通知副本有新的更改，并且各个副本直接从共享存储读取 latest WAL 记录。 这可以减少主服务器上的负载，并且可以更有效地扩展到更多数量的副本。 在我们的实验中，具有内置跨 AD 复制功能的 OCI Database with PostgreSQL 数据库比普通 PostgreSQL 中的同步复制快两倍多。\n3.2 进一步的存储优化 除了共享存储优化之外，OCI Database with PostgreSQL 还实施了以下优化以进一步提高性能。\n原子写入：\nDbOS 针对已知的数据库性能风险实施优化，例如消除“撕裂写入”。 通常，大多数数据库需要某种针对“撕裂写入”的保护，当数据库使用的页面大小（PostgreSQL 使用 8 KB）与底层存储的“原子写入单元”大小（通常为 512B 或 4KB）。例如，如果这是自上 一个检查点以来对页面的第一次修改，PostgreSQL 首先将整个 8KB 页面写入 WAL，然后将该页 面刷新到磁盘。如果页面写入被破坏，那么 PostgreSQL 会回退到使用之前在 WAL 中写入的整 页，并且不会造成任何损害。但这种保护是有代价的——它会导致 WAL 膨胀，并且频繁的检查点 会加剧问题，而频繁的检查点需要减少计划外故障转移期间的恢复时间。 我们在 DbOS 中实现了对 PostgreSQL 页面的原子写入支持。 存储层永远不会覆盖现有页面。 相反，它使用日志结构化技术始终将页面写入磁盘上的新位置，并维护从逻辑文件偏移到磁盘位置的映射层。 旧版本的页面会定期被垃圾收集。这避免了双重写入。 优化的页面缓存：\n带有 PostgreSQL 的 OCI 数据库使用专门构建的缓存层，这与依赖于通用 Linux 内核页面缓存的普通 PostgreSQL 不同。 OCI 的页面缓存实现有很多优化，例如： 专为 PostgreSQL 工作负载定制的自定义预取逻辑。 避免在 PostgreSQL 共享缓冲区和页面缓存中双重缓存页面 通过预取数据页加速 PostgreSQL 恢复 存储级备份： 在普通 Postgres 中，为了维护数据库备份，WAL 被复制到对象存储，并定期拍摄文件系统快照。 此过程同时使用主节点上的网络和 CPU。OCI 数据库与 PostgreSQL 将备份委托给存储层，从而消 除了备份的网络和 CPU 开销。\n3.3 结论 正如前面详细介绍的，OCI Database with PostgreSQL 数据库在成本、性能、规模、可用性和持久 性方面提供了显着的优势。实现大部分优势的关键是基于 DbOS 和 DbFS，它们是专门为优化 PostgreSQL 以在云规模上更有效地工作而构建的。\n","wordCount":"2842","inLanguage":"zh-cn","datePublished":"2023-12-08T00:00:00Z","dateModified":"2023-12-08T00:00:00Z","author":[{"@type":"Person","name":"Yang Yingchao"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://yangyingchao.github.io/posts/oci-database-with-postgresql-%E5%AE%8C%E5%96%84oci%E7%9A%84%E4%BA%91%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A5%97%E4%BB%B6%E4%BB%A5%E6%BB%A1%E8%B6%B3%E5%90%84%E7%A7%8D%E9%9C%80%E6%B1%82/"},"publisher":{"@type":"Organization","name":"MyNotes","logo":{"@type":"ImageObject","url":"https://yangyingchao.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://yangyingchao.github.io accesskey=h title="MyNotes (Alt + H)">MyNotes</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://yangyingchao.github.io/ title=Home><span>Home</span></a></li><li><a href=https://yangyingchao.github.io/posts/ title=Archives><span>Archives</span></a></li><li><a href=https://yangyingchao.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://yangyingchao.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://yangyingchao.github.io/contact/ title="Contact me"><span>Contact me</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">OCI Database with PostgreSQL: 完善OCI的云数据库套件以满足各种需求</h1><div class=post-meta><span title='2023-12-08 00:00:00 +0000 UTC'>December 8, 2023</span>&nbsp;·&nbsp;Yang Yingchao</div></header><div class=post-content><ul><li>1 <a href=#h:2f8a6966-c6d0-4c53-bd48-a538dcab3522>为什么 OCI Database for PostgreSQL 脱颖而出</a></li><li>2 <a href=#h:d1146bb4-c2b0-45a9-bfdd-0e5a6f5671e7>Vanilla PostgreSQL 的问题</a></li><li>3 <a href=#h:ed0ac907-e092-4485-942e-d97ced71c119>OCI Database with PostgreSQL – 高级架构</a><ul><li>3.1 <a href=#h:f3643978-df64-4c44-91e6-3eb81331394a>数据库优化存储 (DbOS) 的优点</a></li><li>3.2 <a href=#h:edaa1505-1793-4798-94fb-fca3c6a5e41f>进一步的存储优化</a></li><li>3.3 <a href=#h:da77a97b-e786-464e-aafc-82fc707ff5af>结论</a></li></ul></li></ul><p>本文为摘录，原文为： <a href="https://mp.weixin.qq.com/s?__biz=MzI3OTM3MDkyNg==&amp;mid=2247497316&amp;idx=1&amp;sn=d08b84d63ab2e4b69949af9170762189&amp;chksm=eb4a7ba5dc3df2b3ca2b3721e5614ab5711be6e984ec44173035323953d193440240f8412591&amp;mpshare=1&amp;scene=1&amp;srcid=1208AtRH30qSa2LdMxzmf3sV&amp;sharer_shareinfo=9a0858a92025bbb0e8887abc9a5eee8a&amp;sharer_shareinfo_first=9a0858a92025bbb0e8887abc9a5eee8a#rd">https://mp.weixin.qq.com/s?__biz=MzI3OTM3MDkyNg==&amp;mid=2247497316&amp;idx=1&amp;sn=d08b84d63ab2e4b69949af9170762189&amp;chksm=eb4a7ba5dc3df2b3ca2b3721e5614ab5711be6e984ec44173035323953d193440240f8412591&amp;mpshare=1&amp;scene=1&amp;srcid=1208AtRH30qSa2LdMxzmf3sV&amp;sharer_shareinfo=9a0858a92025bbb0e8887abc9a5eee8a&amp;sharer_shareinfo_first=9a0858a92025bbb0e8887abc9a5eee8a#rd</a></p><p>对于希望在云中轻松扩展且无需更改应用程序的组织来说，OCI Database with PostgreSQL 数据库
是理想的解决方案。它提供完全的 PostgreSQL 兼容性，同时让用户利用 OCI 灵活、高性能、高可
用性的基础设施以及内置的安全性和简单的定价。此外，这种 OCI 实施还提供了卓越的可扩展性并
减少了管理需求。</p><h2 id=h:2f8a6966-c6d0-4c53-bd48-a538dcab3522>1 为什么 OCI Database for PostgreSQL 脱颖而出<a hidden class=anchor aria-hidden=true href=#h:2f8a6966-c6d0-4c53-bd48-a538dcab3522>#</a></h2><ul><li>性能提升高达 3 倍<ul><li>数据库优化存储</li><li>将 SQL 事务处理引擎与存储层解耦</li></ul></li><li>成本不到友商的一半</li></ul><p>我们将开源 PostgreSQL 称为“Vanilla PostgreSQL”。</p><h2 id=h:d1146bb4-c2b0-45a9-bfdd-0e5a6f5671e7>2 Vanilla PostgreSQL 的问题<a hidden class=anchor aria-hidden=true href=#h:d1146bb4-c2b0-45a9-bfdd-0e5a6f5671e7>#</a></h2><figure><img loading=lazy src=/ox-hugo/oci-640.png width=800px></figure><ol><li><p>主要故障转移期间的数据丢失 - 非零 RPO
如图 2 所示，客户通常跨可用性域复制数据库实例。</p><ul><li>此复制是从 AD1 中的主数据库异步执行到 AD2 中的“副本”的。</li><li>副本数据库可能落后于主数据库。</li><li>如果主数据库发生故障并且副本被提升为新的主数据库，则可能会因滞后而丢失一些数据。</li><li>数据丢失量取决于升级的副本与旧主副本的落后程度。</li></ul><p>vanilla PostgreSQL 中解决此问题的一个解决方案是同步复制功能，但由于性能开销巨大，因此不太受欢迎。</p></li><li><p>手动升级和可管理性的复杂性：
尽管您可以在不同的可用性域中设置副本以实现高可用性，但将备用副本升级为主副本是一个手
动且复杂的过程。必须谨慎选择要升级的新候选节点，从而有效减少数据丢失，同样，将旧主节
点重新添加回集群需要更多手动步骤。例如，旧的主数据库可能有本地提交的多余事务，需要首
先使用 pg_rewind 等工具清除这些事务，然后才能重新加入集群。</p></li><li><p>创建只读副本既昂贵又缓慢：
使用普通 PostgreSQL，创建新副本需要在主数据库上拍摄数据快照并赶上主数据库。对于可能达
到 TB 级的大型数据库，这是一项昂贵且缓慢的操作。为了能够处理应用程序的突发读取需求，
客户必须过度配置数据库资源。由于每个副本必须具有数据库的完整副本，因此运行多个副本的
存储成本可能会变得昂贵。</p></li></ol><h2 id=h:ed0ac907-e092-4485-942e-d97ced71c119>3 OCI Database with PostgreSQL – 高级架构<a hidden class=anchor aria-hidden=true href=#h:ed0ac907-e092-4485-942e-d97ced71c119>#</a></h2><p>在 OCI Database with PostgreSQL 数据库中，Oracle 将 <strong>复制和持久性问题推到了新的数据库优化存储(DbOS) 层</strong>:</p><ul><li>该层是专门为实现高规模、高可用性和高性能数据库服务而构建的。DbOS 提供高度耐用的网络附加存储，</li><li>其中数据块在三个可用性域区域中的多个可用性域之间复制。</li></ul><p>在单 AD 区域中，数据跨多个故障域复制。集群中的所有 PostgreSQL 节点都访问相同的网络附加存
储。每个备用副本不再需要维护自己的数据库副本。主实例写入共享存储，而备用副本实例从同一共
享存储读取并服务用户查询。</p><figure><img loading=lazy src=/ox-hugo/oci-640.jpeg width=800px></figure><h3 id=h:f3643978-df64-4c44-91e6-3eb81331394a>3.1 数据库优化存储 (DbOS) 的优点<a hidden class=anchor aria-hidden=true href=#h:f3643978-df64-4c44-91e6-3eb81331394a>#</a></h3><ul><li><p>持久性（零 RPO）：</p><ul><li>DbOS 在多可用性域区域中跨多个可用性域复制数据，并且可以在整个可用性域丢失的情况下幸存下来。</li><li>DbOS 使用基于仲裁的复制在幕后复制数据块。</li><li>如果主节点发生故障，数据库可以故障转移到使用复制的 DbOS 的其他数据库节点，并且这个新
升级的主 PostgreSQL 实例可以接管而不会丢失数据。之前在旧主数据库上提交的所有事务都存
在于新主数据库中。</li><li>由于 DbOS 层执行复制，因此无需仅仅为了持久性而运行多个副本实例。
例如，可以在没有任何副本的情况下使用 PostgreSQL 实例运行单节点 OCI 数据库，但仍然不会牺牲耐用性。
即使在这种单节点设置中，也保证您具有零 RPO。</li></ul></li><li><p>高可用性 (99.99%)：</p><ul><li>使用 OCI Database with PostgreSQL 数据库，您可以在几分钟内自动将主数据库故障转移到集群中的另一个副本。</li><li>主故障转移速度很快，并且对应用程序几乎是透明的，因为恢复时间目标只需要几分钟。</li><li>为了透明地启用故障转移，主端点被设置为浮动 IP 地址，该地址会自动移动到新的主端点。</li><li>故障转移后，应用程序会自动重新建立与新主数据库的数据库连接，无需对应用程序进行任何配置更改。</li><li>与普通 PostgreSQL 不同，您在启动主故障转移时无需担心复制滞后和数据丢失。
您无需手动选择特定副本来减少数据丢失。集群中的所有实例共享相同的存储，因此在故障转
移时，新的主实例可以保证零数据丢失。</li></ul></li><li><p>弹性：</p><ul><li>由于数据库存储在所有节点之间共享，因此您可以快速创建或删除副本，以满足用户查询工作负载需求。</li><li>与普通 PostgreSQL 不同，您不需要在主节点上拍摄数据快照并将其复制到副本节点来启动新的备用 PostgreSQL 实例。</li><li>可以像使用 PostgreSQL 在 OCI 数据库中启动计算实例一样快速地创建备用副本。</li></ul></li><li><p>只读副本的水平扩展：</p><ul><li>由于副本节点与 PostgreSQL 共享 OCI 数据库中的数据库存储，因此无论数据库集群中的副本数量有多少，您只需要维护一份数据库副本。</li><li>与在云中运行普通 PostgreSQL 相比，带有 PostgreSQL 的 OCI 数据库可显着节省存储成本。</li><li>此外，OCI 的 PostgreSQL 服务提供按使用量付费的数据定价模型，并具有自动扩展功能，可降低您的成本。</li></ul></li><li><p>低副本延迟：</p><ul><li>复制延迟是普通 PostgreSQL 只读副本设置的一个主要挑战。</li><li>由于副本必须重播并保存主副本所做的所有更改，因此很容易落后，尤其是在网络分区的情况下。</li><li>通过共享存储，副本的工作量显着减少。它只需要将更改应用于其缓存中的页面，并且不必保留这些更改。</li><li>使用这种架构，复制延迟通常以毫秒为单位，这使得读取查询能够近乎实时地执行或完成。</li></ul></li><li><p>高效复制：</p><ul><li>OCI Database with PostgreSQL 在存储层执行复制。</li><li>因此，主实例不需要将预写日志 (WAL) 记录物理传送到所有副本。</li><li>相反，它通知副本有新的更改，并且各个副本直接从共享存储读取 latest WAL 记录。</li><li>这可以减少主服务器上的负载，并且可以更有效地扩展到更多数量的副本。</li></ul></li></ul><p>在我们的实验中，具有内置跨 AD 复制功能的 OCI Database with PostgreSQL 数据库比普通
PostgreSQL 中的同步复制快两倍多。</p><h3 id=h:edaa1505-1793-4798-94fb-fca3c6a5e41f>3.2 进一步的存储优化<a hidden class=anchor aria-hidden=true href=#h:edaa1505-1793-4798-94fb-fca3c6a5e41f>#</a></h3><p>除了共享存储优化之外，OCI Database with PostgreSQL 还实施了以下优化以进一步提高性能。</p><ul><li><p>原子写入：</p><ul><li>DbOS 针对已知的数据库性能风险实施优化，例如消除“撕裂写入”。</li><li>通常，大多数数据库需要某种针对“撕裂写入”的保护，当数据库使用的页面大小（PostgreSQL
使用 8 KB）与底层存储的“原子写入单元”大小（通常为 512B 或 4KB）。例如，如果这是自上
一个检查点以来对页面的第一次修改，PostgreSQL 首先将整个 8KB 页面写入 WAL，然后将该页
面刷新到磁盘。如果页面写入被破坏，那么 PostgreSQL 会回退到使用之前在 WAL 中写入的整
页，并且不会造成任何损害。但这种保护是有代价的——它会导致 WAL 膨胀，并且频繁的检查点
会加剧问题，而频繁的检查点需要减少计划外故障转移期间的恢复时间。</li><li>我们在 DbOS 中实现了对 PostgreSQL 页面的原子写入支持。<ul><li>存储层永远不会覆盖现有页面。</li><li>相反，它使用日志结构化技术始终将页面写入磁盘上的新位置，并维护从逻辑文件偏移到磁盘位置的映射层。</li><li>旧版本的页面会定期被垃圾收集。这避免了双重写入。</li></ul></li></ul></li><li><p>优化的页面缓存：</p><ul><li>带有 PostgreSQL 的 OCI 数据库使用专门构建的缓存层，这与依赖于通用 Linux 内核页面缓存的普通 PostgreSQL 不同。</li><li>OCI 的页面缓存实现有很多优化，例如：<ul><li>专为 PostgreSQL 工作负载定制的自定义预取逻辑。</li><li>避免在 PostgreSQL 共享缓冲区和页面缓存中双重缓存页面</li><li>通过预取数据页加速 PostgreSQL 恢复</li></ul></li></ul></li><li><p>存储级备份：
在普通 Postgres 中，为了维护数据库备份，WAL 被复制到对象存储，并定期拍摄文件系统快照。
此过程同时使用主节点上的网络和 CPU。OCI 数据库与 PostgreSQL 将备份委托给存储层，从而消
除了备份的网络和 CPU 开销。</p></li></ul><h3 id=h:da77a97b-e786-464e-aafc-82fc707ff5af>3.3 结论<a hidden class=anchor aria-hidden=true href=#h:da77a97b-e786-464e-aafc-82fc707ff5af>#</a></h3><p>正如前面详细介绍的，OCI Database with PostgreSQL 数据库在成本、性能、规模、可用性和持久
性方面提供了显着的优势。实现大部分优势的关键是基于 DbOS 和 DbFS，它们是专门为优化
PostgreSQL 以在云规模上更有效地工作而构建的。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://yangyingchao.github.io/tags/pg/>pg</a></li></ul></footer><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//disqus_yH1vi2Slvj.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://yangyingchao.github.io>MyNotes</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>