<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>What it means when you convert between different shared_ptrs - The Old New Thing - 杂七杂八随手记</title><meta name=renderer content="webkit"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv=cache-control content="no-transform"><meta http-equiv=cache-control content="no-siteapp"><meta name=theme-color content="#f8f5ec"><meta name=msapplication-navbutton-color content="#f8f5ec"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="#f8f5ec"><meta name=author content="yyc"><meta name=description content="C++中的 shared_ptr 管理一个引用计数指针。通常情况下，它是一个指向对象的指针，当最后一个引用过期时将被删除。但它不一定非得是这样。 回想一下， shared_ptr 实际上"><meta name=keywords content="Hugo,theme,even"><meta name=generator content="Hugo 0.115.0 with theme even"><link rel=canonical href=https://yangyingchao.github.io/posts/p108611/><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/manifest.json><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link href=/sass/main.min.154ed883776547b0e136be39b3037f61350da06f888d0868d1756a9463cd9520.css rel=stylesheet><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin=anonymous><meta property="og:title" content="What it means when you convert between different shared_ptrs - The Old New Thing"><meta property="og:description" content="C++中的 shared_ptr 管理一个引用计数指针。通常情况下，它是一个指向对象的指针，当最后一个引用过期时将被删除。但它不一定非得是这样。 回想一下， shared_ptr 实际上"><meta property="og:type" content="article"><meta property="og:url" content="https://yangyingchao.github.io/posts/p108611/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-08-18T00:00:00+00:00"><meta property="article:modified_time" content="2023-08-18T00:00:00+00:00"><meta itemprop=name content="What it means when you convert between different shared_ptrs - The Old New Thing"><meta itemprop=description content="C++中的 shared_ptr 管理一个引用计数指针。通常情况下，它是一个指向对象的指针，当最后一个引用过期时将被删除。但它不一定非得是这样。 回想一下， shared_ptr 实际上"><meta itemprop=datePublished content="2023-08-18T00:00:00+00:00"><meta itemprop=dateModified content="2023-08-18T00:00:00+00:00"><meta itemprop=wordCount content="1924"><meta itemprop=keywords content="cpp,shared-ptr,lang,"><meta name=twitter:card content="summary"><meta name=twitter:title content="What it means when you convert between different shared_ptrs - The Old New Thing"><meta name=twitter:description content="C++中的 shared_ptr 管理一个引用计数指针。通常情况下，它是一个指向对象的指针，当最后一个引用过期时将被删除。但它不一定非得是这样。 回想一下， shared_ptr 实际上"><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]--></head><body><div id=mobile-navbar class=mobile-navbar><div class=mobile-header-logo><a href=/ class=logo>Even</a></div><div class=mobile-navbar-icon><span></span>
<span></span>
<span></span></div></div><nav id=mobile-menu class="mobile-menu slideout-menu"><ul class=mobile-menu-list><a href=/><li class=mobile-menu-item>Home</li></a><a href=/post/><li class=mobile-menu-item>Archives</li></a><a href=/tags/><li class=mobile-menu-item>Tags</li></a><a href=/categories/><li class=mobile-menu-item>Categories</li></a></ul></nav><div class=container id=mobile-panel><header id=header class=header><div class=logo-wrapper><a href=/ class=logo>Even</a></div><nav class=site-navbar><ul id=menu class=menu><li class=menu-item><a class=menu-item-link href=/>Home</a></li><li class=menu-item><a class=menu-item-link href=/post/>Archives</a></li><li class=menu-item><a class=menu-item-link href=/tags/>Tags</a></li><li class=menu-item><a class=menu-item-link href=/categories/>Categories</a></li></ul></nav></header><main id=main class=main><div class=content-wrapper><div id=content class=content><article class=post><div class=post-content><p>C++中的 <code>shared_ptr</code> 管理一个引用计数指针。通常情况下，它是一个指向对象的指针，当最后一个引用过期时将被删除。但它不一定非得是这样。</p><p>回想一下， <code>shared_ptr</code> 实际上是两个指针。</p><ul><li>指向一个控制块 (control block)的指针，该控制块管理共享和弱引用计数，并在共享引用计数降至零时销毁一个对象（通常称为被管理的对象）。</li><li>从 <code>get()</code> 方法返回的指针，通常称为存储指针。</li></ul><p>大多数情况下，存储的指针指向托管对象，因为当你使用原始指针构造 <code>shared_ptr</code> 或者调用
<code>make_shared</code> 时，得到的就是托管对象。但是，当托管对象和存储的指针不同的时候，有什么用处呢？</p><p>可能会希望有一个 <code>shared_ptr</code> ，其 <code>get()</code> 方法返回另一个大对象的子对象的指针。在这种情
况下，托管对象是较大的对象，而存储的指针是指向子对象的指针。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Sample</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>value1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>value2</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>consume</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>pint</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>Sample</span><span class=o>&gt;</span> <span class=n>p</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>make_shared</span><span class=o>&lt;</span><span class=n>Sample</span><span class=o>&gt;</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=n>consume</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span><span class=p>(</span><span class=n>p</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>value1</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 或者更简洁地
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>auto</span> <span class=n>p</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>make_shared</span><span class=o>&lt;</span><span class=n>Sample</span><span class=o>&gt;</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=n>consume</span><span class=p>({</span><span class=n>p</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>value1</span><span class=p>});</span>
</span></span></code></pre></td></tr></table></div></div><p>在上面的例子中，我们有一个名为 Sample 的类，其中有两个成员。我们创建了一个 <code>shared_ptr</code>
指向该类，并将其保存在 p 中。但是假设还有另一个函数需要一个 <code>shared_ptr&lt;int></code> 。没问题，
我们可以通过重新使用控制块（参数 p）并替换新的存储指针（参数 <code>&amp;p->value1</code> ）来将
<code>std::shared_ptr&lt;Sample></code> 转换为 <code>std::shared_ptr&lt;int></code> 。consume 函数可以使用
<code>shared_ptr&lt;int></code> 访问 value1 成员，并且该 <code>shared_ptr&lt;int></code> 的控制块防止了 Sample 被销毁，从
而防止了 value1 被销毁。</p><p>这里使用了 C++-20 新增的构造函数 – <strong>别名构造函数</strong> ：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>shared_ptr</span><span class=p>(</span> <span class=n>std</span><span class=o>::</span><span class=n>nullptr_t</span> <span class=n>ptr</span><span class=p>,</span> <span class=n>Deleter</span> <span class=n>d</span><span class=p>,</span> <span class=n>Alloc</span> <span class=n>alloc</span> <span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span> <span class=k>class</span> <span class=nc>Y</span> <span class=o>&gt;</span>   										<span class=p>(</span><span class=mi>8</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>shared_ptr</span><span class=p>(</span> <span class=k>const</span> <span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>Y</span><span class=o>&gt;&amp;</span> <span class=n>r</span><span class=p>,</span> <span class=n>element_type</span><span class=o>*</span> <span class=n>ptr</span> <span class=p>)</span> <span class=k>noexcept</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span> <span class=k>class</span> <span class=nc>Y</span> <span class=o>&gt;</span>   										<span class=p>(</span><span class=mi>8</span><span class=p>)</span>   <span class=p>(</span><span class=n>since</span> <span class=n>C</span><span class=o>++</span><span class=mi>20</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>shared_ptr</span><span class=p>(</span> <span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>Y</span><span class=o>&gt;&amp;&amp;</span> <span class=n>r</span><span class=p>,</span> <span class=n>element_type</span><span class=o>*</span> <span class=n>ptr</span> <span class=p>)</span> <span class=k>noexcept</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><ol><li>The aliasing constructor: constructs a shared_ptr which shares ownership information with the initial value of r, but</li></ol><p>holds an unrelated and unmanaged pointer ptr. If this shared_ptr is the last of the group to go out of scope, it will
call the stored deleter for the object originally managed by r. However, calling get() on this shared_ptr will always
return a copy of ptr. It is the responsibility of the programmer to make sure that this ptr remains valid as long as
this shared_ptr exists, such as in the typical use cases where ptr is a member of the object managed by r or is an alias
(e.g., downcast) of r.get() For the second overload taking an rvalue, r is empty and r.get() == nullptr after the call.
(since C++20)</p><ol><li><strong>别名构造函数：</strong> 构造一个 <code>shared_ptr</code> ，与初始值 r 共享所有权信息，但持有一个无关且
未被管理的指针 ptr。如果这个 <code>shared_ptr</code> 是组中最后一个超出作用域的对象，它将调用 r
最初管理的对象的存储删除器。然而，在这个 <code>shared_ptr</code> 上调用 get()将始终返回 ptr 的拷贝。
程序员负责确保在 <code>shared_ptr</code> 存在期间 ptr 保持有效，例如，在 ptr 是 r 所管理的对象的成
员或者是 r.get() 的别名（例如下转型）的典型用例中。对于接受 rvalue 的第二个重载函数，
调用之后 r 为空，r.get() == nullptr。（自 C++20 起）</li></ol><p>通常情况下，储存的指针的生命周期应该包含在管理对象的生命周期内。这可以是一个直接的包含关
系，就像我们在 value1 中所做的那样，也可以是一个更复杂的生命周期依赖链。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Other</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>value</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Sample2</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=n>Other</span><span class=o>&gt;</span> <span class=n>m_other</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>make_unique</span><span class=o>&lt;</span><span class=n>Other</span><span class=o>&gt;</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>p</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>make_shared</span><span class=o>&lt;</span><span class=n>Sample2</span><span class=o>&gt;</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=n>consume</span><span class=p>({</span><span class=n>p</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>m_other</span><span class=o>-&gt;</span><span class=n>value</span><span class=p>});</span>
</span></span></code></pre></td></tr></table></div></div><p>在第二个例子中，我们传递给 consume()函数的 shared_ptr&lt;int>的存储指针指向 Sample2 对象内部的
value 成员，而 Sample2 对象包含一个独有指针指向 Other 对象。该 shared_ptr&lt;int>中的控制块控制着
Sample2 对象的生命周期，这是可以接受的，因为只要 Sample2 对象存活，Other 对象中的值也将保持
存活。</p><p>现在，编译器不会检查您是否具有从托管对象到存储指针的正向生命周期控制链。您可以做一些愚蠢的事情，比如</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Sample3</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=n>Other</span><span class=o>&gt;</span> <span class=n>m_other</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>make_unique</span><span class=o>&lt;</span><span class=n>Other</span><span class=o>&gt;</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>p</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>make_shared</span><span class=o>&lt;</span><span class=n>Sample3</span><span class=o>&gt;</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=n>consume</span><span class=p>({</span> <span class=n>p</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>m_other</span><span class=o>-&gt;</span><span class=n>value</span> <span class=p>});</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>p</span><span class=o>-&gt;</span><span class=n>m_other</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span> <span class=c1>// 糟糕，链条断了
</span></span></span></code></pre></td></tr></table></div></div><p><code>shared_ptr&lt;int></code> 将认为它仍在保持值的活动状态，即使您断开了从 Sample3 到 Other 的链接。</p><p>或者你可以做更愚蠢的事情，比如</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>int</span> <span class=n>unrelated</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>consume</span><span class=p>({</span> <span class=n>p</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>unrelated</span> <span class=p>});</span>
</span></span></code></pre></td></tr></table></div></div><p>shared_ptr&lt;int> 将访问 unrelated，即使它的生命周期与 Sample2 无关。如果 unrelated 被销毁，shared_ptr&lt;int> 将具有一个悬空的存储指针。</p><p>这些其中托管对象与所指对象不同的 shared_ptr 对象通常被称为别名共享指针。</p><p>好的，所以我展示了一种创建别名共享指针的方法，即通过从现有的 shared_ptr 构造一个
shared_ptr（共享托管对象），并提供一个不同的存储指针。如果新的存储指针指向原始对象的基类，
则 shared_ptr 具有一个转换运算符，用于创建对基类子对象的别名共享指针。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Base</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Derived</span> <span class=o>:</span> <span class=n>Base</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>Derived</span><span class=o>&gt;</span> <span class=n>p</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>make_shared</span><span class=o>&lt;</span><span class=n>Derived</span><span class=o>&gt;</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>Base</span><span class=o>&gt;</span> <span class=n>b</span> <span class=o>=</span> <span class=n>p</span><span class=p>;</span> <span class=c1>// 自动转换等效于
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>Base</span><span class=o>&gt;</span> <span class=n>b</span><span class=p>(</span><span class=n>p</span><span class=p>,</span> <span class=n>p</span><span class=p>.</span><span class=n>get</span><span class=p>());</span>
</span></span></code></pre></td></tr></table></div></div><p>如果要进行反向转换（从 Base 到 Derived），可以显式写出：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>Derived</span><span class=o>&gt;</span> <span class=n>b</span><span class=p>(</span><span class=n>p</span><span class=p>,</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=n>Derived</span><span class=o>/&gt;</span><span class=p>(</span><span class=n>p</span><span class=p>.</span><span class=n>get</span><span class=p>()));</span>
</span></span></code></pre></td></tr></table></div></div><p>当然，这需要存储的 Base 指针确实是较大的 Derived 对象的 Base 部分的指针。</p><p>C++ 语言提供了一些助手函数，通过对另一个 <code>shared_ptr</code> 的存储指针进行转换来构造一个 <code>shared_ptr</code> 。</p><p><a id=figure--fig:screenshot@2023-08-18-09:37:06></a></p><figure><img src=/ox-hugo/screenshot@2023-08-18_09:37:06.png width=800px></figure><p>一切看起来都很好，直到我们看到 <code>dynamic_pointer_cast</code> ，它与使用 <code>dynamic_cast</code> 的一行代码不等价！</p><p>原因是，与其他转换不同， <code>dynamic_cast</code> 可以将非空指针更改为空指针，这在运行时类型不匹配
时发生。在这种情况下， <code>dynamic_pointer_case</code> 返回一个空的 <code>shared_ptr</code> （而不是一个具有控制块但
没有存储指针的 <code>shared_ptr</code> ），因为没有需要扩展生命周期的对象。</p><p>现在我们可以完成该表格：</p><p><a id=figure--fig:screenshot@2023-08-18-09:38:00></a></p><figure><img src=/ox-hugo/screenshot@2023-08-18_09:38:00.png alt="Figure 2: 最终转换表格" width=800px><figcaption><p><span class=figure-number>Figure 2: </span>最终转换表格</p></figcaption></figure><p>关于空指针的控制块的这种细节，说明了共享指针图中两个框在技术上是合法但奇怪的。</p><p><a id=figure--fig:screenshot@2023-08-18-09:39:32></a></p><figure><img src=/ox-hugo/screenshot@2023-08-18_09:39:32.png></figure><p>到目前为止，我们已经处理了空的 <code>shared_ptr</code> （不管理对象且没有存储指针）和完整的
<code>shared_ptr</code> （管理对象且具有存储指针）。但还有另外两个框，我将它们命名为“神秘”和“放纵”。下
次我们将看看这两个奇怪的家伙。</p></div></article></div></div></main><footer id=footer class=footer><div class=social-links><a href=mailto:yang.yingchao@qq.com class="iconfont icon-email" title=email></a>
<a href=http://localhost:1313 class="iconfont icon-stack-overflow" title=stack-overflow></a>
<a href=https://github.com/yangyingchao/ class="iconfont icon-github" title=github></a>
<a href=https://yangyingchao.github.io/index.xml type=application/rss+xml class="iconfont icon-rss" title=rss></a></div><div class=copyright><span class=power-by>由 <a class=hexo-link href=https://gohugo.io>Hugo</a> 强力驱动</span>
<span class=division>|</span>
<span class=theme-info>主题 -
<a class=theme-link href=https://github.com/olOwOlo/hugo-theme-even>Even</a></span>
<span class=copyright-year>&copy;
2017 -
2023<span class=heart><i class="iconfont icon-heart"></i></span><span>yyc</span></span></div></footer><div class=back-to-top id=back-to-top><i class="iconfont icon-up"></i></div></div><script src=https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin=anonymous></script>
<script type=text/javascript src=/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js></script></body></html>