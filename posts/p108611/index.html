<!doctype html><html lang=zh-cn dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>What it means when you convert between different shared_ptrs - The Old New Thing | MyNotes</title><meta name=keywords content="cpp,shared-ptr,lang"><meta name=description content="C++中的 shared_ptr 管理一个引用计数指针。通常情况下，它是一个指向对象的指针，当最后一个引用过期时将被删除。但它不一定非得是这样。 回想一下， shared_ptr 实际上"><meta name=author content><link rel=canonical href=https://yangyingchao.github.io/posts/p108611/><link crossorigin=anonymous href=/assets/css/stylesheet.6a98292fb8fa8cf0f3ba4042d4b75515c04267550f3ad49ff6271b5af9562443.css integrity="sha256-apgpL7j6jPDzukBC1LdVFcBCZ1UPOtSf9icbWvlWJEM=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://yangyingchao.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://yangyingchao.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://yangyingchao.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://yangyingchao.github.io/apple-touch-icon.png><link rel=mask-icon href=https://yangyingchao.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="What it means when you convert between different shared_ptrs - The Old New Thing"><meta property="og:description" content="C++中的 shared_ptr 管理一个引用计数指针。通常情况下，它是一个指向对象的指针，当最后一个引用过期时将被删除。但它不一定非得是这样。 回想一下， shared_ptr 实际上"><meta property="og:type" content="article"><meta property="og:url" content="https://yangyingchao.github.io/posts/p108611/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-08-18T00:00:00+00:00"><meta property="article:modified_time" content="2023-08-18T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="What it means when you convert between different shared_ptrs - The Old New Thing"><meta name=twitter:description content="C++中的 shared_ptr 管理一个引用计数指针。通常情况下，它是一个指向对象的指针，当最后一个引用过期时将被删除。但它不一定非得是这样。 回想一下， shared_ptr 实际上"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://yangyingchao.github.io/posts/"},{"@type":"ListItem","position":3,"name":"What it means when you convert between different shared_ptrs - The Old New Thing","item":"https://yangyingchao.github.io/posts/p108611/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"What it means when you convert between different shared_ptrs - The Old New Thing","name":"What it means when you convert between different shared_ptrs - The Old New Thing","description":"C++中的 shared_ptr 管理一个引用计数指针。通常情况下，它是一个指向对象的指针，当最后一个引用过期时将被删除。但它不一定非得是这样。 回想一下， shared_ptr 实际上","keywords":["cpp","shared-ptr","lang"],"articleBody":"C++中的 shared_ptr 管理一个引用计数指针。通常情况下，它是一个指向对象的指针，当最后一个引用过期时将被删除。但它不一定非得是这样。\n回想一下， shared_ptr 实际上是两个指针。\n指向一个控制块 (control block)的指针，该控制块管理共享和弱引用计数，并在共享引用计数降至零时销毁一个对象（通常称为被管理的对象）。 从 get() 方法返回的指针，通常称为存储指针。 大多数情况下，存储的指针指向托管对象，因为当你使用原始指针构造 shared_ptr 或者调用 make_shared 时，得到的就是托管对象。但是，当托管对象和存储的指针不同的时候，有什么用处呢？\n可能会希望有一个 shared_ptr ，其 get() 方法返回另一个大对象的子对象的指针。在这种情 况下，托管对象是较大的对象，而存储的指针是指向子对象的指针。\n1 2 3 4 5 6 7 8 9 10 11 12 13 struct Sample { int value1; int value2; }; void consume(std::shared_ptr\u003cint\u003e pint); std::shared_ptr\u003cSample\u003e p = std::make_shared\u003cSample\u003e(); consume(std::shared_ptr\u003cint\u003e(p, \u0026p-\u003evalue1)); // 或者更简洁地 auto p = std::make_shared\u003cSample\u003e(); consume({p, \u0026p-\u003evalue1}); 在上面的例子中，我们有一个名为 Sample 的类，其中有两个成员。我们创建了一个 shared_ptr 指向该类，并将其保存在 p 中。但是假设还有另一个函数需要一个 shared_ptr 。没问题， 我们可以通过重新使用控制块（参数 p）并替换新的存储指针（参数 \u0026p-\u003evalue1 ）来将 std::shared_ptr 转换为 std::shared_ptr 。consume 函数可以使用 shared_ptr 访问 value1 成员，并且该 shared_ptr 的控制块防止了 Sample 被销毁，从 而防止了 value1 被销毁。\n这里使用了 C++-20 新增的构造函数 – 别名构造函数 ：\n1 2 3 4 5 shared_ptr( std::nullptr_t ptr, Deleter d, Alloc alloc ); template\u003c class Y \u003e (8) shared_ptr( const shared_ptr\u003cY\u003e\u0026 r, element_type* ptr ) noexcept; template\u003c class Y \u003e (8) (since C++20) shared_ptr( shared_ptr\u003cY\u003e\u0026\u0026 r, element_type* ptr ) noexcept; The aliasing constructor: constructs a shared_ptr which shares ownership information with the initial value of r, but holds an unrelated and unmanaged pointer ptr. If this shared_ptr is the last of the group to go out of scope, it will call the stored deleter for the object originally managed by r. However, calling get() on this shared_ptr will always return a copy of ptr. It is the responsibility of the programmer to make sure that this ptr remains valid as long as this shared_ptr exists, such as in the typical use cases where ptr is a member of the object managed by r or is an alias (e.g., downcast) of r.get() For the second overload taking an rvalue, r is empty and r.get() == nullptr after the call. (since C++20)\n别名构造函数： 构造一个 shared_ptr ，与初始值 r 共享所有权信息，但持有一个无关且 未被管理的指针 ptr。如果这个 shared_ptr 是组中最后一个超出作用域的对象，它将调用 r 最初管理的对象的存储删除器。然而，在这个 shared_ptr 上调用 get()将始终返回 ptr 的拷贝。 程序员负责确保在 shared_ptr 存在期间 ptr 保持有效，例如，在 ptr 是 r 所管理的对象的成 员或者是 r.get() 的别名（例如下转型）的典型用例中。对于接受 rvalue 的第二个重载函数， 调用之后 r 为空，r.get() == nullptr。（自 C++20 起） 通常情况下，储存的指针的生命周期应该包含在管理对象的生命周期内。这可以是一个直接的包含关 系，就像我们在 value1 中所做的那样，也可以是一个更复杂的生命周期依赖链。\n1 2 3 4 5 6 7 8 9 struct Other { int value; }; struct Sample2 { const std::unique_ptr\u003cOther\u003e m_other = std::make_unique\u003cOther\u003e(); }; auto p = std::make_shared\u003cSample2\u003e(); consume({p, \u0026p-\u003em_other-\u003evalue}); 在第二个例子中，我们传递给 consume()函数的 shared_ptr的存储指针指向 Sample2 对象内部的 value 成员，而 Sample2 对象包含一个独有指针指向 Other 对象。该 shared_ptr中的控制块控制着 Sample2 对象的生命周期，这是可以接受的，因为只要 Sample2 对象存活，Other 对象中的值也将保持 存活。\n现在，编译器不会检查您是否具有从托管对象到存储指针的正向生命周期控制链。您可以做一些愚蠢的事情，比如\n1 2 3 4 5 6 7 8 9 struct Sample3 { std::unique_ptr\u003cOther\u003e m_other = std::make_unique\u003cOther\u003e(); }; auto p = std::make_shared\u003cSample3\u003e(); consume({ p, \u0026p-\u003em_other-\u003evalue }); p-\u003em_other = nullptr; // 糟糕，链条断了 shared_ptr 将认为它仍在保持值的活动状态，即使您断开了从 Sample3 到 Other 的链接。\n或者你可以做更愚蠢的事情，比如\n1 2 int unrelated; consume({ p, \u0026unrelated }); shared_ptr 将访问 unrelated，即使它的生命周期与 Sample2 无关。如果 unrelated 被销毁，shared_ptr 将具有一个悬空的存储指针。\n这些其中托管对象与所指对象不同的 shared_ptr 对象通常被称为别名共享指针。\n好的，所以我展示了一种创建别名共享指针的方法，即通过从现有的 shared_ptr 构造一个 shared_ptr（共享托管对象），并提供一个不同的存储指针。如果新的存储指针指向原始对象的基类， 则 shared_ptr 具有一个转换运算符，用于创建对基类子对象的别名共享指针。\n1 2 3 4 5 6 7 8 9 struct Base { }; struct Derived : Base { }; std::shared_ptr\u003cDerived\u003e p = std::make_shared\u003cDerived\u003e(); std::shared_ptr\u003cBase\u003e b = p; // 自动转换等效于 std::shared_ptr\u003cBase\u003e b(p, p.get()); 如果要进行反向转换（从 Base 到 Derived），可以显式写出：\n1 std::shared_ptr\u003cDerived\u003e b(p, static_cast\u003cDerived/\u003e(p.get())); 当然，这需要存储的 Base 指针确实是较大的 Derived 对象的 Base 部分的指针。\nC++ 语言提供了一些助手函数，通过对另一个 shared_ptr 的存储指针进行转换来构造一个 shared_ptr 。\n一切看起来都很好，直到我们看到 dynamic_pointer_cast ，它与使用 dynamic_cast 的一行代码不等价！\n原因是，与其他转换不同， dynamic_cast 可以将非空指针更改为空指针，这在运行时类型不匹配 时发生。在这种情况下， dynamic_pointer_case 返回一个空的 shared_ptr （而不是一个具有控制块但 没有存储指针的 shared_ptr ），因为没有需要扩展生命周期的对象。\n现在我们可以完成该表格：\nFigure 2: 最终转换表格\n关于空指针的控制块的这种细节，说明了共享指针图中两个框在技术上是合法但奇怪的。\n到目前为止，我们已经处理了空的 shared_ptr （不管理对象且没有存储指针）和完整的 shared_ptr （管理对象且具有存储指针）。但还有另外两个框，我将它们命名为“神秘”和“放纵”。下 次我们将看看这两个奇怪的家伙。\n","wordCount":"1924","inLanguage":"zh-cn","datePublished":"2023-08-18T00:00:00Z","dateModified":"2023-08-18T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://yangyingchao.github.io/posts/p108611/"},"publisher":{"@type":"Organization","name":"MyNotes","logo":{"@type":"ImageObject","url":"https://yangyingchao.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://yangyingchao.github.io accesskey=h title="MyNotes (Alt + H)">MyNotes</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>What it means when you convert between different shared_ptrs - The Old New Thing</h1><div class=post-meta><span title='2023-08-18 00:00:00 +0000 UTC'>August 18, 2023</span></div></header><div class=post-content><p>C++中的 <code>shared_ptr</code> 管理一个引用计数指针。通常情况下，它是一个指向对象的指针，当最后一个引用过期时将被删除。但它不一定非得是这样。</p><p>回想一下， <code>shared_ptr</code> 实际上是两个指针。</p><ul><li>指向一个控制块 (control block)的指针，该控制块管理共享和弱引用计数，并在共享引用计数降至零时销毁一个对象（通常称为被管理的对象）。</li><li>从 <code>get()</code> 方法返回的指针，通常称为存储指针。</li></ul><p>大多数情况下，存储的指针指向托管对象，因为当你使用原始指针构造 <code>shared_ptr</code> 或者调用
<code>make_shared</code> 时，得到的就是托管对象。但是，当托管对象和存储的指针不同的时候，有什么用处呢？</p><p>可能会希望有一个 <code>shared_ptr</code> ，其 <code>get()</code> 方法返回另一个大对象的子对象的指针。在这种情
况下，托管对象是较大的对象，而存储的指针是指向子对象的指针。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Sample</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>value1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>value2</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>consume</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>pint</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>Sample</span><span class=o>&gt;</span> <span class=n>p</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>make_shared</span><span class=o>&lt;</span><span class=n>Sample</span><span class=o>&gt;</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=n>consume</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span><span class=p>(</span><span class=n>p</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>value1</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 或者更简洁地
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>auto</span> <span class=n>p</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>make_shared</span><span class=o>&lt;</span><span class=n>Sample</span><span class=o>&gt;</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=n>consume</span><span class=p>({</span><span class=n>p</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>value1</span><span class=p>});</span>
</span></span></code></pre></td></tr></table></div></div><p>在上面的例子中，我们有一个名为 Sample 的类，其中有两个成员。我们创建了一个 <code>shared_ptr</code>
指向该类，并将其保存在 p 中。但是假设还有另一个函数需要一个 <code>shared_ptr&lt;int></code> 。没问题，
我们可以通过重新使用控制块（参数 p）并替换新的存储指针（参数 <code>&amp;p->value1</code> ）来将
<code>std::shared_ptr&lt;Sample></code> 转换为 <code>std::shared_ptr&lt;int></code> 。consume 函数可以使用
<code>shared_ptr&lt;int></code> 访问 value1 成员，并且该 <code>shared_ptr&lt;int></code> 的控制块防止了 Sample 被销毁，从
而防止了 value1 被销毁。</p><p>这里使用了 C++-20 新增的构造函数 – <strong>别名构造函数</strong> ：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>shared_ptr</span><span class=p>(</span> <span class=n>std</span><span class=o>::</span><span class=n>nullptr_t</span> <span class=n>ptr</span><span class=p>,</span> <span class=n>Deleter</span> <span class=n>d</span><span class=p>,</span> <span class=n>Alloc</span> <span class=n>alloc</span> <span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span> <span class=k>class</span> <span class=nc>Y</span> <span class=o>&gt;</span>   										<span class=p>(</span><span class=mi>8</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>shared_ptr</span><span class=p>(</span> <span class=k>const</span> <span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>Y</span><span class=o>&gt;&amp;</span> <span class=n>r</span><span class=p>,</span> <span class=n>element_type</span><span class=o>*</span> <span class=n>ptr</span> <span class=p>)</span> <span class=k>noexcept</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span> <span class=k>class</span> <span class=nc>Y</span> <span class=o>&gt;</span>   										<span class=p>(</span><span class=mi>8</span><span class=p>)</span>   <span class=p>(</span><span class=n>since</span> <span class=n>C</span><span class=o>++</span><span class=mi>20</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>shared_ptr</span><span class=p>(</span> <span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>Y</span><span class=o>&gt;&amp;&amp;</span> <span class=n>r</span><span class=p>,</span> <span class=n>element_type</span><span class=o>*</span> <span class=n>ptr</span> <span class=p>)</span> <span class=k>noexcept</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><ol><li>The aliasing constructor: constructs a shared_ptr which shares ownership information with the initial value of r, but</li></ol><p>holds an unrelated and unmanaged pointer ptr. If this shared_ptr is the last of the group to go out of scope, it will
call the stored deleter for the object originally managed by r. However, calling get() on this shared_ptr will always
return a copy of ptr. It is the responsibility of the programmer to make sure that this ptr remains valid as long as
this shared_ptr exists, such as in the typical use cases where ptr is a member of the object managed by r or is an alias
(e.g., downcast) of r.get() For the second overload taking an rvalue, r is empty and r.get() == nullptr after the call.
(since C++20)</p><ol><li><strong>别名构造函数：</strong> 构造一个 <code>shared_ptr</code> ，与初始值 r 共享所有权信息，但持有一个无关且
未被管理的指针 ptr。如果这个 <code>shared_ptr</code> 是组中最后一个超出作用域的对象，它将调用 r
最初管理的对象的存储删除器。然而，在这个 <code>shared_ptr</code> 上调用 get()将始终返回 ptr 的拷贝。
程序员负责确保在 <code>shared_ptr</code> 存在期间 ptr 保持有效，例如，在 ptr 是 r 所管理的对象的成
员或者是 r.get() 的别名（例如下转型）的典型用例中。对于接受 rvalue 的第二个重载函数，
调用之后 r 为空，r.get() == nullptr。（自 C++20 起）</li></ol><p>通常情况下，储存的指针的生命周期应该包含在管理对象的生命周期内。这可以是一个直接的包含关
系，就像我们在 value1 中所做的那样，也可以是一个更复杂的生命周期依赖链。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Other</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>value</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Sample2</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=n>Other</span><span class=o>&gt;</span> <span class=n>m_other</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>make_unique</span><span class=o>&lt;</span><span class=n>Other</span><span class=o>&gt;</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>p</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>make_shared</span><span class=o>&lt;</span><span class=n>Sample2</span><span class=o>&gt;</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=n>consume</span><span class=p>({</span><span class=n>p</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>m_other</span><span class=o>-&gt;</span><span class=n>value</span><span class=p>});</span>
</span></span></code></pre></td></tr></table></div></div><p>在第二个例子中，我们传递给 consume()函数的 shared_ptr&lt;int>的存储指针指向 Sample2 对象内部的
value 成员，而 Sample2 对象包含一个独有指针指向 Other 对象。该 shared_ptr&lt;int>中的控制块控制着
Sample2 对象的生命周期，这是可以接受的，因为只要 Sample2 对象存活，Other 对象中的值也将保持
存活。</p><p>现在，编译器不会检查您是否具有从托管对象到存储指针的正向生命周期控制链。您可以做一些愚蠢的事情，比如</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Sample3</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=n>Other</span><span class=o>&gt;</span> <span class=n>m_other</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>make_unique</span><span class=o>&lt;</span><span class=n>Other</span><span class=o>&gt;</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>p</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>make_shared</span><span class=o>&lt;</span><span class=n>Sample3</span><span class=o>&gt;</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=n>consume</span><span class=p>({</span> <span class=n>p</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>m_other</span><span class=o>-&gt;</span><span class=n>value</span> <span class=p>});</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>p</span><span class=o>-&gt;</span><span class=n>m_other</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span> <span class=c1>// 糟糕，链条断了
</span></span></span></code></pre></td></tr></table></div></div><p><code>shared_ptr&lt;int></code> 将认为它仍在保持值的活动状态，即使您断开了从 Sample3 到 Other 的链接。</p><p>或者你可以做更愚蠢的事情，比如</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>int</span> <span class=n>unrelated</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>consume</span><span class=p>({</span> <span class=n>p</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>unrelated</span> <span class=p>});</span>
</span></span></code></pre></td></tr></table></div></div><p>shared_ptr&lt;int> 将访问 unrelated，即使它的生命周期与 Sample2 无关。如果 unrelated 被销毁，shared_ptr&lt;int> 将具有一个悬空的存储指针。</p><p>这些其中托管对象与所指对象不同的 shared_ptr 对象通常被称为别名共享指针。</p><p>好的，所以我展示了一种创建别名共享指针的方法，即通过从现有的 shared_ptr 构造一个
shared_ptr（共享托管对象），并提供一个不同的存储指针。如果新的存储指针指向原始对象的基类，
则 shared_ptr 具有一个转换运算符，用于创建对基类子对象的别名共享指针。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Base</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Derived</span> <span class=o>:</span> <span class=n>Base</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>Derived</span><span class=o>&gt;</span> <span class=n>p</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>make_shared</span><span class=o>&lt;</span><span class=n>Derived</span><span class=o>&gt;</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>Base</span><span class=o>&gt;</span> <span class=n>b</span> <span class=o>=</span> <span class=n>p</span><span class=p>;</span> <span class=c1>// 自动转换等效于
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>Base</span><span class=o>&gt;</span> <span class=n>b</span><span class=p>(</span><span class=n>p</span><span class=p>,</span> <span class=n>p</span><span class=p>.</span><span class=n>get</span><span class=p>());</span>
</span></span></code></pre></td></tr></table></div></div><p>如果要进行反向转换（从 Base 到 Derived），可以显式写出：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>Derived</span><span class=o>&gt;</span> <span class=n>b</span><span class=p>(</span><span class=n>p</span><span class=p>,</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=n>Derived</span><span class=o>/&gt;</span><span class=p>(</span><span class=n>p</span><span class=p>.</span><span class=n>get</span><span class=p>()));</span>
</span></span></code></pre></td></tr></table></div></div><p>当然，这需要存储的 Base 指针确实是较大的 Derived 对象的 Base 部分的指针。</p><p>C++ 语言提供了一些助手函数，通过对另一个 <code>shared_ptr</code> 的存储指针进行转换来构造一个 <code>shared_ptr</code> 。</p><p></p><figure><img loading=lazy src=/ox-hugo/screenshot@2023-08-18_09:37:06.png width=800px></figure><p>一切看起来都很好，直到我们看到 <code>dynamic_pointer_cast</code> ，它与使用 <code>dynamic_cast</code> 的一行代码不等价！</p><p>原因是，与其他转换不同， <code>dynamic_cast</code> 可以将非空指针更改为空指针，这在运行时类型不匹配
时发生。在这种情况下， <code>dynamic_pointer_case</code> 返回一个空的 <code>shared_ptr</code> （而不是一个具有控制块但
没有存储指针的 <code>shared_ptr</code> ），因为没有需要扩展生命周期的对象。</p><p>现在我们可以完成该表格：</p><p></p><figure><img loading=lazy src=/ox-hugo/screenshot@2023-08-18_09:38:00.png alt="Figure 2: 最终转换表格" width=800px><figcaption><p>Figure 2: 最终转换表格</p></figcaption></figure><p>关于空指针的控制块的这种细节，说明了共享指针图中两个框在技术上是合法但奇怪的。</p><p></p><figure><img loading=lazy src=/ox-hugo/screenshot@2023-08-18_09:39:32.png></figure><p>到目前为止，我们已经处理了空的 <code>shared_ptr</code> （不管理对象且没有存储指针）和完整的
<code>shared_ptr</code> （管理对象且具有存储指针）。但还有另外两个框，我将它们命名为“神秘”和“放纵”。下
次我们将看看这两个奇怪的家伙。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://yangyingchao.github.io/tags/cpp/>cpp</a></li><li><a href=https://yangyingchao.github.io/tags/shared-ptr/>shared-ptr</a></li><li><a href=https://yangyingchao.github.io/tags/lang/>lang</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://yangyingchao.github.io>MyNotes</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>