<!doctype html><html lang=zh-cn><head><title>What it means when you convert between different shared_ptrs - The Old New Thing · MyNotes</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="yyc"><meta name=description content="本文为摘录，原文为： https://devblogs.microsoft.com/oldnewthing/20230817-00/?p=108611 C++中的 shared_ptr 管理一个引用计数指针。通常情况下，它是一个指向对象的指针，当最后一个引用过期时将被删除。但它不一定非得是这"><meta name=keywords content="blog,developer,personal"><meta name=twitter:card content="summary"><meta name=twitter:title content="What it means when you convert between different shared_ptrs - The Old New Thing"><meta name=twitter:description content="本文为摘录，原文为： https://devblogs.microsoft.com/oldnewthing/20230817-00/?p=108611 C++中的 shared_ptr 管理一个引用计数指针。通常情况下，它是一个指向对象的指针，当最后一个引用过期时将被删除。但它不一定非得是这"><meta property="og:title" content="What it means when you convert between different shared_ptrs - The Old New Thing"><meta property="og:description" content="本文为摘录，原文为： https://devblogs.microsoft.com/oldnewthing/20230817-00/?p=108611 C++中的 shared_ptr 管理一个引用计数指针。通常情况下，它是一个指向对象的指针，当最后一个引用过期时将被删除。但它不一定非得是这"><meta property="og:type" content="article"><meta property="og:url" content="https://yangyingchao.github.io/posts/p108611/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-08-18T00:00:00+00:00"><meta property="article:modified_time" content="2023-08-18T00:00:00+00:00"><link rel=canonical href=https://yangyingchao.github.io/posts/p108611/><link rel=preload href="/fonts/forkawesome-webfont.woff2?v=1.2.0" as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.135e22c97ff685fe983fc60048e309ced8f00d8d38f536aa67dba8a13a03dfa4.css integrity="sha256-E14iyX/2hf6YP8YASOMJztjwDY049TaqZ9uooToD36Q=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.a00e6364bacbc8266ad1cc81230774a1397198f8cfb7bcba29b7d6fcb54ce57f.css integrity="sha256-oA5jZLrLyCZq0cyBIwd0oTlxmPjPt7y6KbfW/LVM5X8=" crossorigin=anonymous media=screen><link rel=icon type=image/svg+xml href=/images/favicon.svg sizes=any><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5></head><body class="preload-transitions colorscheme-auto"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=/>MyNotes</a>
<input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/posts/>Blog</a></li><li class=navigation-item><a class=navigation-link href=/tags/>Tags</a></li><li class=navigation-item><a class=navigation-link href=/contact/>Contact me</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://yangyingchao.github.io/posts/p108611/>What it means when you convert between different shared_ptrs - The Old New Thing</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa fa-calendar" aria-hidden=true></i>
<time datetime=2023-08-18T00:00:00Z>August 18, 2023</time></span>
<span class=reading-time><i class="fa fa-clock-o" aria-hidden=true></i>
阅读时间：4 分钟</span></div><div class=tags><i class="fa fa-tag" aria-hidden=true></i>
<span class=tag><a href=/tags/cpp/>cpp</a></span>
<span class=separator>•</span>
<span class=tag><a href=/tags/shared-ptr/>shared-ptr</a></span>
<span class=separator>•</span>
<span class=tag><a href=/tags/lang/>lang</a></span></div></div></header><div class=post-content><p>本文为摘录，原文为： <a href="https://devblogs.microsoft.com/oldnewthing/20230817-00/?p=108611" class=external-link target=_blank rel=noopener>https://devblogs.microsoft.com/oldnewthing/20230817-00/?p=108611</a></p><p>C++中的 <code>shared_ptr</code> 管理一个引用计数指针。通常情况下，它是一个指向对象的指针，当最后一个引用过期时将被删除。但它不一定非得是这样。</p><p>回想一下， <code>shared_ptr</code> 实际上是两个指针。</p><ul><li>指向一个控制块 (control block)的指针，该控制块管理共享和弱引用计数，并在共享引用计数降至零时销毁一个对象（通常称为被管理的对象）。</li><li>从 <code>get()</code> 方法返回的指针，通常称为存储指针。</li></ul><p>大多数情况下，存储的指针指向托管对象，因为当你使用原始指针构造 <code>shared_ptr</code> 或者调用
<code>make_shared</code> 时，得到的就是托管对象。但是，当托管对象和存储的指针不同的时候，有什么用处呢？</p><p>可能会希望有一个 <code>shared_ptr</code> ，其 <code>get()</code> 方法返回另一个大对象的子对象的指针。在这种情
况下，托管对象是较大的对象，而存储的指针是指向子对象的指针。</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:green;font-weight:700>struct</span> <span style=color:#00f;font-weight:700>Sample</span> {
</span></span><span style=display:flex><span>  <span style=color:#b00040>int</span> value1;
</span></span><span style=display:flex><span>  <span style=color:#b00040>int</span> value2;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#b00040>void</span> <span style=color:#00f>consume</span>(std<span style=color:#666>::</span>shared_ptr<span style=color:#666>&lt;</span><span style=color:#b00040>int</span><span style=color:#666>&gt;</span> pint);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>std<span style=color:#666>::</span>shared_ptr<span style=color:#666>&lt;</span>Sample<span style=color:#666>&gt;</span> p <span style=color:#666>=</span> std<span style=color:#666>::</span>make_shared<span style=color:#666>&lt;</span>Sample<span style=color:#666>&gt;</span>();
</span></span><span style=display:flex><span>consume(std<span style=color:#666>::</span>shared_ptr<span style=color:#666>&lt;</span><span style=color:#b00040>int</span><span style=color:#666>&gt;</span>(p, <span style=color:#666>&amp;</span>p<span style=color:#666>-&gt;</span>value1));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// 或者更简洁地
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span><span style=color:green;font-weight:700>auto</span> p <span style=color:#666>=</span> std<span style=color:#666>::</span>make_shared<span style=color:#666>&lt;</span>Sample<span style=color:#666>&gt;</span>();
</span></span><span style=display:flex><span>consume({p, <span style=color:#666>&amp;</span>p<span style=color:#666>-&gt;</span>value1});
</span></span></code></pre></div><p>在上面的例子中，我们有一个名为 Sample 的类，其中有两个成员。我们创建了一个 <code>shared_ptr</code>
指向该类，并将其保存在 p 中。但是假设还有另一个函数需要一个 <code>shared_ptr&lt;int></code> 。没问题，
我们可以通过重新使用控制块（参数 p）并替换新的存储指针（参数 <code>&amp;p->value1</code> ）来将
<code>std::shared_ptr&lt;Sample></code> 转换为 <code>std::shared_ptr&lt;int></code> 。consume 函数可以使用
<code>shared_ptr&lt;int></code> 访问 value1 成员，并且该 <code>shared_ptr&lt;int></code> 的控制块防止了 Sample 被销毁，从
而防止了 value1 被销毁。</p><p>这里使用了 C++-20 新增的构造函数 – <strong>别名构造函数</strong> ：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>shared_ptr( std<span style=color:#666>::</span>nullptr_t ptr, Deleter d, Alloc alloc );
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>template</span><span style=color:#666>&lt;</span> <span style=color:green;font-weight:700>class</span> <span style=color:#00f;font-weight:700>Y</span> <span style=color:#666>&gt;</span>   										(<span style=color:#666>8</span>)
</span></span><span style=display:flex><span>shared_ptr( <span style=color:green;font-weight:700>const</span> shared_ptr<span style=color:#666>&lt;</span>Y<span style=color:#666>&gt;&amp;</span> r, element_type<span style=color:#666>*</span> ptr ) <span style=color:green;font-weight:700>noexcept</span>;
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>template</span><span style=color:#666>&lt;</span> <span style=color:green;font-weight:700>class</span> <span style=color:#00f;font-weight:700>Y</span> <span style=color:#666>&gt;</span>   										(<span style=color:#666>8</span>)   (since C<span style=color:#666>++</span><span style=color:#666>20</span>)
</span></span><span style=display:flex><span>shared_ptr( shared_ptr<span style=color:#666>&lt;</span>Y<span style=color:#666>&gt;&amp;&amp;</span> r, element_type<span style=color:#666>*</span> ptr ) <span style=color:green;font-weight:700>noexcept</span>;
</span></span></code></pre></div><ol><li>The aliasing constructor: constructs a shared_ptr which shares ownership information with the initial value of r, but</li></ol><p>holds an unrelated and unmanaged pointer ptr. If this shared_ptr is the last of the group to go out of scope, it will
call the stored deleter for the object originally managed by r. However, calling get() on this shared_ptr will always
return a copy of ptr. It is the responsibility of the programmer to make sure that this ptr remains valid as long as
this shared_ptr exists, such as in the typical use cases where ptr is a member of the object managed by r or is an alias
(e.g., downcast) of r.get() For the second overload taking an rvalue, r is empty and r.get() == nullptr after the call.
(since C++20)</p><ol><li><strong>别名构造函数：</strong> 构造一个 <code>shared_ptr</code> ，与初始值 r 共享所有权信息，但持有一个无关且
未被管理的指针 ptr。如果这个 <code>shared_ptr</code> 是组中最后一个超出作用域的对象，它将调用 r
最初管理的对象的存储删除器。然而，在这个 <code>shared_ptr</code> 上调用 get()将始终返回 ptr 的拷贝。
程序员负责确保在 <code>shared_ptr</code> 存在期间 ptr 保持有效，例如，在 ptr 是 r 所管理的对象的成
员或者是 r.get() 的别名（例如下转型）的典型用例中。对于接受 rvalue 的第二个重载函数，
调用之后 r 为空，r.get() == nullptr。（自 C++20 起）</li></ol><p>通常情况下，储存的指针的生命周期应该包含在管理对象的生命周期内。这可以是一个直接的包含关
系，就像我们在 value1 中所做的那样，也可以是一个更复杂的生命周期依赖链。</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:green;font-weight:700>struct</span> <span style=color:#00f;font-weight:700>Other</span> {
</span></span><span style=display:flex><span>  <span style=color:#b00040>int</span> value;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>struct</span> <span style=color:#00f;font-weight:700>Sample2</span> {
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>const</span> std<span style=color:#666>::</span>unique_ptr<span style=color:#666>&lt;</span>Other<span style=color:#666>&gt;</span> m_other <span style=color:#666>=</span> std<span style=color:#666>::</span>make_unique<span style=color:#666>&lt;</span>Other<span style=color:#666>&gt;</span>();
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>auto</span> p <span style=color:#666>=</span> std<span style=color:#666>::</span>make_shared<span style=color:#666>&lt;</span>Sample2<span style=color:#666>&gt;</span>();
</span></span><span style=display:flex><span>consume({p, <span style=color:#666>&amp;</span>p<span style=color:#666>-&gt;</span>m_other<span style=color:#666>-&gt;</span>value});
</span></span></code></pre></div><p>在第二个例子中，我们传递给 consume()函数的 shared_ptr&lt;int>的存储指针指向 Sample2 对象内部的
value 成员，而 Sample2 对象包含一个独有指针指向 Other 对象。该 shared_ptr&lt;int>中的控制块控制着
Sample2 对象的生命周期，这是可以接受的，因为只要 Sample2 对象存活，Other 对象中的值也将保持
存活。</p><p>现在，编译器不会检查您是否具有从托管对象到存储指针的正向生命周期控制链。您可以做一些愚蠢的事情，比如</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:green;font-weight:700>struct</span> <span style=color:#00f;font-weight:700>Sample3</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    std<span style=color:#666>::</span>unique_ptr<span style=color:#666>&lt;</span>Other<span style=color:#666>&gt;</span> m_other <span style=color:#666>=</span> std<span style=color:#666>::</span>make_unique<span style=color:#666>&lt;</span>Other<span style=color:#666>&gt;</span>();
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>auto</span> p <span style=color:#666>=</span> std<span style=color:#666>::</span>make_shared<span style=color:#666>&lt;</span>Sample3<span style=color:#666>&gt;</span>();
</span></span><span style=display:flex><span>consume({ p, <span style=color:#666>&amp;</span>p<span style=color:#666>-&gt;</span>m_other<span style=color:#666>-&gt;</span>value });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>p<span style=color:#666>-&gt;</span>m_other <span style=color:#666>=</span> <span style=color:green;font-weight:700>nullptr</span>; <span style=color:#408080;font-style:italic>// 糟糕，链条断了
</span></span></span></code></pre></div><p><code>shared_ptr&lt;int></code> 将认为它仍在保持值的活动状态，即使您断开了从 Sample3 到 Other 的链接。</p><p>或者你可以做更愚蠢的事情，比如</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#b00040>int</span> unrelated;
</span></span><span style=display:flex><span>consume({ p, <span style=color:#666>&amp;</span>unrelated });
</span></span></code></pre></div><p>shared_ptr&lt;int> 将访问 unrelated，即使它的生命周期与 Sample2 无关。如果 unrelated 被销毁，shared_ptr&lt;int> 将具有一个悬空的存储指针。</p><p>这些其中托管对象与所指对象不同的 shared_ptr 对象通常被称为别名共享指针。</p><p>好的，所以我展示了一种创建别名共享指针的方法，即通过从现有的 shared_ptr 构造一个
shared_ptr（共享托管对象），并提供一个不同的存储指针。如果新的存储指针指向原始对象的基类，
则 shared_ptr 具有一个转换运算符，用于创建对基类子对象的别名共享指针。</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:green;font-weight:700>struct</span> <span style=color:#00f;font-weight:700>Base</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>struct</span> <span style=color:#00f;font-weight:700>Derived</span> <span style=color:#666>:</span> Base
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>std<span style=color:#666>::</span>shared_ptr<span style=color:#666>&lt;</span>Derived<span style=color:#666>&gt;</span> p <span style=color:#666>=</span> std<span style=color:#666>::</span>make_shared<span style=color:#666>&lt;</span>Derived<span style=color:#666>&gt;</span>();
</span></span><span style=display:flex><span>std<span style=color:#666>::</span>shared_ptr<span style=color:#666>&lt;</span>Base<span style=color:#666>&gt;</span> b <span style=color:#666>=</span> p; <span style=color:#408080;font-style:italic>// 自动转换等效于
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>std<span style=color:#666>::</span>shared_ptr<span style=color:#666>&lt;</span>Base<span style=color:#666>&gt;</span> b(p, p.get());
</span></span></code></pre></div><p>如果要进行反向转换（从 Base 到 Derived），可以显式写出：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>std<span style=color:#666>::</span>shared_ptr<span style=color:#666>&lt;</span>Derived<span style=color:#666>&gt;</span> b(p, <span style=color:green;font-weight:700>static_cast</span><span style=color:#666>&lt;</span>Derived<span style=color:#666>/&gt;</span>(p.get()));
</span></span></code></pre></div><p>当然，这需要存储的 Base 指针确实是较大的 Derived 对象的 Base 部分的指针。</p><p>C++ 语言提供了一些助手函数，通过对另一个 <code>shared_ptr</code> 的存储指针进行转换来构造一个 <code>shared_ptr</code> 。</p><p></p><figure><img src=/ox-hugo/screenshot@2023-08-18_09:37:06.png width=800px></figure><p>一切看起来都很好，直到我们看到 <code>dynamic_pointer_cast</code> ，它与使用 <code>dynamic_cast</code> 的一行代码不等价！</p><p>原因是，与其他转换不同， <code>dynamic_cast</code> 可以将非空指针更改为空指针，这在运行时类型不匹配
时发生。在这种情况下， <code>dynamic_pointer_case</code> 返回一个空的 <code>shared_ptr</code> （而不是一个具有控制块但
没有存储指针的 <code>shared_ptr</code> ），因为没有需要扩展生命周期的对象。</p><p>现在我们可以完成该表格：</p><p></p><figure><img src=/ox-hugo/screenshot@2023-08-18_09:38:00.png alt="Figure 2: 最终转换表格" width=800px><figcaption><p>Figure 2: 最终转换表格</p></figcaption></figure><p>关于空指针的控制块的这种细节，说明了共享指针图中两个框在技术上是合法但奇怪的。</p><p></p><figure><img src=/ox-hugo/screenshot@2023-08-18_09:39:32.png></figure><p>到目前为止，我们已经处理了空的 <code>shared_ptr</code> （不管理对象且没有存储指针）和完整的
<code>shared_ptr</code> （管理对象且具有存储指针）。但还有另外两个框，我将它们命名为“神秘”和“放纵”。下
次我们将看看这两个奇怪的家伙。</p></div><footer></footer></article></section></div><footer class=footer><section class=container>©
2023
yyc
·
技术支持 <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/ target=_blank rel=noopener>Coder</a>.</section></footer></main><script src=/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script></body></html>