<!doctype html><html lang=zh-cn dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Your Read is Our Priority in Flash Storage | MyNotes</title><meta name=keywords content="read,performance,ssd,raw,rw,openssd"><meta name=description content="1 ABSTRACT 2 INTRODUCTION 3 BACKGROUND 3.1 I/O Asymmetry in Flash SSDs 3.2 RAW Protocol in DBMS Buffer 3.3 RAW Protocol in Storage Buffer 4 READ STALL IN DBMS AND RW COMMAND 4.1 Read Stalls inRelational DBMS Buffer 4.2 RW Command 5 READ STALL IN STORAGE AND R-BUF 5.1 Read Stalls in SSD Buffer 本文为摘录，原文为： attachments/pdf/e/p1911-lee.pdf 1 ABSTRACT 问题："><meta name=author content><link rel=canonical href=https://yangyingchao.github.io/posts/p1911-lee/><link crossorigin=anonymous href=/assets/css/stylesheet.6a98292fb8fa8cf0f3ba4042d4b75515c04267550f3ad49ff6271b5af9562443.css integrity="sha256-apgpL7j6jPDzukBC1LdVFcBCZ1UPOtSf9icbWvlWJEM=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://yangyingchao.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://yangyingchao.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://yangyingchao.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://yangyingchao.github.io/apple-touch-icon.png><link rel=mask-icon href=https://yangyingchao.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Your Read is Our Priority in Flash Storage"><meta property="og:description" content="1 ABSTRACT 2 INTRODUCTION 3 BACKGROUND 3.1 I/O Asymmetry in Flash SSDs 3.2 RAW Protocol in DBMS Buffer 3.3 RAW Protocol in Storage Buffer 4 READ STALL IN DBMS AND RW COMMAND 4.1 Read Stalls inRelational DBMS Buffer 4.2 RW Command 5 READ STALL IN STORAGE AND R-BUF 5.1 Read Stalls in SSD Buffer 本文为摘录，原文为： attachments/pdf/e/p1911-lee.pdf 1 ABSTRACT 问题："><meta property="og:type" content="article"><meta property="og:url" content="https://yangyingchao.github.io/posts/p1911-lee/"><meta property="article:section" content="posts"><meta name=twitter:card content="summary"><meta name=twitter:title content="Your Read is Our Priority in Flash Storage"><meta name=twitter:description content="1 ABSTRACT 2 INTRODUCTION 3 BACKGROUND 3.1 I/O Asymmetry in Flash SSDs 3.2 RAW Protocol in DBMS Buffer 3.3 RAW Protocol in Storage Buffer 4 READ STALL IN DBMS AND RW COMMAND 4.1 Read Stalls inRelational DBMS Buffer 4.2 RW Command 5 READ STALL IN STORAGE AND R-BUF 5.1 Read Stalls in SSD Buffer 本文为摘录，原文为： attachments/pdf/e/p1911-lee.pdf 1 ABSTRACT 问题："><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://yangyingchao.github.io/posts/"},{"@type":"ListItem","position":3,"name":"Your Read is Our Priority in Flash Storage","item":"https://yangyingchao.github.io/posts/p1911-lee/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Your Read is Our Priority in Flash Storage","name":"Your Read is Our Priority in Flash Storage","description":"1 ABSTRACT 2 INTRODUCTION 3 BACKGROUND 3.1 I/O Asymmetry in Flash SSDs 3.2 RAW Protocol in DBMS Buffer 3.3 RAW Protocol in Storage Buffer 4 READ STALL IN DBMS AND RW COMMAND 4.1 Read Stalls inRelational DBMS Buffer 4.2 RW Command 5 READ STALL IN STORAGE AND R-BUF 5.1 Read Stalls in SSD Buffer 本文为摘录，原文为： attachments/pdf/e/p1911-lee.pdf 1 ABSTRACT 问题：","keywords":["read","performance","ssd","raw","rw","openssd"],"articleBody":" 1 ABSTRACT 2 INTRODUCTION 3 BACKGROUND 3.1 I/O Asymmetry in Flash SSDs 3.2 RAW Protocol in DBMS Buffer 3.3 RAW Protocol in Storage Buffer 4 READ STALL IN DBMS AND RW COMMAND 4.1 Read Stalls inRelational DBMS Buffer 4.2 RW Command 5 READ STALL IN STORAGE AND R-BUF 5.1 Read Stalls in SSD Buffer 本文为摘录，原文为： attachments/pdf/e/p1911-lee.pdf\n1 ABSTRACT 问题： 读阻塞\nbuffer manager 采用 read-after-write (RAW) 策略 读写速率不同，导致 读阻塞 RAW 分两层： DBMS buffer Storage buffer （硬件层） 方案：\nRW as new storage interface:\nfused read and write, RW, 读写融合 buffermgr 可同时发出读写请求 脏页拷贝到存储 buffer 之后 马上 read R-Buf\n分离读写 buffer 效果\nRW: tpcc -\u003e 3.2x RW + R-Buf: tpcc -\u003e 3.9x 2 INTRODUCTION 3 BACKGROUND 3.1 I/O Asymmetry in Flash SSDs SSD 读写非对称： 读快，写慢 MLC 闪存，写一个页面需要 1500us ，而读仅需 50us 闪存的 GC 进一步加剧了这一现象 下表为一个测试结果 （FIO） OpenSSD is a solid-state drive which does not have a firmware Flash Translation Layer implemented on the device relies on OS to manage of the physical solid-state storage more flexibility with regard to: data placement decisions, overprovisioning, scheduling, garbage collection and wear leveling 3.2 RAW Protocol in DBMS Buffer 3.3 RAW Protocol in Storage Buffer S-Buf Shared buffer, for both read \u0026 write SSD architecture\n4 READ STALL IN DBMS AND RW COMMAND 4.1 Read Stalls inRelational DBMS Buffer the read stall problem can be alleviated or even disappear with a large buffer PG: 会下降的更多： 61% 4.1.1 Problem Definition 数据库 buffer 层的 write-then-read ，阻挡了使用底层异步并行优化 （libaio or io_uring） 4.2 RW Command 4.2.1 Key Idea. new block I/O command:\nRW write a dirty page to storage, and in parallel, read the missingpage to the host in on I/O call.\n4.2.2 Abstraction and Architecture. 当前存储接口中不存在这样的命令， 作者将 RW 作为 NVME vendor specific command 添加\nrw(rdLBA, wrLBA, len, buf)\nrdLBA/wrLBA: 读写操作的逻辑块地址 len: 两个页面的大小 （假设相等） buf: host buffer 虚地址 当主机向控制器发出 RW 命令后， NVME Controller 并行处理 READ 和 WRITE\n将与 wrLBA 相关的脏页拷贝进控制器缓存 （storage buffer） 马上读取 rdLBA 好处 存储控制器内部可以并行 减少 SYSCALL 和 IO 中断 Consistency and Durability 4.2.3 Prototype Implementation 向 OpenSSD 添加了新的 RW 命令，并扩展固件代码来支持这一语义。\nChanges in OpenSSD\n使用 OpenSSD OpenSSD 可以自由修改软件和硬件设计 使用了 Comos+ board, 该板支持 NVMe 接口 定义了新的 opcode 固件上实现了自定义操作 固件的读写地址不同，可以利用 SSD 的多通道特性来实现并行 Changes in MySQL\n直接使用 VFS 接口的话，不会有提升\n扩展 ioctl\n使之可以掠过 VFS 直接发送 RW 命令 修改了 MySQL 的 buffer manager\n添加新的 IO 函数， buffer manager 可通过该函数来： 获取 read write 的 LBA 发送 RW 命令 修改了 MySQL 的 read 函数： read 返回后当前事务可以直接进行，而无需再申请 buffer （通过操作 LRU list） 5 READ STALL IN STORAGE AND R-BUF 5.1 Read Stalls in SSD Buffer 5.1.1 Problem Definition ","wordCount":"788","inLanguage":"zh-cn","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://yangyingchao.github.io/posts/p1911-lee/"},"publisher":{"@type":"Organization","name":"MyNotes","logo":{"@type":"ImageObject","url":"https://yangyingchao.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://yangyingchao.github.io accesskey=h title="MyNotes (Alt + H)">MyNotes</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://yangyingchao.github.io/ title=Home><span>Home</span></a></li><li><a href=https://yangyingchao.github.io/posts/ title=Archives><span>Archives</span></a></li><li><a href=https://yangyingchao.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://yangyingchao.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://yangyingchao.github.io/contact/ title="Contact me"><span>Contact me</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Your Read is Our Priority in Flash Storage</h1><div class=post-meta></div></header><div class=post-content><ul><li>1 <a href=#h:ebffcd16-173e-4644-a00f-8f6d92c798f0>ABSTRACT</a></li><li>2 <a href=#h:f8ebb4bf-cdee-4786-920f-9e5cca36c7ca>INTRODUCTION</a></li><li>3 <a href=#h:3fd376b5-2ff5-4320-b346-b0e2e679ba7f>BACKGROUND</a><ul><li>3.1 <a href=#h:d5416d09-f7a7-4448-b41e-c5f56ce6dc40>I/O Asymmetry in Flash SSDs</a></li><li>3.2 <a href=#h:5a068019-5346-450f-b2b9-bb52b0395dfe>RAW Protocol in DBMS Buffer</a></li><li>3.3 <a href=#h:b1ad1102-62a1-4ebf-a3d0-5175fb229e15>RAW Protocol in Storage Buffer</a></li></ul></li><li>4 <a href=#h:120954ae-7c0b-4356-9db3-2603f1c95561>READ STALL IN DBMS AND RW COMMAND</a><ul><li>4.1 <a href=#h:1961aec8-3148-4626-8ea7-d7aa8e3630c7>Read Stalls inRelational DBMS Buffer</a></li><li>4.2 <a href=#h:f4ca1bee-0c63-49d3-ad37-d8b7ba336e23>RW Command</a></li></ul></li><li>5 <a href=#h:83365df9-93ca-4225-93ac-036eb29a80cf>READ STALL IN STORAGE AND R-BUF</a><ul><li>5.1 <a href=#h:4af9a557-45e7-494e-8d5b-540929258590>Read Stalls in SSD Buffer</a></li></ul></li></ul><p>本文为摘录，原文为： attachments/pdf/e/p1911-lee.pdf</p><h2 id=h:ebffcd16-173e-4644-a00f-8f6d92c798f0>1 ABSTRACT<a hidden class=anchor aria-hidden=true href=#h:ebffcd16-173e-4644-a00f-8f6d92c798f0>#</a></h2><ul><li><p>问题： <strong>读阻塞</strong></p><ul><li>buffer manager 采用 read-after-write (RAW) 策略</li><li>读写速率不同，导致 <strong>读阻塞</strong></li><li>RAW 分两层：<ul><li>DBMS buffer</li><li>Storage buffer （硬件层）</li></ul></li></ul></li><li><p>方案：</p><ul><li><p>RW as new storage interface:</p><ul><li>fused read and write, RW, 读写融合</li><li>buffermgr 可同时发出读写请求</li><li>脏页拷贝到存储 buffer 之后 马上 read</li></ul></li><li><p>R-Buf</p><ul><li>分离读写 buffer</li></ul></li></ul></li><li><p>效果</p><ul><li>RW: tpcc -> 3.2x</li><li>RW + R-Buf: tpcc -> 3.9x</li></ul></li></ul><h2 id=h:f8ebb4bf-cdee-4786-920f-9e5cca36c7ca>2 INTRODUCTION<a hidden class=anchor aria-hidden=true href=#h:f8ebb4bf-cdee-4786-920f-9e5cca36c7ca>#</a></h2><h2 id=h:3fd376b5-2ff5-4320-b346-b0e2e679ba7f>3 BACKGROUND<a hidden class=anchor aria-hidden=true href=#h:3fd376b5-2ff5-4320-b346-b0e2e679ba7f>#</a></h2><h3 id=h:d5416d09-f7a7-4448-b41e-c5f56ce6dc40>3.1 I/O Asymmetry in Flash SSDs<a hidden class=anchor aria-hidden=true href=#h:d5416d09-f7a7-4448-b41e-c5f56ce6dc40>#</a></h3><ul><li>SSD 读写非对称：<ul><li>读快，写慢<ul><li>MLC 闪存，写一个页面需要 <code>1500us</code> ，而读仅需 <code>50us</code></li></ul></li><li>闪存的 GC 进一步加剧了这一现象</li><li>下表为一个测试结果 （FIO）<ul><li><a href=https://en.wikipedia.org/wiki/Open-channel_SSD>OpenSSD</a><ul><li>is a solid-state drive which does not have a firmware Flash Translation Layer implemented on the device</li><li>relies on OS to manage of the physical solid-state storage</li><li>more flexibility with regard to:<ol><li>data placement decisions,</li><li>overprovisioning,</li><li>scheduling,</li><li>garbage collection and</li><li>wear leveling</li></ol></li></ul></li></ul></li></ul></li></ul><p></p><figure><img loading=lazy src=/ox-hugo/screenshot@2022-10-14_18:12:49.png></figure><h3 id=h:5a068019-5346-450f-b2b9-bb52b0395dfe>3.2 RAW Protocol in DBMS Buffer<a hidden class=anchor aria-hidden=true href=#h:5a068019-5346-450f-b2b9-bb52b0395dfe>#</a></h3><h3 id=h:b1ad1102-62a1-4ebf-a3d0-5175fb229e15>3.3 RAW Protocol in Storage Buffer<a hidden class=anchor aria-hidden=true href=#h:b1ad1102-62a1-4ebf-a3d0-5175fb229e15>#</a></h3><ul><li>S-Buf<ul><li>Shared buffer, for both read & write</li></ul></li></ul><ul><li><p>SSD architecture</p><p></p><figure><img loading=lazy src=/ox-hugo/screenshot@2022-10-17_10:45:59.png width=800px></figure></li></ul><h2 id=h:120954ae-7c0b-4356-9db3-2603f1c95561>4 READ STALL IN DBMS AND RW COMMAND<a hidden class=anchor aria-hidden=true href=#h:120954ae-7c0b-4356-9db3-2603f1c95561>#</a></h2><h3 id=h:1961aec8-3148-4626-8ea7-d7aa8e3630c7>4.1 Read Stalls inRelational DBMS Buffer<a hidden class=anchor aria-hidden=true href=#h:1961aec8-3148-4626-8ea7-d7aa8e3630c7>#</a></h3><ul><li>the read stall problem can be alleviated or even disappear with a large buffer<ul><li>PG: 会下降的更多： 61%</li></ul></li></ul><h4 id=h:1a5ca1de-d6a6-486c-8980-c5f1c608985d>4.1.1 Problem Definition<a hidden class=anchor aria-hidden=true href=#h:1a5ca1de-d6a6-486c-8980-c5f1c608985d>#</a></h4><ul><li>数据库 buffer 层的 <strong>write-then-read</strong> ，阻挡了使用底层异步并行优化 （libaio or io_uring）</li></ul><h3 id=h:f4ca1bee-0c63-49d3-ad37-d8b7ba336e23>4.2 RW Command<a hidden class=anchor aria-hidden=true href=#h:f4ca1bee-0c63-49d3-ad37-d8b7ba336e23>#</a></h3><h4 id=h:83e15275-818a-4f1a-84e7-f9f7dee84b52>4.2.1 Key Idea.<a hidden class=anchor aria-hidden=true href=#h:83e15275-818a-4f1a-84e7-f9f7dee84b52>#</a></h4><p>new block I/O command:</p><p><code>RW</code> write a dirty page to storage, and in parallel, read the missingpage to the host in on I/O call.</p><h4 id=h:bc88385d-6ad1-455f-a85f-5e51c84924c0>4.2.2 Abstraction and Architecture.<a hidden class=anchor aria-hidden=true href=#h:bc88385d-6ad1-455f-a85f-5e51c84924c0>#</a></h4><ul><li><p>当前存储接口中不存在这样的命令， 作者将 <code>RW</code> 作为 NVME vendor specific command 添加</p></li><li><p>rw(rdLBA, wrLBA, len, buf)</p><ul><li>rdLBA/wrLBA: 读写操作的逻辑块地址</li><li>len: 两个页面的大小 （假设相等）</li><li>buf: host buffer 虚地址</li></ul></li><li><p>当主机向控制器发出 RW 命令后， NVME Controller 并行处理 READ 和 WRITE</p><ul><li>将与 wrLBA 相关的脏页拷贝进控制器缓存 （storage buffer）</li><li>马上读取 rdLBA</li></ul></li></ul><p></p><figure><img loading=lazy src=/ox-hugo/screenshot@2022-10-17_17:16:36.png></figure><ul><li>好处<ul><li>存储控制器内部可以并行</li><li>减少 SYSCALL 和 IO 中断</li></ul></li></ul><ul><li>Consistency and Durability</li></ul><h4 id=h:ce460c46-a392-475e-a5c0-887d22858026>4.2.3 Prototype Implementation<a hidden class=anchor aria-hidden=true href=#h:ce460c46-a392-475e-a5c0-887d22858026>#</a></h4><p>向 OpenSSD 添加了新的 RW 命令，并扩展固件代码来支持这一语义。</p><ul><li><p>Changes in OpenSSD</p><ul><li>使用 OpenSSD<ul><li>OpenSSD 可以自由修改软件和硬件设计</li></ul></li><li>使用了 Comos+ board, 该板支持 NVMe 接口</li><li>定义了新的 opcode</li><li>固件上实现了自定义操作</li><li>固件的读写地址不同，可以利用 SSD 的多通道特性来实现并行</li></ul></li><li><p>Changes in MySQL</p><ul><li><p>直接使用 VFS 接口的话，不会有提升</p></li><li><p>扩展 <code>ioctl</code></p><ul><li>使之可以掠过 VFS 直接发送 RW 命令</li></ul></li><li><p>修改了 MySQL 的 buffer manager</p><ul><li>添加新的 IO 函数， buffer manager 可通过该函数来：<ul><li>获取 read write 的 LBA</li><li>发送 RW 命令</li></ul></li><li>修改了 MySQL 的 read 函数：<ul><li>read 返回后当前事务可以直接进行，而无需再申请 buffer
（通过操作 LRU list）</li></ul></li></ul></li></ul></li></ul><h2 id=h:83365df9-93ca-4225-93ac-036eb29a80cf>5 READ STALL IN STORAGE AND R-BUF<a hidden class=anchor aria-hidden=true href=#h:83365df9-93ca-4225-93ac-036eb29a80cf>#</a></h2><h3 id=h:4af9a557-45e7-494e-8d5b-540929258590>5.1 Read Stalls in SSD Buffer<a hidden class=anchor aria-hidden=true href=#h:4af9a557-45e7-494e-8d5b-540929258590>#</a></h3><h4 id=h:df362158-d5d2-4a73-ad45-dd3ea3498de3>5.1.1 Problem Definition<a hidden class=anchor aria-hidden=true href=#h:df362158-d5d2-4a73-ad45-dd3ea3498de3>#</a></h4></div><footer class=post-footer><ul class=post-tags><li><a href=https://yangyingchao.github.io/tags/read/>read</a></li><li><a href=https://yangyingchao.github.io/tags/performance/>performance</a></li><li><a href=https://yangyingchao.github.io/tags/ssd/>ssd</a></li><li><a href=https://yangyingchao.github.io/tags/raw/>raw</a></li><li><a href=https://yangyingchao.github.io/tags/rw/>rw</a></li><li><a href=https://yangyingchao.github.io/tags/openssd/>openssd</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://yangyingchao.github.io>MyNotes</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>