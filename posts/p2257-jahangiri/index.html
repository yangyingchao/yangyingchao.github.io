<!doctype html><html lang=zh-cn><head><title>Design Trade-offs for a Robust Dynamic Hybrid Hash Join · MyNotes</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="yyc"><meta name=description content="1 ABSTRACT 2 INTRODUCTION 3 BACKGROUND 3.1 Hybrid Hash Join 本文为摘录，原文为： attachments/pdf/f/p2257-jahangiri.pdf 1 ABSTRACT 链接到标题 探索分片数量对 HHJ 性能的影响 propose a new lower bound for number of partitions design and evaluate different partition insertion techniques to maximize memory utilization with the lest CPU cost 2 INTRODUCTION 链接"><meta name=keywords content="blog,developer,personal"><meta name=twitter:card content="summary"><meta name=twitter:title content="Design Trade-offs for a Robust Dynamic Hybrid Hash Join"><meta name=twitter:description content="1 ABSTRACT 2 INTRODUCTION 3 BACKGROUND 3.1 Hybrid Hash Join 本文为摘录，原文为： attachments/pdf/f/p2257-jahangiri.pdf 1 ABSTRACT 链接到标题 探索分片数量对 HHJ 性能的影响 propose a new lower bound for number of partitions design and evaluate different partition insertion techniques to maximize memory utilization with the lest CPU cost 2 INTRODUCTION 链接"><meta property="og:title" content="Design Trade-offs for a Robust Dynamic Hybrid Hash Join"><meta property="og:description" content="1 ABSTRACT 2 INTRODUCTION 3 BACKGROUND 3.1 Hybrid Hash Join 本文为摘录，原文为： attachments/pdf/f/p2257-jahangiri.pdf 1 ABSTRACT 链接到标题 探索分片数量对 HHJ 性能的影响 propose a new lower bound for number of partitions design and evaluate different partition insertion techniques to maximize memory utilization with the lest CPU cost 2 INTRODUCTION 链接"><meta property="og:type" content="article"><meta property="og:url" content="https://yangyingchao.github.io/posts/p2257-jahangiri/"><meta property="article:section" content="posts"><link rel=canonical href=https://yangyingchao.github.io/posts/p2257-jahangiri/><link rel=preload href="/fonts/forkawesome-webfont.woff2?v=1.2.0" as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.135e22c97ff685fe983fc60048e309ced8f00d8d38f536aa67dba8a13a03dfa4.css integrity="sha256-E14iyX/2hf6YP8YASOMJztjwDY049TaqZ9uooToD36Q=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.a00e6364bacbc8266ad1cc81230774a1397198f8cfb7bcba29b7d6fcb54ce57f.css integrity="sha256-oA5jZLrLyCZq0cyBIwd0oTlxmPjPt7y6KbfW/LVM5X8=" crossorigin=anonymous media=screen><link rel=icon type=image/svg+xml href=/images/favicon.svg sizes=any><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5></head><body class="preload-transitions colorscheme-auto"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=/>MyNotes</a>
<input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/posts/>Blog</a></li><li class=navigation-item><a class=navigation-link href=/tags/>Tags</a></li><li class=navigation-item><a class=navigation-link href=/contact/>Contact me</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://yangyingchao.github.io/posts/p2257-jahangiri/>Design Trade-offs for a Robust Dynamic Hybrid Hash Join</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa fa-calendar" aria-hidden=true></i>
<time datetime=0001-01-01T00:00:00Z>January 1, 0001</time></span>
<span class=reading-time><i class="fa fa-clock-o" aria-hidden=true></i>
阅读时间：2 分钟</span></div></div></header><div class=post-content><ul><li>1 <a href=#h:9e1fc2bd-a46c-4f59-826f-d16bf450d7bd>ABSTRACT</a></li><li>2 <a href=#h:23eb29f4-1c34-4d76-80b0-6eec925e2ccd>INTRODUCTION</a></li><li>3 <a href=#h:acbe6540-05c1-45da-8752-d8eee5626a9d>BACKGROUND</a><ul><li>3.1 <a href=#h:4b1b3de2-12ce-4f80-92d2-a6e9104b0ddb>Hybrid Hash Join</a></li></ul></li></ul><p>本文为摘录，原文为： attachments/pdf/f/p2257-jahangiri.pdf</p><h2 id=h:9e1fc2bd-a46c-4f59-826f-d16bf450d7bd>1 ABSTRACT
<a class=heading-link href=#h:9e1fc2bd-a46c-4f59-826f-d16bf450d7bd><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h2><ul><li>探索分片数量对 HHJ 性能的影响</li><li>propose a new lower bound for number of partitions</li><li>design and evaluate different partition insertion techniques to maximize memory utilization with the lest CPU cost</li></ul><h2 id=h:23eb29f4-1c34-4d76-80b0-6eec925e2ccd>2 INTRODUCTION
<a class=heading-link href=#h:23eb29f4-1c34-4d76-80b0-6eec925e2ccd><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h2><ul><li><p>HHJ: Hybrid Hash Join</p></li><li><p>算法</p><ul><li>将数据划分成多个分片<ul><li>一个分片在内存中</li><li>其余分片溢出到磁盘</li><li>处理内存中的分片</li><li>多趟，处理其余分片</li></ul></li></ul></li><li><p>分片数量以及选择哪个分片放在内存中，是生成 operator 时候静态指定的</p><ul><li>依据代价模型</li><li>有不足之处：<ol><li>假设 join 列的值程均匀分布</li><li>代价模型倚赖于精确的统计信息，如 输入大小等。</li></ol></li></ul></li><li><p>然而收集、访问或者预测这些信息有时并不可行：</p><ul><li>外部表的统计信息经常不准或者缺失</li><li>join 输入的来源如果是其他算子，则其大小可能不准确</li></ul></li></ul><h2 id=h:acbe6540-05c1-45da-8752-d8eee5626a9d>3 BACKGROUND
<a class=heading-link href=#h:acbe6540-05c1-45da-8752-d8eee5626a9d><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h2><h3 id=h:4b1b3de2-12ce-4f80-92d2-a6e9104b0ddb>3.1 Hybrid Hash Join
<a class=heading-link href=#h:4b1b3de2-12ce-4f80-92d2-a6e9104b0ddb><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h3><h4 id=h:c9017a0c-0884-493e-9908-d8c351237edd>3.1.1 Grace Hash Join (GHI)
<a class=heading-link href=#h:c9017a0c-0884-493e-9908-d8c351237edd><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h4><ul><li>使用内存作为中间介质，将数据划分成内存中可以装下的分片，然后在做 join</li><li>算法<ul><li>Grace Hash Join 连续的处理 build 和 probe 过程</li><li>每个分片都写入磁盘，存程单独的文件</li><li>重复划分过程，直到一个分片可以装入内存为止</li><li>每个分片创建一个 hash table, 开始 join</li></ul></li><li>适用于
小表 (build 表) 也远远大于内存时候</li></ul><h4 id=h:8c63a062-7b34-4e16-a1f1-660dc4a8e8c1>3.1.2 Simple Hash Join (SHJ)
<a class=heading-link href=#h:8c63a062-7b34-4e16-a1f1-660dc4a8e8c1><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h4><ul><li>始终在内存中保存一部分数据，以期减少 IO 的总体开销</li><li>算法<ul><li>records 哈希划分成两个部分：<ul><li>内存分片</li><li>溢出分片</li></ul></li></ul></li><li>适用于内存可以装下大部分小表数据的时候</li></ul><h4 id=h:e85d3dee-7c3d-4675-8a3b-4742df84e4b0>3.1.3 Hybrid Hash Join (HHJ)
<a class=heading-link href=#h:e85d3dee-7c3d-4675-8a3b-4742df84e4b0><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h4><p>混合了 GHJ & SHJ:</p><ul><li>通过划分分片来避免不必要的数据比较</li><li>使用内存来保存一个分片及其对应的哈希表</li></ul><p>如图 <a href=#figure--fig:screenshot@2022-09-15-15:19:35>1</a> (a) 所示。</p><p></p><figure><img src=/ox-hugo/screenshot@2022-09-15_15:19:35.png width=800px></figure><p>步骤：</p><ul><li><p>Build Phase, 使用拆分函数 (split function) 将输入进行哈希划分，其结果：</p><ul><li>划分进入内存分片的，驻留内存</li><li>其余溢出到磁盘中对应文件</li><li>由内存分片构建哈希表</li></ul></li><li><p>Probe Phase 使用同样的拆分函数 (split function) 将输入进行哈希划分，其结果：</p><ul><li>划入内存分片的，直接 probe</li><li>其余写入磁盘的对应文件</li><li>处理完内存分片后，逐一处理溢出文件。</li></ul></li></ul><h4 id=h:a9e5ed71-2527-4a22-a3bc-d7ddd1a0bc0f>3.1.4 Dynamic Hybrid Hash Join
<a class=heading-link href=#h:a9e5ed71-2527-4a22-a3bc-d7ddd1a0bc0f><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h4><p>与 HHJ 相比：</p><ul><li>HHJ: 选择预先定义的一个分片常驻内存</li><li>DHHJ: 使用动态降级策略来选择内存分片：</li></ul><p>如图 <a href=#figure--fig:screenshot@2022-09-15-15:19:35>1</a> (b) 所示，</p><ul><li>Build Phase:<ul><li>build 开始时候，所有分片都在内存中，</li><li>只要内存还够用，始终使用内存来保存分片</li><li>随着输入的增加，由于数据可能倾斜，各个分片的大小开始不一样</li><li>当内存耗尽时， <strong>动态选择</strong> 一个分片进行溢出操作</li></ul></li></ul><p>该方法尤其适用于当输入大小或者join 属性的分布未知或者不准确的时候。</p></div><footer></footer></article></section></div><footer class=footer><section class=container>©
2023
yyc
·
技术支持 <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/ target=_blank rel=noopener>Coder</a>.</section></footer></main><script src=/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script></body></html>