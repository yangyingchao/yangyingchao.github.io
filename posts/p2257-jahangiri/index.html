<!doctype html><html lang=zh-cn dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Design Trade-offs for a Robust Dynamic Hybrid Hash Join | MyNotes</title><meta name=keywords content><meta name=description content="1 ABSTRACT 2 INTRODUCTION 3 BACKGROUND 3.1 Hybrid Hash Join 本文为摘录，原文为： attachments/pdf/f/p2257-jahangiri.pdf 1 ABSTRACT 探索分片数量对 HHJ 性能的影响 propose a new lower bound for number of partitions design and evaluate different partition insertion techniques to maximize memory utilization with the lest CPU cost 2 INTRODUCTION HHJ: Hybrid Hash Join 算法 将"><meta name=author content><link rel=canonical href=https://yangyingchao.github.io/posts/p2257-jahangiri/><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://yangyingchao.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://yangyingchao.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://yangyingchao.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://yangyingchao.github.io/apple-touch-icon.png><link rel=mask-icon href=https://yangyingchao.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Design Trade-offs for a Robust Dynamic Hybrid Hash Join"><meta property="og:description" content="1 ABSTRACT 2 INTRODUCTION 3 BACKGROUND 3.1 Hybrid Hash Join 本文为摘录，原文为： attachments/pdf/f/p2257-jahangiri.pdf 1 ABSTRACT 探索分片数量对 HHJ 性能的影响 propose a new lower bound for number of partitions design and evaluate different partition insertion techniques to maximize memory utilization with the lest CPU cost 2 INTRODUCTION HHJ: Hybrid Hash Join 算法 将"><meta property="og:type" content="article"><meta property="og:url" content="https://yangyingchao.github.io/posts/p2257-jahangiri/"><meta property="article:section" content="posts"><meta name=twitter:card content="summary"><meta name=twitter:title content="Design Trade-offs for a Robust Dynamic Hybrid Hash Join"><meta name=twitter:description content="1 ABSTRACT 2 INTRODUCTION 3 BACKGROUND 3.1 Hybrid Hash Join 本文为摘录，原文为： attachments/pdf/f/p2257-jahangiri.pdf 1 ABSTRACT 探索分片数量对 HHJ 性能的影响 propose a new lower bound for number of partitions design and evaluate different partition insertion techniques to maximize memory utilization with the lest CPU cost 2 INTRODUCTION HHJ: Hybrid Hash Join 算法 将"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://yangyingchao.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Design Trade-offs for a Robust Dynamic Hybrid Hash Join","item":"https://yangyingchao.github.io/posts/p2257-jahangiri/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Design Trade-offs for a Robust Dynamic Hybrid Hash Join","name":"Design Trade-offs for a Robust Dynamic Hybrid Hash Join","description":"1 ABSTRACT 2 INTRODUCTION 3 BACKGROUND 3.1 Hybrid Hash Join 本文为摘录，原文为： attachments/pdf/f/p2257-jahangiri.pdf 1 ABSTRACT 探索分片数量对 HHJ 性能的影响 propose a new lower bound for number of partitions design and evaluate different partition insertion techniques to maximize memory utilization with the lest CPU cost 2 INTRODUCTION HHJ: Hybrid Hash Join 算法 将","keywords":[],"articleBody":" 1 ABSTRACT 2 INTRODUCTION 3 BACKGROUND 3.1 Hybrid Hash Join 本文为摘录，原文为： attachments/pdf/f/p2257-jahangiri.pdf\n1 ABSTRACT 探索分片数量对 HHJ 性能的影响 propose a new lower bound for number of partitions design and evaluate different partition insertion techniques to maximize memory utilization with the lest CPU cost 2 INTRODUCTION HHJ: Hybrid Hash Join\n算法\n将数据划分成多个分片 一个分片在内存中 其余分片溢出到磁盘 处理内存中的分片 多趟，处理其余分片 分片数量以及选择哪个分片放在内存中，是生成 operator 时候静态指定的\n依据代价模型 有不足之处： 假设 join 列的值程均匀分布 代价模型倚赖于精确的统计信息，如 输入大小等。 然而收集、访问或者预测这些信息有时并不可行：\n外部表的统计信息经常不准或者缺失 join 输入的来源如果是其他算子，则其大小可能不准确 3 BACKGROUND 3.1 Hybrid Hash Join 3.1.1 Grace Hash Join (GHI) 使用内存作为中间介质，将数据划分成内存中可以装下的分片，然后在做 join 算法 Grace Hash Join 连续的处理 build 和 probe 过程 每个分片都写入磁盘，存程单独的文件 重复划分过程，直到一个分片可以装入内存为止 每个分片创建一个 hash table, 开始 join 适用于 小表 (build 表) 也远远大于内存时候 3.1.2 Simple Hash Join (SHJ) 始终在内存中保存一部分数据，以期减少 IO 的总体开销 算法 records 哈希划分成两个部分： 内存分片 溢出分片 适用于内存可以装下大部分小表数据的时候 3.1.3 Hybrid Hash Join (HHJ) 混合了 GHJ \u0026 SHJ:\n通过划分分片来避免不必要的数据比较 使用内存来保存一个分片及其对应的哈希表 如图 1 (a) 所示。\n步骤：\nBuild Phase, 使用拆分函数 (split function) 将输入进行哈希划分，其结果：\n划分进入内存分片的，驻留内存 其余溢出到磁盘中对应文件 由内存分片构建哈希表 Probe Phase 使用同样的拆分函数 (split function) 将输入进行哈希划分，其结果：\n划入内存分片的，直接 probe 其余写入磁盘的对应文件 处理完内存分片后，逐一处理溢出文件。 3.1.4 Dynamic Hybrid Hash Join 与 HHJ 相比：\nHHJ: 选择预先定义的一个分片常驻内存 DHHJ: 使用动态降级策略来选择内存分片： 如图 1 (b) 所示，\nBuild Phase: build 开始时候，所有分片都在内存中， 只要内存还够用，始终使用内存来保存分片 随着输入的增加，由于数据可能倾斜，各个分片的大小开始不一样 当内存耗尽时， 动态选择 一个分片进行溢出操作 该方法尤其适用于当输入大小或者join 属性的分布未知或者不准确的时候。\n","wordCount":"800","inLanguage":"zh-cn","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://yangyingchao.github.io/posts/p2257-jahangiri/"},"publisher":{"@type":"Organization","name":"MyNotes","logo":{"@type":"ImageObject","url":"https://yangyingchao.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://yangyingchao.github.io accesskey=h title="MyNotes (Alt + H)">MyNotes</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://yangyingchao.github.io/ title=Home><span>Home</span></a></li><li><a href=https://yangyingchao.github.io/posts/ title=Archives><span>Archives</span></a></li><li><a href=https://yangyingchao.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://yangyingchao.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://yangyingchao.github.io/contact/ title="Contact me"><span>Contact me</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Design Trade-offs for a Robust Dynamic Hybrid Hash Join</h1><div class=post-meta></div></header><div class=post-content><ul><li>1 <a href=#h:9e1fc2bd-a46c-4f59-826f-d16bf450d7bd>ABSTRACT</a></li><li>2 <a href=#h:23eb29f4-1c34-4d76-80b0-6eec925e2ccd>INTRODUCTION</a></li><li>3 <a href=#h:acbe6540-05c1-45da-8752-d8eee5626a9d>BACKGROUND</a><ul><li>3.1 <a href=#h:4b1b3de2-12ce-4f80-92d2-a6e9104b0ddb>Hybrid Hash Join</a></li></ul></li></ul><p>本文为摘录，原文为： attachments/pdf/f/p2257-jahangiri.pdf</p><h2 id=h:9e1fc2bd-a46c-4f59-826f-d16bf450d7bd>1 ABSTRACT<a hidden class=anchor aria-hidden=true href=#h:9e1fc2bd-a46c-4f59-826f-d16bf450d7bd>#</a></h2><ul><li>探索分片数量对 HHJ 性能的影响</li><li>propose a new lower bound for number of partitions</li><li>design and evaluate different partition insertion techniques to maximize memory utilization with the lest CPU cost</li></ul><h2 id=h:23eb29f4-1c34-4d76-80b0-6eec925e2ccd>2 INTRODUCTION<a hidden class=anchor aria-hidden=true href=#h:23eb29f4-1c34-4d76-80b0-6eec925e2ccd>#</a></h2><ul><li><p>HHJ: Hybrid Hash Join</p></li><li><p>算法</p><ul><li>将数据划分成多个分片<ul><li>一个分片在内存中</li><li>其余分片溢出到磁盘</li><li>处理内存中的分片</li><li>多趟，处理其余分片</li></ul></li></ul></li><li><p>分片数量以及选择哪个分片放在内存中，是生成 operator 时候静态指定的</p><ul><li>依据代价模型</li><li>有不足之处：<ol><li>假设 join 列的值程均匀分布</li><li>代价模型倚赖于精确的统计信息，如 输入大小等。</li></ol></li></ul></li><li><p>然而收集、访问或者预测这些信息有时并不可行：</p><ul><li>外部表的统计信息经常不准或者缺失</li><li>join 输入的来源如果是其他算子，则其大小可能不准确</li></ul></li></ul><h2 id=h:acbe6540-05c1-45da-8752-d8eee5626a9d>3 BACKGROUND<a hidden class=anchor aria-hidden=true href=#h:acbe6540-05c1-45da-8752-d8eee5626a9d>#</a></h2><h3 id=h:4b1b3de2-12ce-4f80-92d2-a6e9104b0ddb>3.1 Hybrid Hash Join<a hidden class=anchor aria-hidden=true href=#h:4b1b3de2-12ce-4f80-92d2-a6e9104b0ddb>#</a></h3><h4 id=h:c9017a0c-0884-493e-9908-d8c351237edd>3.1.1 Grace Hash Join (GHI)<a hidden class=anchor aria-hidden=true href=#h:c9017a0c-0884-493e-9908-d8c351237edd>#</a></h4><ul><li>使用内存作为中间介质，将数据划分成内存中可以装下的分片，然后在做 join</li><li>算法<ul><li>Grace Hash Join 连续的处理 build 和 probe 过程</li><li>每个分片都写入磁盘，存程单独的文件</li><li>重复划分过程，直到一个分片可以装入内存为止</li><li>每个分片创建一个 hash table, 开始 join</li></ul></li><li>适用于
小表 (build 表) 也远远大于内存时候</li></ul><h4 id=h:8c63a062-7b34-4e16-a1f1-660dc4a8e8c1>3.1.2 Simple Hash Join (SHJ)<a hidden class=anchor aria-hidden=true href=#h:8c63a062-7b34-4e16-a1f1-660dc4a8e8c1>#</a></h4><ul><li>始终在内存中保存一部分数据，以期减少 IO 的总体开销</li><li>算法<ul><li>records 哈希划分成两个部分：<ul><li>内存分片</li><li>溢出分片</li></ul></li></ul></li><li>适用于内存可以装下大部分小表数据的时候</li></ul><h4 id=h:e85d3dee-7c3d-4675-8a3b-4742df84e4b0>3.1.3 Hybrid Hash Join (HHJ)<a hidden class=anchor aria-hidden=true href=#h:e85d3dee-7c3d-4675-8a3b-4742df84e4b0>#</a></h4><p>混合了 GHJ & SHJ:</p><ul><li>通过划分分片来避免不必要的数据比较</li><li>使用内存来保存一个分片及其对应的哈希表</li></ul><p>如图 <a href=#figure--fig:screenshot@2022-09-15-15:19:35>1</a> (a) 所示。</p><p></p><figure><img loading=lazy src=/ox-hugo/screenshot@2022-09-15_15:19:35.png width=800px></figure><p>步骤：</p><ul><li><p>Build Phase, 使用拆分函数 (split function) 将输入进行哈希划分，其结果：</p><ul><li>划分进入内存分片的，驻留内存</li><li>其余溢出到磁盘中对应文件</li><li>由内存分片构建哈希表</li></ul></li><li><p>Probe Phase 使用同样的拆分函数 (split function) 将输入进行哈希划分，其结果：</p><ul><li>划入内存分片的，直接 probe</li><li>其余写入磁盘的对应文件</li><li>处理完内存分片后，逐一处理溢出文件。</li></ul></li></ul><h4 id=h:a9e5ed71-2527-4a22-a3bc-d7ddd1a0bc0f>3.1.4 Dynamic Hybrid Hash Join<a hidden class=anchor aria-hidden=true href=#h:a9e5ed71-2527-4a22-a3bc-d7ddd1a0bc0f>#</a></h4><p>与 HHJ 相比：</p><ul><li>HHJ: 选择预先定义的一个分片常驻内存</li><li>DHHJ: 使用动态降级策略来选择内存分片：</li></ul><p>如图 <a href=#figure--fig:screenshot@2022-09-15-15:19:35>1</a> (b) 所示，</p><ul><li>Build Phase:<ul><li>build 开始时候，所有分片都在内存中，</li><li>只要内存还够用，始终使用内存来保存分片</li><li>随着输入的增加，由于数据可能倾斜，各个分片的大小开始不一样</li><li>当内存耗尽时， <strong>动态选择</strong> 一个分片进行溢出操作</li></ul></li></ul><p>该方法尤其适用于当输入大小或者join 属性的分布未知或者不准确的时候。</p></div><footer class=post-footer><ul class=post-tags></ul></footer><script src=https://giscus.app/client.js data-repo=yangyingchao/giscus data-repo-id=R_kgDON6NYZA data-category=Announcements data-category-id=DIC_kwDON6NYZM4CnANs data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=zh-CN crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2025 <a href=https://yangyingchao.github.io>MyNotes</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>