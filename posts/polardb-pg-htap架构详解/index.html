<!doctype html><html lang=zh-cn dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>polardb pg HTAP架构详解 | MyNotes</title><meta name=keywords content="tag1,tag2"><meta name=description content="1 HTAP 架构原理 2 分布式优化器 3 算子并行化 4 消除数据倾斜问题 5 SQL 级别弹性扩展 6 事务一致性 7 TPC-H 性能：加速比 8 TPC-H 性能：和传统 MPP 数仓对比 9 分布式执行加"><meta name=author content="Yang, Ying-chao"><link rel=canonical href=https://yangyingchao.github.io/posts/polardb-pg-htap%E6%9E%B6%E6%9E%84%E8%AF%A6%E8%A7%A3/><link crossorigin=anonymous href=/assets/css/stylesheet.6a98292fb8fa8cf0f3ba4042d4b75515c04267550f3ad49ff6271b5af9562443.css integrity="sha256-apgpL7j6jPDzukBC1LdVFcBCZ1UPOtSf9icbWvlWJEM=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://yangyingchao.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://yangyingchao.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://yangyingchao.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://yangyingchao.github.io/apple-touch-icon.png><link rel=mask-icon href=https://yangyingchao.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="polardb pg HTAP架构详解"><meta property="og:description" content="1 HTAP 架构原理 2 分布式优化器 3 算子并行化 4 消除数据倾斜问题 5 SQL 级别弹性扩展 6 事务一致性 7 TPC-H 性能：加速比 8 TPC-H 性能：和传统 MPP 数仓对比 9 分布式执行加"><meta property="og:type" content="article"><meta property="og:url" content="https://yangyingchao.github.io/posts/polardb-pg-htap%E6%9E%B6%E6%9E%84%E8%AF%A6%E8%A7%A3/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-12-11T00:00:00+00:00"><meta property="article:modified_time" content="2023-12-11T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="polardb pg HTAP架构详解"><meta name=twitter:description content="1 HTAP 架构原理 2 分布式优化器 3 算子并行化 4 消除数据倾斜问题 5 SQL 级别弹性扩展 6 事务一致性 7 TPC-H 性能：加速比 8 TPC-H 性能：和传统 MPP 数仓对比 9 分布式执行加"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://yangyingchao.github.io/posts/"},{"@type":"ListItem","position":3,"name":"polardb pg HTAP架构详解","item":"https://yangyingchao.github.io/posts/polardb-pg-htap%E6%9E%B6%E6%9E%84%E8%AF%A6%E8%A7%A3/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"polardb pg HTAP架构详解","name":"polardb pg HTAP架构详解","description":"1 HTAP 架构原理 2 分布式优化器 3 算子并行化 4 消除数据倾斜问题 5 SQL 级别弹性扩展 6 事务一致性 7 TPC-H 性能：加速比 8 TPC-H 性能：和传统 MPP 数仓对比 9 分布式执行加","keywords":["tag1","tag2"],"articleBody":" 1 HTAP 架构原理 2 分布式优化器 3 算子并行化 4 消除数据倾斜问题 5 SQL 级别弹性扩展 6 事务一致性 7 TPC-H 性能：加速比 8 TPC-H 性能：和传统 MPP 数仓对比 9 分布式执行加速索引创建 10 分布式并行执行加速多模：时空数据库 本文为摘录，原文为： https://help.aliyun.com/zh/polardb/polardb-for-postgresql/polardb-for-postgresql-architecture/?spm=a2c4g.11186623.0.0.2e3b5fb1p0L9je\nPolarDB PostgreSQL 版读写分离后，由于底层是存储池，理论上 IO 吞吐是无限大的。而大查询只 能在单个计算节点上执行，单个计算节点的 CPU/MEM/IO 是有限的，因此单个计算节点无法发挥出存 储侧的大 IO 带宽的优势，也无法通过增加计算资源来加速大的查询。PolarDB PostgreSQL 版推出 了基于 Shared-Storage 的 MPP 分布式并行执行，来加速在 OLTP 场景下 OLAP 查询。\n1 HTAP 架构原理 PolarDB PostgreSQL 版底层存储在不同节点上是共享的，因此不能直接像传统 MPP 一样去扫描表。 PolarDB PostgreSQL 版在原来单机执行引擎上支持了 MPP 分布式并行执行，同时对 Shared-Storage 进 行了优化。 基于 Shared-Storage 的 MPP 是业界首创。原理如下：\nShuffle 算子屏蔽数据分布。\nParallelScan 算子屏蔽共享存储。\n如图所示：\n表 A 和表 B 做 join，并做聚合。\n共享存储中的表仍然是单张表，并没有做物理上的分区。\n重新设计 4 类扫描算子，使之在扫描共享存储上的表时能够分片扫描，形成 virtual partition。\n2 分布式优化器 基于社区的 GPORCA 优化器扩展了能感知共享存储特性的 Transformation Rules。使得能够探索共享 存储下特有的 Plan 空间。例如，对于一个表在 PolarDB PostgreSQL 版中既可以全量的扫描，也可以 分区域扫描，这个是和传统 MPP 的本质区别。如下图所示，上面灰色部分是 PolarDB PostgreSQL 版内 核与 GPORCA 优化器的适配部分。下半部分是 ORCA 内核，灰色模块是在 ORCA 内核中对共享存储特性所 做的扩展。\n3 算子并行化 PolarDB PostgreSQL 版中有 4 类算子需要并行化，以下介绍一个具有代表性的 Seqscan 的算子的并行 化。\n为了最大限度的利用存储的大 IO 带宽，在顺序扫描时，按照 4 MB 为单位做逻辑切分，将 IO 尽量打散 到不同的盘上，达到所有的盘同时提供读服务的效果。这样做还有一个优势，就是每个只读节点只 扫描部分表文件，则最终能缓存的表大小是所有只读节点的 BufferPool 总和。\n下面的图表中：\n增加只读节点，扫描性能线性提升 30 倍。\n打开 Buffer 时，扫描从 37 分钟降到 3.75 秒。\n4 消除数据倾斜问题 倾斜是传统 MPP 固有的问题：\n在 PolarDB PostgreSQL 版中，大对象的是通过 heap 表关联 TOAST​表，无论对哪个表切分都无法达到 均衡。\n另外，不同只读节点的事务、Buffer、网络、IO 负载抖动。\n以上两点会导致分布执行时存在长尾进程。\n协调节点内部分成 DataThread 和 ControlThread。\nDataThread 负责收集汇总元组。\nControlThread 负责控制每个扫描算子的扫描进度。\n扫描快的工作进程能多扫描逻辑的数据切片。\n过程中需要考虑 Buffer 的亲和性。\n说明 尽管是动态分配，尽量维护 Buffer 的亲和性。另外，每个算子的上下文存储在 worker 的私有内存中， Coordinator 不存储具体表的信息。\n下面表格中，当出现大对象时，静态切分出现数据倾斜，而动态扫描仍然能够线性提升。\n5 SQL 级别弹性扩展 利用数据共享的特点，还可以支持云原生下极致弹性的要求。将 Coordinator 全链路上各个模块所需 要的外部依赖存在共享存储上，同时 worker 全链路上需要的运行时参数通过控制链路从 Coordinator 同步过来，使 Coordinator 和 worker 无状态化。\n因此：\nSQL 连接的任意只读节点都可以成为 Coordinator 节点，这解决了 Coordinator 单点问题。\n支持不同的 SQL 使用不同的 CPU 数目执行，灵活的配置不同业务 SQL 配置不同的 CPU 核心数。\n6 事务一致性 多个计算节点数据一致性通过等待回放和 globalsnapshot 机制来完成。等待回放保证所有 worker 能 看到所需要的数据版本，而 globalsnapshot 保证了选出一个统一的版本。\n7 TPC-H 性能：加速比 使用 1 TB 的 TPC-H 进行了测试，首先对比了 PolarDB PostgreSQL 版新的分布式并行和单机并行的性能， 有 3 条 SQL 提速 60 倍，19 条 SQL 提速 10 倍以上。\n此外，使用分布式执行引擎测试，增加 CPU 时的性能，可以看到，从 16 核和 128 核时性能线性提升。 单看 22 条 SQL，通过增加 CPU，每条 SQL 性能线性提升。\n8 TPC-H 性能：和传统 MPP 数仓对比 和传统 MPP 数仓对比，同样使用 16 个节点，PolarDB PostgreSQL 版的性能是传统 MPP 数仓的 90%。\n前面讲到给 PolarDB PostgreSQL 版的分布式引擎做到了弹性扩展，数据不需要充分重分布，当 dop=8 时，性能是传统 MPP 数仓的 5.6 倍。\n9 分布式执行加速索引创建 OLTP 业务中会建大量的索引，经分析建索引过程中，80%是在排序和构建索引页，20%在写索引页。 通过使用分布式并行来加速排序过程，同时流水化批量写入。\n上述优化能够使得创建索引有 4~5 倍的提升。\n10 分布式并行执行加速多模：时空数据库 PolarDB PostgreSQL 版是对多模数据库，支持时空数据。时空数据库是计算密集型和 IO 密集型，可 以借助分布式执行来加速。PolarDB PostgreSQL 版针对共享存储退出了扫描共享 RTREE 索引的功能。\n数据量：40000 万，500 GB。\n规格：5个只读节点，每个节点规格为 16 核 CPU、128 GB 内存。\n性能：\n随 CPU 数目线性提升。\n80 核 CPU 时，提升 71 倍。\n","wordCount":"1828","inLanguage":"zh-cn","datePublished":"2023-12-11T00:00:00Z","dateModified":"2023-12-11T00:00:00Z","author":[{"@type":"Person","name":"Yang"},{"@type":"Person","name":"Ying-chao"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://yangyingchao.github.io/posts/polardb-pg-htap%E6%9E%B6%E6%9E%84%E8%AF%A6%E8%A7%A3/"},"publisher":{"@type":"Organization","name":"MyNotes","logo":{"@type":"ImageObject","url":"https://yangyingchao.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://yangyingchao.github.io accesskey=h title="MyNotes (Alt + H)">MyNotes</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://yangyingchao.github.io/ title=Home><span>Home</span></a></li><li><a href=https://yangyingchao.github.io/posts/ title=Archives><span>Archives</span></a></li><li><a href=https://yangyingchao.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://yangyingchao.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://yangyingchao.github.io/contact/ title="Contact me"><span>Contact me</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>polardb pg HTAP架构详解</h1><div class=post-meta><span title='2023-12-11 00:00:00 +0000 UTC'>December 11, 2023</span>&nbsp;·&nbsp;Yang, Ying-chao</div></header><div class=post-content><ul><li>1 <a href=#h:036ce9a9-077e-48de-bb55-5234be6c2087>HTAP 架构原理</a></li><li>2 <a href=#h:5fb147d2-245c-4846-a70f-120912f6df84>分布式优化器</a></li><li>3 <a href=#h:bd455b10-a8d7-45a2-a36b-ce3ffa9fb862>算子并行化</a></li><li>4 <a href=#h:9800261a-d0c9-4291-b68d-70585cab4086>消除数据倾斜问题</a></li><li>5 <a href=#h:ce8787fe-c246-42e2-90b2-f7f85da2ec59>SQL 级别弹性扩展</a></li><li>6 <a href=#h:00c5781c-9f42-42bf-b6d3-5cd0f06d7274>事务一致性</a></li><li>7 <a href=#h:50f1201d-8be4-44f6-a94a-813611fe0e09>TPC-H 性能：加速比</a></li><li>8 <a href=#h:f71c9216-f9a9-439c-ba38-301fa36ce12e>TPC-H 性能：和传统 MPP 数仓对比</a></li><li>9 <a href=#h:a08fa54c-934e-4eef-b8af-7270e0256978>分布式执行加速索引创建</a></li><li>10 <a href=#h:417292af-a08f-42fe-87f1-b61f525ca2e3>分布式并行执行加速多模：时空数据库</a></li></ul><p>本文为摘录，原文为： <a href="https://help.aliyun.com/zh/polardb/polardb-for-postgresql/polardb-for-postgresql-architecture/?spm=a2c4g.11186623.0.0.2e3b5fb1p0L9je">https://help.aliyun.com/zh/polardb/polardb-for-postgresql/polardb-for-postgresql-architecture/?spm=a2c4g.11186623.0.0.2e3b5fb1p0L9je</a></p><p>PolarDB PostgreSQL 版读写分离后，由于底层是存储池，理论上 IO 吞吐是无限大的。而大查询只
能在单个计算节点上执行，单个计算节点的 CPU/MEM/IO 是有限的，因此单个计算节点无法发挥出存
储侧的大 IO 带宽的优势，也无法通过增加计算资源来加速大的查询。PolarDB PostgreSQL 版推出
了基于 Shared-Storage 的 MPP 分布式并行执行，来加速在 OLTP 场景下 OLAP 查询。</p><h2 id=h:036ce9a9-077e-48de-bb55-5234be6c2087>1 HTAP 架构原理<a hidden class=anchor aria-hidden=true href=#h:036ce9a9-077e-48de-bb55-5234be6c2087>#</a></h2><p>PolarDB PostgreSQL 版底层存储在不同节点上是共享的，因此不能直接像传统 MPP 一样去扫描表。
PolarDB PostgreSQL 版在原来单机执行引擎上支持了 MPP 分布式并行执行，同时对 Shared-Storage 进
行了优化。 基于 Shared-Storage 的 MPP 是业界首创。原理如下：</p><ul><li><p>Shuffle 算子屏蔽数据分布。</p></li><li><p>ParallelScan 算子屏蔽共享存储。</p></li></ul><figure><img loading=lazy src=/ox-hugo/p524517.png width=800px></figure><p>如图所示：</p><ul><li><p>表 A 和表 B 做 join，并做聚合。</p></li><li><p>共享存储中的表仍然是单张表，并没有做物理上的分区。</p></li><li><p>重新设计 4 类扫描算子，使之在扫描共享存储上的表时能够分片扫描，形成 virtual partition。</p></li></ul><h2 id=h:5fb147d2-245c-4846-a70f-120912f6df84>2 分布式优化器<a hidden class=anchor aria-hidden=true href=#h:5fb147d2-245c-4846-a70f-120912f6df84>#</a></h2><p>基于社区的 GPORCA 优化器扩展了能感知共享存储特性的 Transformation Rules。使得能够探索共享
存储下特有的 Plan 空间。例如，对于一个表在 PolarDB PostgreSQL 版中既可以全量的扫描，也可以
分区域扫描，这个是和传统 MPP 的本质区别。如下图所示，上面灰色部分是 PolarDB PostgreSQL 版内
核与 GPORCA 优化器的适配部分。下半部分是 ORCA 内核，灰色模块是在 ORCA 内核中对共享存储特性所
做的扩展。</p><figure><img loading=lazy src=/ox-hugo/p524524.png width=800px></figure><h2 id=h:bd455b10-a8d7-45a2-a36b-ce3ffa9fb862>3 算子并行化<a hidden class=anchor aria-hidden=true href=#h:bd455b10-a8d7-45a2-a36b-ce3ffa9fb862>#</a></h2><p>PolarDB PostgreSQL 版中有 4 类算子需要并行化，以下介绍一个具有代表性的 Seqscan 的算子的并行
化。</p><p>为了最大限度的利用存储的大 IO 带宽，在顺序扫描时，按照 4 MB 为单位做逻辑切分，将 IO 尽量打散
到不同的盘上，达到所有的盘同时提供读服务的效果。这样做还有一个优势，就是每个只读节点只
扫描部分表文件，则最终能缓存的表大小是所有只读节点的 BufferPool 总和。</p><figure><img loading=lazy src=/ox-hugo/p524526.png width=800px></figure><p>下面的图表中：</p><ul><li><p>增加只读节点，扫描性能线性提升 30 倍。</p></li><li><p>打开 Buffer 时，扫描从 37 分钟降到 3.75 秒。</p></li></ul><figure><img loading=lazy src=/ox-hugo/p524527.png width=800px></figure><h2 id=h:9800261a-d0c9-4291-b68d-70585cab4086>4 消除数据倾斜问题<a hidden class=anchor aria-hidden=true href=#h:9800261a-d0c9-4291-b68d-70585cab4086>#</a></h2><p>倾斜是传统 MPP 固有的问题：</p><ul><li><p>在 PolarDB PostgreSQL 版中，大对象的是通过 heap 表关联 TOAST​表，无论对哪个表切分都无法达到
均衡。</p></li><li><p>另外，不同只读节点的事务、Buffer、网络、IO 负载抖动。</p></li></ul><p>以上两点会导致分布执行时存在长尾进程。</p><figure><img loading=lazy src=/ox-hugo/p524528.png width=800px></figure><ul><li><p>协调节点内部分成 DataThread 和 ControlThread。</p></li><li><p>DataThread 负责收集汇总元组。</p></li><li><p>ControlThread 负责控制每个扫描算子的扫描进度。</p></li><li><p>扫描快的工作进程能多扫描逻辑的数据切片。</p></li><li><p>过程中需要考虑 Buffer 的亲和性。</p></li></ul><p><strong>说明</strong></p><p>尽管是动态分配，尽量维护 Buffer 的亲和性。另外，每个算子的上下文存储在 worker 的私有内存中，
Coordinator 不存储具体表的信息。</p><p>下面表格中，当出现大对象时，静态切分出现数据倾斜，而动态扫描仍然能够线性提升。</p><figure><img loading=lazy src=/ox-hugo/p524529.png width=800px></figure><h2 id=h:ce8787fe-c246-42e2-90b2-f7f85da2ec59>5 SQL 级别弹性扩展<a hidden class=anchor aria-hidden=true href=#h:ce8787fe-c246-42e2-90b2-f7f85da2ec59>#</a></h2><p>利用数据共享的特点，还可以支持云原生下极致弹性的要求。将 Coordinator 全链路上各个模块所需
要的外部依赖存在共享存储上，同时 worker 全链路上需要的运行时参数通过控制链路从
Coordinator 同步过来，使 Coordinator 和 worker 无状态化。</p><figure><img loading=lazy src=/ox-hugo/p524530.png width=800px></figure><p>因此：</p><ul><li><p>SQL 连接的任意只读节点都可以成为 Coordinator 节点，这解决了 Coordinator 单点问题。</p></li><li><p>支持不同的 SQL 使用不同的 CPU 数目执行，灵活的配置不同业务 SQL 配置不同的 CPU 核心数。</p></li></ul><figure><img loading=lazy src=/ox-hugo/p524531.png width=800px></figure><h2 id=h:00c5781c-9f42-42bf-b6d3-5cd0f06d7274>6 事务一致性<a hidden class=anchor aria-hidden=true href=#h:00c5781c-9f42-42bf-b6d3-5cd0f06d7274>#</a></h2><p>多个计算节点数据一致性通过等待回放和 globalsnapshot 机制来完成。等待回放保证所有 worker 能
看到所需要的数据版本，而 globalsnapshot 保证了选出一个统一的版本。</p><figure><img loading=lazy src=/ox-hugo/p524533.png width=800px></figure><h2 id=h:50f1201d-8be4-44f6-a94a-813611fe0e09>7 TPC-H 性能：加速比<a hidden class=anchor aria-hidden=true href=#h:50f1201d-8be4-44f6-a94a-813611fe0e09>#</a></h2><figure><img loading=lazy src=/ox-hugo/p524534.png width=800px></figure><p>使用 1 TB 的 TPC-H 进行了测试，首先对比了 PolarDB PostgreSQL 版新的分布式并行和单机并行的性能，
有 3 条 SQL 提速 60 倍，19 条 SQL 提速 10 倍以上。</p><figure><img loading=lazy src=/ox-hugo/p524535.png width=800px></figure><figure><img loading=lazy src=/ox-hugo/p524536.png width=800px></figure><p>此外，使用分布式执行引擎测试，增加 CPU 时的性能，可以看到，从 16 核和 128 核时性能线性提升。
单看 22 条 SQL，通过增加 CPU，每条 SQL 性能线性提升。</p><h2 id=h:f71c9216-f9a9-439c-ba38-301fa36ce12e>8 TPC-H 性能：和传统 MPP 数仓对比<a hidden class=anchor aria-hidden=true href=#h:f71c9216-f9a9-439c-ba38-301fa36ce12e>#</a></h2><p>和传统 MPP 数仓对比，同样使用 16 个节点，PolarDB PostgreSQL 版的性能是传统 MPP 数仓的 90%。</p><figure><img loading=lazy src=/ox-hugo/p524538.png width=800px></figure><figure><img loading=lazy src=/ox-hugo/p524539.png width=800px></figure><p>前面讲到给 PolarDB PostgreSQL 版的分布式引擎做到了弹性扩展，数据不需要充分重分布，当
dop=8 时，性能是传统 MPP 数仓的 5.6 倍。</p><h2 id=h:a08fa54c-934e-4eef-b8af-7270e0256978>9 分布式执行加速索引创建<a hidden class=anchor aria-hidden=true href=#h:a08fa54c-934e-4eef-b8af-7270e0256978>#</a></h2><p>OLTP 业务中会建大量的索引，经分析建索引过程中，80%是在排序和构建索引页，20%在写索引页。
通过使用分布式并行来加速排序过程，同时流水化批量写入。</p><figure><img loading=lazy src=/ox-hugo/p524541.png width=800px></figure><p>上述优化能够使得创建索引有 4~5 倍的提升。</p><figure><img loading=lazy src=/ox-hugo/p524542.png width=800px></figure><h2 id=h:417292af-a08f-42fe-87f1-b61f525ca2e3>10 分布式并行执行加速多模：时空数据库<a hidden class=anchor aria-hidden=true href=#h:417292af-a08f-42fe-87f1-b61f525ca2e3>#</a></h2><p>PolarDB PostgreSQL 版是对多模数据库，支持时空数据。时空数据库是计算密集型和 IO 密集型，可
以借助分布式执行来加速。PolarDB PostgreSQL 版针对共享存储退出了扫描共享 RTREE 索引的功能。</p><figure><img loading=lazy src=/ox-hugo/p524543.png width=800px></figure><ul><li><p>数据量：40000 万，500 GB。</p></li><li><p>规格：5个只读节点，每个节点规格为 16 核 CPU、128 GB 内存。</p></li><li><p>性能：</p><ul><li><p>随 CPU 数目线性提升。</p></li><li><p>80 核 CPU 时，提升 71 倍。</p></li></ul></li></ul><figure><img loading=lazy src=/ox-hugo/p524546.png width=800px></figure></div><footer class=post-footer><ul class=post-tags><li><a href=https://yangyingchao.github.io/tags/tag1/>tag1</a></li><li><a href=https://yangyingchao.github.io/tags/tag2/>tag2</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://yangyingchao.github.io>MyNotes</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>