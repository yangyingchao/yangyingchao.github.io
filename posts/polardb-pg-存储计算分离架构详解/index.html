<!doctype html><html lang=zh-cn dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>PolarDB PostgreSQL 版：存储计算分离架构详解 | MyNotes</title><meta name=keywords content="sharedata"><meta name=description content="1 Shared-Storage 带来的挑战 2 架构原理 3 数据一致性 3.1 传统数据库的内存状态同步 3.2 基于 Shared-Storage 的内存状态同步 3.3 基于 Shared-Storage 的过去页面 3.4 过去页面的解法 3.5 基于 Shared-Storage 的未来页面 3.6 未"><meta name=author content="Yang, Ying-chao"><link rel=canonical href=https://yangyingchao.github.io/posts/polardb-pg-%E5%AD%98%E5%82%A8%E8%AE%A1%E7%AE%97%E5%88%86%E7%A6%BB%E6%9E%B6%E6%9E%84%E8%AF%A6%E8%A7%A3/><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://yangyingchao.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://yangyingchao.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://yangyingchao.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://yangyingchao.github.io/apple-touch-icon.png><link rel=mask-icon href=https://yangyingchao.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="PolarDB PostgreSQL 版：存储计算分离架构详解"><meta property="og:description" content="1 Shared-Storage 带来的挑战 2 架构原理 3 数据一致性 3.1 传统数据库的内存状态同步 3.2 基于 Shared-Storage 的内存状态同步 3.3 基于 Shared-Storage 的过去页面 3.4 过去页面的解法 3.5 基于 Shared-Storage 的未来页面 3.6 未"><meta property="og:type" content="article"><meta property="og:url" content="https://yangyingchao.github.io/posts/polardb-pg-%E5%AD%98%E5%82%A8%E8%AE%A1%E7%AE%97%E5%88%86%E7%A6%BB%E6%9E%B6%E6%9E%84%E8%AF%A6%E8%A7%A3/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-12-11T00:00:00+00:00"><meta property="article:modified_time" content="2023-12-11T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="PolarDB PostgreSQL 版：存储计算分离架构详解"><meta name=twitter:description content="1 Shared-Storage 带来的挑战 2 架构原理 3 数据一致性 3.1 传统数据库的内存状态同步 3.2 基于 Shared-Storage 的内存状态同步 3.3 基于 Shared-Storage 的过去页面 3.4 过去页面的解法 3.5 基于 Shared-Storage 的未来页面 3.6 未"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://yangyingchao.github.io/posts/"},{"@type":"ListItem","position":2,"name":"PolarDB PostgreSQL 版：存储计算分离架构详解","item":"https://yangyingchao.github.io/posts/polardb-pg-%E5%AD%98%E5%82%A8%E8%AE%A1%E7%AE%97%E5%88%86%E7%A6%BB%E6%9E%B6%E6%9E%84%E8%AF%A6%E8%A7%A3/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"PolarDB PostgreSQL 版：存储计算分离架构详解","name":"PolarDB PostgreSQL 版：存储计算分离架构详解","description":"1 Shared-Storage 带来的挑战 2 架构原理 3 数据一致性 3.1 传统数据库的内存状态同步 3.2 基于 Shared-Storage 的内存状态同步 3.3 基于 Shared-Storage 的过去页面 3.4 过去页面的解法 3.5 基于 Shared-Storage 的未来页面 3.6 未","keywords":["sharedata"],"articleBody":" 1 Shared-Storage 带来的挑战 2 架构原理 3 数据一致性 3.1 传统数据库的内存状态同步 3.2 基于 Shared-Storage 的内存状态同步 3.3 基于 Shared-Storage 的过去页面 3.4 过去页面的解法 3.5 基于 Shared-Storage 的未来页面 3.6 未来页面的解法 4 低延迟复制 4.1 传统流复制的问题 4.2 优化 1：只复制 Meta 4.3 优化 2：页面回放优化 4.4 优化 3：DDL 锁回放优化 5 Recovery 优化 5.1 背景 5.2 Lazy Recovery 5.3 Persistent BufferPool 本文为摘录，原文为： https://help.aliyun.com/zh/polardb/polardb-for-postgresql/polardb-for-postgresql-architecture/?spm=a2c4g.11186623.0.0.2e3b5fb1p0L9je\n1 Shared-Storage 带来的挑战 基于 Shared-Storage，数据库由传统的 share nothing，转变成了 Shared-Storage 架构。需要解决以 下问题：\n数据一致性：由原来的 N 份计算+N 份存储，转变成了 N 份计算+1 份存储。 读写分离：如何基于新架构做到低延迟的复制。 高可用：如何 Recovery 和 Failover。 IO 模型：如何从 Buffer-IO 向 Direct-IO 优化。 2 架构原理 基于 Shared-Storage 的 PolarDB PostgreSQL 版的架构原理如下：\n主节点为可读可写节点（RW），只读节点为只读（RO）。\nShared-Storage 层，只有主节点能写入，因此主节点和只读节点能看到一致的落盘的数据。\n只读节点的内存状态是通过回放 WAL 保持和主节点同步的。\n主节点的 WAL 日志写到 Shared-Storage，仅复制 WAL 的 meta 给只读节点。\n只读节点从 Shared-Storage 上读取 WAL 并回放。\n3 数据一致性 3.1 传统数据库的内存状态同步 传统 share nothing 的数据库，主节点和只读节点都有各自的内存和存储，只需要从主节点复制 WAL 日志到只读节点，并在只读节点上依次回放日志即可，这也是复制状态机的基本原理。\n3.2 基于 Shared-Storage 的内存状态同步 存储计算分离后，Shared-Storage 上读取到的页面是一致的，内存状态是通过从 Shared-Storage 上 读取最新的 WAL 并回放得来，如下图所示：\n主节点通过刷脏将版本 200 写入到 Shared-Storage。\n只读节点基于版本 100，并回放日志得到 200。\n3.3 基于 Shared-Storage 的过去页面 上述流程中，只读节点中基于日志回放出来的页面会被淘汰掉，此后需要再次从存储上读取页面， 会出现读取的页面是之前的老页面，称为过去页面。如下图所示：\nT1 时刻，主节点在 T1 时刻写入日志 LSN=200，把页面 P1 的内容从 500 更新到 600。\n只读节点此时页面 P1 的内容是 500。\nT2 时刻，主节点将日志 200 的 meta 信息发送给只读节点，只读节点得知存在新的日志。\nT3 时刻，此时在只读节点上读取页面 P1，需要读取页面 P1 和 LSN=200 的日志，进行一次回放，得 到 P1 的最新内容为 600。\nT4 时刻，只读节点上由于 BufferPool 不足，将回放出来的最新页面 P1 淘汰掉。\n主节点没有将最新的页面 P1 为 600 的最新内容刷脏到 Shared-Storage 上。\nT5 时刻，再次从只读节点上发起读取 P1 操作，由于内存中已经将 P1 淘汰掉了，因此从 Shared-Storage 上读取，此时读取到了过去页面的内容。\n3.4 过去页面的解法 只读节点在任意时刻读取页面时，需要找到对应的 Base 页面和对应起点的日志，依次回放。如下图 所示：\n在只读节点内存中维护每个 Page 对应的日志 meta。\n在读取时一个 Page 时，按需逐个应用日志直到期望的 Page 版本。\n应用日志时，通过日志的 meta 从 Shared-Storage 上读取。\n通过上述分析，需要维护每个 Page 到日志的倒排索引，而只读节点的内存是有限的，因此这个 Page 到日志的索引需要持久化，PolarDB PostgreSQL 版设计了一个可持久化的索引结构-LogIndex。 LogIndex 本质是一个可持久化的 hash 数据结构。\n只读节点通过 WAL receiver 接收从主节点过来的 WAL meta 信息。\nWAL meta 记录该条日志修改了哪些 Page。\n将该条 WAL meta 插入到 LogIndex 中。其中，key 是 Page ID，value 是 LSN。\n一条 WAL 日志可能更新了多个 Page（索引分裂），在 LogIndex 中有多条记录。\n同时在 BufferPool 中给该 Page 打上 outdate 标记，以便下次读取的时候从 LogIndex 重回放对应的 日志。\n当内存达到一定阈值时，LogIndex 异步将内存中的 hash 刷到盘上。\n通过 LogIndex 解决了刷脏依赖过去页面的问题，也是将只读节点的回放转变成了 Lazy 的回放：只需 要回放日志的 meta 信息即可。\n3.5 基于 Shared-Storage 的未来页面 在存储计算分离后，刷脏依赖还存在未来页面的问题。如下图所示：\nT1 时刻，主节点对 P1 更新了 2 次，产生了 2 条日志，此时主节点和只读节点上页面 P1 的内容都是 500。\nT2 时刻， 发送日志 LSN=200 给只读节点。\nT3 时刻，只读节点回放 LSN=200 的日志，得到 P1 的内容为 600，此时只读节点日志回放到了 200， 后面的 LSN=300 的日志对其来说还不存在。\nT4 时刻，主节点刷脏，将 P1 最新的内容 700 刷到了 Shared-Storage 上，同时只读节点上 BufferPool 淘汰掉了页面 P1。\nT5 时刻，只读节点再次读取页面 P1，由于 BufferPool 中不存在 P1，因此从共享内存上读取了最新 的 P1，但是只读节点并没有回放 LSN=300 的日志，读取到了一个对其来说超前的未来页面。\n未来页面的问题是：部分页面是未来页面，部分页面是正常的页面，会导致数据不一致。例如， 索引分裂成 2 个 Page 后，一个读取到了正常的 Page，另一个读取到了未来页面，B+Tree 的索引结 构会被破坏。\n3.6 未来页面的解法 未来页面的原因是主节点刷脏的速度超过了任一只读节点的回放速度（虽然只读节点的 Lazy 回放已 经很快了）。因此，解法就是对主节点刷脏进度时做控制：不能超过最慢的只读节点的回放位点。 如下图所示：\n只读节点回放到 T4 位点。\n主节点在刷脏时，对所有脏页按照 LSN 排序，仅刷在 T4 之前的脏页（包括 T4），之后的脏页不刷。\n其中，T4 的 LSN 位点称为一致性位点。\n4 低延迟复制 4.1 传统流复制的问题 同步链路：日志同步路径 IO 多，网络传输量大。\n页面回放：读取和 Buffer 修改慢（IO 密集型+CPU 密集型）。\nDDL 回放：修改文件时需要对修改的文件加锁，而加锁的过程容易被阻塞，导致 DDL 慢。\n快照更新：RO 高并发引起事务快照更新慢。\n流程如下：\n主节点写入 WAL 日志到本地文件系统中。\nWAL Sender 进程读取，并发送。\n只读节点的 WAL Receiver 进程接收写入到本地文件系统中。\n回放进程读取 WAL 日志，读取对应的 Page 到 BufferPool 中，并在内存中回放。\n主节点刷脏页到 Shared Storage。\n从上述流程可以看到，整个链路是很长的，只读节点延迟高，影响用户业务读写分离负载均衡。\n4.2 优化 1：只复制 Meta 因为底层是 Shared-Storage，只读节点可直接从 Shared-Storage 上读取所需要的 WAL 数据。因此主节 点只把 WAL 日志的元数据（去掉 Payload）复制到只读节点，这样网络传输量小，减少关键路径上的 IO。如下图所示：\nWAL Record 是由：Header，PageID，Payload 组成。\n由于只读节点可以直接读取 Shared-Storage 上的 WAL 文件，因此主节点只把 WAL 日志的元数据发送 （复制）到只读节点，包括：Header，PageID。\n在只读节点上，通过 WAL 的元数据直接读取 Shared-Storage 上完整的 WAL 文件。\n通过上述优化，能显著减少主节点和只读节点间的网络传输量。从下图可以看到网络传输量减少了 98%。\n4.3 优化 2：页面回放优化 在传统数据库中日志回放的过程中会读取大量的 Page 并逐个日志 Apply，然后落盘。该流程在用户读 IO 的关键路径上，借助存储计算分离可以做到：如果只读节点上 Page 不在 BufferPool 中，不产生任 何 IO，仅仅记录 LogIndex 即可。\n可以将回放进程中的以下 IO 操作 offload 到 session 进程中：\n数据页 IO 开销。\n日志 apply 开销。\n基于 LogIndex 页面的多版本回放。\n如下图所示，在只读节点上的回放进程中，在 Apply 一条 WAL 的 meta 时：\n如果对应 Page 不在内存中，仅仅记录 LogIndex。\n如果对应的 Page 在内存中，则标记为 Outdate，并记录 LogIndex，回放过程完成。\n用户 session 进程在读取 Page 时，读取正确的 Page 到 BufferPool 中，并通过 LogIndex 来回放相应的 日志。\n可以看到，主要的 IO 操作由原来的单个回放进程 offload 到了多个用户进程。\n通过上述优化，能显著减少回放的延迟，比其他云原生数据库快 30 倍。\n4.4 优化 3：DDL 锁回放优化 在主节点执行 DDL 时（例如，drop table），需要在所有节点上都对表上排他锁，这样能保证表文件 不会在只读节点上读取时被主节点删除掉了（因为文件在 Shared-Storage 上只有一份）。在所有只 读节点上对表上排他锁是通过 WAL 复制到所有的只读节点，只读节点回放 DDL 锁来完成。而回放进程 在回放 DDL 锁时，对表上锁可能会阻塞很久，因此可以通过把 DDL 锁 offload 到其他进程上来优化回放 进程的关键路径。\n通过上述优化，能够保证回放进程一直处于平滑的状态，不会因为去等 DDL 而阻塞了回放的关键路径。\n上述 3 个优化之后，极大的降低了复制延迟，能够带来如下优势：\n读写分离：负载均衡，更接近 Oracle RAC 使用体验。\n高可用：加速 HA 流程。\n稳定性：最小化未来页的数量，可以写更少或者无需写页面快照。\n5 Recovery 优化 5.1 背景 数据库 OOM、Crash 等场景恢复时间长，本质上是日志回放慢，在共享存储 Direct-IO 模型下问题更加 突出。\n5.2 Lazy Recovery 上述内容介绍通过 LogIndex 在只读节点上做到了 Lazy 的回放，在主节点重启后的 recovery 过程中， 本质也是在回放日志，因此，可以借助 Lazy 回放来加速 recovery 的过程：\n从 checkpoint 点开始逐条去读 WAL 日志。\n回放完 LogIndex 日志后，即认为回放完成。\nrecovery 完成，开始提供服务。\n真正的回放被 offload 到了重启之后进来的 session 进程中。\n优化之后（回放 500 MB 日志量），如下图所示：\n5.3 Persistent BufferPool 上述方案优化了在 recovery 的重启速度，但是在重启之后，session 进程通过读取 WAL 日志来回放想 要的 page。表示为在 recovery 之后会有短暂的响应慢的问题。优化的办法为在数据库重启时 BufferPool 并不销毁，如下图所示：crash 和 restart 期间 BufferPool 不销毁。\n内核中的共享内存分成 2 部分：\n全局结构，ProcArray 等。\nBufferPool 结构；其中 BufferPool 通过具名共享内存来分配，在进程重启后仍然有效。而全局结 构在进程重启后需要重新初始化。\n而 BufferPool 中并不是所有的 Page 都是可以复用的。例如：在重启前，某进程对 Page 上 X 锁，随后 crash 了，该 X 锁就没有进程来释放了。因此，在 crash 和 restart 之后需要把所有的 BufferPool 遍历 一遍，剔除掉不能被复用的 Page。另外，BufferPool 的回收依赖 kubernetes。该优化之后，使得重 启前后性能平稳。\n","wordCount":"3708","inLanguage":"zh-cn","datePublished":"2023-12-11T00:00:00Z","dateModified":"2023-12-11T00:00:00Z","author":[{"@type":"Person","name":"Yang"},{"@type":"Person","name":"Ying-chao"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://yangyingchao.github.io/posts/polardb-pg-%E5%AD%98%E5%82%A8%E8%AE%A1%E7%AE%97%E5%88%86%E7%A6%BB%E6%9E%B6%E6%9E%84%E8%AF%A6%E8%A7%A3/"},"publisher":{"@type":"Organization","name":"MyNotes","logo":{"@type":"ImageObject","url":"https://yangyingchao.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://yangyingchao.github.io accesskey=h title="MyNotes (Alt + H)">MyNotes</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://yangyingchao.github.io/ title=Home><span>Home</span></a></li><li><a href=https://yangyingchao.github.io/posts/ title=Archives><span>Archives</span></a></li><li><a href=https://yangyingchao.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://yangyingchao.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://yangyingchao.github.io/contact/ title="Contact me"><span>Contact me</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">PolarDB PostgreSQL 版：存储计算分离架构详解</h1><div class=post-meta><span title='2023-12-11 00:00:00 +0000 UTC'>December 11, 2023</span>&nbsp;·&nbsp;Yang, Ying-chao</div></header><div class=post-content><ul><li>1 <a href=#h:d8d4ef97-4485-44f4-bc2d-c78a873701cd>Shared-Storage 带来的挑战</a></li><li>2 <a href=#h:c750efed-81ff-4f8e-ae09-ed02f60bb63d>架构原理</a></li><li>3 <a href=#h:a071ef56-0879-41d2-b95e-67f9e2cfbcec>数据一致性</a><ul><li>3.1 <a href=#h:ef8c9431-3ca6-442e-a55f-71a5a595c5f3>传统数据库的内存状态同步</a></li><li>3.2 <a href=#h:1cfe1c7c-a47a-451e-b10c-3f836fe98d41>基于 Shared-Storage 的内存状态同步</a></li><li>3.3 <a href=#h:16a80370-6a2e-4d84-952b-d5c4a4502de9>基于 Shared-Storage 的过去页面</a></li><li>3.4 <a href=#h:2cec3b2e-3535-4bfd-9c2f-7e472f90e237>过去页面的解法</a></li><li>3.5 <a href=#h:55fd37e4-0218-4b6e-aafc-7a47b0793ab7>基于 Shared-Storage 的未来页面</a></li><li>3.6 <a href=#h:62e86f15-aa20-4c60-a5e9-c2f6cf52efa5>未来页面的解法</a></li></ul></li><li>4 <a href=#h:87c53a58-40bf-48f7-a6c6-37ae183b7458>低延迟复制</a><ul><li>4.1 <a href=#h:ae890731-50a7-4503-a45c-54f40a2f59a8>传统流复制的问题</a></li><li>4.2 <a href=#h:8e96148b-53d3-49d2-9a7d-9477c53d476f>优化 1：只复制 Meta</a></li><li>4.3 <a href=#h:8c215440-dc4e-4295-9d49-5a913b3ed609>优化 2：页面回放优化</a></li><li>4.4 <a href=#h:2890df00-9e44-4df5-b228-d572ea27eac7>优化 3：DDL 锁回放优化</a></li></ul></li><li>5 <a href=#h:2eff1fce-d7c0-44bd-82df-bc786a42a946>Recovery 优化</a><ul><li>5.1 <a href=#h:45cfaf2c-5ce3-4d89-a739-2684e04f5090>背景</a></li><li>5.2 <a href=#h:6a304701-3040-4134-8b94-e94a3b68b24f>Lazy Recovery</a></li><li>5.3 <a href=#h:656635f1-34a8-4284-a914-34458659c504>Persistent BufferPool</a></li></ul></li></ul><p>本文为摘录，原文为： <a href="https://help.aliyun.com/zh/polardb/polardb-for-postgresql/polardb-for-postgresql-architecture/?spm=a2c4g.11186623.0.0.2e3b5fb1p0L9je">https://help.aliyun.com/zh/polardb/polardb-for-postgresql/polardb-for-postgresql-architecture/?spm=a2c4g.11186623.0.0.2e3b5fb1p0L9je</a></p><h2 id=h:d8d4ef97-4485-44f4-bc2d-c78a873701cd>1 Shared-Storage 带来的挑战<a hidden class=anchor aria-hidden=true href=#h:d8d4ef97-4485-44f4-bc2d-c78a873701cd>#</a></h2><p>基于 Shared-Storage，数据库由传统的 share nothing，转变成了 Shared-Storage 架构。需要解决以
下问题：</p><ul><li>数据一致性：由原来的 N 份计算+N 份存储，转变成了 N 份计算+1 份存储。</li><li>读写分离：如何基于新架构做到低延迟的复制。</li><li>高可用：如何 Recovery 和 Failover。</li><li>IO 模型：如何从 Buffer-IO 向 Direct-IO 优化。</li></ul><h2 id=h:c750efed-81ff-4f8e-ae09-ed02f60bb63d>2 架构原理<a hidden class=anchor aria-hidden=true href=#h:c750efed-81ff-4f8e-ae09-ed02f60bb63d>#</a></h2><figure><img loading=lazy src=/ox-hugo/p523782.png width=800px></figure><p>基于 Shared-Storage 的 PolarDB PostgreSQL 版的架构原理如下：</p><ul><li><p>主节点为可读可写节点（RW），只读节点为只读（RO）。</p></li><li><p>Shared-Storage 层，只有主节点能写入，因此主节点和只读节点能看到一致的落盘的数据。</p></li><li><p>只读节点的内存状态是通过回放 WAL 保持和主节点同步的。</p></li><li><p>主节点的 WAL 日志写到 Shared-Storage，仅复制 WAL 的 meta 给只读节点。</p></li><li><p>只读节点从 Shared-Storage 上读取 WAL 并回放。</p></li></ul><h2 id=h:a071ef56-0879-41d2-b95e-67f9e2cfbcec>3 数据一致性<a hidden class=anchor aria-hidden=true href=#h:a071ef56-0879-41d2-b95e-67f9e2cfbcec>#</a></h2><h3 id=h:ef8c9431-3ca6-442e-a55f-71a5a595c5f3>3.1 传统数据库的内存状态同步<a hidden class=anchor aria-hidden=true href=#h:ef8c9431-3ca6-442e-a55f-71a5a595c5f3>#</a></h3><p>传统 share nothing 的数据库，主节点和只读节点都有各自的内存和存储，只需要从主节点复制 WAL
日志到只读节点，并在只读节点上依次回放日志即可，这也是复制状态机的基本原理。</p><h3 id=h:1cfe1c7c-a47a-451e-b10c-3f836fe98d41>3.2 基于 Shared-Storage 的内存状态同步<a hidden class=anchor aria-hidden=true href=#h:1cfe1c7c-a47a-451e-b10c-3f836fe98d41>#</a></h3><p>存储计算分离后，Shared-Storage 上读取到的页面是一致的，内存状态是通过从 Shared-Storage 上
读取最新的 WAL 并回放得来，如下图所示：</p><figure><img loading=lazy src=/ox-hugo/p523839.png width=800px></figure><ol><li><p>主节点通过刷脏将版本 200 写入到 Shared-Storage。</p></li><li><p>只读节点基于版本 100，并回放日志得到 200。</p></li></ol><h3 id=h:16a80370-6a2e-4d84-952b-d5c4a4502de9>3.3 基于 Shared-Storage 的过去页面<a hidden class=anchor aria-hidden=true href=#h:16a80370-6a2e-4d84-952b-d5c4a4502de9>#</a></h3><p>上述流程中，只读节点中基于日志回放出来的页面会被淘汰掉，此后需要再次从存储上读取页面，
会出现读取的页面是之前的老页面，称为过去页面。如下图所示：</p><figure><img loading=lazy src=/ox-hugo/p523841.png width=800px></figure><ol><li><p>T1 时刻，主节点在 T1 时刻写入日志 LSN=200，把页面 P1 的内容从 500 更新到 600。</p></li><li><p>只读节点此时页面 P1 的内容是 500。</p></li><li><p>T2 时刻，主节点将日志 200 的 meta 信息发送给只读节点，只读节点得知存在新的日志。</p></li><li><p>T3 时刻，此时在只读节点上读取页面 P1，需要读取页面 P1 和 LSN=200 的日志，进行一次回放，得
到 P1 的最新内容为 600。</p></li><li><p>T4 时刻，只读节点上由于 BufferPool 不足，将回放出来的最新页面 P1 淘汰掉。</p></li><li><p>主节点没有将最新的页面 P1 为 600 的最新内容刷脏到 Shared-Storage 上。</p></li><li><p>T5 时刻，再次从只读节点上发起读取 P1 操作，由于内存中已经将 P1 淘汰掉了，因此从
Shared-Storage 上读取，此时读取到了过去页面的内容。</p></li></ol><h3 id=h:2cec3b2e-3535-4bfd-9c2f-7e472f90e237>3.4 过去页面的解法<a hidden class=anchor aria-hidden=true href=#h:2cec3b2e-3535-4bfd-9c2f-7e472f90e237>#</a></h3><p>只读节点在任意时刻读取页面时，需要找到对应的 Base 页面和对应起点的日志，依次回放。如下图
所示：</p><figure><img loading=lazy src=/ox-hugo/p523842.png width=800px></figure><ol><li><p>在只读节点内存中维护每个 Page 对应的日志 meta。</p></li><li><p>在读取时一个 Page 时，按需逐个应用日志直到期望的 Page 版本。</p></li><li><p>应用日志时，通过日志的 meta 从 Shared-Storage 上读取。</p></li></ol><p>通过上述分析，需要维护每个 Page 到日志的倒排索引，而只读节点的内存是有限的，因此这个 Page
到日志的索引需要持久化，PolarDB PostgreSQL 版设计了一个可持久化的索引结构-LogIndex。
LogIndex 本质是一个可持久化的 hash 数据结构。</p><ol><li><p>只读节点通过 WAL receiver 接收从主节点过来的 WAL meta 信息。</p></li><li><p>WAL meta 记录该条日志修改了哪些 Page。</p></li><li><p>将该条 WAL meta 插入到 LogIndex 中。其中，key 是 Page ID，value 是 LSN。</p></li><li><p>一条 WAL 日志可能更新了多个 Page（索引分裂），在 LogIndex 中有多条记录。</p></li><li><p>同时在 BufferPool 中给该 Page 打上 outdate 标记，以便下次读取的时候从 LogIndex 重回放对应的
日志。</p></li><li><p>当内存达到一定阈值时，LogIndex 异步将内存中的 hash 刷到盘上。</p></li></ol><figure><img loading=lazy src=/ox-hugo/p524145.png width=800px></figure><p>通过 LogIndex 解决了刷脏依赖过去页面的问题，也是将只读节点的回放转变成了 Lazy 的回放：只需
要回放日志的 meta 信息即可。</p><h3 id=h:55fd37e4-0218-4b6e-aafc-7a47b0793ab7>3.5 基于 Shared-Storage 的未来页面<a hidden class=anchor aria-hidden=true href=#h:55fd37e4-0218-4b6e-aafc-7a47b0793ab7>#</a></h3><p>在存储计算分离后，刷脏依赖还存在未来页面的问题。如下图所示：</p><figure><img loading=lazy src=/ox-hugo/p524147.png width=800px></figure><ol><li><p>T1 时刻，主节点对 P1 更新了 2 次，产生了 2 条日志，此时主节点和只读节点上页面 P1 的内容都是
500。</p></li><li><p>T2 时刻， 发送日志 LSN=200 给只读节点。</p></li><li><p>T3 时刻，只读节点回放 LSN=200 的日志，得到 P1 的内容为 600，此时只读节点日志回放到了 200，
后面的 LSN=300 的日志对其来说还不存在。</p></li><li><p>T4 时刻，主节点刷脏，将 P1 最新的内容 700 刷到了 Shared-Storage 上，同时只读节点上
BufferPool 淘汰掉了页面 P1。</p></li><li><p>T5 时刻，只读节点再次读取页面 P1，由于 BufferPool 中不存在 P1，因此从共享内存上读取了最新
的 P1，但是只读节点并没有回放 LSN=300 的日志，读取到了一个对其来说超前的未来页面。</p></li><li><p>未来页面的问题是：部分页面是未来页面，部分页面是正常的页面，会导致数据不一致。例如，
索引分裂成 2 个 Page 后，一个读取到了正常的 Page，另一个读取到了未来页面，B+Tree 的索引结
构会被破坏。</p></li></ol><h3 id=h:62e86f15-aa20-4c60-a5e9-c2f6cf52efa5>3.6 未来页面的解法<a hidden class=anchor aria-hidden=true href=#h:62e86f15-aa20-4c60-a5e9-c2f6cf52efa5>#</a></h3><p>未来页面的原因是主节点刷脏的速度超过了任一只读节点的回放速度（虽然只读节点的 Lazy 回放已
经很快了）。因此，解法就是对主节点刷脏进度时做控制：不能超过最慢的只读节点的回放位点。
如下图所示：</p><figure><img loading=lazy src=/ox-hugo/p524158.png width=800px></figure><ol><li><p>只读节点回放到 T4 位点。</p></li><li><p>主节点在刷脏时，对所有脏页按照 LSN 排序，仅刷在 T4 之前的脏页（包括 T4），之后的脏页不刷。</p></li><li><p>其中，T4 的 LSN 位点称为一致性位点。</p></li></ol><h2 id=h:87c53a58-40bf-48f7-a6c6-37ae183b7458>4 低延迟复制<a hidden class=anchor aria-hidden=true href=#h:87c53a58-40bf-48f7-a6c6-37ae183b7458>#</a></h2><h3 id=h:ae890731-50a7-4503-a45c-54f40a2f59a8>4.1 传统流复制的问题<a hidden class=anchor aria-hidden=true href=#h:ae890731-50a7-4503-a45c-54f40a2f59a8>#</a></h3><ol><li><p>同步链路：日志同步路径 IO 多，网络传输量大。</p></li><li><p>页面回放：读取和 Buffer 修改慢（IO 密集型+CPU 密集型）。</p></li><li><p>DDL 回放：修改文件时需要对修改的文件加锁，而加锁的过程容易被阻塞，导致 DDL 慢。</p></li><li><p>快照更新：RO 高并发引起事务快照更新慢。</p></li></ol><figure><img loading=lazy src=/ox-hugo/p524169.png width=800px></figure><p>流程如下：</p><ol><li><p>主节点写入 WAL 日志到本地文件系统中。</p></li><li><p>WAL Sender 进程读取，并发送。</p></li><li><p>只读节点的 WAL Receiver 进程接收写入到本地文件系统中。</p></li><li><p>回放进程读取 WAL 日志，读取对应的 Page 到 BufferPool 中，并在内存中回放。</p></li><li><p>主节点刷脏页到 Shared Storage。</p></li></ol><p>从上述流程可以看到，整个链路是很长的，只读节点延迟高，影响用户业务读写分离负载均衡。</p><h3 id=h:8e96148b-53d3-49d2-9a7d-9477c53d476f>4.2 优化 1：只复制 Meta<a hidden class=anchor aria-hidden=true href=#h:8e96148b-53d3-49d2-9a7d-9477c53d476f>#</a></h3><p>因为底层是 Shared-Storage，只读节点可直接从 Shared-Storage 上读取所需要的 WAL 数据。因此主节
点只把 WAL 日志的元数据（去掉 Payload）复制到只读节点，这样网络传输量小，减少关键路径上的
IO。如下图所示：</p><ol><li><p>WAL Record 是由：Header，PageID，Payload 组成。</p></li><li><p>由于只读节点可以直接读取 Shared-Storage 上的 WAL 文件，因此主节点只把 WAL 日志的元数据发送
（复制）到只读节点，包括：Header，PageID。</p></li><li><p>在只读节点上，通过 WAL 的元数据直接读取 Shared-Storage 上完整的 WAL 文件。</p></li></ol><p>通过上述优化，能显著减少主节点和只读节点间的网络传输量。从下图可以看到网络传输量减少了 98%。</p><h3 id=h:8c215440-dc4e-4295-9d49-5a913b3ed609>4.3 优化 2：页面回放优化<a hidden class=anchor aria-hidden=true href=#h:8c215440-dc4e-4295-9d49-5a913b3ed609>#</a></h3><p>在传统数据库中日志回放的过程中会读取大量的 Page 并逐个日志 Apply，然后落盘。该流程在用户读
IO 的关键路径上，借助存储计算分离可以做到：如果只读节点上 Page 不在 BufferPool 中，不产生任
何 IO，仅仅记录 LogIndex 即可。</p><p>可以将回放进程中的以下 IO 操作 offload 到 session 进程中：</p><ul><li><p>数据页 IO 开销。</p></li><li><p>日志 apply 开销。</p></li><li><p>基于 LogIndex 页面的多版本回放。</p></li></ul><p>如下图所示，在只读节点上的回放进程中，在 Apply 一条 WAL 的 meta 时：</p><figure><img loading=lazy src=/ox-hugo/p524202.png width=800px></figure><ul><li><p>如果对应 Page 不在内存中，仅仅记录 LogIndex。</p></li><li><p>如果对应的 Page 在内存中，则标记为 Outdate，并记录 LogIndex，回放过程完成。</p></li><li><p>用户 session 进程在读取 Page 时，读取正确的 Page 到 BufferPool 中，并通过 LogIndex 来回放相应的
日志。</p></li><li><p>可以看到，主要的 IO 操作由原来的单个回放进程 offload 到了多个用户进程。</p></li></ul><p>通过上述优化，能显著减少回放的延迟，比其他云原生数据库快 30 倍。</p><h3 id=h:2890df00-9e44-4df5-b228-d572ea27eac7>4.4 优化 3：DDL 锁回放优化<a hidden class=anchor aria-hidden=true href=#h:2890df00-9e44-4df5-b228-d572ea27eac7>#</a></h3><p>在主节点执行 DDL 时（例如，drop table），需要在所有节点上都对表上排他锁，这样能保证表文件
不会在只读节点上读取时被主节点删除掉了（因为文件在 Shared-Storage 上只有一份）。在所有只
读节点上对表上排他锁是通过 WAL 复制到所有的只读节点，只读节点回放 DDL 锁来完成。而回放进程
在回放 DDL 锁时，对表上锁可能会阻塞很久，因此可以通过把 DDL 锁 offload 到其他进程上来优化回放
进程的关键路径。</p><figure><img loading=lazy src=/ox-hugo/p524333.png width=800px></figure><p>通过上述优化，能够保证回放进程一直处于平滑的状态，不会因为去等 DDL 而阻塞了回放的关键路径。</p><figure><img loading=lazy src=/ox-hugo/TB1UdKEM6TpK1RjSZKPXXa3UpXa-256-256.png width=-1px></figure><p>上述 3 个优化之后，极大的降低了复制延迟，能够带来如下优势：</p><ul><li><p>读写分离：负载均衡，更接近 Oracle RAC 使用体验。</p></li><li><p>高可用：加速 HA 流程。</p></li><li><p>稳定性：最小化未来页的数量，可以写更少或者无需写页面快照。</p></li></ul><h2 id=h:2eff1fce-d7c0-44bd-82df-bc786a42a946>5 Recovery 优化<a hidden class=anchor aria-hidden=true href=#h:2eff1fce-d7c0-44bd-82df-bc786a42a946>#</a></h2><h3 id=h:45cfaf2c-5ce3-4d89-a739-2684e04f5090>5.1 背景<a hidden class=anchor aria-hidden=true href=#h:45cfaf2c-5ce3-4d89-a739-2684e04f5090>#</a></h3><p>数据库 OOM、Crash 等场景恢复时间长，本质上是日志回放慢，在共享存储 Direct-IO 模型下问题更加
突出。</p><figure><img loading=lazy src=/ox-hugo/p524484.png width=800px></figure><h3 id=h:6a304701-3040-4134-8b94-e94a3b68b24f>5.2 Lazy Recovery<a hidden class=anchor aria-hidden=true href=#h:6a304701-3040-4134-8b94-e94a3b68b24f>#</a></h3><p>上述内容介绍通过 LogIndex 在只读节点上做到了 Lazy 的回放，在主节点重启后的 recovery 过程中，
本质也是在回放日志，因此，可以借助 Lazy 回放来加速 recovery 的过程：</p><figure><img loading=lazy src=/ox-hugo/p524488.png width=800px></figure><ol><li><p>从 checkpoint 点开始逐条去读 WAL 日志。</p></li><li><p>回放完 LogIndex 日志后，即认为回放完成。</p></li><li><p>recovery 完成，开始提供服务。</p></li><li><p>真正的回放被 offload 到了重启之后进来的 session 进程中。</p></li></ol><p>优化之后（回放 500 MB 日志量），如下图所示：</p><figure><img loading=lazy src=/ox-hugo/p524501.png width=769px></figure><h3 id=h:656635f1-34a8-4284-a914-34458659c504>5.3 Persistent BufferPool<a hidden class=anchor aria-hidden=true href=#h:656635f1-34a8-4284-a914-34458659c504>#</a></h3><p>上述方案优化了在 recovery 的重启速度，但是在重启之后，session 进程通过读取 WAL 日志来回放想
要的 page。表示为在 recovery 之后会有短暂的响应慢的问题。优化的办法为在数据库重启时
BufferPool 并不销毁，如下图所示：crash 和 restart 期间 BufferPool 不销毁。</p><figure><img loading=lazy src=/ox-hugo/p524505.png width=800px></figure><p>内核中的共享内存分成 2 部分：</p><ul><li><p>全局结构，ProcArray 等。</p></li><li><p>BufferPool 结构；其中 BufferPool 通过具名共享内存来分配，在进程重启后仍然有效。而全局结
构在进程重启后需要重新初始化。</p><figure><img loading=lazy src=/ox-hugo/p524825.png width=800px></figure></li></ul><p>而 BufferPool 中并不是所有的 Page 都是可以复用的。例如：在重启前，某进程对 Page 上 X 锁，随后
crash 了，该 X 锁就没有进程来释放了。因此，在 crash 和 restart 之后需要把所有的 BufferPool 遍历
一遍，剔除掉不能被复用的 Page。另外，BufferPool 的回收依赖 kubernetes。该优化之后，使得重
启前后性能平稳。</p><figure><img loading=lazy src=/ox-hugo/p524514.png width=800px></figure></div><footer class=post-footer><ul class=post-tags><li><a href=https://yangyingchao.github.io/tags/sharedata/>sharedata</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://yangyingchao.github.io>MyNotes</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>