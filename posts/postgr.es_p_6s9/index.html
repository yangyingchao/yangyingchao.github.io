<!doctype html><html lang=zh-cn dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>cary huang: PostgreSQL’s Planner – Simple Scan Paths vs Plans | MyNotes</title><meta name=keywords content="pg,planner"><meta name=description content="1 Introduction 2 Where it all start 3 What happens behind pg_plan_query 4 set_base_rel_sizes() 5 set_base_rel_pathlist() 6 generate_gather_paths 7 get_cheapest_fractional_path and create_plan 8 Examine the Plan 本文为摘录，原文为： https://postgr.es/p/6s9 1 Introduction 当你向 PostgreSQL 发送查询时，通常会经历查询处理的各个阶段，并在最后返回"><meta name=author content="Yang Yingchao"><link rel=canonical href=https://yangyingchao.github.io/posts/postgr.es_p_6s9/><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://yangyingchao.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://yangyingchao.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://yangyingchao.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://yangyingchao.github.io/apple-touch-icon.png><link rel=mask-icon href=https://yangyingchao.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="cary huang:  PostgreSQL’s Planner – Simple Scan Paths vs Plans"><meta property="og:description" content="1 Introduction 2 Where it all start 3 What happens behind pg_plan_query 4 set_base_rel_sizes() 5 set_base_rel_pathlist() 6 generate_gather_paths 7 get_cheapest_fractional_path and create_plan 8 Examine the Plan 本文为摘录，原文为： https://postgr.es/p/6s9 1 Introduction 当你向 PostgreSQL 发送查询时，通常会经历查询处理的各个阶段，并在最后返回"><meta property="og:type" content="article"><meta property="og:url" content="https://yangyingchao.github.io/posts/postgr.es_p_6s9/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-03-25T00:00:00+00:00"><meta property="article:modified_time" content="2024-03-25T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="cary huang:  PostgreSQL’s Planner – Simple Scan Paths vs Plans"><meta name=twitter:description content="1 Introduction 2 Where it all start 3 What happens behind pg_plan_query 4 set_base_rel_sizes() 5 set_base_rel_pathlist() 6 generate_gather_paths 7 get_cheapest_fractional_path and create_plan 8 Examine the Plan 本文为摘录，原文为： https://postgr.es/p/6s9 1 Introduction 当你向 PostgreSQL 发送查询时，通常会经历查询处理的各个阶段，并在最后返回"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://yangyingchao.github.io/posts/"},{"@type":"ListItem","position":2,"name":"cary huang:  PostgreSQL’s Planner – Simple Scan Paths vs Plans","item":"https://yangyingchao.github.io/posts/postgr.es_p_6s9/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"cary huang:  PostgreSQL’s Planner – Simple Scan Paths vs Plans","name":"cary huang:  PostgreSQL’s Planner – Simple Scan Paths vs Plans","description":"1 Introduction 2 Where it all start 3 What happens behind pg_plan_query 4 set_base_rel_sizes() 5 set_base_rel_pathlist() 6 generate_gather_paths 7 get_cheapest_fractional_path and create_plan 8 Examine the Plan 本文为摘录，原文为： https://postgr.es/p/6s9 1 Introduction 当你向 PostgreSQL 发送查询时，通常会经历查询处理的各个阶段，并在最后返回","keywords":["pg","planner"],"articleBody":" 1 Introduction 2 Where it all start 3 What happens behind pg_plan_query 4 set_base_rel_sizes() 5 set_base_rel_pathlist() 6 generate_gather_paths 7 get_cheapest_fractional_path and create_plan 8 Examine the Plan 本文为摘录，原文为： https://postgr.es/p/6s9\n1 Introduction 当你向 PostgreSQL 发送查询时，通常会经历查询处理的各个阶段，并在最后返回结果。这些阶段被称为：\n解析（Parse） 分析（Analyze） 重写（Rewrite） 规划（Plan） 执行（Execute） 在这篇博客中，我们将只关注“规划”阶段或者“规划器”模块，因为这或许是最有趣或者最复杂的阶段。 我将分享我对规划器模块的理解，探究其内部运作以处理一个简单的顺序扫描。这将基于 PostgreSQL 16。\n虽然规划器的目标非常简单，即从一系列可选路径中识别最快的“路径”，并据此制订一个“方案”， 以便“执行器”模块在下一个阶段执行。然而， 要识别最快的“路径”正是使规划器变得复杂的原因 。\n2 Where it all start 在 postgres.c 中的 exec_simple_query() 函数是查询处理阶段发生的地方。 我们将关注它落在 pg_plan_query() 之后发生了什么。 我只会提到它将会落在的重要函数。\n3 What happens behind pg_plan_query 实际上会发生很多事情，比如：\n标识子查询、分区表、外键表、连接等等\n借助表访问方法估计所有涉及表的大小\n确定完成查询的所有可能路径\n顺序扫描、索引扫描、TID 扫描、并行工作线程等 在所有路径中找到最佳路径，通常是成本最低的\n制定一个执行计划。\n对于单个表的简单 SELECT 查询，不涉及任何连接或子查询，pg_plan_query 下的近似调用栈如下可 视化描述：\n这个甘特图被极大地简化，但展示了规划模块的若干关键要素。如果字太小，你可能需要下载图片以 得到更好的视觉效果。接下来将详细解释带有蓝色星标记的区块。\n4 set_base_rel_sizes() :NOTER_DOCUMENT: https://postgr.es/p/6s9 :NOTER_OPEN: eww :NOTER_PAGE: 2076 :END:\n正如其名称所示，这是用于估算与所有关系（表、视图、索引等）有关的大小的主要入口点。 大小 包括预估的行数（元组）和列数。 这些信息通常必须从“堆访问方法”中获取，其中它将可以访问“缓 冲区管理器”和“存储管理器”以提供大小的估算。\n总大小将是所有涉及表的大小之和。 这对后续的“成本估算”阶段非常重要。\n5 set_base_rel_pathlist() 对于简单表的简单顺序扫描，程序会最终到达这里。其他更复杂的查询将使用不同的路径构建技术。 有关其他路径构建技术，请参考 allpaths.c 中的“set_rel_pathlist()”。\n目前，默认添加了 4 个扫描路径：\n顺序扫描 逐个顺序扫描所有内容\n部分顺序扫描 这是以“部分”添加的，因为它将由“gather”节点聚合，该节点在下一阶段考虑。 这本质上意味着是一个并行顺序扫描\n仅当关系或查询是并行安全时才添加\n索引扫描 如果表有索引，可以考虑作为潜在路径\ntid 扫描 如果查询包含范围限制子句（WHERE ctid \u003e ‘(1,30)’ AND ctid \u003c ‘(30,5)’），则 tid 扫描可能 是一个选项\n所有这些都需要一些成本，这些成本是由元组或页面的数量以及每个元组/页面的成本因素来估算的， 如下配置:\n# - Planner Cost Constants - seq_page_cost = 1.0 # measured on an arbitrary scale random_page_cost = 4.0 # same scale as above cpu_tuple_cost = 0.01 # same scale as above cpu_index_tuple_cost = 0.005 # same scale as above cpu_operator_cost = 0.0025 # same scale as above parallel_setup_cost = 1000.0 # same scale as above parallel_tuple_cost = 0.1 # same scale as above 不同的路径方法具有不同的成本计算，它们会调用以下方法来计算“启动成本”和“运行成本”：\ncost_seqscan() cost_indexscan() cost_tidscan() 你可以在选择最理想路径制定计划时从根本上影响规划者的决策。例如，如果你希望规划者更频繁地 使用并行扫描，你可以考虑降低每个并行扫描元组的成本，通过调小\"parallel_tuple_cost\"，比如 设为 0.001。\n“add_path” 函数被调用以将路径添加到潜在路径列表中，但请记住规划器的路径构建机制确实有一 种排出机制。这意味着如果我们打算添加一条明显优于已添加的其他路径的路径，它可能会删除所有 现有路径并接受新路径。同样，如果要添加的路径明显更差，则根本不会被添加。\n如果规划程序认为并行顺序扫描是安全的，则会调用“add_partial_path”。这种顺序扫描是 “partial”（部分的），因为需要对其进行收集和聚合，以形成最终结果，从而导致额外的成本，因 此并行性可能并不总是理想的。以下是一个经验法则：\n如果 PostgreSQL 需要扫描大量数据，但我们只需要其中的少量数据，则并行性可以帮助 如果 PostgreSQL 需要扫描大量数据，而其中大部分是我们需要的数据，则并行性可能会更慢。 6 generate_gather_paths 如果已经添加了一些部分路径，通常是顺序扫描子路径，则调用此例程。这个例程添加了一个名为 “gather”的新路径类型，其中包含一个名为“顺序扫描”的子路径。gather 路径必须考虑每个子路径的 成本，以及从并行工作程序获取元组和在最终形式中对数据进行聚合的成本。\n7 get_cheapest_fractional_path and create_plan 一旦所有可能的路径候选项都被添加完毕，将调用此函数来选择最便宜的路径，即总成本最低的路径。 然后选择的路径将被输入到“create_plan”中，其中路径（以及子路径（如果有））将会递归地创建， 并制定成执行器能理解和执行的最终计划结构。\n8 Examine the Plan 我们可以在查询之前使用 EXPLAIN ANALYZE 来检查规划器选择的最便宜的计划及其成本细节。以下 示例是一个包含 1 个名为“gather”的主计划及 1 个局部计划“sequential scan”的查询计划，该计划有 2 个 worker。您可以通过箭头（-\u003e）来判断它代表一个子路径。\npostgres=# explain analyze select * from test where a \u003e 500000 and a \u003c600000; QUERY PLAN ------------------------------------------------------------ Gather (cost=1000.00..329718.40 rows=112390 width=36) (actual time=62.362..5106.295 rows=99999 loops=1) Workers Planned: 2 Workers Launched: 2 -\u003e Parallel Seq Scan on test (cost=0.00..317479.40 rows=46829 width=36) (actual time=58.020..3416.544 rows=33333 loops=3) Filter: ((a \u003e 500000) AND (a \u003c 600000)) Rows Removed by Filter: 13300000 Planning Time: 0.489 ms Execution Time: 5110.030 ms (8 rows) 如果规划器选择了顺序扫描主路径而没有选择任何子路径，查询计划会如下所示：\npostgres=# explain analyze select * from test where a \u003e 500000; QUERY PLAN ------------------------------------------------------------ Seq Scan on test (cost=0.00..676994.40 rows=39571047 width=6) (actual time=0.011..7852.896 rows=39500000 loops=1) Filter: (a \u003e 500000) Rows Removed by Filter: 500000 Planning Time: 0.115 ms Execution Time: 9318.773 ms (5 rows) ","wordCount":"2157","inLanguage":"zh-cn","datePublished":"2024-03-25T00:00:00Z","dateModified":"2024-03-25T00:00:00Z","author":[{"@type":"Person","name":"Yang Yingchao"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://yangyingchao.github.io/posts/postgr.es_p_6s9/"},"publisher":{"@type":"Organization","name":"MyNotes","logo":{"@type":"ImageObject","url":"https://yangyingchao.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://yangyingchao.github.io accesskey=h title="MyNotes (Alt + H)">MyNotes</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://yangyingchao.github.io/ title=Home><span>Home</span></a></li><li><a href=https://yangyingchao.github.io/posts/ title=Archives><span>Archives</span></a></li><li><a href=https://yangyingchao.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://yangyingchao.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://yangyingchao.github.io/contact/ title="Contact me"><span>Contact me</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">cary huang: PostgreSQL’s Planner – Simple Scan Paths vs Plans</h1><div class=post-meta><span title='2024-03-25 00:00:00 +0000 UTC'>March 25, 2024</span>&nbsp;·&nbsp;Yang Yingchao</div></header><div class=post-content><ul><li>1 <a href=#introduction>Introduction</a></li><li>2 <a href=#where-it-all-start>Where it all start</a></li><li>3 <a href=#what-happens-behind-pg-plan-query>What happens behind <code>pg_plan_query</code></a></li><li>4 <a href=#set-base-rel-sizes>set_base_rel_sizes()</a></li><li>5 <a href=#set-base-rel-pathlist>set_base_rel_pathlist()</a></li><li>6 <a href=#generate-gather-paths>generate_gather_paths</a></li><li>7 <a href=#get-cheapest-fractional-path-and-create-plan>get_cheapest_fractional_path and create_plan</a></li><li>8 <a href=#examine-the-plan>Examine the Plan</a></li></ul><p>本文为摘录，原文为： <a href=https://postgr.es/p/6s9>https://postgr.es/p/6s9</a></p><h2 id=introduction>1 Introduction<a hidden class=anchor aria-hidden=true href=#introduction>#</a></h2><p>当你向 PostgreSQL 发送查询时，通常会经历查询处理的各个阶段，并在最后返回结果。这些阶段被称为：</p><ul><li>解析（Parse）</li><li>分析（Analyze）</li><li>重写（Rewrite）</li><li>规划（Plan）</li><li>执行（Execute）</li></ul><p>在这篇博客中，我们将只关注“规划”阶段或者“规划器”模块，因为这或许是最有趣或者最复杂的阶段。
我将分享我对规划器模块的理解，探究其内部运作以处理一个简单的顺序扫描。这将基于 PostgreSQL
16。</p><p>虽然规划器的目标非常简单，即从一系列可选路径中识别最快的“路径”，并据此制订一个“方案”，
以便“执行器”模块在下一个阶段执行。然而， <strong>要识别最快的“路径”正是使规划器变得复杂的原因</strong> 。</p><h2 id=where-it-all-start>2 Where it all start<a hidden class=anchor aria-hidden=true href=#where-it-all-start>#</a></h2><p>在 postgres.c 中的 <code>exec_simple_query()</code> 函数是查询处理阶段发生的地方。
我们将关注它落在 <code>pg_plan_query()</code> 之后发生了什么。
我只会提到它将会落在的重要函数。</p><figure><img loading=lazy src=/ox-hugo/highgo-training-Copy-of-Page-12.drawio-1.png width=800px></figure><h2 id=what-happens-behind-pg-plan-query>3 What happens behind <code>pg_plan_query</code><a hidden class=anchor aria-hidden=true href=#what-happens-behind-pg-plan-query>#</a></h2><p>实际上会发生很多事情，比如：</p><ul><li><p>标识子查询、分区表、外键表、连接等等</p></li><li><p>借助表访问方法估计所有涉及表的大小</p></li><li><p>确定完成查询的所有可能路径</p><ul><li>顺序扫描、索引扫描、TID 扫描、并行工作线程等</li></ul></li><li><p>在所有路径中找到最佳路径，通常是成本最低的</p></li><li><p>制定一个执行计划。</p></li></ul><p>对于单个表的简单 SELECT 查询，不涉及任何连接或子查询，pg_plan_query 下的近似调用栈如下可
视化描述：</p><p>这个甘特图被极大地简化，但展示了规划模块的若干关键要素。如果字太小，你可能需要下载图片以
得到更好的视觉效果。接下来将详细解释带有蓝色星标记的区块。</p><figure><img loading=lazy src=/ox-hugo/highgo-training-Page-20.drawio-4.png width=800px></figure><h2 id=set-base-rel-sizes>4 set_base_rel_sizes()<a hidden class=anchor aria-hidden=true href=#set-base-rel-sizes>#</a></h2><p>:NOTER_DOCUMENT: <a href=https://postgr.es/p/6s9>https://postgr.es/p/6s9</a>
:NOTER_OPEN: eww
:NOTER_PAGE: 2076
:END:</p><p>正如其名称所示，这是用于估算与所有关系（表、视图、索引等）有关的大小的主要入口点。 大小
包括预估的行数（元组）和列数。 这些信息通常必须从“堆访问方法”中获取，其中它将可以访问“缓
冲区管理器”和“存储管理器”以提供大小的估算。</p><p>总大小将是所有涉及表的大小之和。 这对后续的“成本估算”阶段非常重要。</p><h2 id=set-base-rel-pathlist>5 set_base_rel_pathlist()<a hidden class=anchor aria-hidden=true href=#set-base-rel-pathlist>#</a></h2><p>对于简单表的简单顺序扫描，程序会最终到达这里。其他更复杂的查询将使用不同的路径构建技术。
有关其他路径构建技术，请参考 allpaths.c 中的“set_rel_pathlist()”。</p><p>目前，默认添加了 4 个扫描路径：</p><ul><li><p>顺序扫描
逐个顺序扫描所有内容</p></li><li><p>部分顺序扫描</p><ul><li><p>这是以“部分”添加的，因为它将由“gather”节点聚合，该节点在下一阶段考虑。
这本质上意味着是一个并行顺序扫描</p></li><li><p>仅当关系或查询是并行安全时才添加</p></li></ul></li><li><p>索引扫描
如果表有索引，可以考虑作为潜在路径</p></li><li><p>tid 扫描
如果查询包含范围限制子句（WHERE ctid > &lsquo;(1,30)&rsquo; AND ctid &lt; &lsquo;(30,5)&rsquo;），则 tid 扫描可能
是一个选项</p></li></ul><p>所有这些都需要一些成本，这些成本是由元组或页面的数量以及每个元组/页面的成本因素来估算的，
如下配置:</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cfg data-lang=cfg><span style=display:flex><span><span style=color:#408080;font-style:italic># - Planner Cost Constants -</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#7d9029>seq_page_cost</span> <span style=color:#666>=</span> <span style=color:#ba2121>1.0                    # measured on an arbitrary scale</span>
</span></span><span style=display:flex><span><span style=color:#7d9029>random_page_cost</span> <span style=color:#666>=</span> <span style=color:#ba2121>4.0                 # same scale as above</span>
</span></span><span style=display:flex><span><span style=color:#7d9029>cpu_tuple_cost</span> <span style=color:#666>=</span> <span style=color:#ba2121>0.01                  # same scale as above</span>
</span></span><span style=display:flex><span><span style=color:#7d9029>cpu_index_tuple_cost</span> <span style=color:#666>=</span> <span style=color:#ba2121>0.005           # same scale as above</span>
</span></span><span style=display:flex><span><span style=color:#7d9029>cpu_operator_cost</span> <span style=color:#666>=</span> <span style=color:#ba2121>0.0025             # same scale as above</span>
</span></span><span style=display:flex><span><span style=color:#7d9029>parallel_setup_cost</span> <span style=color:#666>=</span> <span style=color:#ba2121>1000.0           # same scale as above</span>
</span></span><span style=display:flex><span><span style=color:#7d9029>parallel_tuple_cost</span> <span style=color:#666>=</span> <span style=color:#ba2121>0.1              # same scale as above</span>
</span></span></code></pre></div><p>不同的路径方法具有不同的成本计算，它们会调用以下方法来计算“启动成本”和“运行成本”：</p><ul><li>cost_seqscan()</li><li>cost_indexscan()</li><li>cost_tidscan()</li></ul><p>你可以在选择最理想路径制定计划时从根本上影响规划者的决策。例如，如果你希望规划者更频繁地
使用并行扫描，你可以考虑降低每个并行扫描元组的成本，通过调小"parallel_tuple_cost"，比如
设为 0.001。</p><p>&ldquo;add_path&rdquo; 函数被调用以将路径添加到潜在路径列表中，但请记住规划器的路径构建机制确实有一
种排出机制。这意味着如果我们打算添加一条明显优于已添加的其他路径的路径，它可能会删除所有
现有路径并接受新路径。同样，如果要添加的路径明显更差，则根本不会被添加。</p><p>如果规划程序认为并行顺序扫描是安全的，则会调用“add_partial_path”。这种顺序扫描是
“partial”（部分的），因为需要对其进行收集和聚合，以形成最终结果，从而导致额外的成本，因
此并行性可能并不总是理想的。以下是一个经验法则：</p><ul><li>如果 PostgreSQL 需要扫描大量数据，但我们只需要其中的少量数据，则并行性可以帮助</li><li>如果 PostgreSQL 需要扫描大量数据，而其中大部分是我们需要的数据，则并行性可能会更慢。</li></ul><h2 id=generate-gather-paths>6 generate_gather_paths<a hidden class=anchor aria-hidden=true href=#generate-gather-paths>#</a></h2><p>如果已经添加了一些部分路径，通常是顺序扫描子路径，则调用此例程。这个例程添加了一个名为
“gather”的新路径类型，其中包含一个名为“顺序扫描”的子路径。gather 路径必须考虑每个子路径的
成本，以及从并行工作程序获取元组和在最终形式中对数据进行聚合的成本。</p><h2 id=get-cheapest-fractional-path-and-create-plan>7 get_cheapest_fractional_path and create_plan<a hidden class=anchor aria-hidden=true href=#get-cheapest-fractional-path-and-create-plan>#</a></h2><p>一旦所有可能的路径候选项都被添加完毕，将调用此函数来选择最便宜的路径，即总成本最低的路径。
然后选择的路径将被输入到“create_plan”中，其中路径（以及子路径（如果有））将会递归地创建，
并制定成执行器能理解和执行的最终计划结构。</p><h2 id=examine-the-plan>8 Examine the Plan<a hidden class=anchor aria-hidden=true href=#examine-the-plan>#</a></h2><p>我们可以在查询之前使用 EXPLAIN ANALYZE 来检查规划器选择的最便宜的计划及其成本细节。以下
示例是一个包含 1 个名为“gather”的主计划及 1 个局部计划“sequential scan”的查询计划，该计划有 2
个 worker。您可以通过箭头（->）来判断它代表一个子路径。</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span>postgres<span style=color:#666>=#</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>explain</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>analyze</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>select</span><span style=color:#bbb> </span><span style=color:#666>*</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>from</span><span style=color:#bbb> </span>test<span style=color:#bbb> </span><span style=color:green;font-weight:700>where</span><span style=color:#bbb> </span>a<span style=color:#bbb> </span><span style=color:#666>&gt;</span><span style=color:#bbb> </span><span style=color:#666>500000</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>and</span><span style=color:#bbb> </span>a<span style=color:#bbb> </span><span style=color:#666>&lt;</span><span style=color:#666>600000</span>;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                          </span>QUERY<span style=color:#bbb> </span>PLAN<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#408080;font-style:italic>------------------------------------------------------------
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span><span style=color:#bbb> </span>Gather<span style=color:#bbb>  </span>(cost<span style=color:#666>=</span><span style=color:#666>1000</span>.<span style=color:#666>00</span>..<span style=color:#666>329718</span>.<span style=color:#666>40</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>rows</span><span style=color:#666>=</span><span style=color:#666>112390</span><span style=color:#bbb> </span>width<span style=color:#666>=</span><span style=color:#666>36</span>)<span style=color:#bbb> </span>(actual<span style=color:#bbb> </span>time<span style=color:#666>=</span><span style=color:#666>62</span>.<span style=color:#666>362</span>..<span style=color:#666>5106</span>.<span style=color:#666>295</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>rows</span><span style=color:#666>=</span><span style=color:#666>99999</span><span style=color:#bbb> </span>loops<span style=color:#666>=</span><span style=color:#666>1</span>)<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>   </span>Workers<span style=color:#bbb> </span>Planned:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>   </span>Workers<span style=color:#bbb> </span>Launched:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>   </span><span style=color:#666>-&gt;</span><span style=color:#bbb>  </span>Parallel<span style=color:#bbb> </span>Seq<span style=color:#bbb> </span>Scan<span style=color:#bbb> </span><span style=color:green;font-weight:700>on</span><span style=color:#bbb> </span>test<span style=color:#bbb>  </span>(cost<span style=color:#666>=</span><span style=color:#666>0</span>.<span style=color:#666>00</span>..<span style=color:#666>317479</span>.<span style=color:#666>40</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>rows</span><span style=color:#666>=</span><span style=color:#666>46829</span><span style=color:#bbb> </span>width<span style=color:#666>=</span><span style=color:#666>36</span>)<span style=color:#bbb> </span>(actual<span style=color:#bbb> </span>time<span style=color:#666>=</span><span style=color:#666>58</span>.<span style=color:#666>020</span>..<span style=color:#666>3416</span>.<span style=color:#666>544</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>rows</span><span style=color:#666>=</span><span style=color:#666>33333</span><span style=color:#bbb> </span>loops<span style=color:#666>=</span><span style=color:#666>3</span>)<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>         </span>Filter:<span style=color:#bbb> </span>((a<span style=color:#bbb> </span><span style=color:#666>&gt;</span><span style=color:#bbb> </span><span style=color:#666>500000</span>)<span style=color:#bbb> </span><span style=color:green;font-weight:700>AND</span><span style=color:#bbb> </span>(a<span style=color:#bbb> </span><span style=color:#666>&lt;</span><span style=color:#bbb> </span><span style=color:#666>600000</span>))<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>         </span><span style=color:green;font-weight:700>Rows</span><span style=color:#bbb> </span>Removed<span style=color:#bbb> </span><span style=color:green;font-weight:700>by</span><span style=color:#bbb> </span>Filter:<span style=color:#bbb> </span><span style=color:#666>13300000</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span>Planning<span style=color:#bbb> </span>Time:<span style=color:#bbb> </span><span style=color:#666>0</span>.<span style=color:#666>489</span><span style=color:#bbb> </span>ms<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span>Execution<span style=color:#bbb> </span>Time:<span style=color:#bbb> </span><span style=color:#666>5110</span>.<span style=color:#666>030</span><span style=color:#bbb> </span>ms<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>(<span style=color:#666>8</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>rows</span>)<span style=color:#bbb>
</span></span></span></code></pre></div><p>如果规划器选择了顺序扫描主路径而没有选择任何子路径，查询计划会如下所示：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span>postgres<span style=color:#666>=#</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>explain</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>analyze</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>select</span><span style=color:#bbb> </span><span style=color:#666>*</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>from</span><span style=color:#bbb> </span>test<span style=color:#bbb> </span><span style=color:green;font-weight:700>where</span><span style=color:#bbb> </span>a<span style=color:#bbb> </span><span style=color:#666>&gt;</span><span style=color:#bbb> </span><span style=color:#666>500000</span>;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                          </span>QUERY<span style=color:#bbb> </span>PLAN<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#408080;font-style:italic>------------------------------------------------------------
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span><span style=color:#bbb> </span>Seq<span style=color:#bbb> </span>Scan<span style=color:#bbb> </span><span style=color:green;font-weight:700>on</span><span style=color:#bbb> </span>test<span style=color:#bbb>  </span>(cost<span style=color:#666>=</span><span style=color:#666>0</span>.<span style=color:#666>00</span>..<span style=color:#666>676994</span>.<span style=color:#666>40</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>rows</span><span style=color:#666>=</span><span style=color:#666>39571047</span><span style=color:#bbb> </span>width<span style=color:#666>=</span><span style=color:#666>6</span>)<span style=color:#bbb> </span>(actual<span style=color:#bbb> </span>time<span style=color:#666>=</span><span style=color:#666>0</span>.<span style=color:#666>011</span>..<span style=color:#666>7852</span>.<span style=color:#666>896</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>rows</span><span style=color:#666>=</span><span style=color:#666>39500000</span><span style=color:#bbb> </span>loops<span style=color:#666>=</span><span style=color:#666>1</span>)<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>   </span>Filter:<span style=color:#bbb> </span>(a<span style=color:#bbb> </span><span style=color:#666>&gt;</span><span style=color:#bbb> </span><span style=color:#666>500000</span>)<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>   </span><span style=color:green;font-weight:700>Rows</span><span style=color:#bbb> </span>Removed<span style=color:#bbb> </span><span style=color:green;font-weight:700>by</span><span style=color:#bbb> </span>Filter:<span style=color:#bbb> </span><span style=color:#666>500000</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span>Planning<span style=color:#bbb> </span>Time:<span style=color:#bbb> </span><span style=color:#666>0</span>.<span style=color:#666>115</span><span style=color:#bbb> </span>ms<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span>Execution<span style=color:#bbb> </span>Time:<span style=color:#bbb> </span><span style=color:#666>9318</span>.<span style=color:#666>773</span><span style=color:#bbb> </span>ms<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>(<span style=color:#666>5</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>rows</span>)<span style=color:#bbb>
</span></span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://yangyingchao.github.io/tags/pg/>pg</a></li><li><a href=https://yangyingchao.github.io/tags/planner/>planner</a></li></ul></footer><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//disqus_yH1vi2Slvj.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://yangyingchao.github.io>MyNotes</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>