<!doctype html><html lang=zh-cn><head><title>Stream Control Transmission Protocol (SCTP) · MyNotes</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="yyc"><meta name=description content="1 SCTP Associations 2 Using Multiple Interfaces 3 Streams 4 Association ID 5 Rec & Send 6 CDB with SCTP? 7 SCTP Interface Model 7.1 two types of SCTP sockets 7.2 The One-to-One Style 7.3 The One-to-Many Style 本文为摘录，原文为： https://www.linuxjournal.com/article/9749 1 SCTP Associations 链接到标题 SCTP 的联合 (association) 类似于 TCP 的连接 (connection)"><meta name=keywords content="blog,developer,personal"><meta name=twitter:card content="summary"><meta name=twitter:title content="Stream Control Transmission Protocol (SCTP)"><meta name=twitter:description content="1 SCTP Associations 2 Using Multiple Interfaces 3 Streams 4 Association ID 5 Rec & Send 6 CDB with SCTP? 7 SCTP Interface Model 7.1 two types of SCTP sockets 7.2 The One-to-One Style 7.3 The One-to-Many Style 本文为摘录，原文为： https://www.linuxjournal.com/article/9749 1 SCTP Associations 链接到标题 SCTP 的联合 (association) 类似于 TCP 的连接 (connection)"><meta property="og:title" content="Stream Control Transmission Protocol (SCTP)"><meta property="og:description" content="1 SCTP Associations 2 Using Multiple Interfaces 3 Streams 4 Association ID 5 Rec & Send 6 CDB with SCTP? 7 SCTP Interface Model 7.1 two types of SCTP sockets 7.2 The One-to-One Style 7.3 The One-to-Many Style 本文为摘录，原文为： https://www.linuxjournal.com/article/9749 1 SCTP Associations 链接到标题 SCTP 的联合 (association) 类似于 TCP 的连接 (connection)"><meta property="og:type" content="article"><meta property="og:url" content="https://yangyingchao.github.io/posts/sctp/"><meta property="article:section" content="posts"><link rel=canonical href=https://yangyingchao.github.io/posts/sctp/><link rel=preload href="/fonts/forkawesome-webfont.woff2?v=1.2.0" as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.135e22c97ff685fe983fc60048e309ced8f00d8d38f536aa67dba8a13a03dfa4.css integrity="sha256-E14iyX/2hf6YP8YASOMJztjwDY049TaqZ9uooToD36Q=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.a00e6364bacbc8266ad1cc81230774a1397198f8cfb7bcba29b7d6fcb54ce57f.css integrity="sha256-oA5jZLrLyCZq0cyBIwd0oTlxmPjPt7y6KbfW/LVM5X8=" crossorigin=anonymous media=screen><link rel=icon type=image/svg+xml href=/images/favicon.svg sizes=any><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5></head><body class="preload-transitions colorscheme-auto"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=/>MyNotes</a>
<input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/posts/>Blog</a></li><li class=navigation-item><a class=navigation-link href=/tags/>Tags</a></li><li class=navigation-item><a class=navigation-link href=/contact/>Contact me</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://yangyingchao.github.io/posts/sctp/>Stream Control Transmission Protocol (SCTP)</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa fa-calendar" aria-hidden=true></i>
<time datetime=0001-01-01T00:00:00Z>January 1, 0001</time></span>
<span class=reading-time><i class="fa fa-clock-o" aria-hidden=true></i>
阅读时间：3 分钟</span></div><div class=tags><i class="fa fa-tag" aria-hidden=true></i>
<span class=tag><a href=/tags/network/>network</a></span>
<span class=separator>•</span>
<span class=tag><a href=/tags/protocol/>protocol</a></span>
<span class=separator>•</span>
<span class=tag><a href=/tags/sctp/>sctp</a></span></div></div></header><div class=post-content><ul><li>1 <a href=#h:2815bca8-e6bb-4b22-93b8-52266d83331a>SCTP Associations</a></li><li>2 <a href=#h:a7d3a58f-21fb-4e4e-b3d1-1de8bf5291e3>Using Multiple Interfaces</a></li><li>3 <a href=#h:bbf694f6-56f7-4d97-8334-74bfe30fd53d>Streams</a></li><li>4 <a href=#h:276f19c3-3843-4d1b-a1ee-3dfd0126996c>Association ID</a></li><li>5 <a href=#h:ae3adb64-a1ab-4352-aa2a-8b58a81d1bf4>Rec & Send</a></li><li>6 <a href=#h:d0a6f1bd-1d91-4b94-b5cd-f70950fb9e9f>CDB with SCTP?</a></li><li>7 <a href=#h:fa817dc8-9b69-4412-8a1c-54067ac156b4>SCTP Interface Model</a><ul><li>7.1 <a href=#h:79c523c0-858f-44d3-a13a-8ffb6cd217ac>two types of SCTP sockets</a></li><li>7.2 <a href=#h:af8a22bd-336b-47ac-a22b-ba2a592aa426>The One-to-One Style</a></li><li>7.3 <a href=#h:400f90d1-fb4b-4e76-ae90-8feff25e9124>The One-to-Many Style</a></li></ul></li></ul><p>本文为摘录，原文为： <a href=https://www.linuxjournal.com/article/9749 class=external-link target=_blank rel=noopener>https://www.linuxjournal.com/article/9749</a></p><h2 id=h:2815bca8-e6bb-4b22-93b8-52266d83331a>1 SCTP Associations
<a class=heading-link href=#h:2815bca8-e6bb-4b22-93b8-52266d83331a><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h2><p>SCTP 的联合 (association) 类似于 TCP 的连接 (connection) ， 但又有不同：</p><ul><li>TCP connection 在服务端和客户端之间的网络接口上建立的 <strong>一对一</strong> 连接</li><li>SCTP association 是 <strong>多对多</strong> ：<ul><li>可以在服务端的多个网口和客户端的多个网口之间建立联合
例如，服务端和客户端各自有两个设备： Ethernet & Wi-Fi , 则服务端和客户端之
间的联合可以包括 4 路：<ul><li>Eth -> Eth</li><li>Eth -> Wi-Fi</li><li>Wi-Fi -> Eth</li><li>Wi-Fi -> Wi-Fi</li></ul></li></ul></li></ul><ul><li>一个联合中又可以有多个 stream ， 各个 stream 之间互不干扰，不会阻塞
stream 用 stream id 来区分，从 0 开始增加</li></ul><ul><li>每个 socket 可以用来服务多个联合
也就是说，每个 scoket 可以用来同多个主机通讯。 每个 association 用
association id 来区分。</li></ul><h2 id=h:a7d3a58f-21fb-4e4e-b3d1-1de8bf5291e3>2 Using Multiple Interfaces
<a class=heading-link href=#h:a7d3a58f-21fb-4e4e-b3d1-1de8bf5291e3><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h2><ul><li>服务端可以通过 <code>sctp_bindx()</code> 来绑定多个接口</li><li>客户端可以通过 <code>sctp_connectx()</code> 来使用多个地址</li><li>客户端可以通过 <code>sctp_getpaddrs()</code> 来获取远端地址</li><li>客户端可以通过 <code>sctp_getladdrs()</code> 来获取本地地址</li></ul><p>Once an association is set up between two endpoints, messages can be sent between them. Note that SCTP does not concern
itself with QoS (Quality-of-Service) issues, such as real-time delivery, but only with reliability issues. SCTP uses the
multihomed capabilities to try as many possible routes as possible to get messages through. So on the sending side,
there is no control over which interfaces are used; indeed, the sender might even use a scheme such as round-robin among
its interfaces for each message. However, the sending application can indicate to its SCTP stack which of the remote
peer&rsquo;s interface it would prefer to use, and it can tell the remote peer on which interfaces it would prefer to receive
messages. These are done by using the setsockopt() call with option type as SCTP_PRIMARY_ADDR or
SCTP_SET_PEER_PRIMARY_ADDR. Of course, if these particular addresses are not available, SCTP simply will use different
addresses in the association.</p><p>Once SCTP is told which interfaces to use, it basically looks after things itself. It uses heartbeats to keep track of
which interfaces are alive, and it switches interfaces transparently when failure occurs. This is to satisfy the design
goals of SCTP for improved reliability over TCP. Applications can give hints to the SCTP stack about which interfaces to
use, but the stack will ignore these hints on failure.</p><h2 id=h:bbf694f6-56f7-4d97-8334-74bfe30fd53d>3 Streams
<a class=heading-link href=#h:bbf694f6-56f7-4d97-8334-74bfe30fd53d><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h2><p>Negotiating the Number of Streams</p><p>Each endpoint of an association will support a certain number of streams. A Linux endpoint, by default, will expect to
be able to send to ten streams, while it can receive on 65,535 streams. Other SCTP stacks may have different default
values. These values can be changed by setting the socket option SCTP_INITMSG, which takes a structure sctp_initmsg:</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>struct</span> sctp_initmsg {
</span></span><span style=display:flex><span>    <span style=color:#b00040>uint16_t</span> sinit_num_ostreams;
</span></span><span style=display:flex><span>    <span style=color:#b00040>uint16_t</span> sinit_max_ostreams;
</span></span><span style=display:flex><span>    <span style=color:#b00040>uint16_t</span> sinit_max_attempts;
</span></span><span style=display:flex><span>    <span style=color:#b00040>uint16_t</span> sinit_max_init_timeo;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>If this socket option is used to set values, it must be done <strong>before</strong> an
association is made. The parameters will be sent to the peer endpoint during
association initialisation.</p><h2 id=h:276f19c3-3843-4d1b-a1ee-3dfd0126996c>4 Association ID
<a class=heading-link href=#h:276f19c3-3843-4d1b-a1ee-3dfd0126996c><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h2><p>There can be many associations active at any one time—a peer can be connected
to many other peers simultaneously. This is different from TCP where only one
connection on a socket can exist and also is different from UDP where no
connections exist and messages are just sent to arbitrary peers.</p><p>When there can be many associations, you need to be able to distinguish
between them. This is done by an opaque data type called an association ID.
You need to use this sometimes, but not every time.</p><ul><li><p>one-to-one sockets:</p><ul><li>仅用一个联合， Association ID 可以忽略</li><li>created a one-to-one socket:<div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>sockfd <span style=color:#666>=</span> socket(AF_INET, SOCK_STREAM, IPPROTO_SCTP)
</span></span></code></pre></div></li></ul></li><li><p>one-to-many sockets:</p><ul><li>当可以通过目的端地址来标识 Association 时， ID 可以忽略</li><li>其余时候需要使用 ID</li><li>create one-to-many socket:<div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>sockfd <span style=color:#666>=</span> <span style=color:#00f>socket</span>(AF_INET, SOCK_SEQPACKET, IPPROTO_SCTP)
</span></span></code></pre></div></li><li>ID 的获取：<div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>sctp_assoc_t <span style=color:#00f>get_associd</span>(<span style=color:#b00040>int</span> sockfd, <span style=color:green;font-weight:700>struct</span> <span style=color:#00f;font-weight:700>sockaddr</span> <span style=color:#666>*</span>sa, socklen_t salen) {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>struct</span> <span style=color:#00f;font-weight:700>sctp_paddrinfo</span> sp;
</span></span><span style=display:flex><span>    <span style=color:#b00040>int</span> sz;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    sz <span style=color:#666>=</span> <span style=color:green;font-weight:700>sizeof</span>(<span style=color:green;font-weight:700>struct</span> <span style=color:#00f;font-weight:700>sctp_paddrinfo</span>);
</span></span><span style=display:flex><span>    bzero(<span style=color:#666>&amp;</span>sp, sz);
</span></span><span style=display:flex><span>    memcpy(<span style=color:#666>&amp;</span>sp.spinfo_address, sa, salen);
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>if</span> (sctp_opt_info(sockfd, <span style=color:#666>0</span>, SCTP_GET_PEER_ADDR_INFO, <span style=color:#666>&amp;</span>sp, <span style=color:#666>&amp;</span>sz) <span style=color:#666>==</span> <span style=color:#666>-</span><span style=color:#666>1</span>)
</span></span><span style=display:flex><span>        perror(<span style=color:#ba2121>&#34;get assoc&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>return</span> (sp.spinfo_assoc_id);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul></li></ul><p>There is no way to specify from which stream to read. This is deliberate; the
intention is that when data is ready on any stream, then you read
it. Otherwise, data could be blocked on a stream with no one to read it, which
eventually could fill up system buffers. So, you can&rsquo;t restrict reading to any
particular stream. But, once a read is done, you can tell which stream it has
come from by using the mechanism above.</p><p>Typically, a server that reads and handles a message will have (pseudocode) that looks like this:</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>while</span> (<span style=color:green>true</span>) {
</span></span><span style=display:flex><span>    nread <span style=color:#666>=</span> <span style=color:#00f>sctp_recvmsg</span>(..., msg, ..., <span style=color:#666>&amp;</span>sinfo, ...)
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>if</span> (nread <span style=color:#666>&lt;=</span> <span style=color:#666>0</span>) <span style=color:green;font-weight:700>break</span>;
</span></span><span style=display:flex><span>    assoc_id <span style=color:#666>=</span> sinfo.sinfo_assoc_id;
</span></span><span style=display:flex><span>    stream <span style=color:#666>=</span> sinfo.sinfo_stream;
</span></span><span style=display:flex><span>    <span style=color:#00f>handle_mesg</span>(assoc_id, stream, msg, nread);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This is a single-threaded read loop. It ensures that information is read, no matter what association or stream it is
sent on. The application function handle_mesg() can, of course, dispatch the message to different threads if it wants.
Writes, on the other hand can be sent from multiple threads if desired.</p><h2 id=h:ae3adb64-a1ab-4352-aa2a-8b58a81d1bf4>5 Rec & Send
<a class=heading-link href=#h:ae3adb64-a1ab-4352-aa2a-8b58a81d1bf4><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h2><p>When it comes to sending messages back to all the connected clients, SCTP
makes it even easier—the flag <code>SCTP_SENDALL</code> that can can be set in the
<code>sctp_sndrcvinfo</code> field of <code>sctp_send()</code>. So a server simply needs to read a
message from any client, set the SCTP_SENDALL bit and write it back out. The
SCTP stack then will send it to all live peers! There are only a few lines of</p><h2 id=h:d0a6f1bd-1d91-4b94-b5cd-f70950fb9e9f>6 CDB with SCTP?
<a class=heading-link href=#h:d0a6f1bd-1d91-4b94-b5cd-f70950fb9e9f><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h2><ul><li>发送端<ul><li>可使用 一个 socket ， 对多个 server 创建 associations</li><li>多线程并行发送</li></ul></li><li>接收端<ul><li>一个 socket ， 类似 UDP 接收</li><li>单线程接收，分拣</li><li>回发数据？？</li></ul></li></ul><h2 id=h:fa817dc8-9b69-4412-8a1c-54067ac156b4>7 SCTP Interface Model
<a class=heading-link href=#h:fa817dc8-9b69-4412-8a1c-54067ac156b4><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h2><p><a href=https://www.masterraghu.com/subjects/np/introduction/unix_network_programming_v1.3/ch09.html class=external-link target=_blank rel=noopener>https://www.masterraghu.com/subjects/np/introduction/unix_network_programming_v1.3/ch09.html</a></p><h3 id=h:79c523c0-858f-44d3-a13a-8ffb6cd217ac>7.1 two types of SCTP sockets
<a class=heading-link href=#h:79c523c0-858f-44d3-a13a-8ffb6cd217ac><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h3><h3 id=h:af8a22bd-336b-47ac-a22b-ba2a592aa426>7.2 The One-to-One Style
<a class=heading-link href=#h:af8a22bd-336b-47ac-a22b-ba2a592aa426><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h3><p>便于移植基于 TCP 协议的程序。</p><p></p><figure><img src=/ox-hugo/screenshot@2022-06-21_17:11:51.png width=800px></figure><h3 id=h:400f90d1-fb4b-4e76-ae90-8feff25e9124>7.3 The One-to-Many Style
<a class=heading-link href=#h:400f90d1-fb4b-4e76-ae90-8feff25e9124><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h3><p>一对多模式可以减少 server 所使用的 socket 数量：可以使用一个 socket 来建立多个
联合。 联合通过 <code>association id</code> 来标识。 该 ID 由内核指定，对用户透明。</p><p>使用该模式需要注意：</p><ul><li><p>当客户端关闭联合之后， server 端自动关闭，并将相关的状态从内核中移除。</p></li><li><p>使用 one-to-many 方式，可以在四次握手的第三个或者第四个包即开始发送数据。</p></li><li><p>使用 <code>sendto/sendmsg/sctp_sendmsg</code> 发送数据时候，如果联合不存在，会自动创建。</p></li><li><p>必须使用 <code>sendto/sctp_sendmsg</code> 来发送数据，而不能使用 <code>send/write</code></p></li><li><p>发送数据时，总是使用主目的地址 （建立联合时候系统选定的地址）。可以通过设置
flag <code>MSG_ADDR_OVER</code> 来强制使用其他地址。 该 flag 可以在 <code>sctp_sendmsg()</code> 中
通过 <code>sctp_sndrcvinfo</code> 来设置。</p></li><li><p>事件通知可以通过 <code>SCTP_EVENTS</code> 来控制。</p><p></p><figure><img src=/ox-hugo/screenshot@2022-06-21_17:33:56.png></figure></li></ul></div><footer></footer></article></section></div><footer class=footer><section class=container>©
2023
yyc
·
技术支持 <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/ target=_blank rel=noopener>Coder</a>.</section></footer></main><script src=/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script></body></html>