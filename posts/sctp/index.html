<!doctype html><html lang=zh-cn dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Stream Control Transmission Protocol (SCTP) | MyNotes</title><meta name=keywords content="network,protocol,sctp"><meta name=description content="1 SCTP Associations 2 Using Multiple Interfaces 3 Streams 4 Association ID 5 Rec & Send 6 CDB with SCTP? 7 SCTP Interface Model 7.1 two types of SCTP sockets 7.2 The One-to-One Style 7.3 The One-to-Many Style 本文为摘录，原文为： https://www.linuxjournal.com/article/9749 1 SCTP Associations SCTP 的联合 (association) 类似于 TCP 的连接 (connection) ， 但又有不"><meta name=author content><link rel=canonical href=https://yangyingchao.github.io/posts/sctp/><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://yangyingchao.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://yangyingchao.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://yangyingchao.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://yangyingchao.github.io/apple-touch-icon.png><link rel=mask-icon href=https://yangyingchao.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Stream Control Transmission Protocol (SCTP)"><meta property="og:description" content="1 SCTP Associations 2 Using Multiple Interfaces 3 Streams 4 Association ID 5 Rec & Send 6 CDB with SCTP? 7 SCTP Interface Model 7.1 two types of SCTP sockets 7.2 The One-to-One Style 7.3 The One-to-Many Style 本文为摘录，原文为： https://www.linuxjournal.com/article/9749 1 SCTP Associations SCTP 的联合 (association) 类似于 TCP 的连接 (connection) ， 但又有不"><meta property="og:type" content="article"><meta property="og:url" content="https://yangyingchao.github.io/posts/sctp/"><meta property="article:section" content="posts"><meta name=twitter:card content="summary"><meta name=twitter:title content="Stream Control Transmission Protocol (SCTP)"><meta name=twitter:description content="1 SCTP Associations 2 Using Multiple Interfaces 3 Streams 4 Association ID 5 Rec & Send 6 CDB with SCTP? 7 SCTP Interface Model 7.1 two types of SCTP sockets 7.2 The One-to-One Style 7.3 The One-to-Many Style 本文为摘录，原文为： https://www.linuxjournal.com/article/9749 1 SCTP Associations SCTP 的联合 (association) 类似于 TCP 的连接 (connection) ， 但又有不"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://yangyingchao.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Stream Control Transmission Protocol (SCTP)","item":"https://yangyingchao.github.io/posts/sctp/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Stream Control Transmission Protocol (SCTP)","name":"Stream Control Transmission Protocol (SCTP)","description":"1 SCTP Associations 2 Using Multiple Interfaces 3 Streams 4 Association ID 5 Rec \u0026amp; Send 6 CDB with SCTP? 7 SCTP Interface Model 7.1 two types of SCTP sockets 7.2 The One-to-One Style 7.3 The One-to-Many Style 本文为摘录，原文为： https://www.linuxjournal.com/article/9749 1 SCTP Associations SCTP 的联合 (association) 类似于 TCP 的连接 (connection) ， 但又有不","keywords":["network","protocol","sctp"],"articleBody":" 1 SCTP Associations 2 Using Multiple Interfaces 3 Streams 4 Association ID 5 Rec \u0026 Send 6 CDB with SCTP? 7 SCTP Interface Model 7.1 two types of SCTP sockets 7.2 The One-to-One Style 7.3 The One-to-Many Style 本文为摘录，原文为： https://www.linuxjournal.com/article/9749\n1 SCTP Associations SCTP 的联合 (association) 类似于 TCP 的连接 (connection) ， 但又有不同：\nTCP connection 在服务端和客户端之间的网络接口上建立的 一对一 连接 SCTP association 是 多对多 ： 可以在服务端的多个网口和客户端的多个网口之间建立联合 例如，服务端和客户端各自有两个设备： Ethernet \u0026 Wi-Fi , 则服务端和客户端之 间的联合可以包括 4 路： Eth -\u003e Eth Eth -\u003e Wi-Fi Wi-Fi -\u003e Eth Wi-Fi -\u003e Wi-Fi 一个联合中又可以有多个 stream ， 各个 stream 之间互不干扰，不会阻塞 stream 用 stream id 来区分，从 0 开始增加 每个 socket 可以用来服务多个联合 也就是说，每个 scoket 可以用来同多个主机通讯。 每个 association 用 association id 来区分。 2 Using Multiple Interfaces 服务端可以通过 sctp_bindx() 来绑定多个接口 客户端可以通过 sctp_connectx() 来使用多个地址 客户端可以通过 sctp_getpaddrs() 来获取远端地址 客户端可以通过 sctp_getladdrs() 来获取本地地址 Once an association is set up between two endpoints, messages can be sent between them. Note that SCTP does not concern itself with QoS (Quality-of-Service) issues, such as real-time delivery, but only with reliability issues. SCTP uses the multihomed capabilities to try as many possible routes as possible to get messages through. So on the sending side, there is no control over which interfaces are used; indeed, the sender might even use a scheme such as round-robin among its interfaces for each message. However, the sending application can indicate to its SCTP stack which of the remote peer’s interface it would prefer to use, and it can tell the remote peer on which interfaces it would prefer to receive messages. These are done by using the setsockopt() call with option type as SCTP_PRIMARY_ADDR or SCTP_SET_PEER_PRIMARY_ADDR. Of course, if these particular addresses are not available, SCTP simply will use different addresses in the association.\nOnce SCTP is told which interfaces to use, it basically looks after things itself. It uses heartbeats to keep track of which interfaces are alive, and it switches interfaces transparently when failure occurs. This is to satisfy the design goals of SCTP for improved reliability over TCP. Applications can give hints to the SCTP stack about which interfaces to use, but the stack will ignore these hints on failure.\n3 Streams Negotiating the Number of Streams\nEach endpoint of an association will support a certain number of streams. A Linux endpoint, by default, will expect to be able to send to ten streams, while it can receive on 65,535 streams. Other SCTP stacks may have different default values. These values can be changed by setting the socket option SCTP_INITMSG, which takes a structure sctp_initmsg:\nstruct sctp_initmsg { uint16_t sinit_num_ostreams; uint16_t sinit_max_ostreams; uint16_t sinit_max_attempts; uint16_t sinit_max_init_timeo; } If this socket option is used to set values, it must be done before an association is made. The parameters will be sent to the peer endpoint during association initialisation.\n4 Association ID There can be many associations active at any one time—a peer can be connected to many other peers simultaneously. This is different from TCP where only one connection on a socket can exist and also is different from UDP where no connections exist and messages are just sent to arbitrary peers.\nWhen there can be many associations, you need to be able to distinguish between them. This is done by an opaque data type called an association ID. You need to use this sometimes, but not every time.\none-to-one sockets: 仅用一个联合， Association ID 可以忽略 created a one-to-one socket: sockfd = socket(AF_INET, SOCK_STREAM, IPPROTO_SCTP) one-to-many sockets: 当可以通过目的端地址来标识 Association 时， ID 可以忽略 其余时候需要使用 ID create one-to-many socket: sockfd = socket(AF_INET, SOCK_SEQPACKET, IPPROTO_SCTP) ID 的获取： sctp_assoc_t get_associd(int sockfd, struct sockaddr *sa, socklen_t salen) { struct sctp_paddrinfo sp; int sz; sz = sizeof(struct sctp_paddrinfo); bzero(\u0026sp, sz); memcpy(\u0026sp.spinfo_address, sa, salen); if (sctp_opt_info(sockfd, 0, SCTP_GET_PEER_ADDR_INFO, \u0026sp, \u0026sz) == -1) perror(\"get assoc\"); return (sp.spinfo_assoc_id); } There is no way to specify from which stream to read. This is deliberate; the intention is that when data is ready on any stream, then you read it. Otherwise, data could be blocked on a stream with no one to read it, which eventually could fill up system buffers. So, you can’t restrict reading to any particular stream. But, once a read is done, you can tell which stream it has come from by using the mechanism above.\nTypically, a server that reads and handles a message will have (pseudocode) that looks like this:\nwhile (true) { nread = sctp_recvmsg(..., msg, ..., \u0026sinfo, ...) if (nread \u003c= 0) break; assoc_id = sinfo.sinfo_assoc_id; stream = sinfo.sinfo_stream; handle_mesg(assoc_id, stream, msg, nread); } This is a single-threaded read loop. It ensures that information is read, no matter what association or stream it is sent on. The application function handle_mesg() can, of course, dispatch the message to different threads if it wants. Writes, on the other hand can be sent from multiple threads if desired.\n5 Rec \u0026 Send When it comes to sending messages back to all the connected clients, SCTP makes it even easier—the flag SCTP_SENDALL that can can be set in the sctp_sndrcvinfo field of sctp_send(). So a server simply needs to read a message from any client, set the SCTP_SENDALL bit and write it back out. The SCTP stack then will send it to all live peers! There are only a few lines of\n6 CDB with SCTP? 发送端 可使用 一个 socket ， 对多个 server 创建 associations 多线程并行发送 接收端 一个 socket ， 类似 UDP 接收 单线程接收，分拣 回发数据？？ 7 SCTP Interface Model https://www.masterraghu.com/subjects/np/introduction/unix_network_programming_v1.3/ch09.html\n7.1 two types of SCTP sockets 7.2 The One-to-One Style 便于移植基于 TCP 协议的程序。\n7.3 The One-to-Many Style 一对多模式可以减少 server 所使用的 socket 数量：可以使用一个 socket 来建立多个 联合。 联合通过 association id 来标识。 该 ID 由内核指定，对用户透明。\n使用该模式需要注意：\n当客户端关闭联合之后， server 端自动关闭，并将相关的状态从内核中移除。\n使用 one-to-many 方式，可以在四次握手的第三个或者第四个包即开始发送数据。\n使用 sendto/sendmsg/sctp_sendmsg 发送数据时候，如果联合不存在，会自动创建。\n必须使用 sendto/sctp_sendmsg 来发送数据，而不能使用 send/write\n发送数据时，总是使用主目的地址 （建立联合时候系统选定的地址）。可以通过设置 flag MSG_ADDR_OVER 来强制使用其他地址。 该 flag 可以在 sctp_sendmsg() 中 通过 sctp_sndrcvinfo 来设置。\n事件通知可以通过 SCTP_EVENTS 来控制。\n","wordCount":"1450","inLanguage":"zh-cn","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://yangyingchao.github.io/posts/sctp/"},"publisher":{"@type":"Organization","name":"MyNotes","logo":{"@type":"ImageObject","url":"https://yangyingchao.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://yangyingchao.github.io accesskey=h title="MyNotes (Alt + H)">MyNotes</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://yangyingchao.github.io/ title=Home><span>Home</span></a></li><li><a href=https://yangyingchao.github.io/posts/ title=Archives><span>Archives</span></a></li><li><a href=https://yangyingchao.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://yangyingchao.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://yangyingchao.github.io/contact/ title="Contact me"><span>Contact me</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Stream Control Transmission Protocol (SCTP)</h1><div class=post-meta></div></header><div class=post-content><ul><li>1 <a href=#h:2815bca8-e6bb-4b22-93b8-52266d83331a>SCTP Associations</a></li><li>2 <a href=#h:a7d3a58f-21fb-4e4e-b3d1-1de8bf5291e3>Using Multiple Interfaces</a></li><li>3 <a href=#h:bbf694f6-56f7-4d97-8334-74bfe30fd53d>Streams</a></li><li>4 <a href=#h:276f19c3-3843-4d1b-a1ee-3dfd0126996c>Association ID</a></li><li>5 <a href=#h:ae3adb64-a1ab-4352-aa2a-8b58a81d1bf4>Rec & Send</a></li><li>6 <a href=#h:d0a6f1bd-1d91-4b94-b5cd-f70950fb9e9f>CDB with SCTP?</a></li><li>7 <a href=#h:fa817dc8-9b69-4412-8a1c-54067ac156b4>SCTP Interface Model</a><ul><li>7.1 <a href=#h:79c523c0-858f-44d3-a13a-8ffb6cd217ac>two types of SCTP sockets</a></li><li>7.2 <a href=#h:af8a22bd-336b-47ac-a22b-ba2a592aa426>The One-to-One Style</a></li><li>7.3 <a href=#h:400f90d1-fb4b-4e76-ae90-8feff25e9124>The One-to-Many Style</a></li></ul></li></ul><p>本文为摘录，原文为： <a href=https://www.linuxjournal.com/article/9749>https://www.linuxjournal.com/article/9749</a></p><h2 id=h:2815bca8-e6bb-4b22-93b8-52266d83331a>1 SCTP Associations<a hidden class=anchor aria-hidden=true href=#h:2815bca8-e6bb-4b22-93b8-52266d83331a>#</a></h2><p>SCTP 的联合 (association) 类似于 TCP 的连接 (connection) ， 但又有不同：</p><ul><li>TCP connection 在服务端和客户端之间的网络接口上建立的 <strong>一对一</strong> 连接</li><li>SCTP association 是 <strong>多对多</strong> ：<ul><li>可以在服务端的多个网口和客户端的多个网口之间建立联合
例如，服务端和客户端各自有两个设备： Ethernet & Wi-Fi , 则服务端和客户端之
间的联合可以包括 4 路：<ul><li>Eth -> Eth</li><li>Eth -> Wi-Fi</li><li>Wi-Fi -> Eth</li><li>Wi-Fi -> Wi-Fi</li></ul></li></ul></li></ul><ul><li>一个联合中又可以有多个 stream ， 各个 stream 之间互不干扰，不会阻塞
stream 用 stream id 来区分，从 0 开始增加</li></ul><ul><li>每个 socket 可以用来服务多个联合
也就是说，每个 scoket 可以用来同多个主机通讯。 每个 association 用
association id 来区分。</li></ul><h2 id=h:a7d3a58f-21fb-4e4e-b3d1-1de8bf5291e3>2 Using Multiple Interfaces<a hidden class=anchor aria-hidden=true href=#h:a7d3a58f-21fb-4e4e-b3d1-1de8bf5291e3>#</a></h2><ul><li>服务端可以通过 <code>sctp_bindx()</code> 来绑定多个接口</li><li>客户端可以通过 <code>sctp_connectx()</code> 来使用多个地址</li><li>客户端可以通过 <code>sctp_getpaddrs()</code> 来获取远端地址</li><li>客户端可以通过 <code>sctp_getladdrs()</code> 来获取本地地址</li></ul><p>Once an association is set up between two endpoints, messages can be sent between them. Note that SCTP does not concern
itself with QoS (Quality-of-Service) issues, such as real-time delivery, but only with reliability issues. SCTP uses the
multihomed capabilities to try as many possible routes as possible to get messages through. So on the sending side,
there is no control over which interfaces are used; indeed, the sender might even use a scheme such as round-robin among
its interfaces for each message. However, the sending application can indicate to its SCTP stack which of the remote
peer&rsquo;s interface it would prefer to use, and it can tell the remote peer on which interfaces it would prefer to receive
messages. These are done by using the setsockopt() call with option type as SCTP_PRIMARY_ADDR or
SCTP_SET_PEER_PRIMARY_ADDR. Of course, if these particular addresses are not available, SCTP simply will use different
addresses in the association.</p><p>Once SCTP is told which interfaces to use, it basically looks after things itself. It uses heartbeats to keep track of
which interfaces are alive, and it switches interfaces transparently when failure occurs. This is to satisfy the design
goals of SCTP for improved reliability over TCP. Applications can give hints to the SCTP stack about which interfaces to
use, but the stack will ignore these hints on failure.</p><h2 id=h:bbf694f6-56f7-4d97-8334-74bfe30fd53d>3 Streams<a hidden class=anchor aria-hidden=true href=#h:bbf694f6-56f7-4d97-8334-74bfe30fd53d>#</a></h2><p>Negotiating the Number of Streams</p><p>Each endpoint of an association will support a certain number of streams. A Linux endpoint, by default, will expect to
be able to send to ten streams, while it can receive on 65,535 streams. Other SCTP stacks may have different default
values. These values can be changed by setting the socket option SCTP_INITMSG, which takes a structure sctp_initmsg:</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>struct</span> sctp_initmsg {
</span></span><span style=display:flex><span>    <span style=color:#b00040>uint16_t</span> sinit_num_ostreams;
</span></span><span style=display:flex><span>    <span style=color:#b00040>uint16_t</span> sinit_max_ostreams;
</span></span><span style=display:flex><span>    <span style=color:#b00040>uint16_t</span> sinit_max_attempts;
</span></span><span style=display:flex><span>    <span style=color:#b00040>uint16_t</span> sinit_max_init_timeo;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>If this socket option is used to set values, it must be done <strong>before</strong> an
association is made. The parameters will be sent to the peer endpoint during
association initialisation.</p><h2 id=h:276f19c3-3843-4d1b-a1ee-3dfd0126996c>4 Association ID<a hidden class=anchor aria-hidden=true href=#h:276f19c3-3843-4d1b-a1ee-3dfd0126996c>#</a></h2><p>There can be many associations active at any one time—a peer can be connected
to many other peers simultaneously. This is different from TCP where only one
connection on a socket can exist and also is different from UDP where no
connections exist and messages are just sent to arbitrary peers.</p><p>When there can be many associations, you need to be able to distinguish
between them. This is done by an opaque data type called an association ID.
You need to use this sometimes, but not every time.</p><ul><li><p>one-to-one sockets:</p><ul><li>仅用一个联合， Association ID 可以忽略</li><li>created a one-to-one socket:<div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>sockfd <span style=color:#666>=</span> socket(AF_INET, SOCK_STREAM, IPPROTO_SCTP)
</span></span></code></pre></div></li></ul></li><li><p>one-to-many sockets:</p><ul><li>当可以通过目的端地址来标识 Association 时， ID 可以忽略</li><li>其余时候需要使用 ID</li><li>create one-to-many socket:<div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>sockfd <span style=color:#666>=</span> <span style=color:#00f>socket</span>(AF_INET, SOCK_SEQPACKET, IPPROTO_SCTP)
</span></span></code></pre></div></li><li>ID 的获取：<div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>sctp_assoc_t <span style=color:#00f>get_associd</span>(<span style=color:#b00040>int</span> sockfd, <span style=color:green;font-weight:700>struct</span> <span style=color:#00f;font-weight:700>sockaddr</span> <span style=color:#666>*</span>sa, socklen_t salen) {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>struct</span> <span style=color:#00f;font-weight:700>sctp_paddrinfo</span> sp;
</span></span><span style=display:flex><span>    <span style=color:#b00040>int</span> sz;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    sz <span style=color:#666>=</span> <span style=color:green;font-weight:700>sizeof</span>(<span style=color:green;font-weight:700>struct</span> <span style=color:#00f;font-weight:700>sctp_paddrinfo</span>);
</span></span><span style=display:flex><span>    bzero(<span style=color:#666>&amp;</span>sp, sz);
</span></span><span style=display:flex><span>    memcpy(<span style=color:#666>&amp;</span>sp.spinfo_address, sa, salen);
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>if</span> (sctp_opt_info(sockfd, <span style=color:#666>0</span>, SCTP_GET_PEER_ADDR_INFO, <span style=color:#666>&amp;</span>sp, <span style=color:#666>&amp;</span>sz) <span style=color:#666>==</span> <span style=color:#666>-</span><span style=color:#666>1</span>)
</span></span><span style=display:flex><span>        perror(<span style=color:#ba2121>&#34;get assoc&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>return</span> (sp.spinfo_assoc_id);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul></li></ul><p>There is no way to specify from which stream to read. This is deliberate; the
intention is that when data is ready on any stream, then you read
it. Otherwise, data could be blocked on a stream with no one to read it, which
eventually could fill up system buffers. So, you can&rsquo;t restrict reading to any
particular stream. But, once a read is done, you can tell which stream it has
come from by using the mechanism above.</p><p>Typically, a server that reads and handles a message will have (pseudocode) that looks like this:</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>while</span> (<span style=color:green>true</span>) {
</span></span><span style=display:flex><span>    nread <span style=color:#666>=</span> <span style=color:#00f>sctp_recvmsg</span>(..., msg, ..., <span style=color:#666>&amp;</span>sinfo, ...)
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>if</span> (nread <span style=color:#666>&lt;=</span> <span style=color:#666>0</span>) <span style=color:green;font-weight:700>break</span>;
</span></span><span style=display:flex><span>    assoc_id <span style=color:#666>=</span> sinfo.sinfo_assoc_id;
</span></span><span style=display:flex><span>    stream <span style=color:#666>=</span> sinfo.sinfo_stream;
</span></span><span style=display:flex><span>    <span style=color:#00f>handle_mesg</span>(assoc_id, stream, msg, nread);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This is a single-threaded read loop. It ensures that information is read, no matter what association or stream it is
sent on. The application function handle_mesg() can, of course, dispatch the message to different threads if it wants.
Writes, on the other hand can be sent from multiple threads if desired.</p><h2 id=h:ae3adb64-a1ab-4352-aa2a-8b58a81d1bf4>5 Rec & Send<a hidden class=anchor aria-hidden=true href=#h:ae3adb64-a1ab-4352-aa2a-8b58a81d1bf4>#</a></h2><p>When it comes to sending messages back to all the connected clients, SCTP
makes it even easier—the flag <code>SCTP_SENDALL</code> that can can be set in the
<code>sctp_sndrcvinfo</code> field of <code>sctp_send()</code>. So a server simply needs to read a
message from any client, set the SCTP_SENDALL bit and write it back out. The
SCTP stack then will send it to all live peers! There are only a few lines of</p><h2 id=h:d0a6f1bd-1d91-4b94-b5cd-f70950fb9e9f>6 CDB with SCTP?<a hidden class=anchor aria-hidden=true href=#h:d0a6f1bd-1d91-4b94-b5cd-f70950fb9e9f>#</a></h2><ul><li>发送端<ul><li>可使用 一个 socket ， 对多个 server 创建 associations</li><li>多线程并行发送</li></ul></li><li>接收端<ul><li>一个 socket ， 类似 UDP 接收</li><li>单线程接收，分拣</li><li>回发数据？？</li></ul></li></ul><h2 id=h:fa817dc8-9b69-4412-8a1c-54067ac156b4>7 SCTP Interface Model<a hidden class=anchor aria-hidden=true href=#h:fa817dc8-9b69-4412-8a1c-54067ac156b4>#</a></h2><p><a href=https://www.masterraghu.com/subjects/np/introduction/unix_network_programming_v1.3/ch09.html>https://www.masterraghu.com/subjects/np/introduction/unix_network_programming_v1.3/ch09.html</a></p><h3 id=h:79c523c0-858f-44d3-a13a-8ffb6cd217ac>7.1 two types of SCTP sockets<a hidden class=anchor aria-hidden=true href=#h:79c523c0-858f-44d3-a13a-8ffb6cd217ac>#</a></h3><h3 id=h:af8a22bd-336b-47ac-a22b-ba2a592aa426>7.2 The One-to-One Style<a hidden class=anchor aria-hidden=true href=#h:af8a22bd-336b-47ac-a22b-ba2a592aa426>#</a></h3><p>便于移植基于 TCP 协议的程序。</p><p></p><figure><img loading=lazy src=/ox-hugo/screenshot@2022-06-21_17:11:51.png width=800px></figure><h3 id=h:400f90d1-fb4b-4e76-ae90-8feff25e9124>7.3 The One-to-Many Style<a hidden class=anchor aria-hidden=true href=#h:400f90d1-fb4b-4e76-ae90-8feff25e9124>#</a></h3><p>一对多模式可以减少 server 所使用的 socket 数量：可以使用一个 socket 来建立多个
联合。 联合通过 <code>association id</code> 来标识。 该 ID 由内核指定，对用户透明。</p><p>使用该模式需要注意：</p><ul><li><p>当客户端关闭联合之后， server 端自动关闭，并将相关的状态从内核中移除。</p></li><li><p>使用 one-to-many 方式，可以在四次握手的第三个或者第四个包即开始发送数据。</p></li><li><p>使用 <code>sendto/sendmsg/sctp_sendmsg</code> 发送数据时候，如果联合不存在，会自动创建。</p></li><li><p>必须使用 <code>sendto/sctp_sendmsg</code> 来发送数据，而不能使用 <code>send/write</code></p></li><li><p>发送数据时，总是使用主目的地址 （建立联合时候系统选定的地址）。可以通过设置
flag <code>MSG_ADDR_OVER</code> 来强制使用其他地址。 该 flag 可以在 <code>sctp_sendmsg()</code> 中
通过 <code>sctp_sndrcvinfo</code> 来设置。</p></li><li><p>事件通知可以通过 <code>SCTP_EVENTS</code> 来控制。</p><p></p><figure><img loading=lazy src=/ox-hugo/screenshot@2022-06-21_17:33:56.png></figure></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://yangyingchao.github.io/tags/network/>network</a></li><li><a href=https://yangyingchao.github.io/tags/protocol/>protocol</a></li><li><a href=https://yangyingchao.github.io/tags/sctp/>sctp</a></li></ul></footer><script src=https://giscus.app/client.js data-repo=yangyingchao/giscus data-repo-id=R_kgDON6NYZA data-category=Announcements data-category-id=DIC_kwDON6NYZM4CnANs data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=zh-CN crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2025 <a href=https://yangyingchao.github.io>MyNotes</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>