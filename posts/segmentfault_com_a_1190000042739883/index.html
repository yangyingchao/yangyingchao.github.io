<!doctype html><html lang=zh-cn dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>数据库 - StarRocks 技术内幕 | Join 查询优化 | MyNotes</title><meta name=keywords content="starrocks,join"><meta name=description content="1 Join 背景 2 Join 逻辑优化 3 Join Reorder 4 分布式 Join 规划 5 总结 本文为摘录，原文为： https://segmentfault.com/a/1190000042739883 作者：贺凯，StarRocks Committer 导读：欢迎来到 StarRocks 技术内幕系列文章，我们将"><meta name=author content="Yang, Ying-chao"><link rel=canonical href=https://yangyingchao.github.io/posts/segmentfault_com_a_1190000042739883/><link crossorigin=anonymous href=/assets/css/stylesheet.6a98292fb8fa8cf0f3ba4042d4b75515c04267550f3ad49ff6271b5af9562443.css integrity="sha256-apgpL7j6jPDzukBC1LdVFcBCZ1UPOtSf9icbWvlWJEM=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://yangyingchao.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://yangyingchao.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://yangyingchao.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://yangyingchao.github.io/apple-touch-icon.png><link rel=mask-icon href=https://yangyingchao.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="数据库 - StarRocks 技术内幕 | Join 查询优化"><meta property="og:description" content="1 Join 背景 2 Join 逻辑优化 3 Join Reorder 4 分布式 Join 规划 5 总结 本文为摘录，原文为： https://segmentfault.com/a/1190000042739883 作者：贺凯，StarRocks Committer 导读：欢迎来到 StarRocks 技术内幕系列文章，我们将"><meta property="og:type" content="article"><meta property="og:url" content="https://yangyingchao.github.io/posts/segmentfault_com_a_1190000042739883/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-01-03T00:00:00+00:00"><meta property="article:modified_time" content="2025-01-03T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="数据库 - StarRocks 技术内幕 | Join 查询优化"><meta name=twitter:description content="1 Join 背景 2 Join 逻辑优化 3 Join Reorder 4 分布式 Join 规划 5 总结 本文为摘录，原文为： https://segmentfault.com/a/1190000042739883 作者：贺凯，StarRocks Committer 导读：欢迎来到 StarRocks 技术内幕系列文章，我们将"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://yangyingchao.github.io/posts/"},{"@type":"ListItem","position":3,"name":"数据库 - StarRocks 技术内幕 | Join 查询优化","item":"https://yangyingchao.github.io/posts/segmentfault_com_a_1190000042739883/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"数据库 - StarRocks 技术内幕 | Join 查询优化","name":"数据库 - StarRocks 技术内幕 | Join 查询优化","description":"1 Join 背景 2 Join 逻辑优化 3 Join Reorder 4 分布式 Join 规划 5 总结 本文为摘录，原文为： https://segmentfault.com/a/1190000042739883 作者：贺凯，StarRocks Committer 导读：欢迎来到 StarRocks 技术内幕系列文章，我们将","keywords":["starrocks","join"],"articleBody":" 1 Join 背景 2 Join 逻辑优化 3 Join Reorder 4 分布式 Join 规划 5 总结 本文为摘录，原文为： https://segmentfault.com/a/1190000042739883\n作者：贺凯，StarRocks Committer\n导读：欢迎来到 StarRocks 技术内幕系列文章，我们将为你全方位揭晓 StarRocks 背后的技术原理和实践细节，助你逐步上手这款明星 开源数据库产品。\n本文整理自作者在 StarRocks 线下 MeetUp 的分享，主要介绍 StarRocks 在 Join 查询规划上的经验和探索。文章主要分为四个部分： Join 背景，Join 逻辑优化，Join Reorder，分布式 Join 规划。\n1 Join 背景 1、Join 类型\n上图列举了常见的 Join 类型：\nCross Join：左表和右表的一个笛卡尔积。 Full / Left / Right Outer Join：Outer Join 需要根据语义，对两表/左表/右表上没有匹配上的行进行补 Null。 Anti Join：输出连接关系上没有匹配上的数据行，通常 Anti Join 出现在 not in 或者 not exists 子查询的规划中。 Semi Join：与 Anti Join 相反，只输出在连接关系上匹配的数据行即可。 Inner Join：输出左表和右表的交集，根据连接条件产生一对多的结果行。 2、Join 优化的难点\nJoin 的执行效率通常分成两部分来优化，一是提高单机上 Join 算子的效率，二是规划一个合理的 Join 计划，尽可能地减少 Join 的输 入/执行成本。本文主要集中在后者的介绍上，那么接下来就从 Join 优化的难点开始讲起。\n难点一，Join 的实现方式多。 如上图所示，不同 Join 的实现方式在不同场景下效率不同，如 Sort-Merge Join 在 Join 有序数据时，效率可能远高于 Hash Join，但 是在数据 Hash 分布的分布式数据库里，Hash Join 的效率可能远比 Sort-Merge 高。而数据库则需要针对不同的场景，选择合适的 Join 方式。\n难点二，多表 Join 的执行顺序。 在多表 Join 的场景下，选择度高的 Join 先执行，会提高整个 SQL 的效率，但是怎么判断出 Join 的执行顺序呢？这却是十分困难的。\n如上图所示，在 Left-Deep 模型下，N 个表 Join 可能的排列个数有 2^n-1 个，但是在 Bushy 模型下，排列个数高达 2^(n-1) * C(n-1)个， 对于数据库而言，查找一个最佳 Join 顺序的耗时和成本是指数级的增长。\n难点三，Join 的效果难以评估。 在执行 SQL 之前，数据库难以准确评估一个 Join 实际的执行效果，通常我们都认为小表 Join 大表的选择度高于大表 Join 大表。但是 实际情况下呢？显然并不是这样的，还有很多一对多的场景，甚至在更复杂的 SQL 中，存在各种聚合、过滤的算子，在数据经过一系列运 算后，数据库系统对于 Join 的输入都会难以评估准确。\n难点四，单机最优的计划不等于分布式最优。 在分布式系统中，会通过 Re-Shuffle 或者广播数据的方式，将需要的数据发送到目的端参与计算，分布式数据库中 Join 也是如此。但 这也带来了另外一个问题，一个单机数据库上最优的执行计划，因为没有考虑数据的分布 \u0026 网络传输的开销，放在分布式数据库上未必是 最优的执行计划。分布式数据库在规划 Join 的执行计划和执行方式时，需要考虑数据的分布和网络成本。\n3、SQL 的优化流程\nStarRocks 对于 SQL 的优化主要通过优化器完成，主要集中在 Rewrite 和 Optimize 阶段。关于优化器的详细介绍可以参考 StarRocks 优化器代码导读（https://zhuanlan.zhihu.com/p/…）。\n4、Join 优化的原则\nStarRocks 目前 Join 的算法主要是一个 Hash Join，默认使用右表去构建 Hash 表，在这个前提下，我们总结了五个优化方向：\n不同 Join 类型的算子，性能是不同的，尽可能使用性能高的 Join 类型，避免使用性能差的 Join 类型。根据 Join 输出的数据量， 大致上的性能排序：Semi-Join/Anti-Join \u003e Inner Join \u003e Outer Join \u003e Full Outer Join \u003e Cross Join。 Hash Join 实现时，使用小表做 Hash 表，远比用一个大表做 Hash 表高效。 多表 Join 时，优先执行选择度高的 Join，能大幅减少后续 Join 的开销。 尽可能减少参与 Join 的数据量。 尽可能减少分布式 Join 产生的网络成本。 2 Join 逻辑优化 ◎ —\n这部分主要给大家介绍一些 Join 上的启发式规则。\n1、类型转换\n第一个优化规则紧贴着前面所说的第一个优化原则，也就是把低效率的 Join 类型转为高效的 Join 类型，主要包括以下三个转换规则。\n转换规则一：Cross Join 转换为 Inner Join 当 Cross Join 满足某个约束时，可以将 Cross Join 转为 Inner Join。该约束为：Join 上至少存在一个表示连接关系的谓词。例如：\n– 转换前 Select * From t1, t2 Where t1.v1 = t2.v1;\n– 转换后, Where t1.v1 = t2.v1 是连接关系谓词 Select * From t1 Inner Join t2 On t1.v1 = t2.v1;\n转换规则二：Outer Join 转换为 Inner Join 当满足以下约束时，可以将 Outer Join 转为 Inner Join：\nLeft / Right Outer Join 上存在一个 Right / Left 表的相关谓词； 该相关谓词是一个严格（Restrick Null）谓词。 例如：\n– 转换前 Select * From t1 Left Outer Join t2 On t1.v1 = t2.v1 Where t2.v1 \u003e 0; – 转换后， t2.v1 \u003e 0 是一个 t2 表上的严格谓词 Select * From t1 Inner Join t2 On t1.v1 = t2.v1 Where t2.v1 \u003e 0;\n需要注意的是，在 Outer Join 中，需要根据 On 子句的连接谓词进行补 Null 操作，而不是过滤，所以该转换规则不适用 On 子句中的 连接谓词。例如：\nSelect * From t1 Left Outer Join t2 On t1.v1 = t2.v1 And t2.v1 \u003e 1; – 显然，上面的 SQL 和下面 SQL 的语义并不等价 Select * From t1 Inner Join t2 On t1.v1 = t2.v1 And t2.v1 \u003e 1;\n这里需要提到一个概念，即严格（Restrick Null）谓词。StarRocks 把一个可以过滤掉 Null 值的谓词叫做严格谓词，例如 a \u003e 0；而不 能过滤 Null 的谓词，叫做非严格谓词，例如：a IS Null。大部分谓词都是严格谓词，非严格谓词主要是 IS Null、IF、CASE WHEN 或函数 构成的谓词。\nStarRocks 对于严格谓词的判断，用了一个简单的方法：将需要检测的列全部替换成 Null，然后进行表达式化简。如果结果是 True，意 味着输入为 Null 时，Where 子句无法过滤数据，那么该谓词是一个非严格谓词；反之，如果结果是 False 或 Null，那么是一个严格谓 词。\n转换规则三：Full Outer Join 转为 Left / Right Outer Join 同样，当满足该约束时，Full Outer Join 可以转为 Left / Right Outer Join：存在一个可以 bind 到 Left / Right 表的严格谓词。 例如：\n– 转换前 Select * From t1 Full Outer Join t2 On t1.v1 = t2.v1 Where t1.v1 \u003e 0; – 转换后， t1.v1 \u003e 0 是一个左表上的谓词，且是一个严格谓词 Select * From t1 Left Outer Join t2 On t1.v1 = t2.v1 Where t1.v1 \u003e\n2、谓词下推\n谓词下推是一个 Join 上非常重要，也是很常用的一个优化规则，其主要目的是提前过滤 Join 的输入，从而提升 Join 的性能。\n对于 Where 子句，当满足以下约束时，我们可以进行谓词下推，并且伴随着谓词下推，我们可以做 Join 类型转换：\n任意 Join 类型； Where 谓词可以 bind 到其中一个输入上。 例如：\nSelect * From t1 Left Outer Join t2 On t1.v1 = t2.v1 Left Outer Join t3 On t2.v2 = t3.v2 Where t1.v1 = 1 And t2.v1 = 2 And t3.v2 = 3;\n其谓词下推的流程如下。\n第一步，分别下推 (t1.v1 = 1 And t2.v1 = 2) 和 (t3.v2 = 3)，由于满足类型转换规则(t1 Left Outer Join t2) Left Outer Join t3 转换为 (t1 Left Outer Join t2) Inner Join t3。\n第二步，继续下推 (t1.v1 = 1) 和 (t2.v1 = 2)，且 t1 Left Outer Join t2 转换为 t1 Inner Join t2。\n需要注意的是，对于 On 子句上的连接谓词，其下推的规则和 Where 子句有所不同，这里我们分为 Inner Join 和其他 Join 类型两种 情况。\n第一种情况是，对于 Inner Join，On 子句上的连接谓词下推，和 Where 子句相同，上面已经叙述过，这里不再重复。\n第二种情况是，对于 Outer / Semi / Anti Join 的连接谓词下推，需要满足以下约束，且下推过程中无法进行类型转换：\n必须为 [Left/Right] Outer/Semi/Anti Join； 连接谓词只能 bind 到 [Right/Left] 输入上。 例如：\nSelect * From t1 Left Outer Join t2 On t1.v1 = t2.v1 And t1.v1 = 1 And t2.v1 = 2 Left Outer Join t3 On t2.v2 = t3.v2 And t3.v2 = 3;\n其 On 连接谓词下推的流程如下。\n第一步，下推 t1 Left Join t2 Left Join t3 上可以 bind 到右表的连接谓词 (t3.v2 = 3)，此时无法将 Left Outer Join 转换为 Inner Join。\n第二步，下推 t1 Left Join t2 上可以 bind 到右表的连接谓词 (t2.v1 = 2)。由于 t1.v1 = 1 是 bind 到左表的，下推以后会过滤 t1 的数据，所以该行为与 Left Outer Join 语义不符，无法下推该谓词。\n3、谓词提取\n在之前的谓词下推的规则中，只能下推满足合取语义的谓词，例如 t1.v1 = 1 And t2.v1 = 2 And t3.v2 = 3 中，三个子谓词都是通过合 取谓词连接，而无法下推析取语义的谓词，例如 t1.v1 = 1 Or t2.v1 = 2 Or t3.v2 = 3。\n但是在实际场景中，析取谓词也十分常见，对此 StarRocks 做了一个提取谓词（列值推导）的优化。通过一系列的交并集操作，将析取谓 词中的列值范围提取出合取谓词，继而下推合取谓词。例如：\n– 谓词提取前 Select * From t1 Join t2 On t1.v1 = t2.v1 Where (t2.v1 = 2 AND t1.v2 = 3) OR (t2.v1 \u003e 5 AND t1.v2 = 4)\n– 利用(t2.v1 = 2 AND t1.v2 = 3) OR (t2.v1 \u003e 5 AND t1.v2 = 4)进行列值推导，推导出（t2.v1 \u003e= 2），（t1.v2 IN (3, 4)）两个谓词 Select * From t1 Join t2 On t1.v1 = t2.v1 Where (t2.v1 = 2 AND t1.v2 = 3) OR (t2.v1 \u003e 5 AND t1.v2 = 4) AND t2.v1 \u003e= 2 AND t1.v2 IN (3, 4);\n这里需要注意的是，提取出来的谓词范围可能是原始谓词范围的超集，所以不一定能直接替换原始谓词。\n4、等价推导\n在谓词上，除了上述的谓词提取，还有另一个重要的优化，叫等价推导。等价推导主要利用了 Join 的连接关系，从左表/右表列的取值范 围，推导出右表/左表对应列的取值范围。例如：\n– 原始 SQL Select * From t1 Join t2 On t1.v1 = t2.v1 Where (t2.v1 = 2 AND t1.v2 = 3) OR (t2.v1 \u003e 5 AND t1.v2 = 4)\n– 利用(t2.v1 = 2 AND t1.v2 = 3) OR (t2.v1 \u003e 5 AND t1.v2 = 4)进行列值推导，推导出（t2.v1 \u003e= 2），（t1.v2 IN (3, 4)）两个谓词 Select * From t1 Join t2 On t1.v1 = t2.v1 Where (t2.v1 = 2 AND t1.v2 = 3) OR (t2.v1 \u003e 5 AND t1.v2 = 4) AND t2.v1 \u003e= 2 AND t1.v2 IN (3, 4);\n– 利用连接谓词(t1.v1 = t2.v1)和(t2.v1 \u003e= 2)进行等价推导，推导出（t1.v1 \u003e= 2）谓词 Select * From t1 Join t2 On t1.v1 = t2.v1 Where (t2.v1 = 2 AND t1.v2 = 3) OR (t2.v1 \u003e 5 AND t1.v2 = 4) AND t2.v1 \u003e= 2 AND t1.v2 IN (3, 4) AND t1.v1 \u003e= 2;\n当然，等价推导的作用范围并不像谓词提取一样广泛，谓词提取可以在任意谓词上进行，但等价推导和谓词下推类似，在不同的 Join 上 有不同的条件约束，这里同样分为 Where 谓词和 On 连接谓词来解析。\nWhere 谓词：\n几乎没有约束，可以从左表的谓词推导出右表，反之亦可。 On 连接谓词：\n在 Inner Join 上和 Where 谓词相同，没有条件约束； 除 Inner Join 外，仅支持 Semi Join 和 Outer Join，且仅支持与 Join 方向相反的单向推导。例如，Left Outer Join 可以从左表 的谓词推导出右表的谓词，Right Outer Join 可以从右表的谓词推导出左表的谓词。 为什么在 Outer / Semi Join 上存在单向的限制呢？原因也很简单，以 Left Outer Join 为例，在谓词下推的规则中有提到，Left Outer Join 只能下推右表的谓词，而左表的谓词则由于违法语义导致无法下推。所以执行等价推导时，从右表谓词推导出的左表谓词，同 样需要满足该约束。\n那么在这个前提下，推导出来的左表谓词并不能起到提前过滤数据的作用，而且还会带来执行额外谓词的开销，所以 Outer / Semi Join 只支持单向推导。\n关于等价推导的实现，StarRocks 是通过维护了两个 Map 实现的。一个 Map 用于维护 Column 和 Column 之间的等价关系，另一个 Map 则用来维护 Column 到 Value 或者表达式的等值关系，通过这两个 Map 相互查找，实现等价推导。如图：\n5、Limit 下推\n除了谓词可以下推，Join 上也支持 Limit 的下推。当 SQL 是一个 Outer Join 或 Cross Join 时，可以将 Limit 下推到输出行数稳定 的孩子上。其中，Left Outer Join 输出行数至少和左孩子一致，那么 Limit 可以下推到左表上，Right Outer Join 反之。\n– 下推前 Select * From t1 Left Outer Join t2 On t1.v1 = t2.v1 Limit 100;\n– 下推后 Select * From (Select * From t1 Limit 100) t Left Outer Join t2 On t.v1 = t2.v1 Limit 100;\n比较特殊的是 Cross Join 和 Full Outer Join、Cross Join 的输出是一个笛卡尔积，行数是左表 x 右表；而 Full Outer Join 的输出 行数，则至少是左表 + 右表，所以这两种 Join 可以在左表和右表上各下推一个 Limit。例如：\n– 下推前 Select * From t1 Join t2 Limit 100;\n– 下推后 Select * From (Select * From t1 Limit 100) x1 Join (Select * From t2 Limit 100) Limit 100;\n3 Join Reorder ◎ —\nJoin Reorder 用于推断多表 Join 的执行顺序，数据库需要尽可能地先执行一个高选择度的 Join，这样就能减少后续 Join 的输入数据， 从而提升性能。\nStarRocks 的 Join Reorder，主要是在一个连续的 Inner Join 或者 Cross Join 上工作。以下图为例，StarRocks 会将一组连续的 Inner / Cross Join 叫做一个 Multi Join Node，而 Multi Join Node 就是一个 Join Reorder 的单位，即下推存在两个 Multi Join Node，StarRocks 将分别对着两个 Multi Join Node 进行 Join Reorder 推导。\n目前业界实现 JoinReorder 的算法有很多种，或者基于不同模型的，例如：\nHeuristic：基于启发式规则的，类似 MemSQL，通过定义维度表中心表排 Join 顺序。 Left-Deep：左深树模型，搜索空间小，但是不一定最优。 Bushy：稠密树模型，搜索空间大，包含最优解。其常见的一些 reorder 算法有： Exhaustive(Commutativity + Associativity)\nGreedy\nSimulated annealing\nDP（DPsize, DPsub，DPccp…）\nGenetic：GreenPlum\n……\n其中 StarRocks 实现了 Left-Deep、Exhaustive、Greedy、DPsub，接下来会着重介绍一下 StarRocks 中 Exhaustive、Greedy 的实现。\n1、Exhaustive\n穷举算法通常包括两个规则，通过这两个规则基本上覆盖 Join 的全排列组合。\n规则一：Join 的交换律。 A Join B 转为 B Join A，转换过程中需要注意 Join 类型的变化，比如 Left Outer Join 交换后变为 Right Outer Join。\n规则二：Join 的结合律。 (A Join B) Join C 转为 A Join（B Join C)。结合律上 StarRocks 又分为两种，一种是 Inner / Cross Join 的结合律，另一种是 Semi Join 的结合律。\n2、Greedy\nStarRocks 在贪心算法上主要参考多序列贪心算法，其次做了一个小改进，就是对于贪心算法每层产生的结果，StarRocks 都会保留 10 个最优解（可能不是全局最优），以此往后迭代，最终计算出 10 个贪心最优的 Plan。\n当然，由于贪心算法的局限性，这样的优化只是提高了计算出全局最优解的概率，并不能保证一定得到全局最优的 Plan。\n3、Cost Model\nStarRocks 使用这些 Join Reorder 的算法推导出 N 个 Plan，最终会根据 Cost Model 的算法，估算出每个 Join 的 Cost，整个 Cost 的计算公式如下：\nJoin Cost: CPU * (Row(L) + Row(R)) + Memory * Row(R)\n其中 Row(L）、Row(R) 分别表示 Join 左右孩子的输出行数，公式主要是考虑 CPU 开销，以及 Hash Join 右表做 Hash 表内存的开销， 下图详细展示了 StarRocks 中 Join 的输出行数的计算方式。\n此外，由于不同算法探索 Join Reorder 的空间不同，StarRocks 按照算法的空间复杂度和耗时做了基本的测试，具体如下。\n基于上述耗时的结论，StarRocks 对各个算法的执行做了简单的限制。当在 4 表以内的 Join Reorder 使用穷举算法；4~10 表时会分别 使用左深、贪心、动态规划算法产生 1 个、10 个、1 个计划，并且在此基础上会使用 Join 交换律探索更多的 Plan；当 10 表以上时， StarRocks 就只使用贪心和左深产生的 11 个 Plan 为基础进行 Reorder；另外，在 StarRocks 没有统计信息时，基于 Cost 的贪心和动 规都无法很好地工作，所以只会使用左深产生的 1 个 Plan 为基础 Reorder。\n4 分布式 Join 规划 ◎ —\n在前面介绍完一个 Join 查询的一些逻辑上的优化点后，后面会结合 StarRocks 作为一个分布式数据库，在分布式 Join 执行上的优化。\n1、MPP 并行执行\n首先，StarRocks 的执行框架是一个 MPP 的并行执行架构，整体架构如图所示，以一个简单的 Join SQL 为例，StarRocks 执行 A Join B 的流程如下：\n按照 A 表和 B 表的分布信息分别从不同的机器上读取数据； 按照 Join 的连接谓词，将 A 表和 B 表的数据 Re-Shuffle 到同一批机器上； 单机 Join 执行，输出结果。 可以看到，实际执行过程中，不只是一台机器参与计算，A 表的机器、B 表的机器、Join 的机器可能都不是同一批机器，中间会涉及到网 络传输、数据交换等操作。而在这个过程中，很自然地就带来了网络操作的开销。所以对于 StarRocks，优化分布式 Join 效率中比较重 要的一个措施，就是尽可能地减少网络开销，更合理地拆分/分发整个查询计划，尽可能将并行执行的优势发挥出来。\n2、分布式 Join 优化\n这里先介绍一些 StarRocks 可以生成的分布式执行计划，以一个最简单的 Join 为例：\nSelect * From A Join B on A.a = B.b\n可以看到，StarRocks 实际执行中会产生 5 种最基本的分布式 Plan：\nShuffle Join：分别将 A、B 两表的数据按照连接关系都 Shuffle 到同一批机器上，再进行 Join 操作。 Broadcast Join：通过将 B 表的数据全量的广播到 A 表的机器上，在 A 表的机器上进行 Join 操作，相比较于 Shuffle Join，节省 了 A 表的数据 Shuffle，但是 B 表的数据是全量广播，适合 B 表是个小表的场景。 Bucket Shuffle Join：在 Broadcast 的基础上进一步优化，将 B 表按照 A 表的分布方式 Shuffle 到 A 表的机器上进行 Join 操作， B 表 Shuffle 的数据量全局只有一份，比 Broadcast 少传输了很多倍数据量。当然，有约束条件限制，Join 的连接关系必须和 A 表 的分布一致。 Colocate Join：通过建表时指定 A 表和 B 表是同一个 Colocate Group，意味着 A、B 表的分布完全一致，那么当 Join 的连接关系 和 A、B 表分布一致时，StarRocks 可以直接在 A、B 表的机器上直接 Join，不需要进行数据 Shuffle。 Replicate Join：StarRocks 的实验性功能，当每一台 A 表的机器上都存在一份完整的 B 表数据时，直接在本地进行 Join 操作，该 Join 的约束条件比较严格，基本上意味着 B 表的副本数需要和整个集群的机器数保持一致，所以实践意义并不理想。 StarRocks 会对每个 Join 都尝试生成上述 5 种分布式 Join 计划，但是由于不同 Join 类型的语义限制，实际上一些特殊的 Join 类型 只能生成特定的分布式 Join 计划。例如，Cross Join 只能生成 Broadcast Join。\n3、探索分布式 Join\nStarRocks 的分布式 Join 计划，是通过一系列的 Distribution Property 推导产生的。以下述的 Join SQL 的 Shuffle Join Plan 为 例，Join 会自顶向下地向 A、B 表分别要求 Shuffle Property。\n当 Scan 节点无法满足该要求时，会通过 Enforce 操作，加入一个 Shuffle 的操作节点，用于满足 Join 的要求。最后在生成执行计划 时，StarRocks 会将 Shuffle 节点“翻译”成一个 Exchange 节点，通过该节点完成网络数据的传输和交换。\n其他的分布式 Join 生成方式和 Shuffle Join 类似，都是由 Join 向下要求不同的属性推导出。\nSelect * From A Join B on A.a = B.b\n4、复杂的分布式 Join\n在用户场景中，用户的 SQL 远比前面的一个 A Join B 复杂得多，可能是 3 表 Join，也可能是 4 表 Join。实际上，StarRocks 对于更 复杂的 Join，同样也会生成更复杂多样的分布式 Plan，但都是基于上述最基础的几种 Join 方式推导出来的。例如：\nSelect * From A Join B on A.a = B.b Join C on A.a = C.c\n这里简单举几个 StarRocks 基于 Shuffle Join 和 Broadcast Join 生成的分布式 Plan：\n当然，如果继续引入 Colocate Join 和 Bucket Shuffle Join，StarRocks 还可以推导出下面这样一些 Plan：\n对于上面这些复杂的分布式 Join Plan，其推导原理和前面的原理几乎一致。Distribution Property 在节点间会一直向下传递，进而推 导出各种 Join 组合的分布式 Plan。具体的推导实现也可以参考 StarRocks 优化器代码导读（https://zhuanlan.zhihu.com/p/…）。\n5、Global Runtime Filter\n除了分布式 Plan 的这样一些探索外，StarRocks 在规划 Plan 时，还会结合 Join 算子的执行特点，来构造全局性的 Global Runtime Filter 这样一个优化。StarRocks 的 Hash Join 执行过程如下：\nStarRocks 先查询得到全量的右表数据；\n将右表的数据构造为一个 Hash 表；\n再去拉取左表的数据；\n基于 Hash 表来构建 Join 的连接关系；\n输出 Join 结果。\n那么，Global Runtime Filter 的工作时机就在 Step 2 和 Step 3 之间，StarRocks 在得到右表的数据后，通过这些运行时数据构造出 来一个过滤谓词，在拉取左表数据前先将这样一个 Runime 的过滤谓词下发到左表的 Scan 节点，从而帮助左表的 Scan 节点提前过滤数 据，最终达到减少 Join 输入的目的。\n目前 Global Runtime Filter 支持的过滤方式为：Min / Max、In predicate 和 Bloom Filter。示意图如下：\n5 总结 本文讲述了 StarRocks 对 Join 查询优化的实践和探索，所有的优化都是紧贴提到的优化原则。当然，用户在自行优化 SQL 时，也完全 可以参考如下 5 点，以及 StarRocks 提供的功能进行优化。\n不同 Join 类型的算子，性能是不同的，尽可能使用性能高的 Join 类型，避免使用性能差的 Join 类型。根据 Join 输出的数据量， 大致的性能排序为：Semi-Join/Anti-Join \u003e Inner Join \u003e Outer Join \u003e Full Outer Join \u003e Cross Join。 Hash Join 的实现时，使用小表做 Hash 表，远比用一个大表做 Hash 表高效。 多表 Join 时，优先执行选择度高的 Join，能大幅减少后续 Join 的开销。 尽可能减少参与 Join 的数据量。 尽可能减少分布式 Join 产生的网络成本。 StarRocks 在支持了那么多优化后，也有了更多的心得和更多的规划，比如：\n支持更多的 Join 实现方式，更智能地结合上下文选择更合适的 Join 实现算子； 结合 StarRocks 的特性，支持更多特定的 Join Reorder 算法； 尽可能地解决 Cost 估算的问题，引入更多的算法或者数据结构来确保估算结果； 支持更多调度方式，可能优化网络成本开销。 ","wordCount":"7717","inLanguage":"zh-cn","datePublished":"2025-01-03T00:00:00Z","dateModified":"2025-01-03T00:00:00Z","author":[{"@type":"Person","name":"Yang"},{"@type":"Person","name":"Ying-chao"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://yangyingchao.github.io/posts/segmentfault_com_a_1190000042739883/"},"publisher":{"@type":"Organization","name":"MyNotes","logo":{"@type":"ImageObject","url":"https://yangyingchao.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://yangyingchao.github.io accesskey=h title="MyNotes (Alt + H)">MyNotes</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://yangyingchao.github.io/ title=Home><span>Home</span></a></li><li><a href=https://yangyingchao.github.io/posts/ title=Archives><span>Archives</span></a></li><li><a href=https://yangyingchao.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://yangyingchao.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://yangyingchao.github.io/contact/ title="Contact me"><span>Contact me</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>数据库 - StarRocks 技术内幕 | Join 查询优化</h1><div class=post-meta><span title='2025-01-03 00:00:00 +0000 UTC'>January 3, 2025</span>&nbsp;·&nbsp;Yang, Ying-chao</div></header><div class=post-content><ul><li>1 <a href=#join-%E8%83%8C%E6%99%AF>Join 背景</a></li><li>2 <a href=#join-%E9%80%BB%E8%BE%91%E4%BC%98%E5%8C%96>Join 逻辑优化</a></li><li>3 <a href=#join-reorder>Join Reorder</a></li><li>4 <a href=#%E5%88%86%E5%B8%83%E5%BC%8F-join-%E8%A7%84%E5%88%92>分布式 Join 规划</a></li><li>5 <a href=#%E6%80%BB%E7%BB%93>总结</a></li></ul><p>本文为摘录，原文为： <a href=https://segmentfault.com/a/1190000042739883>https://segmentfault.com/a/1190000042739883</a></p><p>作者：贺凯，StarRocks Committer</p><p>导读：欢迎来到 StarRocks 技术内幕系列文章，我们将为你全方位揭晓 StarRocks 背后的技术原理和实践细节，助你逐步上手这款明星
开源数据库产品。</p><p>本文整理自作者在 StarRocks 线下 MeetUp 的分享，主要介绍 StarRocks 在 Join 查询规划上的经验和探索。文章主要分为四个部分：
Join 背景，Join 逻辑优化，Join Reorder，分布式 Join 规划。</p><h2 id=join-背景>1 Join 背景<a hidden class=anchor aria-hidden=true href=#join-背景>#</a></h2><p>1、Join 类型</p><p>上图列举了常见的 Join 类型：</p><ul><li>Cross Join：左表和右表的一个笛卡尔积。</li><li>Full / Left / Right Outer Join：Outer Join 需要根据语义，对两表/左表/右表上没有匹配上的行进行补 Null。</li><li>Anti Join：输出连接关系上没有匹配上的数据行，通常 Anti Join 出现在 not in 或者 not exists 子查询的规划中。</li><li>Semi Join：与 Anti Join 相反，只输出在连接关系上匹配的数据行即可。</li><li>Inner Join：输出左表和右表的交集，根据连接条件产生一对多的结果行。</li></ul><p>2、Join 优化的难点</p><p>Join 的执行效率通常分成两部分来优化，一是提高单机上 Join 算子的效率，二是规划一个合理的 Join 计划，尽可能地减少 Join 的输
入/执行成本。本文主要集中在后者的介绍上，那么接下来就从 Join 优化的难点开始讲起。</p><ul><li>难点一，Join 的实现方式多。</li></ul><p>如上图所示，不同 Join 的实现方式在不同场景下效率不同，如 Sort-Merge Join 在 Join 有序数据时，效率可能远高于 Hash Join，但
是在数据 Hash 分布的分布式数据库里，Hash Join 的效率可能远比 Sort-Merge 高。而数据库则需要针对不同的场景，选择合适的
Join 方式。</p><ul><li>难点二，多表 Join 的执行顺序。</li></ul><p>在多表 Join 的场景下，选择度高的 Join 先执行，会提高整个 SQL 的效率，但是怎么判断出 Join 的执行顺序呢？这却是十分困难的。</p><p>如上图所示，在 Left-Deep 模型下，N 个表 Join 可能的排列个数有 2^n-1 个，但是在 Bushy 模型下，排列个数高达 2^(n-1) * C(n-1)个，
对于数据库而言，查找一个最佳 Join 顺序的耗时和成本是指数级的增长。</p><ul><li>难点三，Join 的效果难以评估。</li></ul><p>在执行 SQL 之前，数据库难以准确评估一个 Join 实际的执行效果，通常我们都认为小表 Join 大表的选择度高于大表 Join 大表。但是
实际情况下呢？显然并不是这样的，还有很多一对多的场景，甚至在更复杂的 SQL 中，存在各种聚合、过滤的算子，在数据经过一系列运
算后，数据库系统对于 Join 的输入都会难以评估准确。</p><ul><li>难点四，单机最优的计划不等于分布式最优。</li></ul><p>在分布式系统中，会通过 Re-Shuffle 或者广播数据的方式，将需要的数据发送到目的端参与计算，分布式数据库中 Join 也是如此。但
这也带来了另外一个问题，一个单机数据库上最优的执行计划，因为没有考虑数据的分布 & 网络传输的开销，放在分布式数据库上未必是
最优的执行计划。分布式数据库在规划 Join 的执行计划和执行方式时，需要考虑数据的分布和网络成本。</p><p>3、SQL 的优化流程</p><p>StarRocks 对于 SQL 的优化主要通过优化器完成，主要集中在 Rewrite 和 Optimize 阶段。关于优化器的详细介绍可以参考 StarRocks
优化器代码导读（<a href=https://zhuanlan.zhihu.com/p/>https://zhuanlan.zhihu.com/p/</a>…）。</p><p>4、Join 优化的原则</p><p>StarRocks 目前 Join 的算法主要是一个 Hash Join，默认使用右表去构建 Hash 表，在这个前提下，我们总结了五个优化方向：</p><ol><li>不同 Join 类型的算子，性能是不同的，尽可能使用性能高的 Join 类型，避免使用性能差的 Join 类型。根据 Join 输出的数据量，
大致上的性能排序：Semi-Join/Anti-Join > Inner Join > Outer Join > Full Outer Join > Cross Join。</li><li>Hash Join 实现时，使用小表做 Hash 表，远比用一个大表做 Hash 表高效。</li><li>多表 Join 时，优先执行选择度高的 Join，能大幅减少后续 Join 的开销。</li><li>尽可能减少参与 Join 的数据量。</li><li>尽可能减少分布式 Join 产生的网络成本。</li></ol><h2 id=join-逻辑优化>2 Join 逻辑优化<a hidden class=anchor aria-hidden=true href=#join-逻辑优化>#</a></h2><p>◎ —</p><p>这部分主要给大家介绍一些 Join 上的启发式规则。</p><p>1、类型转换</p><p>第一个优化规则紧贴着前面所说的第一个优化原则，也就是把低效率的 Join 类型转为高效的 Join 类型，主要包括以下三个转换规则。</p><ul><li>转换规则一：Cross Join 转换为 Inner Join</li></ul><p>当 Cross Join 满足某个约束时，可以将 Cross Join 转为 Inner Join。该约束为：Join 上至少存在一个表示连接关系的谓词。例如：</p><p>– 转换前
Select * From t1, t2 Where t1.v1 = t2.v1;</p><p>– 转换后, Where t1.v1 = t2.v1 是连接关系谓词
Select * From t1 Inner Join t2 On t1.v1 = t2.v1;</p><ul><li>转换规则二：Outer Join 转换为 Inner Join</li></ul><p>当满足以下约束时，可以将 Outer Join 转为 Inner Join：</p><ol><li>Left / Right Outer Join 上存在一个 Right / Left 表的相关谓词；</li><li>该相关谓词是一个严格（Restrick Null）谓词。</li></ol><p>例如：</p><p>– 转换前
Select * From t1 Left Outer Join t2 On t1.v1 = t2.v1 Where t2.v1 > 0;
– 转换后， t2.v1 > 0 是一个 t2 表上的严格谓词
Select * From t1 Inner Join t2 On t1.v1 = t2.v1 Where t2.v1 > 0;</p><p>需要注意的是，在 Outer Join 中，需要根据 On 子句的连接谓词进行补 Null 操作，而不是过滤，所以该转换规则不适用 On 子句中的
连接谓词。例如：</p><p>Select * From t1 Left Outer Join t2 On t1.v1 = t2.v1 And t2.v1 > 1;
– 显然，上面的 SQL 和下面 SQL 的语义并不等价
Select * From t1 Inner Join t2 On t1.v1 = t2.v1 And t2.v1 > 1;</p><p>这里需要提到一个概念，即严格（Restrick Null）谓词。StarRocks 把一个可以过滤掉 Null 值的谓词叫做严格谓词，例如 a > 0；而不
能过滤 Null 的谓词，叫做非严格谓词，例如：a IS Null。大部分谓词都是严格谓词，非严格谓词主要是 IS Null、IF、CASE WHEN 或函数
构成的谓词。</p><p>StarRocks 对于严格谓词的判断，用了一个简单的方法：将需要检测的列全部替换成 Null，然后进行表达式化简。如果结果是 True，意
味着输入为 Null 时，Where 子句无法过滤数据，那么该谓词是一个非严格谓词；反之，如果结果是 False 或 Null，那么是一个严格谓
词。</p><ul><li>转换规则三：Full Outer Join 转为 Left / Right Outer Join</li></ul><p>同样，当满足该约束时，Full Outer Join 可以转为 Left / Right Outer Join：存在一个可以 bind 到 Left / Right 表的严格谓词。
例如：</p><p>– 转换前
Select * From t1 Full Outer Join t2 On t1.v1 = t2.v1 Where t1.v1 > 0;
– 转换后， t1.v1 > 0 是一个左表上的谓词，且是一个严格谓词
Select * From t1 Left Outer Join t2 On t1.v1 = t2.v1 Where t1.v1 ></p><p>2、谓词下推</p><p>谓词下推是一个 Join 上非常重要，也是很常用的一个优化规则，其主要目的是提前过滤 Join 的输入，从而提升 Join 的性能。</p><p>对于 Where 子句，当满足以下约束时，我们可以进行谓词下推，并且伴随着谓词下推，我们可以做 Join 类型转换：</p><ol><li>任意 Join 类型；</li><li>Where 谓词可以 bind 到其中一个输入上。</li></ol><p>例如：</p><p>Select *
From t1 Left Outer Join t2 On t1.v1 = t2.v1
Left Outer Join t3 On t2.v2 = t3.v2
Where t1.v1 = 1 And t2.v1 = 2 And t3.v2 = 3;</p><p>其谓词下推的流程如下。</p><p>第一步，分别下推 (t1.v1 = 1 And t2.v1 = 2) 和 (t3.v2 = 3)，由于满足类型转换规则(t1 Left Outer Join t2) Left Outer Join
t3 转换为 (t1 Left Outer Join t2) Inner Join t3。</p><p>第二步，继续下推 (t1.v1 = 1) 和 (t2.v1 = 2)，且 t1 Left Outer Join t2 转换为 t1 Inner Join t2。</p><p>需要注意的是，对于 On 子句上的连接谓词，其下推的规则和 Where 子句有所不同，这里我们分为 Inner Join 和其他 Join 类型两种
情况。</p><p>第一种情况是，对于 Inner Join，On 子句上的连接谓词下推，和 Where 子句相同，上面已经叙述过，这里不再重复。</p><p>第二种情况是，对于 Outer / Semi / Anti Join 的连接谓词下推，需要满足以下约束，且下推过程中无法进行类型转换：</p><ul><li>必须为 [Left/Right] Outer/Semi/Anti Join；</li><li>连接谓词只能 bind 到 [Right/Left] 输入上。</li></ul><p>例如：</p><p>Select *
From t1 Left Outer Join t2 On t1.v1 = t2.v1 And t1.v1 = 1 And t2.v1 = 2
Left Outer Join t3 On t2.v2 = t3.v2 And t3.v2 = 3;</p><p>其 On 连接谓词下推的流程如下。</p><p>第一步，下推 t1 Left Join t2 Left Join t3 上可以 bind 到右表的连接谓词 (t3.v2 = 3)，此时无法将 Left Outer Join 转换为
Inner Join。</p><p>第二步，下推 t1 Left Join t2 上可以 bind 到右表的连接谓词 (t2.v1 = 2)。由于 t1.v1 = 1 是 bind 到左表的，下推以后会过滤 t1
的数据，所以该行为与 Left Outer Join 语义不符，无法下推该谓词。</p><p>3、谓词提取</p><p>在之前的谓词下推的规则中，只能下推满足合取语义的谓词，例如 t1.v1 = 1 And t2.v1 = 2 And t3.v2 = 3 中，三个子谓词都是通过合
取谓词连接，而无法下推析取语义的谓词，例如 t1.v1 = 1 Or t2.v1 = 2 Or t3.v2 = 3。</p><p>但是在实际场景中，析取谓词也十分常见，对此 StarRocks 做了一个提取谓词（列值推导）的优化。通过一系列的交并集操作，将析取谓
词中的列值范围提取出合取谓词，继而下推合取谓词。例如：</p><p>– 谓词提取前
Select *
From t1 Join t2 On t1.v1 = t2.v1
Where (t2.v1 = 2 AND t1.v2 = 3) OR (t2.v1 > 5 AND t1.v2 = 4)</p><p>– 利用(t2.v1 = 2 AND t1.v2 = 3) OR (t2.v1 > 5 AND t1.v2 = 4)进行列值推导，推导出（t2.v1 >= 2），（t1.v2 IN (3, 4)）两个谓词
Select *
From t1 Join t2 On t1.v1 = t2.v1
Where (t2.v1 = 2 AND t1.v2 = 3) OR (t2.v1 > 5 AND t1.v2 = 4)
AND t2.v1 >= 2 AND t1.v2 IN (3, 4);</p><p>这里需要注意的是，提取出来的谓词范围可能是原始谓词范围的超集，所以不一定能直接替换原始谓词。</p><p>4、等价推导</p><p>在谓词上，除了上述的谓词提取，还有另一个重要的优化，叫等价推导。等价推导主要利用了 Join 的连接关系，从左表/右表列的取值范
围，推导出右表/左表对应列的取值范围。例如：</p><p>– 原始 SQL
Select *
From t1 Join t2 On t1.v1 = t2.v1
Where (t2.v1 = 2 AND t1.v2 = 3) OR (t2.v1 > 5 AND t1.v2 = 4)</p><p>– 利用(t2.v1 = 2 AND t1.v2 = 3) OR (t2.v1 > 5 AND t1.v2 = 4)进行列值推导，推导出（t2.v1 >= 2），（t1.v2 IN (3, 4)）两个谓词
Select *
From t1 Join t2 On t1.v1 = t2.v1
Where (t2.v1 = 2 AND t1.v2 = 3) OR (t2.v1 > 5 AND t1.v2 = 4)
AND t2.v1 >= 2 AND t1.v2 IN (3, 4);</p><p>– 利用连接谓词(t1.v1 = t2.v1)和(t2.v1 >= 2)进行等价推导，推导出（t1.v1 >= 2）谓词
Select *
From t1 Join t2 On t1.v1 = t2.v1
Where (t2.v1 = 2 AND t1.v2 = 3) OR (t2.v1 > 5 AND t1.v2 = 4)
AND t2.v1 >= 2 AND t1.v2 IN (3, 4) AND t1.v1 >= 2;</p><p>当然，等价推导的作用范围并不像谓词提取一样广泛，谓词提取可以在任意谓词上进行，但等价推导和谓词下推类似，在不同的 Join 上
有不同的条件约束，这里同样分为 Where 谓词和 On 连接谓词来解析。</p><p>Where 谓词：</p><ul><li>几乎没有约束，可以从左表的谓词推导出右表，反之亦可。</li></ul><p>On 连接谓词：</p><ul><li>在 Inner Join 上和 Where 谓词相同，没有条件约束；</li><li>除 Inner Join 外，仅支持 Semi Join 和 Outer Join，且仅支持与 Join 方向相反的单向推导。例如，Left Outer Join 可以从左表
的谓词推导出右表的谓词，Right Outer Join 可以从右表的谓词推导出左表的谓词。</li></ul><p>为什么在 Outer / Semi Join 上存在单向的限制呢？原因也很简单，以 Left Outer Join 为例，在谓词下推的规则中有提到，Left
Outer Join 只能下推右表的谓词，而左表的谓词则由于违法语义导致无法下推。所以执行等价推导时，从右表谓词推导出的左表谓词，同
样需要满足该约束。</p><p>那么在这个前提下，推导出来的左表谓词并不能起到提前过滤数据的作用，而且还会带来执行额外谓词的开销，所以 Outer / Semi Join
只支持单向推导。</p><p>关于等价推导的实现，StarRocks 是通过维护了两个 Map 实现的。一个 Map 用于维护 Column 和 Column 之间的等价关系，另一个 Map
则用来维护 Column 到 Value 或者表达式的等值关系，通过这两个 Map 相互查找，实现等价推导。如图：</p><p>5、Limit 下推</p><p>除了谓词可以下推，Join 上也支持 Limit 的下推。当 SQL 是一个 Outer Join 或 Cross Join 时，可以将 Limit 下推到输出行数稳定
的孩子上。其中，Left Outer Join 输出行数至少和左孩子一致，那么 Limit 可以下推到左表上，Right Outer Join 反之。</p><p>– 下推前
Select *
From t1 Left Outer Join t2 On t1.v1 = t2.v1
Limit 100;</p><p>– 下推后
Select *
From (Select * From t1 Limit 100) t Left Outer Join t2 On t.v1 = t2.v1
Limit 100;</p><p>比较特殊的是 Cross Join 和 Full Outer Join、Cross Join 的输出是一个笛卡尔积，行数是左表 x 右表；而 Full Outer Join 的输出
行数，则至少是左表 + 右表，所以这两种 Join 可以在左表和右表上各下推一个 Limit。例如：</p><p>– 下推前
Select *
From t1 Join t2
Limit 100;</p><p>– 下推后
Select *
From (Select * From t1 Limit 100) x1 Join
(Select * From t2 Limit 100)
Limit 100;</p><h2 id=join-reorder>3 Join Reorder<a hidden class=anchor aria-hidden=true href=#join-reorder>#</a></h2><p>◎ —</p><p>Join Reorder 用于推断多表 Join 的执行顺序，数据库需要尽可能地先执行一个高选择度的 Join，这样就能减少后续 Join 的输入数据，
从而提升性能。</p><p>StarRocks 的 Join Reorder，主要是在一个连续的 Inner Join 或者 Cross Join 上工作。以下图为例，StarRocks 会将一组连续的
Inner / Cross Join 叫做一个 Multi Join Node，而 Multi Join Node 就是一个 Join Reorder 的单位，即下推存在两个 Multi Join
Node，StarRocks 将分别对着两个 Multi Join Node 进行 Join Reorder 推导。</p><p>目前业界实现 JoinReorder 的算法有很多种，或者基于不同模型的，例如：</p><ul><li>Heuristic：基于启发式规则的，类似 MemSQL，通过定义维度表中心表排 Join 顺序。</li><li>Left-Deep：左深树模型，搜索空间小，但是不一定最优。</li><li>Bushy：稠密树模型，搜索空间大，包含最优解。其常见的一些 reorder 算法有：</li></ul><p>Exhaustive(Commutativity + Associativity)</p><p>Greedy</p><p>Simulated annealing</p><p>DP（DPsize, DPsub，DPccp…）</p><p>Genetic：GreenPlum</p><p>……</p><p>其中 StarRocks 实现了 Left-Deep、Exhaustive、Greedy、DPsub，接下来会着重介绍一下 StarRocks 中 Exhaustive、Greedy 的实现。</p><p>1、Exhaustive</p><p>穷举算法通常包括两个规则，通过这两个规则基本上覆盖 Join 的全排列组合。</p><ul><li>规则一：Join 的交换律。</li></ul><p>A Join B 转为 B Join A，转换过程中需要注意 Join 类型的变化，比如 Left Outer Join 交换后变为 Right Outer Join。</p><ul><li>规则二：Join 的结合律。</li></ul><p>(A Join B) Join C 转为 A Join（B Join C)。结合律上 StarRocks 又分为两种，一种是 Inner / Cross Join 的结合律，另一种是
Semi Join 的结合律。</p><p>2、Greedy</p><p>StarRocks 在贪心算法上主要参考多序列贪心算法，其次做了一个小改进，就是对于贪心算法每层产生的结果，StarRocks 都会保留 10
个最优解（可能不是全局最优），以此往后迭代，最终计算出 10 个贪心最优的 Plan。</p><p>当然，由于贪心算法的局限性，这样的优化只是提高了计算出全局最优解的概率，并不能保证一定得到全局最优的 Plan。</p><p>3、Cost Model</p><p>StarRocks 使用这些 Join Reorder 的算法推导出 N 个 Plan，最终会根据 Cost Model 的算法，估算出每个 Join 的 Cost，整个 Cost
的计算公式如下：</p><p>Join Cost: CPU * (Row(L) + Row(R)) + Memory * Row(R)</p><p>其中 Row(L）、Row(R) 分别表示 Join 左右孩子的输出行数，公式主要是考虑 CPU 开销，以及 Hash Join 右表做 Hash 表内存的开销，
下图详细展示了 StarRocks 中 Join 的输出行数的计算方式。</p><p>此外，由于不同算法探索 Join Reorder 的空间不同，StarRocks 按照算法的空间复杂度和耗时做了基本的测试，具体如下。</p><p>基于上述耗时的结论，StarRocks 对各个算法的执行做了简单的限制。当在 4 表以内的 Join Reorder 使用穷举算法；4~10 表时会分别
使用左深、贪心、动态规划算法产生 1 个、10 个、1 个计划，并且在此基础上会使用 Join 交换律探索更多的 Plan；当 10 表以上时，
StarRocks 就只使用贪心和左深产生的 11 个 Plan 为基础进行 Reorder；另外，在 StarRocks 没有统计信息时，基于 Cost 的贪心和动
规都无法很好地工作，所以只会使用左深产生的 1 个 Plan 为基础 Reorder。</p><h2 id=分布式-join-规划>4 分布式 Join 规划<a hidden class=anchor aria-hidden=true href=#分布式-join-规划>#</a></h2><p>◎ —</p><p>在前面介绍完一个 Join 查询的一些逻辑上的优化点后，后面会结合 StarRocks 作为一个分布式数据库，在分布式 Join 执行上的优化。</p><p>1、MPP 并行执行</p><p>首先，StarRocks 的执行框架是一个 MPP 的并行执行架构，整体架构如图所示，以一个简单的 Join SQL 为例，StarRocks 执行 A Join
B 的流程如下：</p><ol><li>按照 A 表和 B 表的分布信息分别从不同的机器上读取数据；</li><li>按照 Join 的连接谓词，将 A 表和 B 表的数据 Re-Shuffle 到同一批机器上；</li><li>单机 Join 执行，输出结果。</li></ol><p>可以看到，实际执行过程中，不只是一台机器参与计算，A 表的机器、B 表的机器、Join 的机器可能都不是同一批机器，中间会涉及到网
络传输、数据交换等操作。而在这个过程中，很自然地就带来了网络操作的开销。所以对于 StarRocks，优化分布式 Join 效率中比较重
要的一个措施，就是尽可能地减少网络开销，更合理地拆分/分发整个查询计划，尽可能将并行执行的优势发挥出来。</p><p>2、分布式 Join 优化</p><p>这里先介绍一些 StarRocks 可以生成的分布式执行计划，以一个最简单的 Join 为例：</p><p>Select * From A Join B on A.a = B.b</p><p>可以看到，StarRocks 实际执行中会产生 5 种最基本的分布式 Plan：</p><ul><li>Shuffle Join：分别将 A、B 两表的数据按照连接关系都 Shuffle 到同一批机器上，再进行 Join 操作。</li><li>Broadcast Join：通过将 B 表的数据全量的广播到 A 表的机器上，在 A 表的机器上进行 Join 操作，相比较于 Shuffle Join，节省
了 A 表的数据 Shuffle，但是 B 表的数据是全量广播，适合 B 表是个小表的场景。</li><li>Bucket Shuffle Join：在 Broadcast 的基础上进一步优化，将 B 表按照 A 表的分布方式 Shuffle 到 A 表的机器上进行 Join 操作，
B 表 Shuffle 的数据量全局只有一份，比 Broadcast 少传输了很多倍数据量。当然，有约束条件限制，Join 的连接关系必须和 A 表
的分布一致。</li><li>Colocate Join：通过建表时指定 A 表和 B 表是同一个 Colocate Group，意味着 A、B 表的分布完全一致，那么当 Join 的连接关系
和 A、B 表分布一致时，StarRocks 可以直接在 A、B 表的机器上直接 Join，不需要进行数据 Shuffle。</li><li>Replicate Join：StarRocks 的实验性功能，当每一台 A 表的机器上都存在一份完整的 B 表数据时，直接在本地进行 Join 操作，该
Join 的约束条件比较严格，基本上意味着 B 表的副本数需要和整个集群的机器数保持一致，所以实践意义并不理想。</li></ul><p>StarRocks 会对每个 Join 都尝试生成上述 5 种分布式 Join 计划，但是由于不同 Join 类型的语义限制，实际上一些特殊的 Join 类型
只能生成特定的分布式 Join 计划。例如，Cross Join 只能生成 Broadcast Join。</p><p>3、探索分布式 Join</p><p>StarRocks 的分布式 Join 计划，是通过一系列的 Distribution Property 推导产生的。以下述的 Join SQL 的 Shuffle Join Plan 为
例，Join 会自顶向下地向 A、B 表分别要求 Shuffle Property。</p><p>当 Scan 节点无法满足该要求时，会通过 Enforce 操作，加入一个 Shuffle 的操作节点，用于满足 Join 的要求。最后在生成执行计划
时，StarRocks 会将 Shuffle 节点“翻译”成一个 Exchange 节点，通过该节点完成网络数据的传输和交换。</p><p>其他的分布式 Join 生成方式和 Shuffle Join 类似，都是由 Join 向下要求不同的属性推导出。</p><p>Select * From A Join B on A.a = B.b</p><p>4、复杂的分布式 Join</p><p>在用户场景中，用户的 SQL 远比前面的一个 A Join B 复杂得多，可能是 3 表 Join，也可能是 4 表 Join。实际上，StarRocks 对于更
复杂的 Join，同样也会生成更复杂多样的分布式 Plan，但都是基于上述最基础的几种 Join 方式推导出来的。例如：</p><p>Select * From A Join B on A.a = B.b Join C on A.a = C.c</p><p>这里简单举几个 StarRocks 基于 Shuffle Join 和 Broadcast Join 生成的分布式 Plan：</p><p>当然，如果继续引入 Colocate Join 和 Bucket Shuffle Join，StarRocks 还可以推导出下面这样一些 Plan：</p><p>对于上面这些复杂的分布式 Join Plan，其推导原理和前面的原理几乎一致。Distribution Property 在节点间会一直向下传递，进而推
导出各种 Join 组合的分布式 Plan。具体的推导实现也可以参考 StarRocks 优化器代码导读（<a href=https://zhuanlan.zhihu.com/p/>https://zhuanlan.zhihu.com/p/</a>…）。</p><p>5、Global Runtime Filter</p><p>除了分布式 Plan 的这样一些探索外，StarRocks 在规划 Plan 时，还会结合 Join 算子的执行特点，来构造全局性的 Global Runtime
Filter 这样一个优化。StarRocks 的 Hash Join 执行过程如下：</p><ol><li><p>StarRocks 先查询得到全量的右表数据；</p></li><li><p>将右表的数据构造为一个 Hash 表；</p></li><li><p>再去拉取左表的数据；</p></li><li><p>基于 Hash 表来构建 Join 的连接关系；</p></li><li><p>输出 Join 结果。</p></li></ol><p>那么，Global Runtime Filter 的工作时机就在 Step 2 和 Step 3 之间，StarRocks 在得到右表的数据后，通过这些运行时数据构造出
来一个过滤谓词，在拉取左表数据前先将这样一个 Runime 的过滤谓词下发到左表的 Scan 节点，从而帮助左表的 Scan 节点提前过滤数
据，最终达到减少 Join 输入的目的。</p><p>目前 Global Runtime Filter 支持的过滤方式为：Min / Max、In predicate 和 Bloom Filter。示意图如下：</p><h2 id=总结>5 总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h2><p>本文讲述了 StarRocks 对 Join 查询优化的实践和探索，所有的优化都是紧贴提到的优化原则。当然，用户在自行优化 SQL 时，也完全
可以参考如下 5 点，以及 StarRocks 提供的功能进行优化。</p><ol><li>不同 Join 类型的算子，性能是不同的，尽可能使用性能高的 Join 类型，避免使用性能差的 Join 类型。根据 Join 输出的数据量，
大致的性能排序为：Semi-Join/Anti-Join > Inner Join > Outer Join > Full Outer Join > Cross Join。</li><li>Hash Join 的实现时，使用小表做 Hash 表，远比用一个大表做 Hash 表高效。</li><li>多表 Join 时，优先执行选择度高的 Join，能大幅减少后续 Join 的开销。</li><li>尽可能减少参与 Join 的数据量。</li><li>尽可能减少分布式 Join 产生的网络成本。</li></ol><p>StarRocks 在支持了那么多优化后，也有了更多的心得和更多的规划，比如：</p><ul><li>支持更多的 Join 实现方式，更智能地结合上下文选择更合适的 Join 实现算子；</li><li>结合 StarRocks 的特性，支持更多特定的 Join Reorder 算法；</li><li>尽可能地解决 Cost 估算的问题，引入更多的算法或者数据结构来确保估算结果；</li><li>支持更多调度方式，可能优化网络成本开销。</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://yangyingchao.github.io/tags/starrocks/>starrocks</a></li><li><a href=https://yangyingchao.github.io/tags/join/>join</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://yangyingchao.github.io>MyNotes</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>