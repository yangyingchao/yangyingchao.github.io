<!doctype html><html lang=zh-cn><head><title>The mapping of oid and relfilenode in PG · MyNotes</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="yyc"><meta name=description content="1 Relfilenode of ordinary table 2 Relfilenode of Nail tables 3 Nail table Relfilenode storage mechanism 4 Summary 本文为摘录，原文为： https://www.highgo.ca/2021/01/12/the-mapping-of-oid-and-relfilenode-in-pg/ A table in PostgreSQL has a relfilenode value, which specifies the file name of the table on disk (except foreign table and partition table). In general, this value can be found in the relfilenode field of the pg_class table, but there"><meta name=keywords content="blog,developer,personal"><meta name=twitter:card content="summary"><meta name=twitter:title content="The mapping of oid and relfilenode in PG"><meta name=twitter:description content="1 Relfilenode of ordinary table 2 Relfilenode of Nail tables 3 Nail table Relfilenode storage mechanism 4 Summary 本文为摘录，原文为： https://www.highgo.ca/2021/01/12/the-mapping-of-oid-and-relfilenode-in-pg/ A table in PostgreSQL has a relfilenode value, which specifies the file name of the table on disk (except foreign table and partition table). In general, this value can be found in the relfilenode field of the pg_class table, but there"><meta property="og:title" content="The mapping of oid and relfilenode in PG"><meta property="og:description" content="1 Relfilenode of ordinary table 2 Relfilenode of Nail tables 3 Nail table Relfilenode storage mechanism 4 Summary 本文为摘录，原文为： https://www.highgo.ca/2021/01/12/the-mapping-of-oid-and-relfilenode-in-pg/ A table in PostgreSQL has a relfilenode value, which specifies the file name of the table on disk (except foreign table and partition table). In general, this value can be found in the relfilenode field of the pg_class table, but there"><meta property="og:type" content="article"><meta property="og:url" content="https://yangyingchao.github.io/posts/the-mapping-of-oid-and-relfilenode-in-pg/"><meta property="article:section" content="posts"><link rel=canonical href=https://yangyingchao.github.io/posts/the-mapping-of-oid-and-relfilenode-in-pg/><link rel=preload href="/fonts/forkawesome-webfont.woff2?v=1.2.0" as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.135e22c97ff685fe983fc60048e309ced8f00d8d38f536aa67dba8a13a03dfa4.css integrity="sha256-E14iyX/2hf6YP8YASOMJztjwDY049TaqZ9uooToD36Q=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.a00e6364bacbc8266ad1cc81230774a1397198f8cfb7bcba29b7d6fcb54ce57f.css integrity="sha256-oA5jZLrLyCZq0cyBIwd0oTlxmPjPt7y6KbfW/LVM5X8=" crossorigin=anonymous media=screen><link rel=icon type=image/svg+xml href=/images/favicon.svg sizes=any><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5></head><body class="preload-transitions colorscheme-auto"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=/>MyNotes</a>
<input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/posts/>Blog</a></li><li class=navigation-item><a class=navigation-link href=/tags/>Tags</a></li><li class=navigation-item><a class=navigation-link href=/contact/>Contact me</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://yangyingchao.github.io/posts/the-mapping-of-oid-and-relfilenode-in-pg/>The mapping of oid and relfilenode in PG</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa fa-calendar" aria-hidden=true></i>
<time datetime=0001-01-01T00:00:00Z>January 1, 0001</time></span>
<span class=reading-time><i class="fa fa-clock-o" aria-hidden=true></i>
阅读时间：3 分钟</span></div><div class=tags><i class="fa fa-tag" aria-hidden=true></i>
<span class=tag><a href=/tags/tag1/>tag1</a></span>
<span class=separator>•</span>
<span class=tag><a href=/tags/tag2/>tag2</a></span></div></div></header><div class=post-content><ul><li>1 <a href=#h:1f7ebd85-1d1f-499e-9871-86c20f4dee99>Relfilenode of ordinary table</a></li><li>2 <a href=#h:26af2114-0247-479c-acda-e29244cda12e>Relfilenode of Nail tables</a></li><li>3 <a href=#h:e436403d-4da6-4ab0-945c-547dc01b1c7d>Nail table Relfilenode storage mechanism</a></li><li>4 <a href=#h:b40df967-b768-4822-96e4-8277122284f4>Summary</a></li></ul><p>本文为摘录，原文为： <a href=https://www.highgo.ca/2021/01/12/the-mapping-of-oid-and-relfilenode-in-pg/ class=external-link target=_blank rel=noopener>https://www.highgo.ca/2021/01/12/the-mapping-of-oid-and-relfilenode-in-pg/</a></p><p>A table in PostgreSQL has a relfilenode value, which specifies the file name of the table on disk (except foreign table
and partition table). In general, this value can be found in the relfilenode field of the pg_class table, but there are
some specific tables whose query result in the relfilenode field is 0. This blog will explore the kernel processing of
these special tables relfilenode.</p><h2 id=h:1f7ebd85-1d1f-499e-9871-86c20f4dee99>1 Relfilenode of ordinary table
<a class=heading-link href=#h:1f7ebd85-1d1f-499e-9871-86c20f4dee99><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h2><p>When a normal table is created in PostgreSQL, the relfilenode value of the table is stored in pg_class system table. As
it can be seen in this example that when a table is created, it’s OID and relfilenode value are both 16808. You can also
find a file on the disk with the same name as the Relfilenode node value, in-fact the data inserted for the table is
actually stored in the same file.</p><p>postgres=# create table t2(i int);
CREATE TABLE
postgres=# select oid,relname,relfilenode from pg_class where relname = &rsquo;t2&rsquo;;
oid | relname | relfilenode
&mdash;&mdash;-<del>&mdash;&mdash;&mdash;</del>&mdash;&mdash;&ndash;–—
16808 | t2 | 16808
(1 row)</p><p>postgres=# \q
movead@movead-PC:/h2/pgpgpg/bin$ ll ../data/base/12835/16808
-rw&ndash;–—+ 1 movead movead 0 12月 31 17:11 ../data/base/12835/16808
movead@movead-PC:/h2/pgpgpg/bin$</p><p>After we perform operations such as truncate, vacuum full, etc. on a table, the data in this table will be rewritten and
the value of relfilenode for this table will be changed. The following test shows that after truncate, the relfilenode
of the t2 table has changed from 16808 to 16811.</p><p>postgres=# truncate t2;
TRUNCATE TABLE
postgres=# select oid,relname,relfilenode from pg_class where relname = &rsquo;t2&rsquo;;
oid | relname | relfilenode
&mdash;&mdash;-<del>&mdash;&mdash;&mdash;</del>&mdash;&mdash;&ndash;–—
16808 | t2 | 16811
(1 row)</p><p>postgres=# checkpoint;
CHECKPOINT
postgres=# \q
movead@movead-PC:/h2/pgpgpg/bin$ ll ../data/base/12835/16808
ls: 无法访问&rsquo;../data/base/12835/16808&rsquo;: 没有那个文件或目录
movead@movead-PC:/h2/pgpgpg/bin$ ll ../data/base/12835/16811
-rw&ndash;–—+ 1 movead movead 0 12月 31 17:16 ../data/base/12835/16811
movead@movead-PC:/h2/pgpgpg/bin$</p><h2 id=h:26af2114-0247-479c-acda-e29244cda12e>2 Relfilenode of Nail tables
<a class=heading-link href=#h:26af2114-0247-479c-acda-e29244cda12e><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h2><p>postgres=# select oid, relname, relfilenode,reltablespace
from pg_class
where relfilenode = 0 and relkind = &lsquo;r&rsquo;
order by reltablespace;
oid | relname | relfilenode | reltablespace
&mdash;&mdash;<del>&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;</del>&mdash;&mdash;&ndash;–—+&mdash;&mdash;&mdash;-–—
1247 | pg_type | 0 | 0
1255 | pg_proc | 0 | 0
1249 | pg_attribute | 0 | 0
1259 | pg_class | 0 | 0
3592 | pg_shseclabel | 0 | 1664
1262 | pg_database | 0 | 1664
2964 | pg_db_role_setting | 0 | 1664
1213 | pg_tablespace | 0 | 1664
1261 | pg_auth_members | 0 | 1664
1214 | pg_shdepend | 0 | 1664
2396 | pg_shdescription | 0 | 1664
1260 | pg_authid | 0 | 1664
6000 | pg_replication_origin | 0 | 1664
6100 | pg_subscription | 0 | 1664
(14 rows)</p><p>postgres=#</p><p>It can be seen from the above query that the relfilenode of these tables queried from the pg_class catalog is 0. Among
them, pg_type, pg_proc, pg_attribute, and pg_class are non-shared tables, and they are called Nail tables in the kernel.
The remaining tables are shared tables in the pg_global tablespace.</p><p>The purpose of relfilenode field in the pg_class table is to tell the user about the file name of a given table stored
on the disk. For example, when we query the t2 table, the system must get the relfilenode from the pg_class catalog,
then find the file on the disk, open it and scan it. But if we want to query the file name of the pg_class table on
disk, where should we find its relfilenode? A set of functional interfaces is provided in PostgreSQL to convert oid and
relfilenode.</p><p>postgres=# select pg_relation_filenode(1259);
pg_relation_filenode</p><hr><pre><code>            16475
</code></pre><p>(1 row)</p><p>postgres=# select pg_filenode_relation(0,16475);
pg_filenode_relation</p><hr><p>pg_class
(1 row)</p><p>postgres=# select pg_filenode_relation(0,16475)::oid;
pg_filenode_relation</p><hr><pre><code>             1259
</code></pre><p>(1 row)</p><p>postgres=#</p><p>By call pg_relation_filenode(), oid can be converted to relfilenode, and with pg_filenode_relation(), relfilenode can be
converted to oid.</p><p>Since the corresponding relationship between oid and relfilenode for shared and nail tables are not stored in the
pg_class table, how does PostgreSQL save this mapping relationship?</p><p>nail_</p><h2 id=h:e436403d-4da6-4ab0-945c-547dc01b1c7d>3 Nail table Relfilenode storage mechanism
<a class=heading-link href=#h:e436403d-4da6-4ab0-945c-547dc01b1c7d><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h2><p>After research, it is found that there are pg_filenode.map files in the data directory, as shown below.</p><p>movead@movead-PC:/h2/pgpgpg/data/base/12835$ ll pg_filenode.map
-rw&ndash;–—+ 1 movead movead 512 12月 31 15:10 pg_filenode.map
movead@movead-PC:/h2/pgpgpg/data/base/12835$</p><p>movead@movead-PC:/h2/pgpgpg/data/global$ ll pg_filenode.map
-rw&ndash;–—+ 1 movead movead 512 12月 31 15:10 pg_filenode.map
movead@movead-PC:/h2/pgpgpg/data/global$</p><p>The mapping relationship between oid and relfilenode for shared tables is stored in pg_filenode.map file in the global
directory, and the mapping relationship between oid and relfilenode for nail tables in the database with OID 12835 is
stored in the 12835 directory.</p><p>The struct of the pg_filenode.map file is look like as blow:</p><p>typedef struct RelMapping
{
Oid mapoid; <em>* OID of a catalog *</em>
Oid mapfilenode; <em>* its filenode number *</em>
} RelMapping;</p><p>typedef struct RelMapFile
{
int32 magic; <em>* always RELMAPPER_FILEMAGIC *</em>
int32 num_mappings; <em>* number of valid RelMapping entries *</em>
RelMapping mappings[MAX_MAPPINGS];
pg_crc32c crc; <em>* CRC of all above *</em>
int32 pad; <em>* to make the struct size be 512 exactly *</em>
} RelMapFile;</p><h2 id=h:b40df967-b768-4822-96e4-8277122284f4>4 Summary
<a class=heading-link href=#h:b40df967-b768-4822-96e4-8277122284f4><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h2><p>This blog mainly explains the two different manifestations of oid and relfilenode mapping in PostgreSQL. Just remember
that using pg_relation_filenode() will always get the correct result, and query from the pg_class system table may get
the wrong result.</p><p>*
Movead Li</p><p>Movead.Li is kernel development of Highgo Software. Since joining into Highgo Software in 2016, Movead takes the most
time on researching the code of Postgres and is good at ‘Write Ahead Log’ and ‘Database Backup And Recovery’. Base on
the experience Movead has two open-source software on the Postgres database. One is Walminer which can analyze history
wal file to SQL. The other one is pg_lightool which can do a single table or block recovery base on base backup and
walfiles or walfiles only.</p><p>Hello</p><p>Now he has joined the HighGo community team and hopes to make more contributions to the community in the future.</p></div><footer></footer></article></section></div><footer class=footer><section class=container>©
2023
yyc
·
技术支持 <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/ target=_blank rel=noopener>Coder</a>.</section></footer></main><script src=/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script></body></html>