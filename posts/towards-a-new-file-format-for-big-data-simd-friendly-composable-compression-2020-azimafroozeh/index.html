<!doctype html><html lang=zh-cn dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Towards a New File Format for Big Data - SIMD-Friendly Composable Compression | MyNotes</title><meta name=keywords content="simd,compression"><meta name=description content="1 Introduction 2 Related Work 2.1 Storage Layouts 2.2 Bit-(Un)Packing 3 SIMD-Friendly Bit-(Un)Packing 4 Composable Functions 5 Composable Compression Schemes 本文为摘录，原文为： attachments/pdf/a/Towards a New File Format for Big Data - SIMD-Friendly Composable Compression (2020-AzimAfroozeh).pdf 1 Introduction 2 Related Work 2.1 Storage Layouts 2.1.1 NSM 传统上，在数据库系统中，表格数据通"><meta name=author content><link rel=canonical href=https://yangyingchao.github.io/posts/towards-a-new-file-format-for-big-data-simd-friendly-composable-compression-2020-azimafroozeh/><link crossorigin=anonymous href=/assets/css/stylesheet.6a98292fb8fa8cf0f3ba4042d4b75515c04267550f3ad49ff6271b5af9562443.css integrity="sha256-apgpL7j6jPDzukBC1LdVFcBCZ1UPOtSf9icbWvlWJEM=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://yangyingchao.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://yangyingchao.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://yangyingchao.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://yangyingchao.github.io/apple-touch-icon.png><link rel=mask-icon href=https://yangyingchao.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Towards a New File Format for Big Data - SIMD-Friendly Composable Compression"><meta property="og:description" content="1 Introduction 2 Related Work 2.1 Storage Layouts 2.2 Bit-(Un)Packing 3 SIMD-Friendly Bit-(Un)Packing 4 Composable Functions 5 Composable Compression Schemes 本文为摘录，原文为： attachments/pdf/a/Towards a New File Format for Big Data - SIMD-Friendly Composable Compression (2020-AzimAfroozeh).pdf 1 Introduction 2 Related Work 2.1 Storage Layouts 2.1.1 NSM 传统上，在数据库系统中，表格数据通"><meta property="og:type" content="article"><meta property="og:url" content="https://yangyingchao.github.io/posts/towards-a-new-file-format-for-big-data-simd-friendly-composable-compression-2020-azimafroozeh/"><meta property="article:section" content="posts"><meta name=twitter:card content="summary"><meta name=twitter:title content="Towards a New File Format for Big Data - SIMD-Friendly Composable Compression"><meta name=twitter:description content="1 Introduction 2 Related Work 2.1 Storage Layouts 2.2 Bit-(Un)Packing 3 SIMD-Friendly Bit-(Un)Packing 4 Composable Functions 5 Composable Compression Schemes 本文为摘录，原文为： attachments/pdf/a/Towards a New File Format for Big Data - SIMD-Friendly Composable Compression (2020-AzimAfroozeh).pdf 1 Introduction 2 Related Work 2.1 Storage Layouts 2.1.1 NSM 传统上，在数据库系统中，表格数据通"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://yangyingchao.github.io/posts/"},{"@type":"ListItem","position":3,"name":"Towards a New File Format for Big Data - SIMD-Friendly Composable Compression","item":"https://yangyingchao.github.io/posts/towards-a-new-file-format-for-big-data-simd-friendly-composable-compression-2020-azimafroozeh/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Towards a New File Format for Big Data - SIMD-Friendly Composable Compression","name":"Towards a New File Format for Big Data - SIMD-Friendly Composable Compression","description":"1 Introduction 2 Related Work 2.1 Storage Layouts 2.2 Bit-(Un)Packing 3 SIMD-Friendly Bit-(Un)Packing 4 Composable Functions 5 Composable Compression Schemes 本文为摘录，原文为： attachments/pdf/a/Towards a New File Format for Big Data - SIMD-Friendly Composable Compression (2020-AzimAfroozeh).pdf 1 Introduction 2 Related Work 2.1 Storage Layouts 2.1.1 NSM 传统上，在数据库系统中，表格数据通","keywords":["simd","compression"],"articleBody":" 1 Introduction 2 Related Work 2.1 Storage Layouts 2.2 Bit-(Un)Packing 3 SIMD-Friendly Bit-(Un)Packing 4 Composable Functions 5 Composable Compression Schemes 本文为摘录，原文为： attachments/pdf/a/Towards a New File Format for Big Data - SIMD-Friendly Composable Compression (2020-AzimAfroozeh).pdf\n1 Introduction 2 Related Work 2.1 Storage Layouts 2.1.1 NSM 传统上，在数据库系统中，表格数据通常按照磁盘页的起始行逐行存储。这种存储方式被称为 N-ary 存储模型（NSM）。如图 2.1 所示，如果元组大小是可变的，NSM 可能会在页面末尾使用偏移表来定 位每个元组的起始位置。此外，每个元组都以元组头（RH）开头，包含有关元组的信息。RH 以空位图 开头，用于支持空值；以偏移量开头，用于支持可变属性的变量长度值；以及其他实现特定的细节， 以使布局更加灵活。\n2.1.2 DSM 这段文字介绍了分解存储模型（DSM）和它与非分解存储模型（NSM）的比较。DSM 将数据按列存储， 只提供需要的属性。与 NSM 相比，DSM 提供更高效的缓存利用，因为属性值聚集在一起。此外，由于相 邻元组的相似性，DSM 相比 NSM 提供更多的压缩机会。\n2.1.3 PAX 这段文字介绍了在处理在线分析处理（OLAP）工作负载时，DSM 是更好的模型。但是，如果需要重构 整个元组，DSM 会产生性能开销，因为需要在运行时显式地进行元组重构。Ailamaki 等人提出了“跨分 区属性”（PAX）技术，该技术结合了 DSM 的元组间空间局部性和 NSM 的低元组重构成本。PAX 将元组的 所有属性存储在同一个页面中。但是，在页面内，PAX 按列存储所有属性。\n2.2 Bit-(Un)Packing 32 位系统架构中，整数通常使用 32 位存储，尽管可能可以使用更少的位来存储它们。例如，具有 值为 70（0b1000110）的 32 位整数可以使用 7 位而不是 32 位进行存储。一般来说，在[0，2b]范 围内的整数可以使用 b 位编码并连接成一个单独的位字符串。这个过程被称为 位填充 (bit-packing) 。反向操作，即将位字符串转换回可由机器寻址的整数数组的操作被称为 位取消填 充 , bit-unpacking 。位取消填充可以使用五个简单的操作（加载、移位、与、或和存储）来提取 每个整数，如图 2.3 所示。\n在将 32 位数据加载到 CPU 寄存器中之后，使用右移操作将期望的位放置到寄存器的开头。此外，使用 预定义的掩码寄存器进行按位 AND 操作（用 0 表示随机位，用 1 表示期望的位），可以将具有任意值的 位更改为 0。这种实现效率高，因为它不涉及任何分支。\nBit Alignment: 2.2.1 Vectorized Bit-Unpacking Willhaml 等提出了一个方法来通过 SIMD 来批量 bitunpack:\n16-Byte Alignment: 通过 128 位的 SIMD aligned load 从内存中加载 128-bit 的数据 使用一个 128 位的 SIMD 对齐加载指令从内存中加载 128 位的数据。对于一些位宽值，比如 9， 第一个整数值可能不完全加载，因为它跨越了两个 128 位的寄存器。为了处理这些情况，作者更 喜欢使用一个 128 位 SIMD 寄存器串联指令，而不是 128 位 SIMD 不对齐加载指令，因为 SIMD 不对齐的指令在旧处理器上的计算成本高昂。\n4-Byte Alignment: four compressed integer values are copied to four separate 32-bit lanes in a new register using a SIMD shuffle mask instruction.\n使用 SIMD 洗牌掩码指令将四个压缩整数值复制到新寄存器中的四个独立的 32 位通道。\nBit Alignment: 通过将每个语段任意移动几次，通过 SIMD 乘以四个不同整数和一个 SIMD 右移 指令将最后一个寄存器中的四个整数的每个语段的第一位对齐。\n然而，Willhalm 等人的方法仅适用于 SSE，无法扩展到 AVX2，因为 Shuffle 指令无法跨所有 lane 移动字节。\nPolychroniou 等人提出了一项更改，以调整 Willhalm 等人的方法以适用于 AVX2（33）。 为了模拟 256 位跨 lane Shuffle，我们可以将寄存器的每个半段（128 位）复制到两个半段，并使用常规的 256 位 Shuffle。 此外，Willhalm 等人将他们的位解压实现翻译为英特尔 AVX2 指令（34）。 在 Willhalm 的新实现中，模拟的移位操作被 AVX2 矢量-矢量移位指令所取代。 此外，与他们之前的实现相反，新的实现使用非对齐加载指令而不是对齐加载指令，因为他们声称对于当前架构， 这个指令比对齐加载指令更快。只有在数据加载分裂跨越缓存线时才会有性能损失，这被其他情况下的减少所分摊。\n除了水平布局（即连续存储元组）外，Schlegel 等人提出了一种称为垂直布局的替代布局（2）。在 k-垂直布局中，k个连续的位压缩元组存储在不同的存储字中。\n图 2.4 显示了一个 4 路垂直布局的示例，其中每个数字表示序列中整数的位置。可以看到，每 4 个连续整数分布在 4 个不同的字中。垂直布局使我们能够使用单个加载/存储 SIMD 指令加载/存储 压缩数据，而无需使用置换指令将元组分配到 SIMD lane 中。Lemire 等人使用 4 路垂直布局使用 相同的位宽位压缩 128 个元组，以利用 SSE SIMD 指令（35）。\n3 SIMD-Friendly Bit-(Un)Packing In this chapter we present our 1024-bit interleaved bit-(un)packing technique. As discussed in Section 2.2.1, the most efficient Bit-(un)packing approach is proposed by Lemire et al. (35), which uses a 4-way vertical layout.\n在本章中，我们介绍了我们的 1024 位交错位（非）打包技术。正如第 2.2.1 节 所讨论的那样，Lemire 等人（35）提出了最有效的位（非）打包方法，采用 4 路垂直布局。\n4 Composable Functions 5 Composable Compression Schemes ","wordCount":"1813","inLanguage":"zh-cn","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://yangyingchao.github.io/posts/towards-a-new-file-format-for-big-data-simd-friendly-composable-compression-2020-azimafroozeh/"},"publisher":{"@type":"Organization","name":"MyNotes","logo":{"@type":"ImageObject","url":"https://yangyingchao.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://yangyingchao.github.io accesskey=h title="MyNotes (Alt + H)">MyNotes</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://yangyingchao.github.io/ title=Home><span>Home</span></a></li><li><a href=https://yangyingchao.github.io/posts/ title=Archives><span>Archives</span></a></li><li><a href=https://yangyingchao.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://yangyingchao.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://yangyingchao.github.io/contact/ title="Contact me"><span>Contact me</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Towards a New File Format for Big Data - SIMD-Friendly Composable Compression</h1><div class=post-meta></div></header><div class=post-content><ul><li>1 <a href=#h:580c0cb0-61f9-4a43-ac02-4fad348cc20a>Introduction</a></li><li>2 <a href=#h:03a34d6a-6bc6-438c-8f2d-9edd1ffaacdf>Related Work</a><ul><li>2.1 <a href=#h:0f05328b-cb9e-4cd6-98de-0224bc4b0b1b>Storage Layouts</a></li><li>2.2 <a href=#h:ed60df52-edbb-4a50-97fc-7fdb583c275c>Bit-(Un)Packing</a></li></ul></li><li>3 <a href=#h:d68b112b-a914-43aa-8e0f-d15256f92412>SIMD-Friendly Bit-(Un)Packing</a></li><li>4 <a href=#h:f92acd3a-f139-465a-9376-9098f4ed8ed4>Composable Functions</a></li><li>5 <a href=#h:a085ae14-3c24-42f3-8747-92eef98eda99>Composable Compression Schemes</a></li></ul><p>本文为摘录，原文为： attachments/pdf/a/Towards a New File Format for Big Data - SIMD-Friendly Composable Compression (2020-AzimAfroozeh).pdf</p><h2 id=h:580c0cb0-61f9-4a43-ac02-4fad348cc20a>1 Introduction<a hidden class=anchor aria-hidden=true href=#h:580c0cb0-61f9-4a43-ac02-4fad348cc20a>#</a></h2><h2 id=h:03a34d6a-6bc6-438c-8f2d-9edd1ffaacdf>2 Related Work<a hidden class=anchor aria-hidden=true href=#h:03a34d6a-6bc6-438c-8f2d-9edd1ffaacdf>#</a></h2><h3 id=h:0f05328b-cb9e-4cd6-98de-0224bc4b0b1b>2.1 Storage Layouts<a hidden class=anchor aria-hidden=true href=#h:0f05328b-cb9e-4cd6-98de-0224bc4b0b1b>#</a></h3><h4 id=h:afb0adde-6373-4a75-bcca-8531a04288a3>2.1.1 NSM<a hidden class=anchor aria-hidden=true href=#h:afb0adde-6373-4a75-bcca-8531a04288a3>#</a></h4><p>传统上，在数据库系统中，表格数据通常按照磁盘页的起始行逐行存储。这种存储方式被称为 N-ary
存储模型（NSM）。如图 2.1 所示，如果元组大小是可变的，NSM 可能会在页面末尾使用偏移表来定
位每个元组的起始位置。此外，每个元组都以元组头（RH）开头，包含有关元组的信息。RH 以空位图
开头，用于支持空值；以偏移量开头，用于支持可变属性的变量长度值；以及其他实现特定的细节，
以使布局更加灵活。</p><p></p><figure><img loading=lazy src=/ox-hugo/screenshot@2023-06-21_14:46:46.png></figure><h4 id=h:1116bf3c-43b2-43d0-8f73-83bb63e639e9>2.1.2 DSM<a hidden class=anchor aria-hidden=true href=#h:1116bf3c-43b2-43d0-8f73-83bb63e639e9>#</a></h4><p>这段文字介绍了分解存储模型（DSM）和它与非分解存储模型（NSM）的比较。DSM 将数据按列存储，
只提供需要的属性。与 NSM 相比，DSM 提供更高效的缓存利用，因为属性值聚集在一起。此外，由于相
邻元组的相似性，DSM 相比 NSM 提供更多的压缩机会。</p><h4 id=h:73aa13b1-86f3-42bd-8933-8b331740ac35>2.1.3 PAX<a hidden class=anchor aria-hidden=true href=#h:73aa13b1-86f3-42bd-8933-8b331740ac35>#</a></h4><p>这段文字介绍了在处理在线分析处理（OLAP）工作负载时，DSM 是更好的模型。但是，如果需要重构
整个元组，DSM 会产生性能开销，因为需要在运行时显式地进行元组重构。Ailamaki 等人提出了“跨分
区属性”（PAX）技术，该技术结合了 DSM 的元组间空间局部性和 NSM 的低元组重构成本。PAX 将元组的
所有属性存储在同一个页面中。但是，在页面内，PAX 按列存储所有属性。</p><p></p><figure><img loading=lazy src=/ox-hugo/screenshot@2023-06-21_14:50:20.png></figure><h3 id=h:ed60df52-edbb-4a50-97fc-7fdb583c275c>2.2 Bit-(Un)Packing<a hidden class=anchor aria-hidden=true href=#h:ed60df52-edbb-4a50-97fc-7fdb583c275c>#</a></h3><p>32 位系统架构中，整数通常使用 32 位存储，尽管可能可以使用更少的位来存储它们。例如，具有
值为 70（0b1000110）的 32 位整数可以使用 7 位而不是 32 位进行存储。一般来说，在[0，2b]范
围内的整数可以使用 b 位编码并连接成一个单独的位字符串。这个过程被称为 <code>位填充</code>
(bit-packing) 。反向操作，即将位字符串转换回可由机器寻址的整数数组的操作被称为 <code>位取消填 充</code> , bit-unpacking 。位取消填充可以使用五个简单的操作（加载、移位、与、或和存储）来提取
每个整数，如图 2.3 所示。</p><p>在将 32 位数据加载到 CPU 寄存器中之后，使用右移操作将期望的位放置到寄存器的开头。此外，使用
预定义的掩码寄存器进行按位 AND 操作（用 0 表示随机位，用 1 表示期望的位），可以将具有任意值的
位更改为 0。这种实现效率高，因为它不涉及任何分支。</p><p></p><figure><img loading=lazy src=/ox-hugo/screenshot@2023-09-12_16:02:42.png width=800px></figure><ul><li>Bit Alignment:</li></ul><h4 id=h:5a388ec5-7e4f-493a-b9f5-4abac30ce812>2.2.1 Vectorized Bit-Unpacking<a hidden class=anchor aria-hidden=true href=#h:5a388ec5-7e4f-493a-b9f5-4abac30ce812>#</a></h4><p>Willhaml 等提出了一个方法来通过 SIMD 来批量 bitunpack:</p><ul><li><p>16-Byte Alignment: 通过 128 位的 SIMD aligned load 从内存中加载 128-bit 的数据
使用一个 128 位的 SIMD 对齐加载指令从内存中加载 128 位的数据。对于一些位宽值，比如 9，
第一个整数值可能不完全加载，因为它跨越了两个 128 位的寄存器。为了处理这些情况，作者更
喜欢使用一个 128 位 SIMD 寄存器串联指令，而不是 128 位 SIMD 不对齐加载指令，因为 SIMD
不对齐的指令在旧处理器上的计算成本高昂。</p></li><li><p>4-Byte Alignment: four compressed integer values are copied to four separate 32-bit
lanes in a new register using a SIMD shuffle mask instruction.</p><p>使用 SIMD 洗牌掩码指令将四个压缩整数值复制到新寄存器中的四个独立的 32 位通道。</p></li><li><p>Bit Alignment: 通过将每个语段任意移动几次，通过 SIMD 乘以四个不同整数和一个 SIMD 右移
指令将最后一个寄存器中的四个整数的每个语段的第一位对齐。</p></li></ul><p>然而，Willhalm 等人的方法仅适用于 SSE，无法扩展到 AVX2，因为 Shuffle 指令无法跨所有 lane 移动字节。</p><p>Polychroniou 等人提出了一项更改，以调整 Willhalm 等人的方法以适用于 AVX2（33）。
为了模拟 256 位跨 lane Shuffle，我们可以将寄存器的每个半段（128 位）复制到两个半段，并使用常规的 256 位 Shuffle。
此外，Willhalm 等人将他们的位解压实现翻译为英特尔 AVX2 指令（34）。
在 Willhalm 的新实现中，模拟的移位操作被 AVX2 矢量-矢量移位指令所取代。
此外，与他们之前的实现相反，新的实现使用非对齐加载指令而不是对齐加载指令，因为他们声称对于当前架构，
这个指令比对齐加载指令更快。只有在数据加载分裂跨越缓存线时才会有性能损失，这被其他情况下的减少所分摊。</p><p>除了水平布局（即连续存储元组）外，Schlegel 等人提出了一种称为垂直布局的替代布局（2）。在
k-垂直布局中，k个连续的位压缩元组存储在不同的存储字中。</p><p>图 2.4 显示了一个 4 路垂直布局的示例，其中每个数字表示序列中整数的位置。可以看到，每 4
个连续整数分布在 4 个不同的字中。垂直布局使我们能够使用单个加载/存储 SIMD 指令加载/存储
压缩数据，而无需使用置换指令将元组分配到 SIMD lane 中。Lemire 等人使用 4 路垂直布局使用
相同的位宽位压缩 128 个元组，以利用 SSE SIMD 指令（35）。</p><h2 id=h:d68b112b-a914-43aa-8e0f-d15256f92412>3 SIMD-Friendly Bit-(Un)Packing<a hidden class=anchor aria-hidden=true href=#h:d68b112b-a914-43aa-8e0f-d15256f92412>#</a></h2><p>In this chapter we present our 1024-bit interleaved bit-(un)packing technique. As discussed
in Section 2.2.1, the most efficient Bit-(un)packing approach is proposed by Lemire et
al. (35), which uses a 4-way vertical layout.</p><p>在本章中，我们介绍了我们的 1024 位交错位（非）打包技术。正如第 2.2.1 节
所讨论的那样，Lemire 等人（35）提出了最有效的位（非）打包方法，采用 4 路垂直布局。</p><h2 id=h:f92acd3a-f139-465a-9376-9098f4ed8ed4>4 Composable Functions<a hidden class=anchor aria-hidden=true href=#h:f92acd3a-f139-465a-9376-9098f4ed8ed4>#</a></h2><h2 id=h:a085ae14-3c24-42f3-8747-92eef98eda99>5 Composable Compression Schemes<a hidden class=anchor aria-hidden=true href=#h:a085ae14-3c24-42f3-8747-92eef98eda99>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://yangyingchao.github.io/tags/simd/>simd</a></li><li><a href=https://yangyingchao.github.io/tags/compression/>compression</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://yangyingchao.github.io>MyNotes</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>