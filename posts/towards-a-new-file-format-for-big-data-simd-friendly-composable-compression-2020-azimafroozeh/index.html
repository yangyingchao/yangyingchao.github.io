<!doctype html><html lang=zh-cn dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Towards a New File Format for Big Data - SIMD-Friendly Composable Compression | MyNotes</title><meta name=keywords content="simd,compression"><meta name=description content="1 Introduction 2 Related Work 2.1 Storage Layouts 2.2 Bit-(Un)Packing 3 SIMD-Friendly Bit-(Un)Packing 4 Composable Functions 5 Composable Compression Schemes 1 Introduction 2 Related Work 2.1 Storage Layouts 2.1.1 NSM 传统上，在数据库系统中，表格数据通常按照磁盘页的起始行逐行存储。这种存储方式被称"><meta name=author content><link rel=canonical href=https://yangyingchao.github.io/posts/towards-a-new-file-format-for-big-data-simd-friendly-composable-compression-2020-azimafroozeh/><link crossorigin=anonymous href=/assets/css/stylesheet.6a98292fb8fa8cf0f3ba4042d4b75515c04267550f3ad49ff6271b5af9562443.css integrity="sha256-apgpL7j6jPDzukBC1LdVFcBCZ1UPOtSf9icbWvlWJEM=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://yangyingchao.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://yangyingchao.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://yangyingchao.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://yangyingchao.github.io/apple-touch-icon.png><link rel=mask-icon href=https://yangyingchao.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Towards a New File Format for Big Data - SIMD-Friendly Composable Compression"><meta property="og:description" content="1 Introduction 2 Related Work 2.1 Storage Layouts 2.2 Bit-(Un)Packing 3 SIMD-Friendly Bit-(Un)Packing 4 Composable Functions 5 Composable Compression Schemes 1 Introduction 2 Related Work 2.1 Storage Layouts 2.1.1 NSM 传统上，在数据库系统中，表格数据通常按照磁盘页的起始行逐行存储。这种存储方式被称"><meta property="og:type" content="article"><meta property="og:url" content="https://yangyingchao.github.io/posts/towards-a-new-file-format-for-big-data-simd-friendly-composable-compression-2020-azimafroozeh/"><meta property="article:section" content="posts"><meta name=twitter:card content="summary"><meta name=twitter:title content="Towards a New File Format for Big Data - SIMD-Friendly Composable Compression"><meta name=twitter:description content="1 Introduction 2 Related Work 2.1 Storage Layouts 2.2 Bit-(Un)Packing 3 SIMD-Friendly Bit-(Un)Packing 4 Composable Functions 5 Composable Compression Schemes 1 Introduction 2 Related Work 2.1 Storage Layouts 2.1.1 NSM 传统上，在数据库系统中，表格数据通常按照磁盘页的起始行逐行存储。这种存储方式被称"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://yangyingchao.github.io/posts/"},{"@type":"ListItem","position":3,"name":"Towards a New File Format for Big Data - SIMD-Friendly Composable Compression","item":"https://yangyingchao.github.io/posts/towards-a-new-file-format-for-big-data-simd-friendly-composable-compression-2020-azimafroozeh/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Towards a New File Format for Big Data - SIMD-Friendly Composable Compression","name":"Towards a New File Format for Big Data - SIMD-Friendly Composable Compression","description":"1 Introduction 2 Related Work 2.1 Storage Layouts 2.2 Bit-(Un)Packing 3 SIMD-Friendly Bit-(Un)Packing 4 Composable Functions 5 Composable Compression Schemes 1 Introduction 2 Related Work 2.1 Storage Layouts 2.1.1 NSM 传统上，在数据库系统中，表格数据通常按照磁盘页的起始行逐行存储。这种存储方式被称","keywords":["simd","compression"],"articleBody":" 1 Introduction 2 Related Work 2.1 Storage Layouts 2.2 Bit-(Un)Packing 3 SIMD-Friendly Bit-(Un)Packing 4 Composable Functions 5 Composable Compression Schemes 1 Introduction 2 Related Work 2.1 Storage Layouts 2.1.1 NSM 传统上，在数据库系统中，表格数据通常按照磁盘页的起始行逐行存储。这种存储方式被称为 N-ary 存储模型（NSM）。如图 2.1 所示，如果元组大小是可变的，NSM 可能会在页面末尾使用偏移表来定 位每个元组的起始位置。此外，每个元组都以元组头（RH）开头，包含有关元组的信息。RH 以空位图 开头，用于支持空值；以偏移量开头，用于支持可变属性的变量长度值；以及其他实现特定的细节， 以使布局更加灵活。\n2.1.2 DSM 这段文字介绍了分解存储模型（DSM）和它与非分解存储模型（NSM）的比较。DSM 将数据按列存储， 只提供需要的属性。与 NSM 相比，DSM 提供更高效的缓存利用，因为属性值聚集在一起。此外，由于相 邻元组的相似性，DSM 相比 NSM 提供更多的压缩机会。\n2.1.3 PAX 这段文字介绍了在处理在线分析处理（OLAP）工作负载时，DSM 是更好的模型。但是，如果需要重构 整个元组，DSM 会产生性能开销，因为需要在运行时显式地进行元组重构。Ailamaki 等人提出了“跨分 区属性”（PAX）技术，该技术结合了 DSM 的元组间空间局部性和 NSM 的低元组重构成本。PAX 将元组的 所有属性存储在同一个页面中。但是，在页面内，PAX 按列存储所有属性。\n2.2 Bit-(Un)Packing 32 位系统架构中，整数通常使用 32 位存储，尽管可能可以使用更少的位来存储它们。例如，具有 值为 70（0b1000110）的 32 位整数可以使用 7 位而不是 32 位进行存储。一般来说，在[0，2b]范 围内的整数可以使用 b 位编码并连接成一个单独的位字符串。这个过程被称为位填充。反向操作，即 将位字符串转换回可由机器寻址的整数数组的操作被称为位取消填充。位取消填充可以使用五个简单 的操作（加载、移位、与、或和存储）来提取每个整数，如图 2.3 所示。\n3 SIMD-Friendly Bit-(Un)Packing In this chapter we present our 1024-bit interleaved bit-(un)packing technique. As discussed in Section 2.2.1, the most efficient Bit-(un)packing approach is proposed by Lemire et al. (35), which uses a 4-way vertical layout.\n在本章中，我们介绍了我们的 1024 位交错位（非）打包技术。正如第 2.2.1 节 所讨论的那样，Lemire 等人（35）提出了最有效的位（非）打包方法，采用 4 路垂直布局。\n4 Composable Functions 5 Composable Compression Schemes ","wordCount":"844","inLanguage":"zh-cn","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://yangyingchao.github.io/posts/towards-a-new-file-format-for-big-data-simd-friendly-composable-compression-2020-azimafroozeh/"},"publisher":{"@type":"Organization","name":"MyNotes","logo":{"@type":"ImageObject","url":"https://yangyingchao.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://yangyingchao.github.io accesskey=h title="MyNotes (Alt + H)">MyNotes</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Towards a New File Format for Big Data - SIMD-Friendly Composable Compression</h1><div class=post-meta></div></header><div class=post-content><ul><li>1 <a href=#h:580c0cb0-61f9-4a43-ac02-4fad348cc20a>Introduction</a></li><li>2 <a href=#h:03a34d6a-6bc6-438c-8f2d-9edd1ffaacdf>Related Work</a><ul><li>2.1 <a href=#h:0f05328b-cb9e-4cd6-98de-0224bc4b0b1b>Storage Layouts</a></li><li>2.2 <a href=#h:ed60df52-edbb-4a50-97fc-7fdb583c275c>Bit-(Un)Packing</a></li></ul></li><li>3 <a href=#h:d68b112b-a914-43aa-8e0f-d15256f92412>SIMD-Friendly Bit-(Un)Packing</a></li><li>4 <a href=#h:f92acd3a-f139-465a-9376-9098f4ed8ed4>Composable Functions</a></li><li>5 <a href=#h:a085ae14-3c24-42f3-8747-92eef98eda99>Composable Compression Schemes</a></li></ul><h2 id=h:580c0cb0-61f9-4a43-ac02-4fad348cc20a>1 Introduction<a hidden class=anchor aria-hidden=true href=#h:580c0cb0-61f9-4a43-ac02-4fad348cc20a>#</a></h2><h2 id=h:03a34d6a-6bc6-438c-8f2d-9edd1ffaacdf>2 Related Work<a hidden class=anchor aria-hidden=true href=#h:03a34d6a-6bc6-438c-8f2d-9edd1ffaacdf>#</a></h2><h3 id=h:0f05328b-cb9e-4cd6-98de-0224bc4b0b1b>2.1 Storage Layouts<a hidden class=anchor aria-hidden=true href=#h:0f05328b-cb9e-4cd6-98de-0224bc4b0b1b>#</a></h3><h4 id=h:afb0adde-6373-4a75-bcca-8531a04288a3>2.1.1 NSM<a hidden class=anchor aria-hidden=true href=#h:afb0adde-6373-4a75-bcca-8531a04288a3>#</a></h4><p>传统上，在数据库系统中，表格数据通常按照磁盘页的起始行逐行存储。这种存储方式被称为 N-ary
存储模型（NSM）。如图 2.1 所示，如果元组大小是可变的，NSM 可能会在页面末尾使用偏移表来定
位每个元组的起始位置。此外，每个元组都以元组头（RH）开头，包含有关元组的信息。RH 以空位图
开头，用于支持空值；以偏移量开头，用于支持可变属性的变量长度值；以及其他实现特定的细节，
以使布局更加灵活。</p><p></p><figure><img loading=lazy src=/ox-hugo/screenshot@2023-06-21_14:46:46.png></figure><h4 id=h:1116bf3c-43b2-43d0-8f73-83bb63e639e9>2.1.2 DSM<a hidden class=anchor aria-hidden=true href=#h:1116bf3c-43b2-43d0-8f73-83bb63e639e9>#</a></h4><p>这段文字介绍了分解存储模型（DSM）和它与非分解存储模型（NSM）的比较。DSM 将数据按列存储，
只提供需要的属性。与 NSM 相比，DSM 提供更高效的缓存利用，因为属性值聚集在一起。此外，由于相
邻元组的相似性，DSM 相比 NSM 提供更多的压缩机会。</p><h4 id=h:73aa13b1-86f3-42bd-8933-8b331740ac35>2.1.3 PAX<a hidden class=anchor aria-hidden=true href=#h:73aa13b1-86f3-42bd-8933-8b331740ac35>#</a></h4><p>这段文字介绍了在处理在线分析处理（OLAP）工作负载时，DSM 是更好的模型。但是，如果需要重构
整个元组，DSM 会产生性能开销，因为需要在运行时显式地进行元组重构。Ailamaki 等人提出了“跨分
区属性”（PAX）技术，该技术结合了 DSM 的元组间空间局部性和 NSM 的低元组重构成本。PAX 将元组的
所有属性存储在同一个页面中。但是，在页面内，PAX 按列存储所有属性。</p><p></p><figure><img loading=lazy src=/ox-hugo/screenshot@2023-06-21_14:50:20.png></figure><h3 id=h:ed60df52-edbb-4a50-97fc-7fdb583c275c>2.2 Bit-(Un)Packing<a hidden class=anchor aria-hidden=true href=#h:ed60df52-edbb-4a50-97fc-7fdb583c275c>#</a></h3><p>32 位系统架构中，整数通常使用 32 位存储，尽管可能可以使用更少的位来存储它们。例如，具有
值为 70（0b1000110）的 32 位整数可以使用 7 位而不是 32 位进行存储。一般来说，在[0，2b]范
围内的整数可以使用 b 位编码并连接成一个单独的位字符串。这个过程被称为位填充。反向操作，即
将位字符串转换回可由机器寻址的整数数组的操作被称为位取消填充。位取消填充可以使用五个简单
的操作（加载、移位、与、或和存储）来提取每个整数，如图 2.3 所示。</p><h2 id=h:d68b112b-a914-43aa-8e0f-d15256f92412>3 SIMD-Friendly Bit-(Un)Packing<a hidden class=anchor aria-hidden=true href=#h:d68b112b-a914-43aa-8e0f-d15256f92412>#</a></h2><p>In this chapter we present our 1024-bit interleaved bit-(un)packing technique. As discussed
in Section 2.2.1, the most efficient Bit-(un)packing approach is proposed by Lemire et
al. (35), which uses a 4-way vertical layout.</p><p>在本章中，我们介绍了我们的 1024 位交错位（非）打包技术。正如第 2.2.1 节
所讨论的那样，Lemire 等人（35）提出了最有效的位（非）打包方法，采用 4 路垂直布局。</p><h2 id=h:f92acd3a-f139-465a-9376-9098f4ed8ed4>4 Composable Functions<a hidden class=anchor aria-hidden=true href=#h:f92acd3a-f139-465a-9376-9098f4ed8ed4>#</a></h2><h2 id=h:a085ae14-3c24-42f3-8747-92eef98eda99>5 Composable Compression Schemes<a hidden class=anchor aria-hidden=true href=#h:a085ae14-3c24-42f3-8747-92eef98eda99>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://yangyingchao.github.io/tags/simd/>simd</a></li><li><a href=https://yangyingchao.github.io/tags/compression/>compression</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://yangyingchao.github.io>MyNotes</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>