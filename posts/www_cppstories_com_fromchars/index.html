<!doctype html><html lang=zh-cn dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>C++ String Conversion: Exploring std::from_chars in C++17 to C++26 | MyNotes</title><meta name=keywords content="cpp,string,convert"><meta name=description content="1 Before C++17 2 Converting From Characters to Numbers: from_chars 2.1 示例 3 性能 4 C++23 更新 5 C++26 更新 6 C++ 中对 std::from_chars 的编译器支持 7 总结 本文为摘录，原文为： https://www.cppstories.com/2018/12/fromchars/ 随着引入 C++17，C++标准库通过添加 std::from_chars"><meta name=author content="Yang Yingchao"><link rel=canonical href=https://yangyingchao.github.io/posts/www_cppstories_com_fromchars/><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://yangyingchao.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://yangyingchao.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://yangyingchao.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://yangyingchao.github.io/apple-touch-icon.png><link rel=mask-icon href=https://yangyingchao.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="C++ String Conversion: Exploring std::from_chars in C++17 to C++26"><meta property="og:description" content="1 Before C++17 2 Converting From Characters to Numbers: from_chars 2.1 示例 3 性能 4 C++23 更新 5 C++26 更新 6 C++ 中对 std::from_chars 的编译器支持 7 总结 本文为摘录，原文为： https://www.cppstories.com/2018/12/fromchars/ 随着引入 C++17，C++标准库通过添加 std::from_chars"><meta property="og:type" content="article"><meta property="og:url" content="https://yangyingchao.github.io/posts/www_cppstories_com_fromchars/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-10-14T00:00:00+00:00"><meta property="article:modified_time" content="2024-10-14T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="C++ String Conversion: Exploring std::from_chars in C++17 to C++26"><meta name=twitter:description content="1 Before C++17 2 Converting From Characters to Numbers: from_chars 2.1 示例 3 性能 4 C++23 更新 5 C++26 更新 6 C++ 中对 std::from_chars 的编译器支持 7 总结 本文为摘录，原文为： https://www.cppstories.com/2018/12/fromchars/ 随着引入 C++17，C++标准库通过添加 std::from_chars"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://yangyingchao.github.io/posts/"},{"@type":"ListItem","position":2,"name":"C++ String Conversion: Exploring std::from_chars in C++17 to C++26","item":"https://yangyingchao.github.io/posts/www_cppstories_com_fromchars/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"C++ String Conversion: Exploring std::from_chars in C++17 to C++26","name":"C\u002b\u002b String Conversion: Exploring std::from_chars in C\u002b\u002b17 to C\u002b\u002b26","description":"1 Before C++17 2 Converting From Characters to Numbers: from_chars 2.1 示例 3 性能 4 C++23 更新 5 C++26 更新 6 C++ 中对 std::from_chars 的编译器支持 7 总结 本文为摘录，原文为： https://www.cppstories.com/2018/12/fromchars/ 随着引入 C++17，C++标准库通过添加 std::from_chars","keywords":["cpp","string","convert"],"articleBody":" 1 Before C++17 2 Converting From Characters to Numbers: from_chars 2.1 示例 3 性能 4 C++23 更新 5 C++26 更新 6 C++ 中对 std::from_chars 的编译器支持 7 总结 本文为摘录，原文为： https://www.cppstories.com/2018/12/fromchars/\n随着引入 C++17，C++标准库通过添加 std::from_chars 来扩展了将文本转换为数字的功能。这个低级、高性能的 API 相较 于以前的方法（如 atoi 和 stringstream）提供了显著的优势。在本文中，我们将探讨从 C++17 到 C++26 的字符串转换程序 的演变，重点突出了诸如 constexpr 支持和改进的错误处理等关键改进。让我们深入了解细节，看看 std::from_chars 如何 可以改变您对字符串转换的方法。\n1 Before C++17 sprintf / snprintf sscanf atol strtol strstream stringstream to_string stoi 等函数 而在 C++17 中，新增了一种选项： std::from_chars ！为什么需要新方法？难道旧方法不够好吗？\n新的转换例程具有以下特点：\n不抛出异常 不分配内存 不支持本地化 内存安全 错误报告提供有关转换结果的额外信息 虽然 API 可能不太友好，但很容易封装为外观模式。\n一个简单的示例：\nconst std::string str { \"12345678901234\" }; int value = 0; std::from_chars(str.data(), str.data() + str.size(), value); // 省略了错误检查... 2 Converting From Characters to Numbers: from_chars std::from_chars ，在 头文件中可用，是一组重载函数：用于整数类型和浮点类型。\n对于整数类型，我们有以下函数：\nstd::from_chars_result from_chars(const char/ first, const char/ last, TYPE \u0026value, int base = 10); 其中，TYPE 展开为所有可用的有符号和无符号整数类型以及 char。\nbase 可以是从 2 到 36 的数字。\n然后是浮点数版本：\nstd::from_chars_result from_chars(const char/ first, const char/ last, FLOAT_TYPE\u0026 value, std::chars_format fmt = std::chars_format::general); FLOAT_TYPE 展开为 float 、 double 或 long double 。\nchars_format 是一个枚举，包含以下值：\nscientific、 fixed、 hex 和 general（是 fixed 和 scientific 的组合）。 所有这些函数（对于整数和浮点数）的返回值是 from_chars_result ：\nstruct from_chars_result { const char/ ptr; std::errc ec; }; from_chars_result 包含有关转换过程的信息。\n以下是总结：\n| 返回条件 || from_chars_result 的状态 | |——|—————————————————————————-| | 成功 || ptr 指向第一个不匹配模式的字符，或者如果所有字符匹配则为 last 的值，并且 ec 为值初始化状态。 | | 无效转换 || ptr 等于 first，ec 等于 std::errc::invalid_argument。value 未被修改。 | | 超出范围 || 数字太大，无法装入值类型。ec 等于 std::errc::result_out_of_range，ptr 指向第一个不匹配的字符。value 未被修改。 |\n2.1 示例 以下是使用 from_chars 将字符串转换为数字的两个示例，一个是整数一个是浮点数。\n2.1.1 整数类型 #include // from_char, to_char #include #include int main() { const std::string str { \"12345678901234\" }; int value = 0; const auto res = std::from_chars(str.data(), str.data() + str.size(), value); if (res.ec == std::errc()) { std::cout \u003c\u003c \"value: \" \u003c\u003c value \u003c\u003c \", distance: \" \u003c\u003c res.ptr - str.data() \u003c\u003c '\\n'; } else if (res.ec == std::errc::invalid_argument) { std::cout \u003c\u003c \"invalid argument!\\n\"; } else if (res.ec == std::errc::result_out_of_range) { std::cout \u003c\u003c \"out of range! res.ptr distance: \" \u003c\u003c res.ptr - str.data() \u003c\u003c '\\n'; } } 这个示例很简单，它将一个字符串 str 传递给 from_chars，然后在可能的情况下显示结果并提供附加信息。\n你的任务是在编译器资源管理器中运行这段代码。\n“12345678901234” 能够装入这个数字吗？或者你是否看到一些来自转换 API 的错误？\n2.1.2 浮点数 这里是浮点数版本：\n#include // from_char, to_char #include #include int main() { const std::string str { \"16.78\" }; double value = 0; const auto format = std::chars_format::general; const auto res = std::from_chars(str.data(), str.data() + str.size(), value, format); if (res.ec == std::errc()) { std::cout \u003c\u003c \"value: \" \u003c\u003c value \u003c\u003c \", distance: \" \u003c\u003c res.ptr - str.data() \u003c\u003c '\\n'; } else if (res.ec == std::errc::invalid_argument) { std::cout \u003c\u003c \"invalid argument!\\n\"; } else if (res.ec == std::errc::result_out_of_range) { std::cout \u003c\u003c \"out of range! res.ptr distance: \" \u003c\u003c res.ptr - str.data() \u003c\u003c '\\n'; } } 3 性能 我做了一些基准测试，新例程速度非常快！\n一些数字：\n在 GCC 上，它比 stoi 快大约 4.5 倍，比 atoi 快大约 2.2 倍，比 istringstream 快近 50 倍。 在 Clang 上，它比 stoi 快大约 3.5 倍，比 atoi 快 2.7 倍，比 istringstream 快 60 倍！ MSVC 的性能比 stoi 快约 3 倍，比 atoi 快约 2 倍，比 istringstream 快近 50 倍。 你可以在我的 C++17 书籍中找到这些结果：《C++17 详细信息》。\n4 C++23 更新 在 C++23 中，我们为我们的函数得到了一个改进：P2291\nstd::to_chars() 和 std::from_chars() 的整数重载现在是 constexpr 。\n它已经在 GCC 13、Clang 16 和 MSVC 19.34 中实现。\n与 std::optional 一起，它还可以在 constexpr 上下文中工作，我们可以创建以下示例：\n#include #include #include constexpr std::optional\u003cint\u003e to_int(std::string_view sv) { int value {}; const auto ret = std::from_chars(sv.begin(), sv.end(), value); if (ret.ec == std::errc{}) return value; return {}; }; int main() { static_assert(to_int(\"hello\") == std::nullopt); static_assert(to_int(\"10\") == 10); } 在编译器资源管理器中运行\n5 C++26 更新 这项工作尚未完成，在 C++26 中看起来我们将有更多的添加：\n查看 P2497R0，这个提案已经被接受并包含在 C++26 的工作草案中：\n对 函数成功或失败的测试\n这一功能已在 GCC 14 和 Clang 18 中实现。\n简而言之，from_chars_result（以及 to_chars_result）获得了一个 bool 转换运算符：\nconstexpr explicit operator bool() const noexcept; 它必须返回 ec = std::errc{}= 。\n这意味着我们的代码可能会更简单：\nif (res.ec == std::errc()) { ... } 可以变成：\nif (res) { ... } 例如：\n// ... const auto res = std::from_chars(str.data(), str.data() + str.size(), value, format); if (res) { std::cout \u003c\u003c \"value: \" \u003c\u003c value \u003c\u003c \", distance: \" \u003c\u003c res.ptr - str.data() \u003c\u003c '\\n'; } // ... 6 C++ 中对 std::from_chars 的编译器支持 Visual Studio： 完全支持 std::from_chars 是在 Visual Studio 2019 版本 16.4 中引入的，浮点支持从 VS 2017 版本 15.7 开始。Visual Studio 2022 包含了 C++23 功能，如对整数重载的 constexpr 支持。 GCC： 从 GCC 11.0 开始，std::from_chars 提供完整支持，包括整数和浮点转换。最新的 GCC 版本，比如 GCC 13，包含 constexpr 整数支持。 Clang： Clang 7.0 引入了对整数转换的初始支持。Clang 16 及以上支持整数重载的 constexpr。 获取最准确和最新的信息，请查看 CppReference、编译器支持。\n7 总结 如果你想将文本转换为数字，并且不需要任何额外的功能，如区域设置支持，那么 std::from_chars 可能是最好的选择。它提供 了很好的性能，而且更重要的是，你将获得关于转换过程的大量信息（例如扫描了多少个字符）。\n这些例程在解析 JSON 文件、三维文本模型表示（如 OBJ 文件格式）等方面可能特别有用。\n而且新函数甚至可以在编译时使用（截至 C++23），并且在 C++26 中具有更好的错误检查功能。\n","wordCount":"2039","inLanguage":"zh-cn","datePublished":"2024-10-14T00:00:00Z","dateModified":"2024-10-14T00:00:00Z","author":[{"@type":"Person","name":"Yang Yingchao"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://yangyingchao.github.io/posts/www_cppstories_com_fromchars/"},"publisher":{"@type":"Organization","name":"MyNotes","logo":{"@type":"ImageObject","url":"https://yangyingchao.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://yangyingchao.github.io accesskey=h title="MyNotes (Alt + H)">MyNotes</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://yangyingchao.github.io/ title=Home><span>Home</span></a></li><li><a href=https://yangyingchao.github.io/posts/ title=Archives><span>Archives</span></a></li><li><a href=https://yangyingchao.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://yangyingchao.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://yangyingchao.github.io/contact/ title="Contact me"><span>Contact me</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">C++ String Conversion: Exploring std::from_chars in C++17 to C++26</h1><div class=post-meta><span title='2024-10-14 00:00:00 +0000 UTC'>October 14, 2024</span>&nbsp;·&nbsp;Yang Yingchao</div></header><div class=post-content><ul><li>1 <a href=#before-c-plus-plus-17>Before C++17</a></li><li>2 <a href=#converting-from-characters-to-numbers-from-chars>Converting From Characters to Numbers: from_chars</a><ul><li>2.1 <a href=#%E7%A4%BA%E4%BE%8B>示例</a></li></ul></li><li>3 <a href=#%E6%80%A7%E8%83%BD>性能</a></li><li>4 <a href=#c-plus-plus-23-%E6%9B%B4%E6%96%B0>C++23 更新</a></li><li>5 <a href=#c-plus-plus-26-%E6%9B%B4%E6%96%B0>C++26 更新</a></li><li>6 <a href=#c-plus-plus-%E4%B8%AD%E5%AF%B9-std-from-chars-%E7%9A%84%E7%BC%96%E8%AF%91%E5%99%A8%E6%94%AF%E6%8C%81>C++ 中对 std::from_chars 的编译器支持</a></li><li>7 <a href=#%E6%80%BB%E7%BB%93>总结</a></li></ul><p>本文为摘录，原文为： <a href=https://www.cppstories.com/2018/12/fromchars/>https://www.cppstories.com/2018/12/fromchars/</a></p><p>随着引入 C++17，C++标准库通过添加 <code>std::from_chars</code> 来扩展了将文本转换为数字的功能。这个低级、高性能的 API 相较
于以前的方法（如 atoi 和 stringstream）提供了显著的优势。在本文中，我们将探讨从 C++17 到 C++26 的字符串转换程序
的演变，重点突出了诸如 constexpr 支持和改进的错误处理等关键改进。让我们深入了解细节，看看 <code>std::from_chars</code> 如何
可以改变您对字符串转换的方法。</p><h2 id=before-c-plus-plus-17>1 Before C++17<a hidden class=anchor aria-hidden=true href=#before-c-plus-plus-17>#</a></h2><ul><li>sprintf / snprintf</li><li>sscanf</li><li>atol</li><li>strtol</li><li>strstream</li><li>stringstream</li><li>to_string</li><li>stoi 等函数</li></ul><p>而在 C++17 中，新增了一种选项： <code>std::from_chars</code> ！为什么需要新方法？难道旧方法不够好吗？</p><p>新的转换例程具有以下特点：</p><ul><li>不抛出异常</li><li>不分配内存</li><li>不支持本地化</li><li>内存安全</li><li>错误报告提供有关转换结果的额外信息</li></ul><p>虽然 API 可能不太友好，但很容易封装为外观模式。</p><p>一个简单的示例：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:green;font-weight:700>const</span> std<span style=color:#666>::</span>string str { <span style=color:#ba2121>&#34;12345678901234&#34;</span> };
</span></span><span style=display:flex><span><span style=color:#b00040>int</span> value <span style=color:#666>=</span> <span style=color:#666>0</span>;
</span></span><span style=display:flex><span>std<span style=color:#666>::</span>from_chars(str.data(), str.data() <span style=color:#666>+</span> str.size(), value);
</span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// 省略了错误检查...
</span></span></span></code></pre></div><h2 id=converting-from-characters-to-numbers-from-chars>2 Converting From Characters to Numbers: from_chars<a hidden class=anchor aria-hidden=true href=#converting-from-characters-to-numbers-from-chars>#</a></h2><p><code>std::from_chars</code> ，在 &lt;charconv> 头文件中可用，是一组重载函数：用于整数类型和浮点类型。</p><p>对于整数类型，我们有以下函数：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>std<span style=color:#666>::</span>from_chars_result from_chars(<span style=color:green;font-weight:700>const</span> <span style=color:#b00040>char</span><span style=color:#666>/</span> first,
</span></span><span style=display:flex><span>                                  <span style=color:green;font-weight:700>const</span> <span style=color:#b00040>char</span><span style=color:#666>/</span> last,
</span></span><span style=display:flex><span>                                  TYPE <span style=color:#666>&amp;</span>value,
</span></span><span style=display:flex><span>                                  <span style=color:#b00040>int</span> base <span style=color:#666>=</span> <span style=color:#666>10</span>);
</span></span></code></pre></div><p>其中，TYPE 展开为所有可用的有符号和无符号整数类型以及 char。</p><p>base 可以是从 2 到 36 的数字。</p><p>然后是浮点数版本：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>std<span style=color:#666>::</span>from_chars_result from_chars(<span style=color:green;font-weight:700>const</span> <span style=color:#b00040>char</span><span style=color:#666>/</span> first,
</span></span><span style=display:flex><span>                   <span style=color:green;font-weight:700>const</span> <span style=color:#b00040>char</span><span style=color:#666>/</span> last,
</span></span><span style=display:flex><span>                   FLOAT_TYPE<span style=color:#666>&amp;</span> value,
</span></span><span style=display:flex><span>                   std<span style=color:#666>::</span>chars_format fmt <span style=color:#666>=</span> std<span style=color:#666>::</span>chars_format<span style=color:#666>::</span>general);
</span></span></code></pre></div><p><code>FLOAT_TYPE</code> 展开为 <code>float</code> 、 <code>double</code> 或 <code>long double</code> 。</p><p><code>chars_format</code> 是一个枚举，包含以下值：</p><ul><li>scientific、</li><li>fixed、</li><li>hex 和</li><li>general（是 fixed 和 scientific 的组合）。</li></ul><p>所有这些函数（对于整数和浮点数）的返回值是 <code>from_chars_result</code> ：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:green;font-weight:700>struct</span> <span style=color:#00f;font-weight:700>from_chars_result</span> {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>const</span> <span style=color:#b00040>char</span><span style=color:#666>/</span> ptr;
</span></span><span style=display:flex><span>    std<span style=color:#666>::</span>errc ec;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p><code>from_chars_result</code> 包含有关转换过程的信息。</p><p>以下是总结：</p><p></p><p>| 返回条件 || from_chars_result 的状态 |
|&mdash;&mdash;|&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-|
| 成功 || ptr 指向第一个不匹配模式的字符，或者如果所有字符匹配则为 last 的值，并且 ec 为值初始化状态。 |
| 无效转换 || ptr 等于 first，ec 等于 std::errc::invalid_argument。value 未被修改。 |
| 超出范围 || 数字太大，无法装入值类型。ec 等于 std::errc::result_out_of_range，ptr 指向第一个不匹配的字符。value 未被修改。 |</p><h3 id=示例>2.1 示例<a hidden class=anchor aria-hidden=true href=#示例>#</a></h3><p>以下是使用 <code>from_chars</code> 将字符串转换为数字的两个示例，一个是整数一个是浮点数。</p><h4 id=整数类型>2.1.1 整数类型<a hidden class=anchor aria-hidden=true href=#整数类型>#</a></h4><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#bc7a00>#include</span> <span style=color:#bc7a00>&lt;charconv&gt; // from_char, to_char</span><span style=color:#bc7a00>
</span></span></span><span style=display:flex><span><span style=color:#bc7a00>#include</span> <span style=color:#bc7a00>&lt;string&gt;</span><span style=color:#bc7a00>
</span></span></span><span style=display:flex><span><span style=color:#bc7a00>#include</span> <span style=color:#bc7a00>&lt;iostream&gt;</span><span style=color:#bc7a00>
</span></span></span><span style=display:flex><span><span style=color:#bc7a00></span><span style=color:#b00040>int</span> <span style=color:#00f>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>const</span> std<span style=color:#666>::</span>string str { <span style=color:#ba2121>&#34;12345678901234&#34;</span> };
</span></span><span style=display:flex><span>    <span style=color:#b00040>int</span> value <span style=color:#666>=</span> <span style=color:#666>0</span>;
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>const</span> <span style=color:green;font-weight:700>auto</span> res <span style=color:#666>=</span> std<span style=color:#666>::</span>from_chars(str.data(),
</span></span><span style=display:flex><span>                                     str.data() <span style=color:#666>+</span> str.size(),
</span></span><span style=display:flex><span>                                     value);
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>if</span> (res.ec <span style=color:#666>==</span> std<span style=color:#666>::</span>errc())
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        std<span style=color:#666>::</span>cout <span style=color:#666>&lt;&lt;</span> <span style=color:#ba2121>&#34;value: &#34;</span> <span style=color:#666>&lt;&lt;</span> value
</span></span><span style=display:flex><span>                  <span style=color:#666>&lt;&lt;</span> <span style=color:#ba2121>&#34;, distance: &#34;</span> <span style=color:#666>&lt;&lt;</span> res.ptr <span style=color:#666>-</span> str.data() <span style=color:#666>&lt;&lt;</span> <span style=color:#ba2121>&#39;\n&#39;</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>else</span> <span style=color:green;font-weight:700>if</span> (res.ec <span style=color:#666>==</span> std<span style=color:#666>::</span>errc<span style=color:#666>::</span>invalid_argument)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        std<span style=color:#666>::</span>cout <span style=color:#666>&lt;&lt;</span> <span style=color:#ba2121>&#34;invalid argument!</span><span style=color:#b62;font-weight:700>\n</span><span style=color:#ba2121>&#34;</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>else</span> <span style=color:green;font-weight:700>if</span> (res.ec <span style=color:#666>==</span> std<span style=color:#666>::</span>errc<span style=color:#666>::</span>result_out_of_range)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        std<span style=color:#666>::</span>cout <span style=color:#666>&lt;&lt;</span> <span style=color:#ba2121>&#34;out of range! res.ptr distance: &#34;</span>
</span></span><span style=display:flex><span>                  <span style=color:#666>&lt;&lt;</span> res.ptr <span style=color:#666>-</span> str.data() <span style=color:#666>&lt;&lt;</span> <span style=color:#ba2121>&#39;\n&#39;</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这个示例很简单，它将一个字符串 str 传递给 from_chars，然后在可能的情况下显示结果并提供附加信息。</p><p>你的任务是在编译器资源管理器中运行这段代码。</p><p>&ldquo;12345678901234&rdquo; 能够装入这个数字吗？或者你是否看到一些来自转换 API 的错误？</p><h4 id=浮点数>2.1.2 浮点数<a hidden class=anchor aria-hidden=true href=#浮点数>#</a></h4><p>这里是浮点数版本：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#bc7a00>#include</span> <span style=color:#bc7a00>&lt;charconv&gt; // from_char, to_char</span><span style=color:#bc7a00>
</span></span></span><span style=display:flex><span><span style=color:#bc7a00>#include</span> <span style=color:#bc7a00>&lt;string&gt;</span><span style=color:#bc7a00>
</span></span></span><span style=display:flex><span><span style=color:#bc7a00>#include</span> <span style=color:#bc7a00>&lt;iostream&gt;</span><span style=color:#bc7a00>
</span></span></span><span style=display:flex><span><span style=color:#bc7a00></span><span style=color:#b00040>int</span> <span style=color:#00f>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>const</span> std<span style=color:#666>::</span>string str { <span style=color:#ba2121>&#34;16.78&#34;</span> };
</span></span><span style=display:flex><span>    <span style=color:#b00040>double</span> value <span style=color:#666>=</span> <span style=color:#666>0</span>;
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>const</span> <span style=color:green;font-weight:700>auto</span> format <span style=color:#666>=</span> std<span style=color:#666>::</span>chars_format<span style=color:#666>::</span>general;
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>const</span> <span style=color:green;font-weight:700>auto</span> res <span style=color:#666>=</span> std<span style=color:#666>::</span>from_chars(str.data(),
</span></span><span style=display:flex><span>                                 str.data() <span style=color:#666>+</span> str.size(),
</span></span><span style=display:flex><span>                                 value,
</span></span><span style=display:flex><span>                                 format);
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>if</span> (res.ec <span style=color:#666>==</span> std<span style=color:#666>::</span>errc())
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        std<span style=color:#666>::</span>cout <span style=color:#666>&lt;&lt;</span> <span style=color:#ba2121>&#34;value: &#34;</span> <span style=color:#666>&lt;&lt;</span> value
</span></span><span style=display:flex><span>                  <span style=color:#666>&lt;&lt;</span> <span style=color:#ba2121>&#34;, distance: &#34;</span> <span style=color:#666>&lt;&lt;</span> res.ptr <span style=color:#666>-</span> str.data() <span style=color:#666>&lt;&lt;</span> <span style=color:#ba2121>&#39;\n&#39;</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>else</span> <span style=color:green;font-weight:700>if</span> (res.ec <span style=color:#666>==</span> std<span style=color:#666>::</span>errc<span style=color:#666>::</span>invalid_argument)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        std<span style=color:#666>::</span>cout <span style=color:#666>&lt;&lt;</span> <span style=color:#ba2121>&#34;invalid argument!</span><span style=color:#b62;font-weight:700>\n</span><span style=color:#ba2121>&#34;</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>else</span> <span style=color:green;font-weight:700>if</span> (res.ec <span style=color:#666>==</span> std<span style=color:#666>::</span>errc<span style=color:#666>::</span>result_out_of_range)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        std<span style=color:#666>::</span>cout <span style=color:#666>&lt;&lt;</span> <span style=color:#ba2121>&#34;out of range! res.ptr distance: &#34;</span>
</span></span><span style=display:flex><span>                  <span style=color:#666>&lt;&lt;</span> res.ptr <span style=color:#666>-</span> str.data() <span style=color:#666>&lt;&lt;</span> <span style=color:#ba2121>&#39;\n&#39;</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=性能>3 性能<a hidden class=anchor aria-hidden=true href=#性能>#</a></h2><p>我做了一些基准测试，新例程速度非常快！</p><p>一些数字：</p><ul><li>在 GCC 上，它比 stoi 快大约 4.5 倍，比 atoi 快大约 2.2 倍，比 istringstream 快近 50 倍。</li><li>在 Clang 上，它比 stoi 快大约 3.5 倍，比 atoi 快 2.7 倍，比 istringstream 快 60 倍！</li><li>MSVC 的性能比 stoi 快约 3 倍，比 atoi 快约 2 倍，比 istringstream 快近 50 倍。</li></ul><p>你可以在我的 C++17 书籍中找到这些结果：《C++17 详细信息》。</p><h2 id=c-plus-plus-23-更新>4 C++23 更新<a hidden class=anchor aria-hidden=true href=#c-plus-plus-23-更新>#</a></h2><p>在 C++23 中，我们为我们的函数得到了一个改进：P2291</p><p><code>std::to_chars()</code> 和 <code>std::from_chars()</code> 的整数重载现在是 <code>constexpr</code> 。</p><p>它已经在 GCC 13、Clang 16 和 MSVC 19.34 中实现。</p><p>与 std::optional 一起，它还可以在 constexpr 上下文中工作，我们可以创建以下示例：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#bc7a00>#include</span> <span style=color:#bc7a00>&lt;charconv&gt;</span><span style=color:#bc7a00>
</span></span></span><span style=display:flex><span><span style=color:#bc7a00>#include</span> <span style=color:#bc7a00>&lt;optional&gt;</span><span style=color:#bc7a00>
</span></span></span><span style=display:flex><span><span style=color:#bc7a00>#include</span> <span style=color:#bc7a00>&lt;string_view&gt;</span><span style=color:#bc7a00>
</span></span></span><span style=display:flex><span><span style=color:#bc7a00></span><span style=color:green;font-weight:700>constexpr</span> std<span style=color:#666>::</span>optional<span style=color:#666>&lt;</span><span style=color:#b00040>int</span><span style=color:#666>&gt;</span> to_int(std<span style=color:#666>::</span>string_view sv)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#b00040>int</span> value {};
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>const</span> <span style=color:green;font-weight:700>auto</span> ret <span style=color:#666>=</span> std<span style=color:#666>::</span>from_chars(sv.begin(), sv.end(), value);
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>if</span> (ret.ec <span style=color:#666>==</span> std<span style=color:#666>::</span>errc{})
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>return</span> value;
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>return</span> {};
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#b00040>int</span> <span style=color:#00f>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>static_assert</span>(to_int(<span style=color:#ba2121>&#34;hello&#34;</span>) <span style=color:#666>==</span> std<span style=color:#666>::</span>nullopt);
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>static_assert</span>(to_int(<span style=color:#ba2121>&#34;10&#34;</span>) <span style=color:#666>==</span> <span style=color:#666>10</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在编译器资源管理器中运行</p><h2 id=c-plus-plus-26-更新>5 C++26 更新<a hidden class=anchor aria-hidden=true href=#c-plus-plus-26-更新>#</a></h2><p>这项工作尚未完成，在 C++26 中看起来我们将有更多的添加：</p><p>查看 P2497R0，这个提案已经被接受并包含在 C++26 的工作草案中：</p><p>对 &lt;charconv> 函数成功或失败的测试</p><p>这一功能已在 GCC 14 和 Clang 18 中实现。</p><p>简而言之，from_chars_result（以及 to_chars_result）获得了一个 bool 转换运算符：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:green;font-weight:700>constexpr</span> <span style=color:green;font-weight:700>explicit</span> <span style=color:green;font-weight:700>operator</span> <span style=color:#00f>bool</span>() <span style=color:green;font-weight:700>const</span> <span style=color:green;font-weight:700>noexcept</span>;
</span></span></code></pre></div><p>它必须返回 <code>ec =</code> std::errc{}= 。</p><p>这意味着我们的代码可能会更简单：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:green;font-weight:700>if</span> (res.ec <span style=color:#666>==</span> std<span style=color:#666>::</span>errc()) { ... }
</span></span></code></pre></div><p>可以变成：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:green;font-weight:700>if</span> (res) { ... }
</span></span></code></pre></div><p>例如：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#408080;font-style:italic>// ...
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span><span style=color:green;font-weight:700>const</span> <span style=color:green;font-weight:700>auto</span> res <span style=color:#666>=</span> std<span style=color:#666>::</span>from_chars(str.data(),
</span></span><span style=display:flex><span>                                 str.data() <span style=color:#666>+</span> str.size(),
</span></span><span style=display:flex><span>                                 value,
</span></span><span style=display:flex><span>                                 format);
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>if</span> (res)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    std<span style=color:#666>::</span>cout <span style=color:#666>&lt;&lt;</span> <span style=color:#ba2121>&#34;value: &#34;</span> <span style=color:#666>&lt;&lt;</span> value
</span></span><span style=display:flex><span>              <span style=color:#666>&lt;&lt;</span> <span style=color:#ba2121>&#34;, distance: &#34;</span> <span style=color:#666>&lt;&lt;</span> res.ptr <span style=color:#666>-</span> str.data() <span style=color:#666>&lt;&lt;</span> <span style=color:#ba2121>&#39;\n&#39;</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// ...
</span></span></span></code></pre></div><h2 id=c-plus-plus-中对-std-from-chars-的编译器支持>6 C++ 中对 std::from_chars 的编译器支持<a hidden class=anchor aria-hidden=true href=#c-plus-plus-中对-std-from-chars-的编译器支持>#</a></h2><ul><li>Visual Studio：
完全支持 std::from_chars 是在 Visual Studio 2019 版本 16.4 中引入的，浮点支持从 VS 2017 版本 15.7 开始。Visual Studio 2022 包含了 C++23 功能，如对整数重载的 constexpr 支持。</li><li>GCC：
从 GCC 11.0 开始，std::from_chars 提供完整支持，包括整数和浮点转换。最新的 GCC 版本，比如 GCC 13，包含 constexpr 整数支持。</li><li>Clang：
Clang 7.0 引入了对整数转换的初始支持。Clang 16 及以上支持整数重载的 constexpr。</li></ul><p>获取最准确和最新的信息，请查看 CppReference、编译器支持。</p><h2 id=总结>7 总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h2><p>如果你想将文本转换为数字，并且不需要任何额外的功能，如区域设置支持，那么 std::from_chars 可能是最好的选择。它提供
了很好的性能，而且更重要的是，你将获得关于转换过程的大量信息（例如扫描了多少个字符）。</p><p>这些例程在解析 JSON 文件、三维文本模型表示（如 OBJ 文件格式）等方面可能特别有用。</p><p>而且新函数甚至可以在编译时使用（截至 C++23），并且在 C++26 中具有更好的错误检查功能。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://yangyingchao.github.io/tags/cpp/>cpp</a></li><li><a href=https://yangyingchao.github.io/tags/string/>string</a></li><li><a href=https://yangyingchao.github.io/tags/convert/>convert</a></li></ul></footer><script src=https://giscus.app/client.js data-repo=yangyingchao/giscus data-repo-id=R_kgDON6NYZA data-category=Announcements data-category-id=DIC_kwDON6NYZM4CnANs data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=zh-CN crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2025 <a href=https://yangyingchao.github.io>MyNotes</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>