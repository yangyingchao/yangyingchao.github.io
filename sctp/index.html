<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><title>Stream Control Transmission Protocol (SCTP) - 杂货铺</title><meta name=Description content="杂七杂八的，随手记录。"><meta property="og:url" content="https://yangyingchao.github.io/sctp/">
<meta property="og:site_name" content="杂货铺"><meta property="og:title" content="Stream Control Transmission Protocol (SCTP)"><meta property="og:description" content="Table of Contents 1 SCTP Associations 2 Using Multiple Interfaces 3 Streams 4 Association ID 5 Rec & Send 6 CDB with SCTP? 7 SCTP Interface Model 7.1 two types of SCTP sockets 7.2 The One-to-One Style 7.3 The One-to-Many Style 本文为摘录(或转载)，侵删，原文为： https://www.linuxjournal.com/article/9749
1 SCTP Associations SCTP 的联合 (association) 类似于 TCP 的连接 (connection) ， 但又有不同："><meta property="og:locale" content="zh_cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:tag" content="Network"><meta property="article:tag" content="Protocol"><meta property="article:tag" content="Sctp"><meta property="og:image" content="https://yangyingchao.github.io/logo.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://yangyingchao.github.io/logo.png"><meta name=twitter:title content="Stream Control Transmission Protocol (SCTP)"><meta name=twitter:description content="Table of Contents 1 SCTP Associations 2 Using Multiple Interfaces 3 Streams 4 Association ID 5 Rec & Send 6 CDB with SCTP? 7 SCTP Interface Model 7.1 two types of SCTP sockets 7.2 The One-to-One Style 7.3 The One-to-Many Style 本文为摘录(或转载)，侵删，原文为： https://www.linuxjournal.com/article/9749
1 SCTP Associations SCTP 的联合 (association) 类似于 TCP 的连接 (connection) ， 但又有不同："><meta name=application-name content="LoveIt"><meta name=apple-mobile-web-app-title content="LoveIt"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://yangyingchao.github.io/sctp/><link rel=prev href=https://yangyingchao.github.io/p3346-gong/><link rel=next href=https://yangyingchao.github.io/stdinitializer_list_caveats_and_improvements/><link rel=stylesheet href=/css/style.min.css><link rel=preload href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css></noscript><link rel=preload href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"Stream Control Transmission Protocol (SCTP)","inLanguage":"zh-cn","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/yangyingchao.github.io\/sctp\/"},"image":["https:\/\/yangyingchao.github.io\/images\/Apple-Devices-Preview.png"],"genre":"posts","keywords":"network, protocol, sctp","wordcount":1489,"url":"https:\/\/yangyingchao.github.io\/sctp\/","publisher":{"@type":"Organization","name":"xxxx","logo":"https:\/\/yangyingchao.github.io\/images\/avatar.png"},"author":{"@type":"Person","name":"yc"},"description":""}</script></head><body data-header-desktop=normal data-header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("theme","dark")</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title=杂货铺><span class=header-title-pre><i class="fa-solid fa-house-chimney"></i></span>老杨的杂货铺</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/>所有文章 </a><a class=menu-item href=/tags/>标签 </a><a class=menu-item href=/categories/>分类 </a><a class=menu-item href=https://github.com/yangyingchao/MyNotes title=GitHub rel="noopener noreffer" target=_blank><i class='fab fa-github fa-fw' aria-hidden=true></i> </a><span class="menu-item delimiter"></span><span class="menu-item search" id=search-desktop>
<input type=text placeholder=搜索文章标题或内容... id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fas fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fas fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-desktop><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i>
</span></span><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题><i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title=杂货铺><span class=header-title-pre><i class="fa-solid fa-house-chimney"></i></span>老杨的杂货铺</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><div class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容... id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fas fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fas fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-mobile><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></div><a class=menu-item href=/posts/ title>所有文章</a><a class=menu-item href=/tags/ title>标签</a><a class=menu-item href=/categories/ title>分类</a><a class=menu-item href=https://github.com/yangyingchao/MyNotes title=GitHub rel="noopener noreffer" target=_blank><i class='fab fa-github fa-fw' aria-hidden=true></i> </a><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题><i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>目录</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">Stream Control Transmission Protocol (SCTP)</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=/ title=Author rel=author class=author><i class="fas fa-user-circle fa-fw" aria-hidden=true></i>yc</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw" aria-hidden=true></i>&nbsp;<time datetime=0001-01-01>0001-01-01</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden=true></i>&nbsp;约 1489 字&nbsp;
<i class="far fa-clock fa-fw" aria-hidden=true></i>&nbsp;预计阅读 3 分钟&nbsp;</div></div><div class="details toc" id=toc-static data-kept><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fas fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#h:2815bca8-e6bb-4b22-93b8-52266d83331a><span class=section-num>1</span> SCTP Associations</a></li><li><a href=#h:a7d3a58f-21fb-4e4e-b3d1-1de8bf5291e3><span class=section-num>2</span> Using Multiple Interfaces</a></li><li><a href=#h:bbf694f6-56f7-4d97-8334-74bfe30fd53d><span class=section-num>3</span> Streams</a></li><li><a href=#h:276f19c3-3843-4d1b-a1ee-3dfd0126996c><span class=section-num>4</span> Association ID</a></li><li><a href=#h:ae3adb64-a1ab-4352-aa2a-8b58a81d1bf4><span class=section-num>5</span> Rec & Send</a></li><li><a href=#h:d0a6f1bd-1d91-4b94-b5cd-f70950fb9e9f><span class=section-num>6</span> CDB with SCTP?</a></li><li><a href=#h:fa817dc8-9b69-4412-8a1c-54067ac156b4><span class=section-num>7</span> SCTP Interface Model</a><ul><li><a href=#h:79c523c0-858f-44d3-a13a-8ffb6cd217ac><span class=section-num>7.1</span> two types of SCTP sockets</a></li><li><a href=#h:af8a22bd-336b-47ac-a22b-ba2a592aa426><span class=section-num>7.2</span> The One-to-One Style</a></li><li><a href=#h:400f90d1-fb4b-4e76-ae90-8feff25e9124><span class=section-num>7.3</span> The One-to-Many Style</a></li></ul></li></ul></nav></div></div><div class=content id=content><div class="ox-hugo-toc toc has-section-numbers"><div class=heading>Table of Contents</div><ul><li><span class=section-num>1</span> <a href=#h:2815bca8-e6bb-4b22-93b8-52266d83331a rel>SCTP Associations</a></li><li><span class=section-num>2</span> <a href=#h:a7d3a58f-21fb-4e4e-b3d1-1de8bf5291e3 rel>Using Multiple Interfaces</a></li><li><span class=section-num>3</span> <a href=#h:bbf694f6-56f7-4d97-8334-74bfe30fd53d rel>Streams</a></li><li><span class=section-num>4</span> <a href=#h:276f19c3-3843-4d1b-a1ee-3dfd0126996c rel>Association ID</a></li><li><span class=section-num>5</span> <a href=#h:ae3adb64-a1ab-4352-aa2a-8b58a81d1bf4 rel>Rec & Send</a></li><li><span class=section-num>6</span> <a href=#h:d0a6f1bd-1d91-4b94-b5cd-f70950fb9e9f rel>CDB with SCTP?</a></li><li><span class=section-num>7</span> <a href=#h:fa817dc8-9b69-4412-8a1c-54067ac156b4 rel>SCTP Interface Model</a><ul><li><span class=section-num>7.1</span> <a href=#h:79c523c0-858f-44d3-a13a-8ffb6cd217ac rel>two types of SCTP sockets</a></li><li><span class=section-num>7.2</span> <a href=#h:af8a22bd-336b-47ac-a22b-ba2a592aa426 rel>The One-to-One Style</a></li><li><span class=section-num>7.3</span> <a href=#h:400f90d1-fb4b-4e76-ae90-8feff25e9124 rel>The One-to-Many Style</a></li></ul></li></ul></div><p>本文为摘录(或转载)，侵删，原文为： <a href=https://www.linuxjournal.com/article/9749 target=_blank rel="noopener noreffer">https://www.linuxjournal.com/article/9749</a></p><h2 id=h:2815bca8-e6bb-4b22-93b8-52266d83331a><span class=section-num>1</span> SCTP Associations</h2><p>SCTP 的联合 (association) 类似于 TCP 的连接 (connection) ， 但又有不同：</p><ul><li>TCP connection 在服务端和客户端之间的网络接口上建立的 <strong>一对一</strong> 连接</li><li>SCTP association 是 <strong>多对多</strong> ：<ul><li>可以在服务端的多个网口和客户端的多个网口之间建立联合<br>例如，服务端和客户端各自有两个设备： Ethernet & Wi-Fi , 则服务端和客户端之间的联合可以包括 4 路：<ul><li>Eth -> Eth</li><li>Eth -> Wi-Fi</li><li>Wi-Fi -> Eth</li><li>Wi-Fi -> Wi-Fi</li></ul></li></ul></li></ul><ul><li>一个联合中又可以有多个 stream ， 各个 stream 之间互不干扰，不会阻塞<br>stream 用 stream id 来区分，从 0 开始增加</li></ul><ul><li>每个 socket 可以用来服务多个联合<br>也就是说，每个 scoket 可以用来同多个主机通讯。 每个 association 用
association id 来区分。</li></ul><h2 id=h:a7d3a58f-21fb-4e4e-b3d1-1de8bf5291e3><span class=section-num>2</span> Using Multiple Interfaces</h2><ul><li>服务端可以通过 <code>sctp_bindx()</code> 来绑定多个接口</li><li>客户端可以通过 <code>sctp_connectx()</code> 来使用多个地址</li><li>客户端可以通过 <code>sctp_getpaddrs()</code> 来获取远端地址</li><li>客户端可以通过 <code>sctp_getladdrs()</code> 来获取本地地址</li></ul><p>Once an association is set up between two endpoints, messages can be sent between them. Note that SCTP does not concern
itself with QoS (Quality-of-Service) issues, such as real-time delivery, but only with reliability issues. SCTP uses the
multihomed capabilities to try as many possible routes as possible to get messages through. So on the sending side,
there is no control over which interfaces are used; indeed, the sender might even use a scheme such as round-robin among
its interfaces for each message. However, the sending application can indicate to its SCTP stack which of the remote
peer&rsquo;s interface it would prefer to use, and it can tell the remote peer on which interfaces it would prefer to receive
messages. These are done by using the setsockopt() call with option type as SCTP_PRIMARY_ADDR or
SCTP_SET_PEER_PRIMARY_ADDR. Of course, if these particular addresses are not available, SCTP simply will use different
addresses in the association.</p><p>Once SCTP is told which interfaces to use, it basically looks after things itself. It uses heartbeats to keep track of
which interfaces are alive, and it switches interfaces transparently when failure occurs. This is to satisfy the design
goals of SCTP for improved reliability over TCP. Applications can give hints to the SCTP stack about which interfaces to
use, but the stack will ignore these hints on failure.</p><h2 id=h:bbf694f6-56f7-4d97-8334-74bfe30fd53d><span class=section-num>3</span> Streams</h2><p>Negotiating the Number of Streams</p><p>Each endpoint of an association will support a certain number of streams. A Linux endpoint, by default, will expect to
be able to send to ten streams, while it can receive on 65,535 streams. Other SCTP stacks may have different default
values. These values can be changed by setting the socket option SCTP_INITMSG, which takes a structure sctp_initmsg:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>sctp_initmsg</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint16_t</span> <span class=n>sinit_num_ostreams</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint16_t</span> <span class=n>sinit_max_ostreams</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint16_t</span> <span class=n>sinit_max_attempts</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint16_t</span> <span class=n>sinit_max_init_timeo</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>If this socket option is used to set values, it must be done <strong>before</strong> an
association is made. The parameters will be sent to the peer endpoint during
association initialisation.</p><h2 id=h:276f19c3-3843-4d1b-a1ee-3dfd0126996c><span class=section-num>4</span> Association ID</h2><p>There can be many associations active at any one time—a peer can be connected
to many other peers simultaneously. This is different from TCP where only one
connection on a socket can exist and also is different from UDP where no
connections exist and messages are just sent to arbitrary peers.</p><p>When there can be many associations, you need to be able to distinguish
between them. This is done by an opaque data type called an association ID.
You need to use this sometimes, but not every time.</p><ul><li><p>one-to-one sockets:<br></p><ul><li>仅用一个联合， Association ID 可以忽略</li><li>created a one-to-one socket:<div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>sockfd</span> <span class=o>=</span> <span class=n>socket</span><span class=p>(</span><span class=n>AF_INET</span><span class=p>,</span> <span class=n>SOCK_STREAM</span><span class=p>,</span> <span class=n>IPPROTO_SCTP</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div></li></ul></li><li><p>one-to-many sockets:<br></p><ul><li>当可以通过目的端地址来标识 Association 时， ID 可以忽略</li><li>其余时候需要使用 ID</li><li>create one-to-many socket:<div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>sockfd</span> <span class=o>=</span> <span class=nf>socket</span><span class=p>(</span><span class=n>AF_INET</span><span class=p>,</span> <span class=n>SOCK_SEQPACKET</span><span class=p>,</span> <span class=n>IPPROTO_SCTP</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div></li><li>ID 的获取：<div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>sctp_assoc_t</span> <span class=nf>get_associd</span><span class=p>(</span><span class=kt>int</span> <span class=n>sockfd</span><span class=p>,</span> <span class=k>struct</span> <span class=nc>sockaddr</span> <span class=o>*</span><span class=n>sa</span><span class=p>,</span> <span class=n>socklen_t</span> <span class=n>salen</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=nc>sctp_paddrinfo</span> <span class=n>sp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>sz</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>sz</span> <span class=o>=</span> <span class=k>sizeof</span><span class=p>(</span><span class=k>struct</span> <span class=nc>sctp_paddrinfo</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>bzero</span><span class=p>(</span><span class=o>&amp;</span><span class=n>sp</span><span class=p>,</span> <span class=n>sz</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>memcpy</span><span class=p>(</span><span class=o>&amp;</span><span class=n>sp</span><span class=p>.</span><span class=n>spinfo_address</span><span class=p>,</span> <span class=n>sa</span><span class=p>,</span> <span class=n>salen</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>sctp_opt_info</span><span class=p>(</span><span class=n>sockfd</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=n>SCTP_GET_PEER_ADDR_INFO</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>sp</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>sz</span><span class=p>)</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>perror</span><span class=p>(</span><span class=s>&#34;get assoc&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>(</span><span class=n>sp</span><span class=p>.</span><span class=n>spinfo_assoc_id</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></li></ul></li></ul><p>There is no way to specify from which stream to read. This is deliberate; the
intention is that when data is ready on any stream, then you read
it. Otherwise, data could be blocked on a stream with no one to read it, which
eventually could fill up system buffers. So, you can&rsquo;t restrict reading to any
particular stream. But, once a read is done, you can tell which stream it has
come from by using the mechanism above.</p><p>Typically, a server that reads and handles a message will have (pseudocode) that looks like this:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>while</span> <span class=p>(</span><span class=nb>true</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>nread</span> <span class=o>=</span> <span class=nf>sctp_recvmsg</span><span class=p>(...,</span> <span class=n>msg</span><span class=p>,</span> <span class=p>...,</span> <span class=o>&amp;</span><span class=n>sinfo</span><span class=p>,</span> <span class=p>...)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>nread</span> <span class=o>&lt;=</span> <span class=mi>0</span><span class=p>)</span> <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>assoc_id</span> <span class=o>=</span> <span class=n>sinfo</span><span class=p>.</span><span class=n>sinfo_assoc_id</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>stream</span> <span class=o>=</span> <span class=n>sinfo</span><span class=p>.</span><span class=n>sinfo_stream</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>handle_mesg</span><span class=p>(</span><span class=n>assoc_id</span><span class=p>,</span> <span class=n>stream</span><span class=p>,</span> <span class=n>msg</span><span class=p>,</span> <span class=n>nread</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>This is a single-threaded read loop. It ensures that information is read, no matter what association or stream it is
sent on. The application function handle_mesg() can, of course, dispatch the message to different threads if it wants.
Writes, on the other hand can be sent from multiple threads if desired.</p><h2 id=h:ae3adb64-a1ab-4352-aa2a-8b58a81d1bf4><span class=section-num>5</span> Rec & Send</h2><p>When it comes to sending messages back to all the connected clients, SCTP
makes it even easier—the flag <code>SCTP_SENDALL</code> that can can be set in the
<code>sctp_sndrcvinfo</code> field of <code>sctp_send()</code>. So a server simply needs to read a
message from any client, set the SCTP_SENDALL bit and write it back out. The
SCTP stack then will send it to all live peers! There are only a few lines of</p><h2 id=h:d0a6f1bd-1d91-4b94-b5cd-f70950fb9e9f><span class=section-num>6</span> CDB with SCTP?</h2><ul><li>发送端<ul><li>可使用 一个 socket ， 对多个 server 创建 associations</li><li>多线程并行发送</li></ul></li><li>接收端<ul><li>一个 socket ， 类似 UDP 接收</li><li>单线程接收，分拣</li><li>回发数据？？</li></ul></li></ul><h2 id=h:fa817dc8-9b69-4412-8a1c-54067ac156b4><span class=section-num>7</span> SCTP Interface Model</h2><p><a href=https://www.masterraghu.com/subjects/np/introduction/unix_network_programming_v1.3/ch09.html target=_blank rel="noopener noreffer">https://www.masterraghu.com/subjects/np/introduction/unix_network_programming_v1.3/ch09.html</a></p><h3 id=h:79c523c0-858f-44d3-a13a-8ffb6cd217ac><span class=section-num>7.1</span> two types of SCTP sockets</h3><h3 id=h:af8a22bd-336b-47ac-a22b-ba2a592aa426><span class=section-num>7.2</span> The One-to-One Style</h3><p>便于移植基于 TCP 协议的程序。</p><p><a id=figure--fig:screenshot@2022-06-21-17:11:51></a></p><figure><img src=/ox-hugo/screenshot@2022-06-21_17:11:51.png width=800px></figure><h3 id=h:400f90d1-fb4b-4e76-ae90-8feff25e9124><span class=section-num>7.3</span> The One-to-Many Style</h3><p>一对多模式可以减少 server 所使用的 socket 数量：可以使用一个 socket 来建立多个联合。 联合通过 <code>association id</code> 来标识。 该 ID 由内核指定，对用户透明。</p><p>使用该模式需要注意：</p><ul><li><p>当客户端关闭联合之后， server 端自动关闭，并将相关的状态从内核中移除。</p></li><li><p>使用 one-to-many 方式，可以在四次握手的第三个或者第四个包即开始发送数据。</p></li><li><p>使用 <code>sendto/sendmsg/sctp_sendmsg</code> 发送数据时候，如果联合不存在，会自动创建。</p></li><li><p>必须使用 <code>sendto/sctp_sendmsg</code> 来发送数据，而不能使用 <code>send/write</code></p></li><li><p>发送数据时，总是使用主目的地址 （建立联合时候系统选定的地址）。可以通过设置
flag <code>MSG_ADDR_OVER</code> 来强制使用其他地址。 该 flag 可以在 <code>sctp_sendmsg()</code> 中通过 <code>sctp_sndrcvinfo</code> 来设置。</p></li><li><p>事件通知可以通过 <code>SCTP_EVENTS</code> 来控制。</p><p><a id=figure--fig:screenshot@2022-06-21-17:33:56></a></p><figure><img src=/ox-hugo/screenshot@2022-06-21_17:33:56.png></figure></li></ul></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>更新于 0001-01-01</span></div></div><div class=post-info-line><div class=post-info-md><span><a class=link-to-markdown href=/sctp/index.md target=_blank>阅读原始文档</a></span></div><div class=post-info-share><span></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw" aria-hidden=true></i>&nbsp;<a href=/tags/network/>Network</a>,&nbsp;<a href=/tags/protocol/>Protocol</a>,&nbsp;<a href=/tags/sctp/>Sctp</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/p3346-gong/ class=prev rel=prev title="Tair-PMem: A Fully Durable Non-Volatile Memory Database"><i class="fas fa-angle-left fa-fw" aria-hidden=true></i>Tair-PMem: A Fully Durable Non-Volatile Memory Database</a>
<a href=/stdinitializer_list_caveats_and_improvements/ class=next rel=next title="std::initializer_list in C++">std::initializer_list in C++<i class="fas fa-angle-right fa-fw" aria-hidden=true></i></a></div></div><div id=comments><div id=giscus class=comment></div><noscript>Please enable JavaScript to view the comments powered by <a href=https://giscus.app>Giscus</a>.</noscript></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line itemscope itemtype=http://schema.org/CreativeWork>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title=回到顶部><i class="fas fa-arrow-up fa-fw" aria-hidden=true></i>
</a><a href=# id=view-comments class=fixed-button title=查看评论><i class="fas fa-comment fa-fw" aria-hidden=true></i></a></div><script type=text/javascript src=https://cdn.jsdelivr.net/npm/autocomplete.js@0.38.1/dist/autocomplete.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/algoliasearch@4.13.1/dist/algoliasearch-lite.umd.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"复制到剪贴板",maxShownLines:50},comment:{giscus:{category:"Announcements",categoryId:"R_kgDON6NYZA",darkTheme:"dark",emitMetadata:"0",inputPosition:"bottom",lang:"zh-CN",lazyLoading:!1,lightTheme:"light",mapping:"pathname",reactionsEnabled:"1",repo:"yangyingchao/giscus",repoId:""}},search:{algoliaAppID:null,algoliaIndex:"index.zh-cn",algoliaSearchKey:null,highlightTag:"em",maxResultLength:10,noResultsFound:"没有找到结果",snippetLength:30,type:"algolia"}}</script><script type=text/javascript src=/js/theme.min.js></script></body></html>