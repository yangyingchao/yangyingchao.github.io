<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>memory on MyNotes</title><link>https://yangyingchao.github.io/tags/memory/</link><description>Recent content in memory on MyNotes</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Sat, 16 Dec 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://yangyingchao.github.io/tags/memory/index.xml" rel="self" type="application/rss+xml"/><item><title>how to avoid memory being swapped (locking memory pages)</title><link>https://yangyingchao.github.io/posts/how-to-avoid-memory-being-swapped/</link><pubDate>Sat, 16 Dec 2023 00:00:00 +0000</pubDate><guid>https://yangyingchao.github.io/posts/how-to-avoid-memory-being-swapped/</guid><description>1 mlockall() 2 how to do this after program started and program does not call mlockall() ? 本文为摘录，原文为： https://stackoverflow.com/questions/12520499/linux-how-to-lock-the-pages-of-a-process-in-memory 1 mlockall() from manpage: mlockall() and munlockall() mlockall() locks all pages mapped into the address space of the calling process. This in‐ cludes the pages of the code, data, and stack segment, as well as shared libraries, user space kernel</description></item><item><title>NBTree: a Lock-free PM-friendly Persistent B+-Tree for eADR-enabled PM Systems</title><link>https://yangyingchao.github.io/posts/p1187-zhang/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://yangyingchao.github.io/posts/p1187-zhang/</guid><description>本文为摘录，原文为： attachments/pdf/a/p1187-zhang.pdf PM stands for Persistent Memory， 持久内存，它是一种非易失性内存，即使断电也能保留数据。 eADR 保证了 CPU 缓存中的数据在电源故障时会被刷新</description></item></channel></rss>