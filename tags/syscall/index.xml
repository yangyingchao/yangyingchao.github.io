<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>Syscall - 标签 - 老杨的杂货铺</title><link>https://yangyingchao.github.io/tags/syscall/</link><description>Syscall - 标签 - 老杨的杂货铺</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Thu, 21 Sep 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://yangyingchao.github.io/tags/syscall/" rel="self" type="application/rss+xml"/><item><title>Linux Rootkits — Multiple ways to hook syscall(s)</title><link>https://yangyingchao.github.io/linux-rootkits-multiple-ways-to-hook-syscall-s-7001cc02a1e6/</link><pubDate>Thu, 21 Sep 2023 00:00:00 +0000</pubDate><author>yc</author><guid>https://yangyingchao.github.io/linux-rootkits-multiple-ways-to-hook-syscall-s-7001cc02a1e6/</guid><description><![CDATA[<div class="ox-hugo-toc toc has-section-numbers">
<div class="heading">Table of Contents</div>
<ul>
<li><span class="section-num">1</span> <a href="#h:98e4d628-ec24-45db-b9b1-fff7eba4a0af" rel="">Syscall Table hijacking — The good old way, 系统调用表劫持</a></li>
<li><span class="section-num">2</span> <a href="#h:45798689-8b14-43ec-8000-bbecea4d896c" rel="">sys_close — The brute force method</a></li>
<li><span class="section-num">3</span> <a href="#h:889b5097-0190-4799-a9c6-5cb7d50ad082" rel="">VFS hooking</a></li>
<li><span class="section-num">4</span> <a href="#h:ccc260a9-1238-4340-9ad4-0bd94a9a1d1e" rel="">The ftrace helper method</a></li>
</ul>
</div>
<!--endtoc-->
<p>本文为摘录(或转载)，侵删，原文为： <a href="https://foxtrot-sq.medium.com/linux-rootkits-multiple-ways-to-hook-syscall-s-7001cc02a1e6" target="_blank" rel="noopener noreffer ">https://foxtrot-sq.medium.com/linux-rootkits-multiple-ways-to-hook-syscall-s-7001cc02a1e6</a></p>
<p>我们所见到的大多数恶意软件攻击中使用的 rootkit 都是开源的，其行为几乎与在系统中运行的正常进程相同（隐藏和挂钩）。从行为上来看，它们与正常进程几乎没有任何区别。在本文中，我们将探讨一些现有的方法，根据不同的 Linux 内核版本来挂钩系统调用。</p>]]></description></item></channel></rss>