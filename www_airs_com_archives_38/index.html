<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><title>Linkers - 杂货铺</title><meta name=Description content="杂七杂八的，随手记录。"><meta property="og:url" content="https://yangyingchao.github.io/www_airs_com_archives_38/"><meta property="og:site_name" content="杂货铺"><meta property="og:title" content="Linkers"><meta property="og:description" content="Table of Contents 1 Linkers part 1 1.1 链接器做什么？ 2 Linkers part 2 2.1 Basic Linker Data Types 2.2 基本链接器操作 3 part 3 3.1 地址空间 3.2 对象文件格式 4 Shared Libraries 5 Part 5 5.1 Shared Libraries Redux 5.2 ELF Symbols 6 Linkers part 6 本文为摘录(或转载)，侵删，原文为： https://www.airs.com/blog/archives/38
1 Linkers part 1 1.1 链接器做什么？ 很简单：链接器将目标文件转换为可执行文件和共享库。让我们看看这意味着什么。使用链接器的情况是，软件开发过程包括用某种语言编写程序代码：例如，C或 C++或 Fortran（但通常不包括 Java，因为 Java 通常以不同的方式工作，使用加载器而不是链接器）。编译器将这种人类可读的程序代码转换为另一种人类可读的文本形式，称为汇编代码。汇编代码是机器语言的可读形式，计算机可以直接执行。汇编器用于将此汇编代码转换为目标文件。为了完整起见，我要提到某些编译器在内部包括一个汇编器，并直接生成目标文件。无论哪种方式，这就是事情变得有趣的地方。"><meta property="og:locale" content="zh_cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-08-08T00:00:00+00:00"><meta property="article:modified_time" content="2025-08-08T00:00:00+00:00"><meta property="article:tag" content="Linkers"><meta property="article:tag" content="Lianjieqi"><meta property="og:image" content="https://yangyingchao.github.io/logo.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://yangyingchao.github.io/logo.png"><meta name=twitter:title content="Linkers"><meta name=twitter:description content="Table of Contents 1 Linkers part 1 1.1 链接器做什么？ 2 Linkers part 2 2.1 Basic Linker Data Types 2.2 基本链接器操作 3 part 3 3.1 地址空间 3.2 对象文件格式 4 Shared Libraries 5 Part 5 5.1 Shared Libraries Redux 5.2 ELF Symbols 6 Linkers part 6 本文为摘录(或转载)，侵删，原文为： https://www.airs.com/blog/archives/38
1 Linkers part 1 1.1 链接器做什么？ 很简单：链接器将目标文件转换为可执行文件和共享库。让我们看看这意味着什么。使用链接器的情况是，软件开发过程包括用某种语言编写程序代码：例如，C或 C++或 Fortran（但通常不包括 Java，因为 Java 通常以不同的方式工作，使用加载器而不是链接器）。编译器将这种人类可读的程序代码转换为另一种人类可读的文本形式，称为汇编代码。汇编代码是机器语言的可读形式，计算机可以直接执行。汇编器用于将此汇编代码转换为目标文件。为了完整起见，我要提到某些编译器在内部包括一个汇编器，并直接生成目标文件。无论哪种方式，这就是事情变得有趣的地方。"><meta name=application-name content="LoveIt"><meta name=apple-mobile-web-app-title content="LoveIt"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://yangyingchao.github.io/www_airs_com_archives_38/><link rel=prev href=https://yangyingchao.github.io/%E4%B8%83%E6%9C%88%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/><link rel=stylesheet href=/css/style.min.css><link rel=preload href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css></noscript><link rel=preload href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"Linkers","inLanguage":"zh-cn","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/yangyingchao.github.io\/www_airs_com_archives_38\/"},"image":["https:\/\/yangyingchao.github.io\/images\/Apple-Devices-Preview.png"],"genre":"posts","keywords":"linkers, lianjieqi","wordcount":8583,"url":"https:\/\/yangyingchao.github.io\/www_airs_com_archives_38\/","datePublished":"2025-08-08T00:00:00+00:00","dateModified":"2025-08-08T00:00:00+00:00","publisher":{"@type":"Organization","name":"xxxx","logo":"https:\/\/yangyingchao.github.io\/images\/avatar.png"},"author":{"@type":"Person","name":"yc"},"description":""}</script></head><body data-header-desktop=normal data-header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("theme","dark")</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title=杂货铺><span class=header-title-pre><i class="fa-solid fa-house-chimney"></i></span>老杨的杂货铺</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/>所有文章 </a><a class=menu-item href=/tags/>标签 </a><a class=menu-item href=/categories/>分类 </a><a class=menu-item href=https://github.com/yangyingchao/MyNotes title=GitHub rel="noopener noreffer" target=_blank><i class='fab fa-github fa-fw' aria-hidden=true></i> </a><span class="menu-item delimiter"></span><span class="menu-item search" id=search-desktop>
<input type=text placeholder=搜索文章标题或内容... id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fas fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fas fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-desktop><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i>
</span></span><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题><i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title=杂货铺><span class=header-title-pre><i class="fa-solid fa-house-chimney"></i></span>老杨的杂货铺</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><div class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容... id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fas fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fas fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-mobile><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></div><a class=menu-item href=/posts/ title>所有文章</a><a class=menu-item href=/tags/ title>标签</a><a class=menu-item href=/categories/ title>分类</a><a class=menu-item href=https://github.com/yangyingchao/MyNotes title=GitHub rel="noopener noreffer" target=_blank><i class='fab fa-github fa-fw' aria-hidden=true></i> </a><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题><i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>目录</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">Linkers</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=/ title=Author rel=author class=author><i class="fas fa-user-circle fa-fw" aria-hidden=true></i>yc</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw" aria-hidden=true></i>&nbsp;<time datetime=2025-08-08>2025-08-08</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden=true></i>&nbsp;约 8583 字&nbsp;
<i class="far fa-clock fa-fw" aria-hidden=true></i>&nbsp;预计阅读 18 分钟&nbsp;</div></div><div class="details toc" id=toc-static data-kept><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fas fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#linkers-part-1><span class=section-num>1</span> Linkers part 1</a><ul><li><a href=#链接器做什么><span class=section-num>1.1</span> 链接器做什么？</a></li></ul></li><li><a href=#linkers-part-2><span class=section-num>2</span> Linkers part 2</a><ul><li><a href=#basic-linker-data-types><span class=section-num>2.1</span> Basic Linker Data Types</a><ul><li><a href=#符号-symbol><span class=section-num>2.1.1</span> 符号 symbol</a></li><li><a href=#重定位><span class=section-num>2.1.2</span> 重定位</a></li><li><a href=#内容><span class=section-num>2.1.3</span> 内容</a></li></ul></li><li><a href=#基本链接器操作><span class=section-num>2.2</span> 基本链接器操作</a></li></ul></li><li><a href=#part-3><span class=section-num>3</span> part 3</a><ul><li><a href=#地址空间><span class=section-num>3.1</span> 地址空间</a></li><li><a href=#对象文件格式><span class=section-num>3.2</span> 对象文件格式</a></li></ul></li><li><a href=#shared-libraries><span class=section-num>4</span> Shared Libraries</a></li><li><a href=#part-5><span class=section-num>5</span> Part 5</a><ul><li><a href=#shared-libraries-redux><span class=section-num>5.1</span> Shared Libraries Redux</a></li><li><a href=#elf-symbols><span class=section-num>5.2</span> ELF Symbols</a></li></ul></li><li><a href=#linkers-part-6><span class=section-num>6</span> Linkers part 6</a></li></ul></nav></div></div><div class=content id=content><div class="ox-hugo-toc toc has-section-numbers"><div class=heading>Table of Contents</div><ul><li><span class=section-num>1</span> <a href=#linkers-part-1 rel>Linkers part 1</a><ul><li><span class=section-num>1.1</span> <a href=#%e9%93%be%e6%8e%a5%e5%99%a8%e5%81%9a%e4%bb%80%e4%b9%88 rel>链接器做什么？</a></li></ul></li><li><span class=section-num>2</span> <a href=#linkers-part-2 rel>Linkers part 2</a><ul><li><span class=section-num>2.1</span> <a href=#basic-linker-data-types rel>Basic Linker Data Types</a></li><li><span class=section-num>2.2</span> <a href=#%e5%9f%ba%e6%9c%ac%e9%93%be%e6%8e%a5%e5%99%a8%e6%93%8d%e4%bd%9c rel>基本链接器操作</a></li></ul></li><li><span class=section-num>3</span> <a href=#part-3 rel>part 3</a><ul><li><span class=section-num>3.1</span> <a href=#%e5%9c%b0%e5%9d%80%e7%a9%ba%e9%97%b4 rel>地址空间</a></li><li><span class=section-num>3.2</span> <a href=#%e5%af%b9%e8%b1%a1%e6%96%87%e4%bb%b6%e6%a0%bc%e5%bc%8f rel>对象文件格式</a></li></ul></li><li><span class=section-num>4</span> <a href=#shared-libraries rel>Shared Libraries</a></li><li><span class=section-num>5</span> <a href=#part-5 rel>Part 5</a><ul><li><span class=section-num>5.1</span> <a href=#shared-libraries-redux rel>Shared Libraries Redux</a></li><li><span class=section-num>5.2</span> <a href=#elf-symbols rel>ELF Symbols</a></li></ul></li><li><span class=section-num>6</span> <a href=#linkers-part-6 rel>Linkers part 6</a></li></ul></div><p>本文为摘录(或转载)，侵删，原文为： <a href=https://www.airs.com/blog/archives/38 target=_blank rel="noopener noreffer">https://www.airs.com/blog/archives/38</a></p><h2 id=linkers-part-1><span class=section-num>1</span> Linkers part 1</h2><h3 id=链接器做什么><span class=section-num>1.1</span> 链接器做什么？</h3><p>很简单：链接器将目标文件转换为可执行文件和共享库。让我们看看这意味着什么。使用链接器的情况是，软件开发过程包括用某种语言编写程序代码：例如，C或 C++或 Fortran（但通常不包括 Java，因为 Java
通常以不同的方式工作，使用加载器而不是链接器）。编译器将这种人类可读的程序代码转换为另一种人类可读的文本形式，称为汇编代码。汇编代码是机器语言的可读形式，计算机可以直接执行。汇编器用于将此汇编代码转换为目标文件。为了完整起见，我要提到某些编译器在内部包括一个汇编器，并直接生成目标文件。无论哪种方式，这就是事情变得有趣的地方。</p><p>在古老的日子里，当恐龙漫游数据中心时，许多程序是自给自足的。在那些日子里，通常没有编译器——人们直接用汇编代码编写——而汇编器实际上生成了可执行文件，机器可以直接执行。随着 Fortran 和 Cobol 等语言的出现，人们开始以子例程库的方式思考，这意味着必须有某种方法在两个不同的时间运行汇编器，并将输出组合成一个可执行文件。这要求汇编器生成不同类型的输出，这种输出被称为目标文件（我不知道这个名字来自哪里）。同时需要一个新程序将不同的目标文件组合成一个单一的可执行文件。这个新程序被称为链接器（这个名字的来源应该很明显）。</p><p>链接器今天仍然执行相同的任务。在接下来的几十年里，添加了一个新特性：共享库。</p><h2 id=linkers-part-2><span class=section-num>2</span> Linkers part 2</h2><h3 id=basic-linker-data-types><span class=section-num>2.1</span> Basic Linker Data Types</h3><p>链接器操作于少量基本数据类型：符号 (symbols)、重定位 (relocations)和内容 (contents)。这些在输入的目标文件中定义。以下是这些的概述。</p><h4 id=符号-symbol><span class=section-num>2.1.1</span> 符号 symbol</h4><p>一个符号基本上是一个名称和一个值。许多符号代表源代码中的静态对象——即在程序运行期间存在于单一位置的对象。例如，在从 C 代码生成的目标文件中，将为每个函数以及每个全局和静态变量生成一个符号。此类符号的值仅仅是对其内容的偏移量。这种类型的符号称为定义符号。重要的是不要将表示变量 my_global_var
的符号的值与 my_global_var 本身的值混淆。符号的值大致是该变量的地址：在 C 中从表达式 &amp;my_global_var 获得的值。</p><p>符号还用于表示对在不同目标文件中定义的名称的引用。这样的引用被称为未定义符号。还有其他一些使用较少的符号类型，我将在后面描述。</p><p>在链接过程中，链接器将为每个定义符号分配一个地址，并通过查找具有相同名称的定义符号来解析每个未定义符号。</p><h4 id=重定位><span class=section-num>2.1.2</span> 重定位</h4><p>重定位是对内容执行的计算。大多数重定位引用一个符号和内容内的一个偏移量。许多重定位还会提供一个额外的操作数，称为附加数。一个简单且常用的重定位是“将内容中的此位置设置为此符号的值加上此附加数。”重定位所做的计算类型本质上依赖于链接器所生成代码的处理器架构。例如，RISC
处理器需要两个或更多指令来形成内存地址，因此每个指令将有单独的重定位；例如，“将内容中的此位置设置为此符号值的低
16 位。”</p><p>在链接过程中，链接器将按照指示执行所有重定位计算。目标文件中的重定位可能引用未定义符号。如果链接器无法解析该符号，它通常会发出错误（但并不总是：对于某些符号类型或某些重定位类型，错误可能不合适）。</p><h4 id=内容><span class=section-num>2.1.3</span> 内容</h4><p>内容是程序执行期间内存应如何显示的内容。内容具有大小、一个字节数组和类型。它们包含由编译器和汇编器生成的机器代码（称为文本）。它们包含已初始化变量的值（数据）。它们包含如字符串常量和开关表等静态无名数据（只读数据或 rdata）。它们包含未初始化的变量，这种情况下字节数组通常会被省略，并假设仅包含零（bss）。编译器和汇编器努力生成完全正确的内容，但链接器实际上对此并不关心，只将其视为原始数据。链接器从每个文件中读取内容，将其按照类型连接在一起，应用重定位，并将结果写入可执行文件。</p><h3 id=基本链接器操作><span class=section-num>2.2</span> 基本链接器操作</h3><p>此时，我们已经足够了解每个链接器使用的基本步骤。</p><p>– 读取输入目标文件。确定内容的长度和类型。读取符号。– 构建一个包含所有符号的符号表，将未定义符号链接到它们的定义。– 决定所有内容在输出可执行文件中的位置，这意味着决定它们在程序运行时应该放在哪里。– 读取内容数据和重定位。将重定位应用于内容。将结果写入输出文件。– 可选地写出完整的符号表及符号的最终值。</p><h2 id=part-3><span class=section-num>3</span> part 3</h2><h3 id=地址空间><span class=section-num>3.1</span> 地址空间</h3><p>地址空间简单来说就是内存的一个视图，在这个视图中，每个字节都有一个地址。链接器处理三种不同类型的地址空间。</p><ol><li><p>每个输入对象文件是一个小的地址空间：其内容都有地址，符号和重定位通过地址引用这些内容。</p></li><li><p>输出程序在运行时将被放置在内存的某个位置。这就是输出地址空间，我通常称之为使用虚拟内存地址。</p></li><li><p>输出程序将在内存的某个位置被加载。这就是加载内存地址。<br>在典型的 Unix 系统中，虚拟内存地址和加载内存地址是相同的。在嵌入式系统中，它们通常不同；例如，初始化的数据（全局或静态变量的初始内容）可能会被加载到 ROM 中的加载内存地址，然后复制到虚拟内存地址的 RAM 中。</p></li></ol><p>共享库通常可以在不同进程中以不同的虚拟内存地址运行。共享库在创建时有一个基地址；这通常仅仅是零。当动态链接器将共享库复制到进程的虚拟内存空间时，必须应用重定位以调整共享库使其在虚拟内存地址上运行。共享库系统最小化必须应用的重定位数量，因为它们在启动程序时需要时间。</p><h3 id=对象文件格式><span class=section-num>3.2</span> 对象文件格式</h3><p>正如我上面所说，汇编器将人类可读的汇编语言转换为对象文件。对象文件是以一种为链接器设计的格式编写的二进制数据文件。链接器生成一个可执行文件。这个可执行文件是以一种为操作系统或加载程序设计的格式编写的二进制数据文件（即使在动态链接时也是如此，通常操作系统在调用动态链接器以开始运行程序之前会加载可执行文件）。对象文件格式并没有逻辑要求与可执行文件格式相似。然而，在实践中，它们通常非常相似。</p><p>大多数对象文件格式定义了段。段通常保存内存内容，或者可以用于保存其他类型的数据。段通常有一个名称、一个类型、一个大小、一个地址和一个关联的数据数组。</p><p>对象文件格式可以分为两种一般类型：记录导向和段导向。</p><ol><li>记录导向的对象<br>记录导向的对象文件格式定义了一系列大小各异的记录。每个记录以某种特殊代码开始，后面可能跟着数据。读取对象文件需要从头开始读取并处理每个记录。记录用于描述符号和段。重定位可能与段相关联，或者可能由其他记录指定。IEEE-695 和 Mach-O 是当前使用的记录导向对象文件格式。</li></ol><ol><li>段导向的对象文件<br>在段导向的对象文件格式中，文件头描述了具有指定数量段的段表。符号可以出现在由文件头描述的对象文件的单独部分，或者可以出现在特殊段中。重定位可以附加到段上，或者可以出现在单独的段中。对象文件可以通过读取段表，然后直接读取特定段来进行读取。ELF、COFF、PE 和 a.out 是段导向对象文件格式。</li></ol><p>每种对象文件格式都需要能够表示调试信息。调试信息由编译器生成，并由调试器读取。通常，链接器可以将其视为任何其他类型的数据。然而，在实践中，程序的调试信息可能比实际程序本身要大。链接器可以使用各种技术来减少调试信息的量，从而减少可执行文件的大小。这可以加快链接速度，但需要链接器理解调试信息。</p><p>a.out 对象文件格式使用符号表中的特殊字符串存储调试信息，这些字符串被称为 stabs。这些特殊字符串就是特殊类型的符号名称。这种技术也被某些 ECOFF 变体和旧版本的 Mach-O 使用。</p><p>COFF 对象文件格式使用符号表中的特殊字段存储调试信息。这种类型信息是有限的，对于 C++来说完全不够用。解决这些限制的常见技术是在 COFF 段中嵌入 stabs 字符串。</p><p>ELF 对象文件格式在具有特殊名称的段中存储调试信息。调试信息可以是 stabs 字符串或 DWARF 调试格式。</p><h2 id=shared-libraries><span class=section-num>4</span> Shared Libraries</h2><p>我们已经讨论了一些目标文件和可执行文件，那么共享库是什么样的呢？我将重点讲述 SVR4（以及 GNU/Linux 等）中使用的
ELF 共享库，因为它们是最灵活的共享库实现，也是我最熟悉的。</p><p>Windows 共享库，称为 DLL，在灵活性方面较低，因为您必须根据代码是否将进入共享库以不同的方式进行编译。您还必须在源代码中表达符号可见性。这并不是本质上的坏事，实际上 ELF 随着时间的推移吸收了一些这些思路，但 ELF
格式在链接时做出更多的决策，因此更强大。</p><p>当程序链接器创建共享库时，它尚不知道该共享库将在哪个虚拟地址上运行。实际上，在不同的进程中，同一个共享库将在不同的地址上运行，这取决于动态链接器所做的决策。这意味着共享库代码必须是位置无关的(positionindependent)。更准确地说，在动态链接器加载完成后，它必须是位置无关的。只要有足够的重定位信息，动态链接器总是能够将任何代码片段转换为在任何虚拟地址上运行。然而，进行重定位计算必须在每次程序启动时进行，这意味着程序的启动速度会变慢。因此，任何共享库系统都寻求生成位置独立的代码，这要求在运行时应用的重定位数量尽可能最小，同时仍能接近位置相关代码的运行效率。</p><p>一个额外的复杂性是，ELF 共享库的设计大致相当于普通的档案。这意味着默认情况下，主可执行文件可能会覆盖共享库中的符号，导致共享库中的引用会调用可执行文件中的定义，即使共享库也定义了相同的符号。例如，一个可执行文件可能定义了自己版本的 malloc。C 库也定义了 malloc，并且 C 库中包含调用 malloc 的代码。如果可执行文件自己定义了 malloc，它将覆盖 C 库中的函数。当 C 库中的某个其他函数调用 malloc 时，它将调用可执行文件中的定义，而不是 C 库中的定义。</p><p>因此，对于任何特定的 ELF 实现，存在不同的要求在不同的方向上拉扯。正确的实现选择将取决于处理器的特性。尽管如此，大多数，但不是全部，处理器做出的决策相当相似。这里我将描述常见的情况。使用常见情况的处理器实例是 i386；做出一些不同决策的处理器实例是 PowerPC。</p><p>在一般情况下，代码可能会以两种不同的模式编译。</p><ul><li><p>默认情况下，代码是位置依赖的。<br>将位置依赖的代码放入共享库会导致程序链接器生成大量的重定位信息，并使动态链接器在运行时进行大量处理。</p></li><li><p>代码也可以以位置无关模式编译，通常使用 <code>-fpic</code> 选项。<br>位置无关代码在调用非静态函数或引用全局或静态变量时稍微慢一些。然而，它需要的重定位信息要少得多，因此动态链接器将更快地启动程序。</p></li></ul><p>位置无关代码将通过过程链接表（PLT）调用非静态函数。这个 PLT 在.o 文件中并不存在。在.o 文件中，使用 PLT
由一种特殊的重定位来指示。当程序链接器处理这样的重定位时，它会在 PLT 中创建一个条目。它将调整指令，使其成为对 PLT
条目的 PC 相对调用。PC 相对调用本质上是位置无关的，因此不需要重定位条目。程序链接器将为 PLT 条目创建一个重定位，指示动态链接器哪个符号与该条目相关联。这个过程将共享库中每个函数调用的动态重定位数量从每个函数调用一个减少到每个被调用函数一个。</p><p>进一步地，PLT（程序链接表）入口通常由动态链接器懒惰地重定位。在大多数 ELF 系统上，这种懒惰行为可以通过在运行程序时设置 LD_BIND_NOW 环境变量来覆盖。然而，默认情况下，动态链接器实际上不会对 PLT
应用重定位，直到某些代码真正调用了相关函数。这也加快了启动时间，因为许多程序的调用不会触发每一个可能的函数。考虑到共享 C 库时尤其如此，因为它的函数调用远比任何典型的程序要多得多。</p><p>为了使这一切正常工作，程序链接器将 PLT 入口初始化为加载一个索引到某个寄存器中或将其压入栈中，然后跳转到公共代码。公共代码回调到动态链接器，动态链接器使用该索引查找适当的 PLT 重定位，并利用该重定位找到被调用的函数。动态链接器随后使用函数的地址初始化 PLT 条目，然后跳转到该函数的代码。下次调用该函数时，PLT 条目将直接跳转到该函数。</p><p>在给出一个例子之前，我将谈谈位置无关代码中的另一个主要数据结构，即全局偏移表（Global Offset Table，简称 GOT）。它用于全局和静态变量。对于每个来自位置无关代码的全局变量引用，编译器将生成一个从 GOT
中加载以获取变量地址的操作，随后再执行第二个加载以获取变量的实际值。GOT 的地址通常存储在一个寄存器中，以便高效访问。与 PLT 一样，GOT 并不在.o 文件中存在，而是由程序链接器创建。程序链接器将创建动态重定位，动态链接器将在运行时使用这些重定位来初始化 GOT。与 PLT 不同，动态链接器在程序启动时总会完全初始化 GOT。</p><p>例如，在 i386 上，GOT 的地址存储在寄存器%ebx 中。这个寄存器在每个位置无关代码函数的入口处进行初始化。初始化序列因编译器而异，但通常看起来像这样：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>call __i686.get_pc_thunk.bx
</span></span><span class=line><span class=cl>add $offset,%ebx
</span></span></code></pre></td></tr></table></div></div><p>函数 <code>__i686.get_pc_thunk.bx</code> 的内容如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>mov (%esp),%ebx
</span></span><span class=line><span class=cl>ret
</span></span></code></pre></td></tr></table></div></div><p>这一指令序列使用位置无关序列获取它运行的地址。然后使用一个偏移量获取 GOT 的地址。请注意，这要求 GOT
始终与代码保持固定的偏移，无论共享库被加载到哪里。也就是说，动态链接器必须将共享库作为一个固定单元加载；它不能将不同部分加载到不同地址。</p><p>现在，通过从 <code>%ebx</code> 的固定偏移量加载地址，来读取或写入全局和静态变量。程序链接器将为 GOT
中的每个条目创建动态重定位，告知动态链接器如何初始化该条目。这些重定位的类型为 GLOB_DAT。</p><p>对于函数调用，程序链接器将设置一个 PLT 条目，形如下述所示：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>jmp *offset(%ebx)
</span></span><span class=line><span class=cl>pushl #index
</span></span><span class=line><span class=cl>jmp first_plt_entry
</span></span></code></pre></td></tr></table></div></div><p>程序链接器将为 PLT 中的每个条目在 GOT 中分配一个条目。它将为 GOT 条目创建类型为 JMP_SLOT 的动态重定位。它将初始化 GOT 条目为共享库的基地址加上上面代码序列中第二个指令的地址。当动态链接器对 JMP_SLOT 重定位执行初始懒惰绑定时，它仅需在 GOT 条目中添加共享库加载地址与共享库基地址之间的差异。其效果是，第一次 jmp 指令将跳转到第二个指令，该指令将压入索引条目并跳转到第一个 PLT 条目。第一个 PLT 条目是特殊的，形如下述所示：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>pushl 4(%ebx)
</span></span><span class=line><span class=cl>jmp *8(%ebx)
</span></span></code></pre></td></tr></table></div></div><p>这引用了 GOT 中的第二和第三条目。动态链接器将初始化它们，使其具有适合于回调到动态链接器本身的相应值。动态链接器将使用第一个代码序列中压入的索引来查找 JMP_SLOT 重定位。当动态链接器确定要调用的函数时，它将把函数的地址存储到第一个代码序列所引用的 GOT 条目中。因此，下次调用该函数时，jmp 指令将直接跳转到正确的代码。</p><p>这只是快速浏览了许多细节，但我希望这能传达主要思想。这意味着，对于 i386 上的位置无关代码，每次对全局函数的调用在第一次调用后需要多一个额外的指令。每次对全局或静态变量的引用也需要多一个额外的指令。几乎每个函数在开始时使用四个额外的指令来初始化%ebx（不引用任何全局变量的叶子函数不需要初始化%ebx）。所有这些对程序缓存都有一定的负面影响。这是为了让动态链接器快速启动程序而付出的运行时性能代价。</p><p>在其他处理器上，细节自然有所不同。然而，整体风格是相似的：位置无关代码在共享库中启动更快，但运行稍微慢一些。</p><h2 id=part-5><span class=section-num>5</span> Part 5</h2><h3 id=shared-libraries-redux><span class=section-num>5.1</span> Shared Libraries Redux</h3><p>当程序链接器将依赖于位置的代码放入共享库时，它必须将对象文件中的更多重定位信息复制到共享库中。这些重定位信息将在运行时由动态链接器计算为动态重定位。有些重定位信息不必被复制；例如，指向共享库中局部符号的相对程序计数器重定位可以由程序链接器完全解析，而不需要动态重定位。然而，请注意，指向全局符号的相对程序计数器重定位确实需要动态重定位；否则，主可执行文件将无法覆盖该符号。有些重定位信息必须存在于共享库中，但不需要是对象文件中重定位信息的实际副本；例如，一个计算共享库中局部符号绝对地址的重定位通常可以用 RELATIVE 重定位替代，该重定位仅指示动态链接器添加共享库加载地址与其基址之间的差值。使用 RELATIVE
重定位的优势在于动态链接器可以在运行时快速计算，因为它不需要确定符号的值。</p><p>对于位置无关代码，程序链接器的工作更加复杂。编译器和汇编器会协同生成位置无关代码的特殊重定位。虽然各个处理器的细节有所不同，但通常会有一个 PLT 重定位和一个 GOT 重定位。这些重定位会指导程序链接器为 PLT 或
GOT 添加一个条目，同时执行一些计算。例如，在 i386 上，位置无关代码中的函数调用会生成一个 R_386_PLT32 重定位。该重定位将像往常一样引用一个符号。它会指导程序链接器为该符号添加一个 PLT 条目，如果尚不存在的话。重定位的计算随后是对 PLT 条目的 PC 相对引用。（重定位名称中的 32 指的是引用的大小，即 32 位）。昨天我描述了在
i386 上每个 PLT 条目也都有一个对应的 GOT 条目，因此 R_386_PLT32 重定位实际上指导程序链接器同时创建一个 PLT
条目和一个 GOT 条目。</p><p>当程序链接器在 PLT 或 GOT 中创建一个条目时，它还必须生成一个动态重定位以告知动态链接器有关该条目的信息。通常这将是一个 JMP_SLOT 或 GLOB_DAT 重定位。</p><p>这就意味着程序链接器必须跟踪每个符号的 PLT 条目和 GOT 条目。当然，最初不会有这样的条目。当链接器看到 PLT 或 GOT
重定位时，它必须检查重定位所引用的符号是否已经有 PLT 或 GOT 条目，如果没有则创建一个。注意，单个符号可能同时具有
PLT 条目和 GOT 条目；这会发生在位置无关代码中，该代码既调用函数又取其地址。</p><p>动态链接器在 PLT 和 GOT 表中的工作是简单地在运行时计算 JMP_SLOT 和 GLOB_DAT 重定位。这里的主要复杂性是我昨天描述的 PLT 条目的惰性求值。</p><p>C 语言允许取函数地址，这引入了一个有趣的复杂性。在 C 中，您可以取函数的地址，并且可以将这个地址与另一个函数地址进行比较。问题在于，如果您在共享库中取一个函数的地址，得到的自然结果将是 PLT
条目的地址。毕竟，调用函数的跳转就是跳转到这个地址。然而，每个共享库都有其自己的 PLT，因此特定函数的地址在每个共享库中都会有所不同。这意味着在不同共享库中生成的函数指针的比较可能不同，而它们应该相同。这不是一个纯假设的问题；当我做一个错误端口时，在我修复错误之前，我看到在 Tcl
共享库中比较函数指针时失败了。</p><p>在大多数处理器上，解决此错误的办法是对具有 PLT 条目但未定义的符号进行特殊标记。通常符号将被标记为未定义，但带有非零值——该值将设置为 PLT 条目的地址。当动态链接器在搜索用于重定位的符号值时，如果它发现这样的特殊标记符号，它将使用非零值。这将确保所有非函数调用的符号引用都将使用相同的值。为了使这项工作正常，编译器和汇编器必须确保任何不涉及调用的函数引用都不会携带标准 PLT 重定位。这种对函数地址的特殊处理需要在程序链接器和动态链接器中实现。</p><h3 id=elf-symbols><span class=section-num>5.2</span> ELF Symbols</h3><p>好了，关于共享库的内容够多了。让我们更详细地讨论 ELF 符号。我不打算详细列出确切的数据结构——您可以查阅 ELF ABI。我要讨论的是不同的字段及其含义。许多不同类型的 ELF 符号也被其他目标文件格式使用，但我不会涵盖这一点。</p><p>ELF 符号表中的一个条目有八个部分信息：一个名称，一个值，一个大小，一个节，绑定，一个类型，一个可见性，以及未定义的附加信息（目前有六个位未定义，尽管可能会添加更多）。在共享对象中定义的 ELF
符号也可能有一个关联的版本名称。</p><p>名称显而易见。</p><p>对于普通定义的符号，节是在文件中的某个节（具体而言，符号表条目保存了指向节表的索引）。对于目标文件，值是相对于节的起始位置。对于可执行文件，值是绝对地址。对于共享库，值是相对于基地址。</p><p>对于未定义引用符号，节索引是特殊值 SHN_UNDEF，其值为 0。节索引 SHN_ABS（0xfff1）表示符号的值是一个绝对值，而不是相对于任何节。</p><p>节索引 SHN_COMMON（0xfff2）表示公共符号。公共符号是为处理 Fortran 公共块而发明的，它们通常也用于 C
语言中的未初始化全局变量。公共符号具有不寻常的语义。公共符号的值为零，但将大小字段设置为所需的大小。如果一个目标文件有一个公共符号，而另一个文件有一个定义，该公共符号将被视为未定义引用。如果公共符号没有定义，程序链接器会假装看到一个初始化为零的适当大小的定义。两个目标文件可能有不同大小的公共符号，在这种情况下，程序链接器将使用最大的大小。在共享库之间实现公共符号的语义是一个棘手的问题，最近通过引入公共符号的类型和特殊节索引有所缓解（见下面关于符号类型的讨论）。</p><p>除了公共符号外，ELF 符号的大小是变量或函数的大小。这主要用于调试目的。</p><p>ELF 符号的绑定可以是全局的、本地的或弱的。全局符号是全局可见的。本地符号只有在本地可见（例如，一个静态函数）。弱符号有两种类型。弱未定义引用类似于普通未定义引用，除了如果重定位引用了一个没有定义符号的弱未定义引用符号，则它不是错误。相反，重定位的计算就像该符号的值为零一样。</p><p>弱定义符号允许与同名的非弱定义符号链接，而不引起多重定义错误。历史上，程序链接器处理弱定义符号有两种方式。在
SVR4 上，如果程序链接器看到一个弱定义符号后跟同名的非弱定义符号，它将发出多重定义错误。然而，非弱定义符号后跟弱定义符号不会导致错误。在 Solaris 上，一个弱定义符号后跟一个非弱定义符号会导致所有引用附加到非弱定义符号，而没有错误。行为上的差异是由于 ELF ABI
中的模糊性，不同的人有不同的解读。GNU 链接器遵循 Solaris 的行为。</p><p>ELF 符号的类型如下所示：</p><ul><li><p>STT_NOTYPE: no particular type.</p></li><li><p>STT_OBJECT: a data object, such as a variable.</p></li><li><p>STT_FUNC: a function</p></li><li><p>STT_SECTION: a local symbol associated with a section. This type of symbol is used to reduce the number of
local symbols required, by changing all relocations against local symbols in a specific section to use the
STT_SECTION symbol instead.</p></li><li><p>STT_FILE: a special symbol whose name is the name of the source file which produced the object file.</p></li><li><p>STT_COMMON: a common symbol. This is the same as setting the section index to SHN_COMMON, except in a shared object.
The program linker will normally have allocated space for the common symbol in the shared object, so it will have a
real section index. The STT_COMMON type tells the dynamic linker that although the symbol has a regular definition,
it is a common symbol.</p></li><li><p>STT_TLS: a symbol in the Thread Local Storage area. I will describe this in more detail some other day.</p></li></ul><p>ELF 符号的可见性是为提供更好的控制符号在共享库之外的可访问性而发明的。基本思想是符号在共享库内可能是全局的，但在共享库外是本地的。</p><ul><li>STV_DEFAULT: the usual visibility rules apply: global symbols are visible everywhere.</li><li>STV_INTERNAL: the symbol is not accessible outside the current executable or shared library.</li><li>STV_HIDDEN: the symbol is not visible outside the current executable or shared library, but it may be accessed
indirectly, probably because some code took its address.</li><li>STV_PROTECTED: the symbol is visible outside the current executable or shared object, but it may not be overridden.
That is, if a protected symbol in a shared library is referenced by other code in the shared library, that other
code will always reference the symbol in the shared library, even if the executable defines a symbol with the same
name.</li></ul><h2 id=linkers-part-6><span class=section-num>6</span> Linkers part 6</h2></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>更新于 2025-08-08</span></div></div><div class=post-info-line><div class=post-info-md><span><a class=link-to-markdown href=/www_airs_com_archives_38/index.md target=_blank>阅读原始文档</a></span></div><div class=post-info-share><span></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw" aria-hidden=true></i>&nbsp;<a href=/tags/linkers/>Linkers</a>,&nbsp;<a href=/tags/lianjieqi/>Lianjieqi</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/%E4%B8%83%E6%9C%88%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/ class=prev rel=prev title=七月读书笔记><i class="fas fa-angle-left fa-fw" aria-hidden=true></i>七月读书笔记</a></div></div><div id=comments><div id=giscus class=comment></div><noscript>Please enable JavaScript to view the comments powered by <a href=https://giscus.app>Giscus</a>.</noscript></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line itemscope itemtype=http://schema.org/CreativeWork>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title=回到顶部><i class="fas fa-arrow-up fa-fw" aria-hidden=true></i>
</a><a href=# id=view-comments class=fixed-button title=查看评论><i class="fas fa-comment fa-fw" aria-hidden=true></i></a></div><script type=text/javascript src=https://cdn.jsdelivr.net/npm/autocomplete.js@0.38.1/dist/autocomplete.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/algoliasearch@4.13.1/dist/algoliasearch-lite.umd.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"复制到剪贴板",maxShownLines:50},comment:{giscus:{category:"Announcements",categoryId:"R_kgDON6NYZA",darkTheme:"dark",emitMetadata:"0",inputPosition:"bottom",lang:"zh-CN",lazyLoading:!1,lightTheme:"light",mapping:"pathname",reactionsEnabled:"1",repo:"yangyingchao/giscus",repoId:""}},search:{algoliaAppID:null,algoliaIndex:"index.zh-cn",algoliaSearchKey:null,highlightTag:"em",maxResultLength:10,noResultsFound:"没有找到结果",snippetLength:30,type:"algolia"}}</script><script type=text/javascript src=/js/theme.min.js></script></body></html>